{"path":"lucene/sandbox/src/java/org/apache/lucene/search/PointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","commits":[{"id":"976a394d3766ec527a334072ea20ed791d81e330","date":1456749520,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/PointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoUtils.circleToBBox(longitude, latitude, radiusMeters);\n    final GeoRect box1;\n    final GeoRect box2;\n\n    // crosses dateline: split\n    if (box.maxLon < box.minLon) {\n      box1 = new GeoRect(-180.0, box.maxLon, box.minLat, box.maxLat);\n      box2 = new GeoRect(box.minLon, 180.0, box.minLat, box.maxLat);\n    } else {\n      box1 = box;\n      box2 = null;\n    }\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        \n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, Integer.BYTES));\n                             if (GeoDistanceUtils.haversin(latitude, longitude, lat, lon) <= radiusMeters) {\n                               visit(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 3. recurse naively.\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double latMin = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double lonMin = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, Integer.BYTES));\n                             double latMax = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double lonMax = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, Integer.BYTES));\n                             \n                             if ((latMax < box1.minLat || lonMax < box1.minLon || latMin > box1.maxLat || lonMin > box1.maxLon) && \n                                 (box2 == null || latMax < box2.minLat || lonMax < box2.minLon || latMin > box2.maxLat || lonMin > box2.maxLon)) {\n                               // we are fully outside of bounding box(es), don't proceed any further.\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             } else if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["ec60431d008a694828dacb4bc3cda775b6c44a9f","ec60431d008a694828dacb4bc3cda775b6c44a9f","f976862431a9be6f9f76f958b5a9a04aa2342747","f976862431a9be6f9f76f958b5a9a04aa2342747","98e0f1aa9ab98b9d47cc76e3d38926353c75b571","98e0f1aa9ab98b9d47cc76e3d38926353c75b571"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b2020d3d69ed3513a1cbce56d7db5bd7f984197e","date":1456752592,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/PointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/PointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoUtils.circleToBBox(longitude, latitude, radiusMeters);\n    final GeoRect box1;\n    final GeoRect box2;\n\n    // crosses dateline: split\n    if (box.maxLon < box.minLon) {\n      box1 = new GeoRect(-180.0, box.maxLon, box.minLat, box.maxLat);\n      box2 = new GeoRect(box.minLon, 180.0, box.minLat, box.maxLat);\n    } else {\n      box1 = box;\n      box2 = null;\n    }\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        \n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, Integer.BYTES));\n                             if (GeoDistanceUtils.haversin(latitude, longitude, lat, lon) <= radiusMeters) {\n                               visit(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 3. recurse naively.\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double latMin = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double lonMin = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, Integer.BYTES));\n                             double latMax = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double lonMax = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, Integer.BYTES));\n                             \n                             if ((latMax < box1.minLat || lonMax < box1.minLon || latMin > box1.maxLat || lonMin > box1.maxLon) && \n                                 (box2 == null || latMax < box2.minLat || lonMax < box2.minLon || latMin > box2.maxLat || lonMin > box2.maxLon)) {\n                               // we are fully outside of bounding box(es), don't proceed any further.\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             } else if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoUtils.circleToBBox(longitude, latitude, radiusMeters);\n    final GeoRect box1;\n    final GeoRect box2;\n\n    // crosses dateline: split\n    if (box.maxLon < box.minLon) {\n      box1 = new GeoRect(-180.0, box.maxLon, box.minLat, box.maxLat);\n      box2 = new GeoRect(box.minLon, 180.0, box.minLat, box.maxLat);\n    } else {\n      box1 = box;\n      box2 = null;\n    }\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        \n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, Integer.BYTES));\n                             if (GeoDistanceUtils.haversin(latitude, longitude, lat, lon) <= radiusMeters) {\n                               visit(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 3. recurse naively.\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double latMin = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double lonMin = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, Integer.BYTES));\n                             double latMax = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double lonMax = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, Integer.BYTES));\n                             \n                             if ((latMax < box1.minLat || lonMax < box1.minLon || latMin > box1.maxLat || lonMin > box1.maxLon) && \n                                 (box2 == null || latMax < box2.minLat || lonMax < box2.minLon || latMin > box2.maxLat || lonMin > box2.maxLon)) {\n                               // we are fully outside of bounding box(es), don't proceed any further.\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             } else if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/PointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoUtils.circleToBBox(longitude, latitude, radiusMeters);\n    final GeoRect box1;\n    final GeoRect box2;\n\n    // crosses dateline: split\n    if (box.maxLon < box.minLon) {\n      box1 = new GeoRect(-180.0, box.maxLon, box.minLat, box.maxLat);\n      box2 = new GeoRect(box.minLon, 180.0, box.minLat, box.maxLat);\n    } else {\n      box1 = box;\n      box2 = null;\n    }\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        \n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, Integer.BYTES));\n                             if (GeoDistanceUtils.haversin(latitude, longitude, lat, lon) <= radiusMeters) {\n                               visit(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 3. recurse naively.\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double latMin = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double lonMin = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, Integer.BYTES));\n                             double latMax = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double lonMax = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, Integer.BYTES));\n                             \n                             if ((latMax < box1.minLat || lonMax < box1.minLon || latMin > box1.maxLat || lonMin > box1.maxLon) && \n                                 (box2 == null || latMax < box2.minLat || lonMax < box2.minLon || latMin > box2.maxLat || lonMin > box2.maxLon)) {\n                               // we are fully outside of bounding box(es), don't proceed any further.\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             } else if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"94ee361295fb38310ac4d53cb4773d1622423d68","date":1456833885,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/PointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoUtils.circleToBBox(longitude, latitude, radiusMeters);\n    final GeoRect box1;\n    final GeoRect box2;\n\n    // crosses dateline: split\n    if (box.maxLon < box.minLon) {\n      box1 = new GeoRect(-180.0, box.maxLon, box.minLat, box.maxLat);\n      box2 = new GeoRect(box.minLon, 180.0, box.minLat, box.maxLat);\n    } else {\n      box1 = box;\n      box2 = null;\n    }\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLatitude(packedValue, 0);\n                             double lon = LatLonPoint.decodeLongitude(packedValue, Integer.BYTES);\n                             if (GeoDistanceUtils.haversin(latitude, longitude, lat, lon) <= radiusMeters) {\n                               visit(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 3. recurse naively.\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double latMin = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double lonMin = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double lonMax = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n                             \n                             if ((latMax < box1.minLat || lonMax < box1.minLon || latMin > box1.maxLat || lonMin > box1.maxLon) && \n                                 (box2 == null || latMax < box2.minLat || lonMax < box2.minLon || latMin > box2.maxLat || lonMin > box2.maxLon)) {\n                               // we are fully outside of bounding box(es), don't proceed any further.\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             } else if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoUtils.circleToBBox(longitude, latitude, radiusMeters);\n    final GeoRect box1;\n    final GeoRect box2;\n\n    // crosses dateline: split\n    if (box.maxLon < box.minLon) {\n      box1 = new GeoRect(-180.0, box.maxLon, box.minLat, box.maxLat);\n      box2 = new GeoRect(box.minLon, 180.0, box.minLat, box.maxLat);\n    } else {\n      box1 = box;\n      box2 = null;\n    }\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        \n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, Integer.BYTES));\n                             if (GeoDistanceUtils.haversin(latitude, longitude, lat, lon) <= radiusMeters) {\n                               visit(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 3. recurse naively.\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double latMin = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double lonMin = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, Integer.BYTES));\n                             double latMax = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double lonMax = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, Integer.BYTES));\n                             \n                             if ((latMax < box1.minLat || lonMax < box1.minLon || latMin > box1.maxLat || lonMin > box1.maxLon) && \n                                 (box2 == null || latMax < box2.minLat || lonMax < box2.minLon || latMin > box2.maxLat || lonMin > box2.maxLon)) {\n                               // we are fully outside of bounding box(es), don't proceed any further.\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             } else if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":5,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/PointDistanceQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoUtils.circleToBBox(longitude, latitude, radiusMeters);\n    final GeoRect box1;\n    final GeoRect box2;\n\n    // crosses dateline: split\n    if (box.maxLon < box.minLon) {\n      box1 = new GeoRect(-180.0, box.maxLon, box.minLat, box.maxLat);\n      box2 = new GeoRect(box.minLon, 180.0, box.minLat, box.maxLat);\n    } else {\n      box1 = box;\n      box2 = null;\n    }\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n        \n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLatitude(packedValue, 0);\n                             double lon = LatLonPoint.decodeLongitude(packedValue, Integer.BYTES);\n                             if (GeoDistanceUtils.haversin(latitude, longitude, lat, lon) <= radiusMeters) {\n                               visit(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 3. recurse naively.\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double latMin = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double lonMin = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double latMax = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double lonMax = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n                             \n                             if ((latMax < box1.minLat || lonMax < box1.minLon || latMin > box1.maxLat || lonMin > box1.maxLon) && \n                                 (box2 == null || latMax < box2.minLat || lonMax < box2.minLon || latMin > box2.maxLat || lonMin > box2.maxLon)) {\n                               // we are fully outside of bounding box(es), don't proceed any further.\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             } else if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    GeoRect box = GeoUtils.circleToBBox(longitude, latitude, radiusMeters);\n    final GeoRect box1;\n    final GeoRect box2;\n\n    // crosses dateline: split\n    if (box.maxLon < box.minLon) {\n      box1 = new GeoRect(-180.0, box.maxLon, box.minLat, box.maxLat);\n      box2 = new GeoRect(box.minLon, 180.0, box.minLat, box.maxLat);\n    } else {\n      box1 = box;\n      box2 = null;\n    }\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        \n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, Integer.BYTES));\n                             if (GeoDistanceUtils.haversin(latitude, longitude, lat, lon) <= radiusMeters) {\n                               visit(docID);\n                             }\n                           }\n                           \n                           // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).\n                           // 1. check our bounding box(es) first. if the subtree is entirely outside of those, bail.\n                           // 2. see if the subtree is fully contained. if the subtree is enormous along the x axis, wrapping half way around the world, etc: then this can't work, just go to step 3.\n                           // 3. recurse naively.\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double latMin = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double lonMin = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, Integer.BYTES));\n                             double latMax = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double lonMax = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, Integer.BYTES));\n                             \n                             if ((latMax < box1.minLat || lonMax < box1.minLon || latMin > box1.maxLat || lonMin > box1.maxLon) && \n                                 (box2 == null || latMax < box2.minLat || lonMax < box2.minLon || latMin > box2.maxLat || lonMin > box2.maxLon)) {\n                               // we are fully outside of bounding box(es), don't proceed any further.\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             } else if (lonMax - longitude < 90 && longitude - lonMin < 90 &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMin, lonMax) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMin) <= radiusMeters &&\n                                 GeoDistanceUtils.haversin(latitude, longitude, latMax, lonMax) <= radiusMeters) {\n                               // we are fully enclosed, collect everything within this subtree\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else {\n                               // recurse: its inside our bounding box(es), but not fully, or it wraps around.\n                               return Relation.CELL_CROSSES_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"af2638813028b254a88b418ebeafb541afb49653":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b2020d3d69ed3513a1cbce56d7db5bd7f984197e"],"b2020d3d69ed3513a1cbce56d7db5bd7f984197e":["976a394d3766ec527a334072ea20ed791d81e330"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"94ee361295fb38310ac4d53cb4773d1622423d68":["b2020d3d69ed3513a1cbce56d7db5bd7f984197e"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["af2638813028b254a88b418ebeafb541afb49653","94ee361295fb38310ac4d53cb4773d1622423d68"],"976a394d3766ec527a334072ea20ed791d81e330":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"]},"commit2Childs":{"af2638813028b254a88b418ebeafb541afb49653":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"b2020d3d69ed3513a1cbce56d7db5bd7f984197e":["af2638813028b254a88b418ebeafb541afb49653","94ee361295fb38310ac4d53cb4773d1622423d68"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["af2638813028b254a88b418ebeafb541afb49653","976a394d3766ec527a334072ea20ed791d81e330"],"94ee361295fb38310ac4d53cb4773d1622423d68":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"976a394d3766ec527a334072ea20ed791d81e330":["b2020d3d69ed3513a1cbce56d7db5bd7f984197e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}