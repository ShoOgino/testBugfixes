{"path":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testLargeOutputsOnArrayArcs().mjava","commits":[{"id":"0b6d0fabff70855609f5c77e7555f106cdab31f8","date":1327618303,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testLargeOutputsOnArrayArcs().mjava","pathOld":"/dev/null","sourceNew":"  public void testLargeOutputsOnArrayArcs() throws Exception {\n    final ByteSequenceOutputs outputs = ByteSequenceOutputs.getSingleton();\n    final Builder<BytesRef> builder = new Builder<BytesRef>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    final byte[] bytes = new byte[300];\n    final IntsRef input = new IntsRef();\n    input.grow(1);\n    input.length = 1;\n    final BytesRef output = new BytesRef(bytes);\n    for(int arc=0;arc<6;arc++) {\n      input.ints[0] = arc;\n      output.bytes[0] = (byte) arc;\n      builder.add(input, BytesRef.deepCopyOf(output));\n    }\n\n    final FST<BytesRef> fst = builder.finish();\n    for(int arc=0;arc<6;arc++) {\n      input.ints[0] = arc;\n      final BytesRef result = Util.get(fst, input);\n      assertNotNull(result);\n      assertEquals(300, result.length);\n      assertEquals(result.bytes[result.offset], arc);\n      for(int byteIDX=1;byteIDX<result.length;byteIDX++) {\n        assertEquals(0, result.bytes[result.offset+byteIDX]);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"78a55f24d9b493c2a1cecf79f1d78279062b545b","date":1327688152,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testLargeOutputsOnArrayArcs().mjava","pathOld":"/dev/null","sourceNew":"  public void testLargeOutputsOnArrayArcs() throws Exception {\n    final ByteSequenceOutputs outputs = ByteSequenceOutputs.getSingleton();\n    final Builder<BytesRef> builder = new Builder<BytesRef>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    final byte[] bytes = new byte[300];\n    final IntsRef input = new IntsRef();\n    input.grow(1);\n    input.length = 1;\n    final BytesRef output = new BytesRef(bytes);\n    for(int arc=0;arc<6;arc++) {\n      input.ints[0] = arc;\n      output.bytes[0] = (byte) arc;\n      builder.add(input, BytesRef.deepCopyOf(output));\n    }\n\n    final FST<BytesRef> fst = builder.finish();\n    for(int arc=0;arc<6;arc++) {\n      input.ints[0] = arc;\n      final BytesRef result = Util.get(fst, input);\n      assertNotNull(result);\n      assertEquals(300, result.length);\n      assertEquals(result.bytes[result.offset], arc);\n      for(int byteIDX=1;byteIDX<result.length;byteIDX++) {\n        assertEquals(0, result.bytes[result.offset+byteIDX]);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd92b8bcc88e969302510acf77bd6970da3994c4","date":1327839530,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testLargeOutputsOnArrayArcs().mjava","pathOld":"/dev/null","sourceNew":"  public void testLargeOutputsOnArrayArcs() throws Exception {\n    final ByteSequenceOutputs outputs = ByteSequenceOutputs.getSingleton();\n    final Builder<BytesRef> builder = new Builder<BytesRef>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    final byte[] bytes = new byte[300];\n    final IntsRef input = new IntsRef();\n    input.grow(1);\n    input.length = 1;\n    final BytesRef output = new BytesRef(bytes);\n    for(int arc=0;arc<6;arc++) {\n      input.ints[0] = arc;\n      output.bytes[0] = (byte) arc;\n      builder.add(input, BytesRef.deepCopyOf(output));\n    }\n\n    final FST<BytesRef> fst = builder.finish();\n    for(int arc=0;arc<6;arc++) {\n      input.ints[0] = arc;\n      final BytesRef result = Util.get(fst, input);\n      assertNotNull(result);\n      assertEquals(300, result.length);\n      assertEquals(result.bytes[result.offset], arc);\n      for(int byteIDX=1;byteIDX<result.length;byteIDX++) {\n        assertEquals(0, result.bytes[result.offset+byteIDX]);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testLargeOutputsOnArrayArcs().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testLargeOutputsOnArrayArcs().mjava","sourceNew":"  public void testLargeOutputsOnArrayArcs() throws Exception {\n    final ByteSequenceOutputs outputs = ByteSequenceOutputs.getSingleton();\n    final Builder<BytesRef> builder = new Builder<BytesRef>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    final byte[] bytes = new byte[300];\n    final IntsRef input = new IntsRef();\n    input.grow(1);\n    input.length = 1;\n    final BytesRef output = new BytesRef(bytes);\n    for(int arc=0;arc<6;arc++) {\n      input.ints[0] = arc;\n      output.bytes[0] = (byte) arc;\n      builder.add(input, BytesRef.deepCopyOf(output));\n    }\n\n    final FST<BytesRef> fst = builder.finish();\n    for(int arc=0;arc<6;arc++) {\n      input.ints[0] = arc;\n      final BytesRef result = Util.get(fst, input);\n      assertNotNull(result);\n      assertEquals(300, result.length);\n      assertEquals(result.bytes[result.offset], arc);\n      for(int byteIDX=1;byteIDX<result.length;byteIDX++) {\n        assertEquals(0, result.bytes[result.offset+byteIDX]);\n      }\n    }\n  }\n\n","sourceOld":"  public void testLargeOutputsOnArrayArcs() throws Exception {\n    final ByteSequenceOutputs outputs = ByteSequenceOutputs.getSingleton();\n    final Builder<BytesRef> builder = new Builder<BytesRef>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    final byte[] bytes = new byte[300];\n    final IntsRef input = new IntsRef();\n    input.grow(1);\n    input.length = 1;\n    final BytesRef output = new BytesRef(bytes);\n    for(int arc=0;arc<6;arc++) {\n      input.ints[0] = arc;\n      output.bytes[0] = (byte) arc;\n      builder.add(input, BytesRef.deepCopyOf(output));\n    }\n\n    final FST<BytesRef> fst = builder.finish();\n    for(int arc=0;arc<6;arc++) {\n      input.ints[0] = arc;\n      final BytesRef result = Util.get(fst, input);\n      assertNotNull(result);\n      assertEquals(300, result.length);\n      assertEquals(result.bytes[result.offset], arc);\n      for(int byteIDX=1;byteIDX<result.length;byteIDX++) {\n        assertEquals(0, result.bytes[result.offset+byteIDX]);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"0b6d0fabff70855609f5c77e7555f106cdab31f8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"78a55f24d9b493c2a1cecf79f1d78279062b545b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0b6d0fabff70855609f5c77e7555f106cdab31f8"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["0b6d0fabff70855609f5c77e7555f106cdab31f8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fd92b8bcc88e969302510acf77bd6970da3994c4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0b6d0fabff70855609f5c77e7555f106cdab31f8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"0b6d0fabff70855609f5c77e7555f106cdab31f8":["78a55f24d9b493c2a1cecf79f1d78279062b545b","3a119bbc8703c10faa329ec201c654b3a35a1e3e","fd92b8bcc88e969302510acf77bd6970da3994c4"],"78a55f24d9b493c2a1cecf79f1d78279062b545b":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0b6d0fabff70855609f5c77e7555f106cdab31f8","78a55f24d9b493c2a1cecf79f1d78279062b545b","fd92b8bcc88e969302510acf77bd6970da3994c4"],"fd92b8bcc88e969302510acf77bd6970da3994c4":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["78a55f24d9b493c2a1cecf79f1d78279062b545b","fd92b8bcc88e969302510acf77bd6970da3994c4","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}