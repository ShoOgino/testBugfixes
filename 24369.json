{"path":"src/test/org/apache/solr/core/SolrCoreTest#testRefCountMT().mjava","commits":[{"id":"c28792ff7d1774c306e16afbd44ded91a417049b","date":1219072108,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/solr/core/SolrCoreTest#testRefCountMT().mjava","pathOld":"/dev/null","sourceNew":"  public void testRefCountMT() throws Exception {\n    SolrCore core = h.getCore();\n    assertTrue(\"Refcount != 1\", core.getOpenCount() == 1);\n\n    final ClosingRequestHandler handler1 = new ClosingRequestHandler();\n    handler1.inform(core);\n    String path = \"/this/is A path /that won't be registered!\";\n    SolrRequestHandler old = core.registerRequestHandler(path, handler1);\n    assertNull(old); // should not be anything...\n    assertEquals(core.getRequestHandlers().get(path), handler1);\n\n    final int LOOP = 100;\n    final int MT = 16;\n    ExecutorService service = Executors.newFixedThreadPool(MT);\n    List<Callable<Integer>> callees = new ArrayList<Callable<Integer>>(MT);\n    final CoreContainer cores = h.getCoreContainer();\n    for (int i = 0; i < MT; ++i) {\n      Callable<Integer> call = new Callable<Integer>() {\n        void yield(int n) {\n          try {\n            Thread.sleep(0, (n % 13 + 1) * 10);\n          } catch (InterruptedException xint) {\n          }\n        }\n        \n        public Integer call() {\n          SolrCore core = null;\n          int r = 0;\n          try {\n            for (int l = 0; l < LOOP; ++l) {\n              r += 1;\n              core = cores.getCore(\"\");\n              // sprinkle concurrency hinting...\n              yield(l);\n              assertTrue(\"Refcount < 1\", core.getOpenCount() >= 1);              \n              yield(l);\n              assertTrue(\"Refcount > 17\", core.getOpenCount() <= 17);             \n              yield(l);\n              assertTrue(\"Handler is closed\", handler1.closed == false);\n              yield(l);\n              core.close();\n              core = null;\n              yield(l);\n            }\n            return r;\n          } finally {\n            if (core != null)\n              core.close();\n          }\n        }\n      };\n      callees.add(call);\n    }\n\n    List<Future<Integer>> results = service.invokeAll(callees);\n    for (Future<Integer> result : results) {\n      assertTrue(\"loop=\" + result.get() +\" < \" + LOOP, result.get() >= LOOP);\n    }\n    \n    cores.shutdown();\n    assertTrue(\"Refcount != 0\", core.getOpenCount() == 0);\n    assertTrue(\"Handler not closed\", core.isClosed() && handler1.closed == true);\n    \n    service.shutdown();\n    assertTrue(\"Running for too long...\", service.awaitTermination(60, TimeUnit.SECONDS));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/core/SolrCoreTest#testRefCountMT().mjava","pathOld":"src/test/org/apache/solr/core/SolrCoreTest#testRefCountMT().mjava","sourceNew":"  public void testRefCountMT() throws Exception {\n    SolrCore core = h.getCore();\n    assertTrue(\"Refcount != 1\", core.getOpenCount() == 1);\n\n    final ClosingRequestHandler handler1 = new ClosingRequestHandler();\n    handler1.inform(core);\n    String path = \"/this/is A path /that won't be registered!\";\n    SolrRequestHandler old = core.registerRequestHandler(path, handler1);\n    assertNull(old); // should not be anything...\n    assertEquals(core.getRequestHandlers().get(path), handler1);\n\n    final int LOOP = 100;\n    final int MT = 16;\n    ExecutorService service = Executors.newFixedThreadPool(MT);\n    List<Callable<Integer>> callees = new ArrayList<Callable<Integer>>(MT);\n    final CoreContainer cores = h.getCoreContainer();\n    for (int i = 0; i < MT; ++i) {\n      Callable<Integer> call = new Callable<Integer>() {\n        void yield(int n) {\n          try {\n            Thread.sleep(0, (n % 13 + 1) * 10);\n          } catch (InterruptedException xint) {\n          }\n        }\n        \n        public Integer call() {\n          SolrCore core = null;\n          int r = 0;\n          try {\n            for (int l = 0; l < LOOP; ++l) {\n              r += 1;\n              core = cores.getCore(\"\");\n              // sprinkle concurrency hinting...\n              yield(l);\n              assertTrue(\"Refcount < 1\", core.getOpenCount() >= 1);              \n              yield(l);\n              assertTrue(\"Refcount > 17\", core.getOpenCount() <= 17);             \n              yield(l);\n              assertTrue(\"Handler is closed\", handler1.closed == false);\n              yield(l);\n              core.close();\n              core = null;\n              yield(l);\n            }\n            return r;\n          } finally {\n            if (core != null)\n              core.close();\n          }\n        }\n      };\n      callees.add(call);\n    }\n\n    List<Future<Integer>> results = service.invokeAll(callees);\n    for (Future<Integer> result : results) {\n      assertTrue(\"loop=\" + result.get() +\" < \" + LOOP, result.get() >= LOOP);\n    }\n    \n    cores.shutdown();\n    assertTrue(\"Refcount != 0\", core.getOpenCount() == 0);\n    assertTrue(\"Handler not closed\", core.isClosed() && handler1.closed == true);\n    \n    service.shutdown();\n    assertTrue(\"Running for too long...\", service.awaitTermination(60, TimeUnit.SECONDS));\n  }\n\n","sourceOld":"  public void testRefCountMT() throws Exception {\n    SolrCore core = h.getCore();\n    assertTrue(\"Refcount != 1\", core.getOpenCount() == 1);\n\n    final ClosingRequestHandler handler1 = new ClosingRequestHandler();\n    handler1.inform(core);\n    String path = \"/this/is A path /that won't be registered!\";\n    SolrRequestHandler old = core.registerRequestHandler(path, handler1);\n    assertNull(old); // should not be anything...\n    assertEquals(core.getRequestHandlers().get(path), handler1);\n\n    final int LOOP = 100;\n    final int MT = 16;\n    ExecutorService service = Executors.newFixedThreadPool(MT);\n    List<Callable<Integer>> callees = new ArrayList<Callable<Integer>>(MT);\n    final CoreContainer cores = h.getCoreContainer();\n    for (int i = 0; i < MT; ++i) {\n      Callable<Integer> call = new Callable<Integer>() {\n        void yield(int n) {\n          try {\n            Thread.sleep(0, (n % 13 + 1) * 10);\n          } catch (InterruptedException xint) {\n          }\n        }\n        \n        public Integer call() {\n          SolrCore core = null;\n          int r = 0;\n          try {\n            for (int l = 0; l < LOOP; ++l) {\n              r += 1;\n              core = cores.getCore(\"\");\n              // sprinkle concurrency hinting...\n              yield(l);\n              assertTrue(\"Refcount < 1\", core.getOpenCount() >= 1);              \n              yield(l);\n              assertTrue(\"Refcount > 17\", core.getOpenCount() <= 17);             \n              yield(l);\n              assertTrue(\"Handler is closed\", handler1.closed == false);\n              yield(l);\n              core.close();\n              core = null;\n              yield(l);\n            }\n            return r;\n          } finally {\n            if (core != null)\n              core.close();\n          }\n        }\n      };\n      callees.add(call);\n    }\n\n    List<Future<Integer>> results = service.invokeAll(callees);\n    for (Future<Integer> result : results) {\n      assertTrue(\"loop=\" + result.get() +\" < \" + LOOP, result.get() >= LOOP);\n    }\n    \n    cores.shutdown();\n    assertTrue(\"Refcount != 0\", core.getOpenCount() == 0);\n    assertTrue(\"Handler not closed\", core.isClosed() && handler1.closed == true);\n    \n    service.shutdown();\n    assertTrue(\"Running for too long...\", service.awaitTermination(60, TimeUnit.SECONDS));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"c28792ff7d1774c306e16afbd44ded91a417049b":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"ad94625fb8d088209f46650c8097196fec67f00c":["c28792ff7d1774c306e16afbd44ded91a417049b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["c28792ff7d1774c306e16afbd44ded91a417049b"],"c28792ff7d1774c306e16afbd44ded91a417049b":["ad94625fb8d088209f46650c8097196fec67f00c"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}