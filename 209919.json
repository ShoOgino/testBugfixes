{"path":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(SolrIndexSearcher).mjava","commits":[{"id":"773a737806859660d4756f710adc0ad53e05f9d5","date":1432140757,"type":0,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(SolrIndexSearcher).mjava","pathOld":"/dev/null","sourceNew":"  public Long getMaxVersionFromIndex(SolrIndexSearcher searcher) throws IOException {\n\n    String versionFieldName = versionField.getName();\n\n    log.info(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    long maxVersionInIndex = 0L;\n\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      Terms versionTerms = searcher.getLeafReader().terms(versionFieldName);\n      if (versionTerms != null) {\n        maxVersionInIndex = NumericUtils.getMaxLong(versionTerms);\n        log.info(\"Found MAX value {} from Terms for {} in index\", maxVersionInIndex, versionFieldName);\n      } else {\n        log.warn(\"No terms found for {}, cannot seed version bucket highest value from index\", versionFieldName);\n      }\n    } else {\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map funcContext = ValueSource.newContext(searcher);\n      vs.createWeight(funcContext, searcher);\n      // TODO: multi-thread this\n      for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n        int maxDoc = ctx.reader().maxDoc();\n        FunctionValues fv = vs.getValues(funcContext, ctx);\n        for (int doc = 0; doc < maxDoc; doc++) {\n          long v = fv.longVal(doc);\n          maxVersionInIndex = Math.max(v, maxVersionInIndex);\n        }\n      }\n    }\n\n    return maxVersionInIndex;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["1248476067f7f652e875bd77a9a3faeecde50430","7049ad12744e132ed475c4ad0e547cecc4ef0053"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9220b7d1848f68bc299608612f8e0139c4036fcf","date":1432485783,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(SolrIndexSearcher).mjava","sourceNew":"  public Long getMaxVersionFromIndex(SolrIndexSearcher searcher) throws IOException {\n\n    String versionFieldName = versionField.getName();\n\n    log.info(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    long maxVersionInIndex = 0L;\n\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      Terms versionTerms = searcher.getLeafReader().terms(versionFieldName);\n      if (versionTerms != null) {\n        maxVersionInIndex = NumericUtils.getMaxLong(versionTerms);\n        log.info(\"Found MAX value {} from Terms for {} in index\", maxVersionInIndex, versionFieldName);\n      } else {\n        log.info(\"No terms found for {}, cannot seed version bucket highest value from index\", versionFieldName);\n      }\n    } else {\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map funcContext = ValueSource.newContext(searcher);\n      vs.createWeight(funcContext, searcher);\n      // TODO: multi-thread this\n      for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n        int maxDoc = ctx.reader().maxDoc();\n        FunctionValues fv = vs.getValues(funcContext, ctx);\n        for (int doc = 0; doc < maxDoc; doc++) {\n          long v = fv.longVal(doc);\n          maxVersionInIndex = Math.max(v, maxVersionInIndex);\n        }\n      }\n    }\n\n    return maxVersionInIndex;\n  }\n\n","sourceOld":"  public Long getMaxVersionFromIndex(SolrIndexSearcher searcher) throws IOException {\n\n    String versionFieldName = versionField.getName();\n\n    log.info(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    long maxVersionInIndex = 0L;\n\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      Terms versionTerms = searcher.getLeafReader().terms(versionFieldName);\n      if (versionTerms != null) {\n        maxVersionInIndex = NumericUtils.getMaxLong(versionTerms);\n        log.info(\"Found MAX value {} from Terms for {} in index\", maxVersionInIndex, versionFieldName);\n      } else {\n        log.warn(\"No terms found for {}, cannot seed version bucket highest value from index\", versionFieldName);\n      }\n    } else {\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map funcContext = ValueSource.newContext(searcher);\n      vs.createWeight(funcContext, searcher);\n      // TODO: multi-thread this\n      for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n        int maxDoc = ctx.reader().maxDoc();\n        FunctionValues fv = vs.getValues(funcContext, ctx);\n        for (int doc = 0; doc < maxDoc; doc++) {\n          long v = fv.longVal(doc);\n          maxVersionInIndex = Math.max(v, maxVersionInIndex);\n        }\n      }\n    }\n\n    return maxVersionInIndex;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9d775b03c78dd6a655e7096562b3c54fc991e200","date":1438772930,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(SolrIndexSearcher).mjava","sourceNew":"  public Long getMaxVersionFromIndex(SolrIndexSearcher searcher) throws IOException {\n\n    String versionFieldName = versionField.getName();\n\n    log.info(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    long maxVersionInIndex = 0L;\n\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      Terms versionTerms = searcher.getLeafReader().terms(versionFieldName);\n      if (versionTerms != null) {\n\n        log.info(\"\\n\\n versionTerms is a \"+versionTerms.getClass().getName()+\", versionTerms.size() = \"+versionTerms.size()+\" \\n\\n\");\n\n        maxVersionInIndex = NumericUtils.getMaxLong(versionTerms);\n        log.info(\"Found MAX value {} from Terms for {} in index\", maxVersionInIndex, versionFieldName);\n      } else {\n        log.info(\"No terms found for {}, cannot seed version bucket highest value from index\", versionFieldName);\n      }\n    } else {\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map funcContext = ValueSource.newContext(searcher);\n      vs.createWeight(funcContext, searcher);\n      // TODO: multi-thread this\n      for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n        int maxDoc = ctx.reader().maxDoc();\n        FunctionValues fv = vs.getValues(funcContext, ctx);\n        for (int doc = 0; doc < maxDoc; doc++) {\n          long v = fv.longVal(doc);\n          maxVersionInIndex = Math.max(v, maxVersionInIndex);\n        }\n      }\n    }\n\n    return maxVersionInIndex;\n  }\n\n","sourceOld":"  public Long getMaxVersionFromIndex(SolrIndexSearcher searcher) throws IOException {\n\n    String versionFieldName = versionField.getName();\n\n    log.info(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    long maxVersionInIndex = 0L;\n\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      Terms versionTerms = searcher.getLeafReader().terms(versionFieldName);\n      if (versionTerms != null) {\n        maxVersionInIndex = NumericUtils.getMaxLong(versionTerms);\n        log.info(\"Found MAX value {} from Terms for {} in index\", maxVersionInIndex, versionFieldName);\n      } else {\n        log.info(\"No terms found for {}, cannot seed version bucket highest value from index\", versionFieldName);\n      }\n    } else {\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map funcContext = ValueSource.newContext(searcher);\n      vs.createWeight(funcContext, searcher);\n      // TODO: multi-thread this\n      for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n        int maxDoc = ctx.reader().maxDoc();\n        FunctionValues fv = vs.getValues(funcContext, ctx);\n        for (int doc = 0; doc < maxDoc; doc++) {\n          long v = fv.longVal(doc);\n          maxVersionInIndex = Math.max(v, maxVersionInIndex);\n        }\n      }\n    }\n\n    return maxVersionInIndex;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0b0d2d199bb71ec1b8a01057db2cc28c3b11d040","date":1438773029,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(SolrIndexSearcher).mjava","sourceNew":"  public Long getMaxVersionFromIndex(SolrIndexSearcher searcher) throws IOException {\n\n    String versionFieldName = versionField.getName();\n\n    log.info(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    long maxVersionInIndex = 0L;\n\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      Terms versionTerms = searcher.getLeafReader().terms(versionFieldName);\n      if (versionTerms != null) {\n        maxVersionInIndex = NumericUtils.getMaxLong(versionTerms);\n        log.info(\"Found MAX value {} from Terms for {} in index\", maxVersionInIndex, versionFieldName);\n      } else {\n        log.info(\"No terms found for {}, cannot seed version bucket highest value from index\", versionFieldName);\n      }\n    } else {\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map funcContext = ValueSource.newContext(searcher);\n      vs.createWeight(funcContext, searcher);\n      // TODO: multi-thread this\n      for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n        int maxDoc = ctx.reader().maxDoc();\n        FunctionValues fv = vs.getValues(funcContext, ctx);\n        for (int doc = 0; doc < maxDoc; doc++) {\n          long v = fv.longVal(doc);\n          maxVersionInIndex = Math.max(v, maxVersionInIndex);\n        }\n      }\n    }\n\n    return maxVersionInIndex;\n  }\n\n","sourceOld":"  public Long getMaxVersionFromIndex(SolrIndexSearcher searcher) throws IOException {\n\n    String versionFieldName = versionField.getName();\n\n    log.info(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    long maxVersionInIndex = 0L;\n\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      Terms versionTerms = searcher.getLeafReader().terms(versionFieldName);\n      if (versionTerms != null) {\n\n        log.info(\"\\n\\n versionTerms is a \"+versionTerms.getClass().getName()+\", versionTerms.size() = \"+versionTerms.size()+\" \\n\\n\");\n\n        maxVersionInIndex = NumericUtils.getMaxLong(versionTerms);\n        log.info(\"Found MAX value {} from Terms for {} in index\", maxVersionInIndex, versionFieldName);\n      } else {\n        log.info(\"No terms found for {}, cannot seed version bucket highest value from index\", versionFieldName);\n      }\n    } else {\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map funcContext = ValueSource.newContext(searcher);\n      vs.createWeight(funcContext, searcher);\n      // TODO: multi-thread this\n      for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n        int maxDoc = ctx.reader().maxDoc();\n        FunctionValues fv = vs.getValues(funcContext, ctx);\n        for (int doc = 0; doc < maxDoc; doc++) {\n          long v = fv.longVal(doc);\n          maxVersionInIndex = Math.max(v, maxVersionInIndex);\n        }\n      }\n    }\n\n    return maxVersionInIndex;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7049ad12744e132ed475c4ad0e547cecc4ef0053","date":1438822408,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(SolrIndexSearcher).mjava","sourceNew":"  public Long getMaxVersionFromIndex(SolrIndexSearcher searcher) throws IOException {\n\n    String versionFieldName = versionField.getName();\n\n    log.info(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    long maxVersionInIndex = 0L;\n\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      Terms versionTerms = searcher.getLeafReader().terms(versionFieldName);\n      Long max = (versionTerms != null) ? NumericUtils.getMaxLong(versionTerms) : null;\n      if (max != null) {\n        maxVersionInIndex = max.longValue();\n        log.info(\"Found MAX value {} from Terms for {} in index\", maxVersionInIndex, versionFieldName);\n      } else {\n        log.info(\"No terms found for {}, cannot seed version bucket highest value from index\", versionFieldName);\n      }\n    } else {\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map funcContext = ValueSource.newContext(searcher);\n      vs.createWeight(funcContext, searcher);\n      // TODO: multi-thread this\n      for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n        int maxDoc = ctx.reader().maxDoc();\n        FunctionValues fv = vs.getValues(funcContext, ctx);\n        for (int doc = 0; doc < maxDoc; doc++) {\n          long v = fv.longVal(doc);\n          maxVersionInIndex = Math.max(v, maxVersionInIndex);\n        }\n      }\n    }\n\n    return maxVersionInIndex;\n  }\n\n","sourceOld":"  public Long getMaxVersionFromIndex(SolrIndexSearcher searcher) throws IOException {\n\n    String versionFieldName = versionField.getName();\n\n    log.info(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    long maxVersionInIndex = 0L;\n\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      Terms versionTerms = searcher.getLeafReader().terms(versionFieldName);\n      if (versionTerms != null) {\n        maxVersionInIndex = NumericUtils.getMaxLong(versionTerms);\n        log.info(\"Found MAX value {} from Terms for {} in index\", maxVersionInIndex, versionFieldName);\n      } else {\n        log.info(\"No terms found for {}, cannot seed version bucket highest value from index\", versionFieldName);\n      }\n    } else {\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map funcContext = ValueSource.newContext(searcher);\n      vs.createWeight(funcContext, searcher);\n      // TODO: multi-thread this\n      for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n        int maxDoc = ctx.reader().maxDoc();\n        FunctionValues fv = vs.getValues(funcContext, ctx);\n        for (int doc = 0; doc < maxDoc; doc++) {\n          long v = fv.longVal(doc);\n          maxVersionInIndex = Math.max(v, maxVersionInIndex);\n        }\n      }\n    }\n\n    return maxVersionInIndex;\n  }\n\n","bugFix":["773a737806859660d4756f710adc0ad53e05f9d5"],"bugIntro":["1248476067f7f652e875bd77a9a3faeecde50430"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"77cae179618908dcb534af567cdf3019505ada6c","date":1449365361,"type":5,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(SolrIndexSearcher).mjava","sourceNew":"  public Long getMaxVersionFromIndex(IndexSearcher searcher) throws IOException {\n\n    String versionFieldName = versionField.getName();\n\n    log.info(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    long maxVersionInIndex = 0L;\n\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      LeafReader leafReader = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader());\n      Terms versionTerms = leafReader.terms(versionFieldName);\n      Long max = (versionTerms != null) ? NumericUtils.getMaxLong(versionTerms) : null;\n      if (max != null) {\n        maxVersionInIndex = max.longValue();\n        log.info(\"Found MAX value {} from Terms for {} in index\", maxVersionInIndex, versionFieldName);\n      } else {\n        log.info(\"No terms found for {}, cannot seed version bucket highest value from index\", versionFieldName);\n      }\n    } else {\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map funcContext = ValueSource.newContext(searcher);\n      vs.createWeight(funcContext, searcher);\n      // TODO: multi-thread this\n      for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n        int maxDoc = ctx.reader().maxDoc();\n        FunctionValues fv = vs.getValues(funcContext, ctx);\n        for (int doc = 0; doc < maxDoc; doc++) {\n          long v = fv.longVal(doc);\n          maxVersionInIndex = Math.max(v, maxVersionInIndex);\n        }\n      }\n    }\n\n    return maxVersionInIndex;\n  }\n\n","sourceOld":"  public Long getMaxVersionFromIndex(SolrIndexSearcher searcher) throws IOException {\n\n    String versionFieldName = versionField.getName();\n\n    log.info(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    long maxVersionInIndex = 0L;\n\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      Terms versionTerms = searcher.getLeafReader().terms(versionFieldName);\n      Long max = (versionTerms != null) ? NumericUtils.getMaxLong(versionTerms) : null;\n      if (max != null) {\n        maxVersionInIndex = max.longValue();\n        log.info(\"Found MAX value {} from Terms for {} in index\", maxVersionInIndex, versionFieldName);\n      } else {\n        log.info(\"No terms found for {}, cannot seed version bucket highest value from index\", versionFieldName);\n      }\n    } else {\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map funcContext = ValueSource.newContext(searcher);\n      vs.createWeight(funcContext, searcher);\n      // TODO: multi-thread this\n      for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n        int maxDoc = ctx.reader().maxDoc();\n        FunctionValues fv = vs.getValues(funcContext, ctx);\n        for (int doc = 0; doc < maxDoc; doc++) {\n          long v = fv.longVal(doc);\n          maxVersionInIndex = Math.max(v, maxVersionInIndex);\n        }\n      }\n    }\n\n    return maxVersionInIndex;\n  }\n\n","bugFix":null,"bugIntro":["1248476067f7f652e875bd77a9a3faeecde50430"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"77cae179618908dcb534af567cdf3019505ada6c":["7049ad12744e132ed475c4ad0e547cecc4ef0053"],"9220b7d1848f68bc299608612f8e0139c4036fcf":["773a737806859660d4756f710adc0ad53e05f9d5"],"0b0d2d199bb71ec1b8a01057db2cc28c3b11d040":["9d775b03c78dd6a655e7096562b3c54fc991e200"],"773a737806859660d4756f710adc0ad53e05f9d5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7049ad12744e132ed475c4ad0e547cecc4ef0053":["0b0d2d199bb71ec1b8a01057db2cc28c3b11d040"],"9d775b03c78dd6a655e7096562b3c54fc991e200":["9220b7d1848f68bc299608612f8e0139c4036fcf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["77cae179618908dcb534af567cdf3019505ada6c"]},"commit2Childs":{"77cae179618908dcb534af567cdf3019505ada6c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9220b7d1848f68bc299608612f8e0139c4036fcf":["9d775b03c78dd6a655e7096562b3c54fc991e200"],"773a737806859660d4756f710adc0ad53e05f9d5":["9220b7d1848f68bc299608612f8e0139c4036fcf"],"0b0d2d199bb71ec1b8a01057db2cc28c3b11d040":["7049ad12744e132ed475c4ad0e547cecc4ef0053"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["773a737806859660d4756f710adc0ad53e05f9d5"],"7049ad12744e132ed475c4ad0e547cecc4ef0053":["77cae179618908dcb534af567cdf3019505ada6c"],"9d775b03c78dd6a655e7096562b3c54fc991e200":["0b0d2d199bb71ec1b8a01057db2cc28c3b11d040"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}