{"path":"solr/core/src/test/org/apache/solr/spelling/SpellPossibilityIteratorTest#testOverlappingTokens().mjava","commits":[{"id":"0ad9ec888e587ca9a3279368245cdf00aabdc108","date":1338832525,"type":0,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/spelling/SpellPossibilityIteratorTest#testOverlappingTokens().mjava","pathOld":"/dev/null","sourceNew":"\t@Test\n  public void testOverlappingTokens() throws Exception {\n\t  Map<Token, LinkedHashMap<String, Integer>> overlappingSuggestions = new LinkedHashMap<Token, LinkedHashMap<String, Integer>>();\n\t  overlappingSuggestions.put(TOKEN_AYE, AYE);\n    overlappingSuggestions.put(TOKEN_BEE, BEE);\n    overlappingSuggestions.put(TOKEN_AYE_BEE, AYE_BEE);\n    overlappingSuggestions.put(TOKEN_CEE, CEE);\n    \n    PossibilityIterator iter = new PossibilityIterator(overlappingSuggestions, Integer.MAX_VALUE, Integer.MAX_VALUE, true);\n    int aCount = 0;\n    int abCount = 0;\n    Set<PossibilityIterator.RankedSpellPossibility> dupChecker = new HashSet<PossibilityIterator.RankedSpellPossibility>();\n    while (iter.hasNext()) {\n      PossibilityIterator.RankedSpellPossibility rsp = iter.next();\n      Token a = null;\n      Token b = null;\n      Token ab = null;\n      Token c = null;\n      for(SpellCheckCorrection scc : rsp.corrections) {\n        if(scc.getOriginal().equals(TOKEN_AYE)) {\n          a = scc.getOriginal();\n        } else if(scc.getOriginal().equals(TOKEN_BEE)) {\n          b = scc.getOriginal();\n        } else if(scc.getOriginal().equals(TOKEN_AYE_BEE)) {\n          ab = scc.getOriginal();\n        } else if(scc.getOriginal().equals(TOKEN_CEE)) {\n          c = scc.getOriginal();\n        }       \n        if(ab!=null) {\n          abCount++;\n        } else {\n          aCount++;\n        }       \n      }\n      assertTrue(c != null);\n      assertTrue(ab != null || (a!=null && b!=null));\n      assertTrue(ab == null || (a==null && b==null));\n      assertTrue(dupChecker.add(rsp));\n    }\n    assertTrue(aCount==2160);\n    assertTrue(abCount==180);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4093b270ba337f9c25a4c0e6cb2ae2c07f697376","date":1347897716,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/spelling/SpellPossibilityIteratorTest#testOverlappingTokens().mjava","pathOld":"solr/core/src/test/org/apache/solr/spelling/SpellPossibilityIteratorTest#testOverlappingTokens().mjava","sourceNew":"  @Test\n  public void testOverlappingTokens() throws Exception {\n    Map<Token, LinkedHashMap<String, Integer>> overlappingSuggestions = new LinkedHashMap<Token, LinkedHashMap<String, Integer>>();\n    overlappingSuggestions.put(TOKEN_AYE, AYE);\n    overlappingSuggestions.put(TOKEN_BEE, BEE);\n    overlappingSuggestions.put(TOKEN_AYE_BEE, AYE_BEE);\n    overlappingSuggestions.put(TOKEN_CEE, CEE);\n    \n    PossibilityIterator iter = new PossibilityIterator(overlappingSuggestions, Integer.MAX_VALUE, Integer.MAX_VALUE, true);\n    int aCount = 0;\n    int abCount = 0;\n    Set<PossibilityIterator.RankedSpellPossibility> dupChecker = new HashSet<PossibilityIterator.RankedSpellPossibility>();\n    while (iter.hasNext()) {\n      PossibilityIterator.RankedSpellPossibility rsp = iter.next();\n      Token a = null;\n      Token b = null;\n      Token ab = null;\n      Token c = null;\n      for(SpellCheckCorrection scc : rsp.corrections) {\n        if(scc.getOriginal().equals(TOKEN_AYE)) {\n          a = scc.getOriginal();\n        } else if(scc.getOriginal().equals(TOKEN_BEE)) {\n          b = scc.getOriginal();\n        } else if(scc.getOriginal().equals(TOKEN_AYE_BEE)) {\n          ab = scc.getOriginal();\n        } else if(scc.getOriginal().equals(TOKEN_CEE)) {\n          c = scc.getOriginal();\n        }       \n        if(ab!=null) {\n          abCount++;\n        } else {\n          aCount++;\n        }       \n      }\n      assertTrue(c != null);\n      assertTrue(ab != null || (a!=null && b!=null));\n      assertTrue(ab == null || (a==null && b==null));\n      assertTrue(dupChecker.add(rsp));\n    }\n    assertTrue(aCount==2160);\n    assertTrue(abCount==180);\n  }\n\n","sourceOld":"\t@Test\n  public void testOverlappingTokens() throws Exception {\n\t  Map<Token, LinkedHashMap<String, Integer>> overlappingSuggestions = new LinkedHashMap<Token, LinkedHashMap<String, Integer>>();\n\t  overlappingSuggestions.put(TOKEN_AYE, AYE);\n    overlappingSuggestions.put(TOKEN_BEE, BEE);\n    overlappingSuggestions.put(TOKEN_AYE_BEE, AYE_BEE);\n    overlappingSuggestions.put(TOKEN_CEE, CEE);\n    \n    PossibilityIterator iter = new PossibilityIterator(overlappingSuggestions, Integer.MAX_VALUE, Integer.MAX_VALUE, true);\n    int aCount = 0;\n    int abCount = 0;\n    Set<PossibilityIterator.RankedSpellPossibility> dupChecker = new HashSet<PossibilityIterator.RankedSpellPossibility>();\n    while (iter.hasNext()) {\n      PossibilityIterator.RankedSpellPossibility rsp = iter.next();\n      Token a = null;\n      Token b = null;\n      Token ab = null;\n      Token c = null;\n      for(SpellCheckCorrection scc : rsp.corrections) {\n        if(scc.getOriginal().equals(TOKEN_AYE)) {\n          a = scc.getOriginal();\n        } else if(scc.getOriginal().equals(TOKEN_BEE)) {\n          b = scc.getOriginal();\n        } else if(scc.getOriginal().equals(TOKEN_AYE_BEE)) {\n          ab = scc.getOriginal();\n        } else if(scc.getOriginal().equals(TOKEN_CEE)) {\n          c = scc.getOriginal();\n        }       \n        if(ab!=null) {\n          abCount++;\n        } else {\n          aCount++;\n        }       \n      }\n      assertTrue(c != null);\n      assertTrue(ab != null || (a!=null && b!=null));\n      assertTrue(ab == null || (a==null && b==null));\n      assertTrue(dupChecker.add(rsp));\n    }\n    assertTrue(aCount==2160);\n    assertTrue(abCount==180);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/spelling/SpellPossibilityIteratorTest#testOverlappingTokens().mjava","pathOld":"solr/core/src/test/org/apache/solr/spelling/SpellPossibilityIteratorTest#testOverlappingTokens().mjava","sourceNew":"  @Test\n  public void testOverlappingTokens() throws Exception {\n    Map<Token, LinkedHashMap<String, Integer>> overlappingSuggestions = new LinkedHashMap<>();\n    overlappingSuggestions.put(TOKEN_AYE, AYE);\n    overlappingSuggestions.put(TOKEN_BEE, BEE);\n    overlappingSuggestions.put(TOKEN_AYE_BEE, AYE_BEE);\n    overlappingSuggestions.put(TOKEN_CEE, CEE);\n    \n    PossibilityIterator iter = new PossibilityIterator(overlappingSuggestions, Integer.MAX_VALUE, Integer.MAX_VALUE, true);\n    int aCount = 0;\n    int abCount = 0;\n    Set<PossibilityIterator.RankedSpellPossibility> dupChecker = new HashSet<>();\n    while (iter.hasNext()) {\n      PossibilityIterator.RankedSpellPossibility rsp = iter.next();\n      Token a = null;\n      Token b = null;\n      Token ab = null;\n      Token c = null;\n      for(SpellCheckCorrection scc : rsp.corrections) {\n        if(scc.getOriginal().equals(TOKEN_AYE)) {\n          a = scc.getOriginal();\n        } else if(scc.getOriginal().equals(TOKEN_BEE)) {\n          b = scc.getOriginal();\n        } else if(scc.getOriginal().equals(TOKEN_AYE_BEE)) {\n          ab = scc.getOriginal();\n        } else if(scc.getOriginal().equals(TOKEN_CEE)) {\n          c = scc.getOriginal();\n        }       \n        if(ab!=null) {\n          abCount++;\n        } else {\n          aCount++;\n        }       \n      }\n      assertTrue(c != null);\n      assertTrue(ab != null || (a!=null && b!=null));\n      assertTrue(ab == null || (a==null && b==null));\n      assertTrue(dupChecker.add(rsp));\n    }\n    assertTrue(aCount==2160);\n    assertTrue(abCount==180);\n  }\n\n","sourceOld":"  @Test\n  public void testOverlappingTokens() throws Exception {\n    Map<Token, LinkedHashMap<String, Integer>> overlappingSuggestions = new LinkedHashMap<Token, LinkedHashMap<String, Integer>>();\n    overlappingSuggestions.put(TOKEN_AYE, AYE);\n    overlappingSuggestions.put(TOKEN_BEE, BEE);\n    overlappingSuggestions.put(TOKEN_AYE_BEE, AYE_BEE);\n    overlappingSuggestions.put(TOKEN_CEE, CEE);\n    \n    PossibilityIterator iter = new PossibilityIterator(overlappingSuggestions, Integer.MAX_VALUE, Integer.MAX_VALUE, true);\n    int aCount = 0;\n    int abCount = 0;\n    Set<PossibilityIterator.RankedSpellPossibility> dupChecker = new HashSet<PossibilityIterator.RankedSpellPossibility>();\n    while (iter.hasNext()) {\n      PossibilityIterator.RankedSpellPossibility rsp = iter.next();\n      Token a = null;\n      Token b = null;\n      Token ab = null;\n      Token c = null;\n      for(SpellCheckCorrection scc : rsp.corrections) {\n        if(scc.getOriginal().equals(TOKEN_AYE)) {\n          a = scc.getOriginal();\n        } else if(scc.getOriginal().equals(TOKEN_BEE)) {\n          b = scc.getOriginal();\n        } else if(scc.getOriginal().equals(TOKEN_AYE_BEE)) {\n          ab = scc.getOriginal();\n        } else if(scc.getOriginal().equals(TOKEN_CEE)) {\n          c = scc.getOriginal();\n        }       \n        if(ab!=null) {\n          abCount++;\n        } else {\n          aCount++;\n        }       \n      }\n      assertTrue(c != null);\n      assertTrue(ab != null || (a!=null && b!=null));\n      assertTrue(ab == null || (a==null && b==null));\n      assertTrue(dupChecker.add(rsp));\n    }\n    assertTrue(aCount==2160);\n    assertTrue(abCount==180);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"0ad9ec888e587ca9a3279368245cdf00aabdc108":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["0ad9ec888e587ca9a3279368245cdf00aabdc108"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0ad9ec888e587ca9a3279368245cdf00aabdc108":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0ad9ec888e587ca9a3279368245cdf00aabdc108"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}