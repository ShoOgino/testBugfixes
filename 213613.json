{"path":"lucene/facet/src/test/org/apache/lucene/facet/search/params/MultiCategoryListIteratorTest#testMultipleCategoryLists().mjava","commits":[{"id":"bceb02c33032dd9bbf107cd06d0b74e5db4f110a","date":1357909746,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/params/MultiCategoryListIteratorTest#testMultipleCategoryLists().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testMultipleCategoryLists() throws Exception {\n    Random random = random();\n    int numDimensions = atLeast(random, 2); // at least 2 dimensions\n    String[] dimensions = new String[numDimensions];\n    for (int i = 0; i < numDimensions; i++) {\n      dimensions[i] = \"dim\" + i;\n    }\n    \n    // build the PerDimensionIndexingParams\n    HashMap<CategoryPath,CategoryListParams> clps = new HashMap<CategoryPath,CategoryListParams>();\n    for (String dim : dimensions) {\n      CategoryPath cp = new CategoryPath(dim);\n      CategoryListParams clp = new CategoryListParams(new Term(\"$\" + dim, CategoryListParams.DEFAULT_TERM.bytes()));\n      clps.put(cp, clp);\n    }\n    PerDimensionIndexingParams indexingParams = new PerDimensionIndexingParams(clps);\n    \n    // index some documents\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null).setMaxBufferedDocs(2));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    FacetFields facetFields = new FacetFields(taxoWriter, indexingParams);\n    int ndocs = atLeast(random, 10);\n    for (int i = 0; i < ndocs; i++) {\n      Document doc = new Document();\n      int numCategories = random.nextInt(numDimensions) + 1;\n      ArrayList<CategoryPath> categories = new ArrayList<CategoryPath>();\n      for (int j = 0; j < numCategories; j++) {\n        String dimension = dimensions[random.nextInt(dimensions.length)];\n        categories.add(new CategoryPath(dimension, Integer.toString(i)));\n      }\n      facetFields.addFields(doc, categories);\n      indexWriter.addDocument(doc);\n    }\n    IOUtils.close(indexWriter, taxoWriter);\n    \n    // test the multi iterator\n    CategoryListCache clCache = null;\n    if (random.nextBoolean()) {\n      clCache = new CategoryListCache();\n    }\n    \n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n    CategoryListIterator[] iterators = new CategoryListIterator[numDimensions];\n    for (int i = 0; i < iterators.length; i++) {\n      CategoryListParams clp = indexingParams.getCategoryListParams(new CategoryPath(dimensions[i]));\n      IntDecoder decoder = clp.createEncoder().createMatchingDecoder();\n      if (clCache != null && random.nextBoolean()) {\n        clCache.loadAndRegister(clp, indexReader, taxoReader, indexingParams);\n        iterators[i] = clCache.get(clp).iterator(0); // no partitions\n      } else {\n        iterators[i] = new PayloadCategoryListIteraor(indexReader, clp.getTerm(), decoder);\n      }\n    }\n    MultiCategoryListIterator cli = new MultiCategoryListIterator(iterators);\n    assertTrue(\"failed to init multi-iterator\", cli.init());\n    IntsRef ordinals = new IntsRef();\n    int maxDoc = indexReader.maxDoc();\n    for (int i = 0; i < maxDoc; i++) {\n      cli.getOrdinals(i, ordinals);\n      assertTrue(\"document \" + i + \" does not have categories\", ordinals.length > 0);\n      for (int j = 0; j < ordinals.length; j++) {\n        CategoryPath cp = taxoReader.getPath(ordinals.ints[j]);\n        assertNotNull(\"ordinal \" + ordinals.ints[j] + \" not found in taxonomy\", cp);\n        if (cp.length == 2) {\n          assertEquals(\"invalid category for document \" + i, i, Integer.parseInt(cp.components[1]));\n        }\n      }\n    }\n    \n    IOUtils.close(indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4e6354dd7c71fe122926fc53d7d29f715b1283db","date":1357915185,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/params/MultiCategoryListIteratorTest#testMultipleCategoryLists().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testMultipleCategoryLists() throws Exception {\n    Random random = random();\n    int numDimensions = atLeast(random, 2); // at least 2 dimensions\n    String[] dimensions = new String[numDimensions];\n    for (int i = 0; i < numDimensions; i++) {\n      dimensions[i] = \"dim\" + i;\n    }\n    \n    // build the PerDimensionIndexingParams\n    HashMap<CategoryPath,CategoryListParams> clps = new HashMap<CategoryPath,CategoryListParams>();\n    for (String dim : dimensions) {\n      CategoryPath cp = new CategoryPath(dim);\n      CategoryListParams clp = new CategoryListParams(new Term(\"$\" + dim, CategoryListParams.DEFAULT_TERM.bytes()));\n      clps.put(cp, clp);\n    }\n    PerDimensionIndexingParams indexingParams = new PerDimensionIndexingParams(clps);\n    \n    // index some documents\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null).setMaxBufferedDocs(2));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    FacetFields facetFields = new FacetFields(taxoWriter, indexingParams);\n    int ndocs = atLeast(random, 10);\n    for (int i = 0; i < ndocs; i++) {\n      Document doc = new Document();\n      int numCategories = random.nextInt(numDimensions) + 1;\n      ArrayList<CategoryPath> categories = new ArrayList<CategoryPath>();\n      for (int j = 0; j < numCategories; j++) {\n        String dimension = dimensions[random.nextInt(dimensions.length)];\n        categories.add(new CategoryPath(dimension, Integer.toString(i)));\n      }\n      facetFields.addFields(doc, categories);\n      indexWriter.addDocument(doc);\n    }\n    IOUtils.close(indexWriter, taxoWriter);\n    \n    // test the multi iterator\n    CategoryListCache clCache = null;\n    if (random.nextBoolean()) {\n      clCache = new CategoryListCache();\n    }\n    \n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n    CategoryListIterator[] iterators = new CategoryListIterator[numDimensions];\n    for (int i = 0; i < iterators.length; i++) {\n      CategoryListParams clp = indexingParams.getCategoryListParams(new CategoryPath(dimensions[i]));\n      IntDecoder decoder = clp.createEncoder().createMatchingDecoder();\n      if (clCache != null && random.nextBoolean()) {\n        clCache.loadAndRegister(clp, indexReader, taxoReader, indexingParams);\n        iterators[i] = clCache.get(clp).iterator(0); // no partitions\n      } else {\n        iterators[i] = new PayloadCategoryListIteraor(indexReader, clp.getTerm(), decoder);\n      }\n    }\n    MultiCategoryListIterator cli = new MultiCategoryListIterator(iterators);\n    assertTrue(\"failed to init multi-iterator\", cli.init());\n    IntsRef ordinals = new IntsRef();\n    int maxDoc = indexReader.maxDoc();\n    for (int i = 0; i < maxDoc; i++) {\n      cli.getOrdinals(i, ordinals);\n      assertTrue(\"document \" + i + \" does not have categories\", ordinals.length > 0);\n      for (int j = 0; j < ordinals.length; j++) {\n        CategoryPath cp = taxoReader.getPath(ordinals.ints[j]);\n        assertNotNull(\"ordinal \" + ordinals.ints[j] + \" not found in taxonomy\", cp);\n        if (cp.length == 2) {\n          assertEquals(\"invalid category for document \" + i, i, Integer.parseInt(cp.components[1]));\n        }\n      }\n    }\n    \n    IOUtils.close(indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"42f51b3ab4258ff4623227b0db011b8bb83db5c7","date":1358164991,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/params/MultiCategoryListIteratorTest#testMultipleCategoryLists().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/params/MultiCategoryListIteratorTest#testMultipleCategoryLists().mjava","sourceNew":"  @Test\n  public void testMultipleCategoryLists() throws Exception {\n    Random random = random();\n    int numDimensions = atLeast(random, 2); // at least 2 dimensions\n    String[] dimensions = new String[numDimensions];\n    for (int i = 0; i < numDimensions; i++) {\n      dimensions[i] = \"dim\" + i;\n    }\n    \n    // build the PerDimensionIndexingParams\n    HashMap<CategoryPath,CategoryListParams> clps = new HashMap<CategoryPath,CategoryListParams>();\n    for (String dim : dimensions) {\n      CategoryPath cp = new CategoryPath(dim);\n      CategoryListParams clp = new CategoryListParams(new Term(\"$\" + dim, CategoryListParams.DEFAULT_TERM.bytes()));\n      clps.put(cp, clp);\n    }\n    PerDimensionIndexingParams indexingParams = new PerDimensionIndexingParams(clps);\n    \n    // index some documents\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null).setMaxBufferedDocs(2));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    FacetFields facetFields = new FacetFields(taxoWriter, indexingParams);\n    int ndocs = atLeast(random, 10);\n    for (int i = 0; i < ndocs; i++) {\n      Document doc = new Document();\n      int numCategories = random.nextInt(numDimensions) + 1;\n      ArrayList<CategoryPath> categories = new ArrayList<CategoryPath>();\n      for (int j = 0; j < numCategories; j++) {\n        String dimension = dimensions[random.nextInt(dimensions.length)];\n        categories.add(new CategoryPath(dimension, Integer.toString(i)));\n      }\n      facetFields.addFields(doc, categories);\n      indexWriter.addDocument(doc);\n    }\n    IOUtils.close(indexWriter, taxoWriter);\n    \n    // test the multi iterator\n    CategoryListCache clCache = null;\n    if (random.nextBoolean()) {\n      clCache = new CategoryListCache();\n    }\n    \n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n    CategoryListIterator[] iterators = new CategoryListIterator[numDimensions];\n    for (int i = 0; i < iterators.length; i++) {\n      CategoryListParams clp = indexingParams.getCategoryListParams(new CategoryPath(dimensions[i]));\n      IntDecoder decoder = clp.createEncoder().createMatchingDecoder();\n      if (clCache != null && random.nextBoolean()) {\n        clCache.loadAndRegister(clp, indexReader, taxoReader, indexingParams);\n        iterators[i] = clCache.get(clp).iterator(0); // no partitions\n      } else {\n        iterators[i] = new PayloadCategoryListIteraor(clp.getTerm(), decoder);\n      }\n    }\n    MultiCategoryListIterator cli = new MultiCategoryListIterator(iterators);\n    for (AtomicReaderContext context : indexReader.leaves()) {\n      assertTrue(\"failed to init multi-iterator\", cli.setNextReader(context));\n      IntsRef ordinals = new IntsRef();\n      final int maxDoc = context.reader().maxDoc();\n      for (int i = 0; i < maxDoc; i++) {\n        cli.getOrdinals(i, ordinals);\n        assertTrue(\"document \" + i + \" does not have categories\", ordinals.length > 0);\n        for (int j = 0; j < ordinals.length; j++) {\n          CategoryPath cp = taxoReader.getPath(ordinals.ints[j]);\n          assertNotNull(\"ordinal \" + ordinals.ints[j] + \" not found in taxonomy\", cp);\n          if (cp.length == 2) {\n            int globalDoc = i + context.docBase;\n            assertEquals(\"invalid category for document \" + globalDoc, globalDoc, Integer.parseInt(cp.components[1]));\n          }\n        }\n      }\n    }\n    \n    IOUtils.close(indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","sourceOld":"  @Test\n  public void testMultipleCategoryLists() throws Exception {\n    Random random = random();\n    int numDimensions = atLeast(random, 2); // at least 2 dimensions\n    String[] dimensions = new String[numDimensions];\n    for (int i = 0; i < numDimensions; i++) {\n      dimensions[i] = \"dim\" + i;\n    }\n    \n    // build the PerDimensionIndexingParams\n    HashMap<CategoryPath,CategoryListParams> clps = new HashMap<CategoryPath,CategoryListParams>();\n    for (String dim : dimensions) {\n      CategoryPath cp = new CategoryPath(dim);\n      CategoryListParams clp = new CategoryListParams(new Term(\"$\" + dim, CategoryListParams.DEFAULT_TERM.bytes()));\n      clps.put(cp, clp);\n    }\n    PerDimensionIndexingParams indexingParams = new PerDimensionIndexingParams(clps);\n    \n    // index some documents\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null).setMaxBufferedDocs(2));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    FacetFields facetFields = new FacetFields(taxoWriter, indexingParams);\n    int ndocs = atLeast(random, 10);\n    for (int i = 0; i < ndocs; i++) {\n      Document doc = new Document();\n      int numCategories = random.nextInt(numDimensions) + 1;\n      ArrayList<CategoryPath> categories = new ArrayList<CategoryPath>();\n      for (int j = 0; j < numCategories; j++) {\n        String dimension = dimensions[random.nextInt(dimensions.length)];\n        categories.add(new CategoryPath(dimension, Integer.toString(i)));\n      }\n      facetFields.addFields(doc, categories);\n      indexWriter.addDocument(doc);\n    }\n    IOUtils.close(indexWriter, taxoWriter);\n    \n    // test the multi iterator\n    CategoryListCache clCache = null;\n    if (random.nextBoolean()) {\n      clCache = new CategoryListCache();\n    }\n    \n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n    CategoryListIterator[] iterators = new CategoryListIterator[numDimensions];\n    for (int i = 0; i < iterators.length; i++) {\n      CategoryListParams clp = indexingParams.getCategoryListParams(new CategoryPath(dimensions[i]));\n      IntDecoder decoder = clp.createEncoder().createMatchingDecoder();\n      if (clCache != null && random.nextBoolean()) {\n        clCache.loadAndRegister(clp, indexReader, taxoReader, indexingParams);\n        iterators[i] = clCache.get(clp).iterator(0); // no partitions\n      } else {\n        iterators[i] = new PayloadCategoryListIteraor(indexReader, clp.getTerm(), decoder);\n      }\n    }\n    MultiCategoryListIterator cli = new MultiCategoryListIterator(iterators);\n    assertTrue(\"failed to init multi-iterator\", cli.init());\n    IntsRef ordinals = new IntsRef();\n    int maxDoc = indexReader.maxDoc();\n    for (int i = 0; i < maxDoc; i++) {\n      cli.getOrdinals(i, ordinals);\n      assertTrue(\"document \" + i + \" does not have categories\", ordinals.length > 0);\n      for (int j = 0; j < ordinals.length; j++) {\n        CategoryPath cp = taxoReader.getPath(ordinals.ints[j]);\n        assertNotNull(\"ordinal \" + ordinals.ints[j] + \" not found in taxonomy\", cp);\n        if (cp.length == 2) {\n          assertEquals(\"invalid category for document \" + i, i, Integer.parseInt(cp.components[1]));\n        }\n      }\n    }\n    \n    IOUtils.close(indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8917bfede3b4ca30f4305c1e391e9218959cd723","date":1358189662,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/params/MultiCategoryListIteratorTest#testMultipleCategoryLists().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/params/MultiCategoryListIteratorTest#testMultipleCategoryLists().mjava","sourceNew":"  @Test\n  public void testMultipleCategoryLists() throws Exception {\n    Random random = random();\n    int numDimensions = atLeast(random, 2); // at least 2 dimensions\n    String[] dimensions = new String[numDimensions];\n    for (int i = 0; i < numDimensions; i++) {\n      dimensions[i] = \"dim\" + i;\n    }\n    \n    // build the PerDimensionIndexingParams\n    HashMap<CategoryPath,CategoryListParams> clps = new HashMap<CategoryPath,CategoryListParams>();\n    for (String dim : dimensions) {\n      CategoryPath cp = new CategoryPath(dim);\n      CategoryListParams clp = new CategoryListParams(new Term(\"$\" + dim, CategoryListParams.DEFAULT_TERM.bytes()));\n      clps.put(cp, clp);\n    }\n    PerDimensionIndexingParams indexingParams = new PerDimensionIndexingParams(clps);\n    \n    // index some documents\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null).setMaxBufferedDocs(2));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    FacetFields facetFields = new FacetFields(taxoWriter, indexingParams);\n    int ndocs = atLeast(random, 10);\n    for (int i = 0; i < ndocs; i++) {\n      Document doc = new Document();\n      int numCategories = random.nextInt(numDimensions) + 1;\n      ArrayList<CategoryPath> categories = new ArrayList<CategoryPath>();\n      for (int j = 0; j < numCategories; j++) {\n        String dimension = dimensions[random.nextInt(dimensions.length)];\n        categories.add(new CategoryPath(dimension, Integer.toString(i)));\n      }\n      facetFields.addFields(doc, categories);\n      indexWriter.addDocument(doc);\n    }\n    IOUtils.close(indexWriter, taxoWriter);\n    \n    // test the multi iterator\n    CategoryListCache clCache = null;\n    if (random.nextBoolean()) {\n      clCache = new CategoryListCache();\n    }\n    \n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n    CategoryListIterator[] iterators = new CategoryListIterator[numDimensions];\n    for (int i = 0; i < iterators.length; i++) {\n      CategoryListParams clp = indexingParams.getCategoryListParams(new CategoryPath(dimensions[i]));\n      IntDecoder decoder = clp.createEncoder().createMatchingDecoder();\n      if (clCache != null && random.nextBoolean()) {\n        clCache.loadAndRegister(clp, indexReader, taxoReader, indexingParams);\n        iterators[i] = clCache.get(clp).iterator(0); // no partitions\n      } else {\n        iterators[i] = new PayloadCategoryListIteraor(clp.getTerm(), decoder);\n      }\n    }\n    MultiCategoryListIterator cli = new MultiCategoryListIterator(iterators);\n    for (AtomicReaderContext context : indexReader.leaves()) {\n      assertTrue(\"failed to init multi-iterator\", cli.setNextReader(context));\n      IntsRef ordinals = new IntsRef();\n      final int maxDoc = context.reader().maxDoc();\n      for (int i = 0; i < maxDoc; i++) {\n        cli.getOrdinals(i, ordinals);\n        assertTrue(\"document \" + i + \" does not have categories\", ordinals.length > 0);\n        for (int j = 0; j < ordinals.length; j++) {\n          CategoryPath cp = taxoReader.getPath(ordinals.ints[j]);\n          assertNotNull(\"ordinal \" + ordinals.ints[j] + \" not found in taxonomy\", cp);\n          if (cp.length == 2) {\n            int globalDoc = i + context.docBase;\n            assertEquals(\"invalid category for document \" + globalDoc, globalDoc, Integer.parseInt(cp.components[1]));\n          }\n        }\n      }\n    }\n    \n    IOUtils.close(indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","sourceOld":"  @Test\n  public void testMultipleCategoryLists() throws Exception {\n    Random random = random();\n    int numDimensions = atLeast(random, 2); // at least 2 dimensions\n    String[] dimensions = new String[numDimensions];\n    for (int i = 0; i < numDimensions; i++) {\n      dimensions[i] = \"dim\" + i;\n    }\n    \n    // build the PerDimensionIndexingParams\n    HashMap<CategoryPath,CategoryListParams> clps = new HashMap<CategoryPath,CategoryListParams>();\n    for (String dim : dimensions) {\n      CategoryPath cp = new CategoryPath(dim);\n      CategoryListParams clp = new CategoryListParams(new Term(\"$\" + dim, CategoryListParams.DEFAULT_TERM.bytes()));\n      clps.put(cp, clp);\n    }\n    PerDimensionIndexingParams indexingParams = new PerDimensionIndexingParams(clps);\n    \n    // index some documents\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null).setMaxBufferedDocs(2));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    FacetFields facetFields = new FacetFields(taxoWriter, indexingParams);\n    int ndocs = atLeast(random, 10);\n    for (int i = 0; i < ndocs; i++) {\n      Document doc = new Document();\n      int numCategories = random.nextInt(numDimensions) + 1;\n      ArrayList<CategoryPath> categories = new ArrayList<CategoryPath>();\n      for (int j = 0; j < numCategories; j++) {\n        String dimension = dimensions[random.nextInt(dimensions.length)];\n        categories.add(new CategoryPath(dimension, Integer.toString(i)));\n      }\n      facetFields.addFields(doc, categories);\n      indexWriter.addDocument(doc);\n    }\n    IOUtils.close(indexWriter, taxoWriter);\n    \n    // test the multi iterator\n    CategoryListCache clCache = null;\n    if (random.nextBoolean()) {\n      clCache = new CategoryListCache();\n    }\n    \n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n    CategoryListIterator[] iterators = new CategoryListIterator[numDimensions];\n    for (int i = 0; i < iterators.length; i++) {\n      CategoryListParams clp = indexingParams.getCategoryListParams(new CategoryPath(dimensions[i]));\n      IntDecoder decoder = clp.createEncoder().createMatchingDecoder();\n      if (clCache != null && random.nextBoolean()) {\n        clCache.loadAndRegister(clp, indexReader, taxoReader, indexingParams);\n        iterators[i] = clCache.get(clp).iterator(0); // no partitions\n      } else {\n        iterators[i] = new PayloadCategoryListIteraor(indexReader, clp.getTerm(), decoder);\n      }\n    }\n    MultiCategoryListIterator cli = new MultiCategoryListIterator(iterators);\n    assertTrue(\"failed to init multi-iterator\", cli.init());\n    IntsRef ordinals = new IntsRef();\n    int maxDoc = indexReader.maxDoc();\n    for (int i = 0; i < maxDoc; i++) {\n      cli.getOrdinals(i, ordinals);\n      assertTrue(\"document \" + i + \" does not have categories\", ordinals.length > 0);\n      for (int j = 0; j < ordinals.length; j++) {\n        CategoryPath cp = taxoReader.getPath(ordinals.ints[j]);\n        assertNotNull(\"ordinal \" + ordinals.ints[j] + \" not found in taxonomy\", cp);\n        if (cp.length == 2) {\n          assertEquals(\"invalid category for document \" + i, i, Integer.parseInt(cp.components[1]));\n        }\n      }\n    }\n    \n    IOUtils.close(indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c2cd18c7da6f499a33f06fc89c07a463ec074c0","date":1358329431,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/params/MultiCategoryListIteratorTest#testMultipleCategoryLists().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/params/MultiCategoryListIteratorTest#testMultipleCategoryLists().mjava","sourceNew":"  @Test\n  public void testMultipleCategoryLists() throws Exception {\n    Random random = random();\n    int numDimensions = atLeast(random, 2); // at least 2 dimensions\n    String[] dimensions = new String[numDimensions];\n    for (int i = 0; i < numDimensions; i++) {\n      dimensions[i] = \"dim\" + i;\n    }\n    \n    // build the PerDimensionIndexingParams\n    HashMap<CategoryPath,CategoryListParams> clps = new HashMap<CategoryPath,CategoryListParams>();\n    for (String dim : dimensions) {\n      CategoryPath cp = new CategoryPath(dim);\n      CategoryListParams clp = new CategoryListParams(\"$\" + dim);\n      clps.put(cp, clp);\n    }\n    PerDimensionIndexingParams indexingParams = new PerDimensionIndexingParams(clps);\n    \n    // index some documents\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null).setMaxBufferedDocs(2));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    FacetFields facetFields = new FacetFields(taxoWriter, indexingParams);\n    int ndocs = atLeast(random, 10);\n    for (int i = 0; i < ndocs; i++) {\n      Document doc = new Document();\n      int numCategories = random.nextInt(numDimensions) + 1;\n      ArrayList<CategoryPath> categories = new ArrayList<CategoryPath>();\n      for (int j = 0; j < numCategories; j++) {\n        String dimension = dimensions[random.nextInt(dimensions.length)];\n        categories.add(new CategoryPath(dimension, Integer.toString(i)));\n      }\n      facetFields.addFields(doc, categories);\n      indexWriter.addDocument(doc);\n    }\n    IOUtils.close(indexWriter, taxoWriter);\n    \n    // test the multi iterator\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n    CategoryListIterator[] iterators = new CategoryListIterator[numDimensions];\n    for (int i = 0; i < iterators.length; i++) {\n      CategoryListParams clp = indexingParams.getCategoryListParams(new CategoryPath(dimensions[i]));\n      IntDecoder decoder = clp.createEncoder().createMatchingDecoder();\n      iterators[i] = new DocValuesCategoryListIterator(clp.field, decoder);\n    }\n    MultiCategoryListIterator cli = new MultiCategoryListIterator(iterators);\n    for (AtomicReaderContext context : indexReader.leaves()) {\n      assertTrue(\"failed to init multi-iterator\", cli.setNextReader(context));\n      IntsRef ordinals = new IntsRef();\n      final int maxDoc = context.reader().maxDoc();\n      for (int i = 0; i < maxDoc; i++) {\n        cli.getOrdinals(i, ordinals);\n        assertTrue(\"document \" + i + \" does not have categories\", ordinals.length > 0);\n        for (int j = 0; j < ordinals.length; j++) {\n          CategoryPath cp = taxoReader.getPath(ordinals.ints[j]);\n          assertNotNull(\"ordinal \" + ordinals.ints[j] + \" not found in taxonomy\", cp);\n          if (cp.length == 2) {\n            int globalDoc = i + context.docBase;\n            assertEquals(\"invalid category for document \" + globalDoc, globalDoc, Integer.parseInt(cp.components[1]));\n          }\n        }\n      }\n    }\n    \n    IOUtils.close(indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","sourceOld":"  @Test\n  public void testMultipleCategoryLists() throws Exception {\n    Random random = random();\n    int numDimensions = atLeast(random, 2); // at least 2 dimensions\n    String[] dimensions = new String[numDimensions];\n    for (int i = 0; i < numDimensions; i++) {\n      dimensions[i] = \"dim\" + i;\n    }\n    \n    // build the PerDimensionIndexingParams\n    HashMap<CategoryPath,CategoryListParams> clps = new HashMap<CategoryPath,CategoryListParams>();\n    for (String dim : dimensions) {\n      CategoryPath cp = new CategoryPath(dim);\n      CategoryListParams clp = new CategoryListParams(new Term(\"$\" + dim, CategoryListParams.DEFAULT_TERM.bytes()));\n      clps.put(cp, clp);\n    }\n    PerDimensionIndexingParams indexingParams = new PerDimensionIndexingParams(clps);\n    \n    // index some documents\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null).setMaxBufferedDocs(2));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    FacetFields facetFields = new FacetFields(taxoWriter, indexingParams);\n    int ndocs = atLeast(random, 10);\n    for (int i = 0; i < ndocs; i++) {\n      Document doc = new Document();\n      int numCategories = random.nextInt(numDimensions) + 1;\n      ArrayList<CategoryPath> categories = new ArrayList<CategoryPath>();\n      for (int j = 0; j < numCategories; j++) {\n        String dimension = dimensions[random.nextInt(dimensions.length)];\n        categories.add(new CategoryPath(dimension, Integer.toString(i)));\n      }\n      facetFields.addFields(doc, categories);\n      indexWriter.addDocument(doc);\n    }\n    IOUtils.close(indexWriter, taxoWriter);\n    \n    // test the multi iterator\n    CategoryListCache clCache = null;\n    if (random.nextBoolean()) {\n      clCache = new CategoryListCache();\n    }\n    \n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n    CategoryListIterator[] iterators = new CategoryListIterator[numDimensions];\n    for (int i = 0; i < iterators.length; i++) {\n      CategoryListParams clp = indexingParams.getCategoryListParams(new CategoryPath(dimensions[i]));\n      IntDecoder decoder = clp.createEncoder().createMatchingDecoder();\n      if (clCache != null && random.nextBoolean()) {\n        clCache.loadAndRegister(clp, indexReader, taxoReader, indexingParams);\n        iterators[i] = clCache.get(clp).iterator(0); // no partitions\n      } else {\n        iterators[i] = new PayloadCategoryListIteraor(clp.getTerm(), decoder);\n      }\n    }\n    MultiCategoryListIterator cli = new MultiCategoryListIterator(iterators);\n    for (AtomicReaderContext context : indexReader.leaves()) {\n      assertTrue(\"failed to init multi-iterator\", cli.setNextReader(context));\n      IntsRef ordinals = new IntsRef();\n      final int maxDoc = context.reader().maxDoc();\n      for (int i = 0; i < maxDoc; i++) {\n        cli.getOrdinals(i, ordinals);\n        assertTrue(\"document \" + i + \" does not have categories\", ordinals.length > 0);\n        for (int j = 0; j < ordinals.length; j++) {\n          CategoryPath cp = taxoReader.getPath(ordinals.ints[j]);\n          assertNotNull(\"ordinal \" + ordinals.ints[j] + \" not found in taxonomy\", cp);\n          if (cp.length == 2) {\n            int globalDoc = i + context.docBase;\n            assertEquals(\"invalid category for document \" + globalDoc, globalDoc, Integer.parseInt(cp.components[1]));\n          }\n        }\n      }\n    }\n    \n    IOUtils.close(indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c4015cd39dff8d4dec562d909f9766debac53aa6","date":1358548736,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/params/MultiCategoryListIteratorTest#testMultipleCategoryLists().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/params/MultiCategoryListIteratorTest#testMultipleCategoryLists().mjava","sourceNew":"  @Test\n  public void testMultipleCategoryLists() throws Exception {\n    Random random = random();\n    int numDimensions = atLeast(random, 2); // at least 2 dimensions\n    String[] dimensions = new String[numDimensions];\n    for (int i = 0; i < numDimensions; i++) {\n      dimensions[i] = \"dim\" + i;\n    }\n    \n    // build the PerDimensionIndexingParams\n    HashMap<CategoryPath,CategoryListParams> clps = new HashMap<CategoryPath,CategoryListParams>();\n    for (String dim : dimensions) {\n      CategoryPath cp = new CategoryPath(dim);\n      CategoryListParams clp = new CategoryListParams(\"$\" + dim);\n      clps.put(cp, clp);\n    }\n    PerDimensionIndexingParams indexingParams = new PerDimensionIndexingParams(clps);\n    \n    // index some documents\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null).setMaxBufferedDocs(2));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    FacetFields facetFields = new FacetFields(taxoWriter, indexingParams);\n    int ndocs = atLeast(random, 10);\n    for (int i = 0; i < ndocs; i++) {\n      Document doc = new Document();\n      int numCategories = random.nextInt(numDimensions) + 1;\n      ArrayList<CategoryPath> categories = new ArrayList<CategoryPath>();\n      for (int j = 0; j < numCategories; j++) {\n        String dimension = dimensions[random.nextInt(dimensions.length)];\n        categories.add(new CategoryPath(dimension, Integer.toString(i)));\n      }\n      facetFields.addFields(doc, categories);\n      indexWriter.addDocument(doc);\n    }\n    IOUtils.close(indexWriter, taxoWriter);\n    \n    // test the multi iterator\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n    CategoryListIterator[] iterators = new CategoryListIterator[numDimensions];\n    for (int i = 0; i < iterators.length; i++) {\n      CategoryListParams clp = indexingParams.getCategoryListParams(new CategoryPath(dimensions[i]));\n      IntDecoder decoder = clp.createEncoder().createMatchingDecoder();\n      iterators[i] = new DocValuesCategoryListIterator(clp.field, decoder);\n    }\n    MultiCategoryListIterator cli = new MultiCategoryListIterator(iterators);\n    for (AtomicReaderContext context : indexReader.leaves()) {\n      assertTrue(\"failed to init multi-iterator\", cli.setNextReader(context));\n      IntsRef ordinals = new IntsRef();\n      final int maxDoc = context.reader().maxDoc();\n      for (int i = 0; i < maxDoc; i++) {\n        cli.getOrdinals(i, ordinals);\n        assertTrue(\"document \" + i + \" does not have categories\", ordinals.length > 0);\n        for (int j = 0; j < ordinals.length; j++) {\n          CategoryPath cp = taxoReader.getPath(ordinals.ints[j]);\n          assertNotNull(\"ordinal \" + ordinals.ints[j] + \" not found in taxonomy\", cp);\n          if (cp.length == 2) {\n            int globalDoc = i + context.docBase;\n            assertEquals(\"invalid category for document \" + globalDoc, globalDoc, Integer.parseInt(cp.components[1]));\n          }\n        }\n      }\n    }\n    \n    IOUtils.close(indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","sourceOld":"  @Test\n  public void testMultipleCategoryLists() throws Exception {\n    Random random = random();\n    int numDimensions = atLeast(random, 2); // at least 2 dimensions\n    String[] dimensions = new String[numDimensions];\n    for (int i = 0; i < numDimensions; i++) {\n      dimensions[i] = \"dim\" + i;\n    }\n    \n    // build the PerDimensionIndexingParams\n    HashMap<CategoryPath,CategoryListParams> clps = new HashMap<CategoryPath,CategoryListParams>();\n    for (String dim : dimensions) {\n      CategoryPath cp = new CategoryPath(dim);\n      CategoryListParams clp = new CategoryListParams(new Term(\"$\" + dim, CategoryListParams.DEFAULT_TERM.bytes()));\n      clps.put(cp, clp);\n    }\n    PerDimensionIndexingParams indexingParams = new PerDimensionIndexingParams(clps);\n    \n    // index some documents\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null).setMaxBufferedDocs(2));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    FacetFields facetFields = new FacetFields(taxoWriter, indexingParams);\n    int ndocs = atLeast(random, 10);\n    for (int i = 0; i < ndocs; i++) {\n      Document doc = new Document();\n      int numCategories = random.nextInt(numDimensions) + 1;\n      ArrayList<CategoryPath> categories = new ArrayList<CategoryPath>();\n      for (int j = 0; j < numCategories; j++) {\n        String dimension = dimensions[random.nextInt(dimensions.length)];\n        categories.add(new CategoryPath(dimension, Integer.toString(i)));\n      }\n      facetFields.addFields(doc, categories);\n      indexWriter.addDocument(doc);\n    }\n    IOUtils.close(indexWriter, taxoWriter);\n    \n    // test the multi iterator\n    CategoryListCache clCache = null;\n    if (random.nextBoolean()) {\n      clCache = new CategoryListCache();\n    }\n    \n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n    CategoryListIterator[] iterators = new CategoryListIterator[numDimensions];\n    for (int i = 0; i < iterators.length; i++) {\n      CategoryListParams clp = indexingParams.getCategoryListParams(new CategoryPath(dimensions[i]));\n      IntDecoder decoder = clp.createEncoder().createMatchingDecoder();\n      if (clCache != null && random.nextBoolean()) {\n        clCache.loadAndRegister(clp, indexReader, taxoReader, indexingParams);\n        iterators[i] = clCache.get(clp).iterator(0); // no partitions\n      } else {\n        iterators[i] = new PayloadCategoryListIteraor(clp.getTerm(), decoder);\n      }\n    }\n    MultiCategoryListIterator cli = new MultiCategoryListIterator(iterators);\n    for (AtomicReaderContext context : indexReader.leaves()) {\n      assertTrue(\"failed to init multi-iterator\", cli.setNextReader(context));\n      IntsRef ordinals = new IntsRef();\n      final int maxDoc = context.reader().maxDoc();\n      for (int i = 0; i < maxDoc; i++) {\n        cli.getOrdinals(i, ordinals);\n        assertTrue(\"document \" + i + \" does not have categories\", ordinals.length > 0);\n        for (int j = 0; j < ordinals.length; j++) {\n          CategoryPath cp = taxoReader.getPath(ordinals.ints[j]);\n          assertNotNull(\"ordinal \" + ordinals.ints[j] + \" not found in taxonomy\", cp);\n          if (cp.length == 2) {\n            int globalDoc = i + context.docBase;\n            assertEquals(\"invalid category for document \" + globalDoc, globalDoc, Integer.parseInt(cp.components[1]));\n          }\n        }\n      }\n    }\n    \n    IOUtils.close(indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"90213788e5007cc5e2b3d88200a8265de9d4e6d4","date":1359060940,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/params/MultiCategoryListIteratorTest#testMultipleCategoryLists().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/params/MultiCategoryListIteratorTest#testMultipleCategoryLists().mjava","sourceNew":"  @Test\n  public void testMultipleCategoryLists() throws Exception {\n    Random random = random();\n    int numDimensions = atLeast(random, 2); // at least 2 dimensions\n    String[] dimensions = new String[numDimensions];\n    for (int i = 0; i < numDimensions; i++) {\n      dimensions[i] = \"dim\" + i;\n    }\n    \n    // build the PerDimensionIndexingParams\n    HashMap<CategoryPath,CategoryListParams> clps = new HashMap<CategoryPath,CategoryListParams>();\n    for (String dim : dimensions) {\n      CategoryPath cp = new CategoryPath(dim);\n      CategoryListParams clp = randomCategoryListParams(\"$\" + dim);\n      clps.put(cp, clp);\n    }\n    PerDimensionIndexingParams indexingParams = new PerDimensionIndexingParams(clps);\n    \n    // index some documents\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null).setMaxBufferedDocs(2));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    FacetFields facetFields = new FacetFields(taxoWriter, indexingParams);\n    int ndocs = atLeast(random, 10);\n    for (int i = 0; i < ndocs; i++) {\n      Document doc = new Document();\n      int numCategories = random.nextInt(numDimensions) + 1;\n      ArrayList<CategoryPath> categories = new ArrayList<CategoryPath>();\n      for (int j = 0; j < numCategories; j++) {\n        String dimension = dimensions[random.nextInt(dimensions.length)];\n        categories.add(new CategoryPath(dimension, Integer.toString(i)));\n      }\n      facetFields.addFields(doc, categories);\n      indexWriter.addDocument(doc);\n    }\n    IOUtils.close(indexWriter, taxoWriter);\n    \n    // test the multi iterator\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n    CategoryListIterator[] iterators = new CategoryListIterator[numDimensions];\n    for (int i = 0; i < iterators.length; i++) {\n      CategoryListParams clp = indexingParams.getCategoryListParams(new CategoryPath(dimensions[i]));\n      IntDecoder decoder = clp.createEncoder().createMatchingDecoder();\n      iterators[i] = new DocValuesCategoryListIterator(clp.field, decoder);\n    }\n    MultiCategoryListIterator cli = new MultiCategoryListIterator(iterators);\n    for (AtomicReaderContext context : indexReader.leaves()) {\n      assertTrue(\"failed to init multi-iterator\", cli.setNextReader(context));\n      IntsRef ordinals = new IntsRef();\n      final int maxDoc = context.reader().maxDoc();\n      for (int i = 0; i < maxDoc; i++) {\n        cli.getOrdinals(i, ordinals);\n        assertTrue(\"document \" + i + \" does not have categories\", ordinals.length > 0);\n        for (int j = 0; j < ordinals.length; j++) {\n          CategoryPath cp = taxoReader.getPath(ordinals.ints[j]);\n          assertNotNull(\"ordinal \" + ordinals.ints[j] + \" not found in taxonomy\", cp);\n          if (cp.length == 2) {\n            int globalDoc = i + context.docBase;\n            assertEquals(\"invalid category for document \" + globalDoc, globalDoc, Integer.parseInt(cp.components[1]));\n          }\n        }\n      }\n    }\n    \n    IOUtils.close(indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","sourceOld":"  @Test\n  public void testMultipleCategoryLists() throws Exception {\n    Random random = random();\n    int numDimensions = atLeast(random, 2); // at least 2 dimensions\n    String[] dimensions = new String[numDimensions];\n    for (int i = 0; i < numDimensions; i++) {\n      dimensions[i] = \"dim\" + i;\n    }\n    \n    // build the PerDimensionIndexingParams\n    HashMap<CategoryPath,CategoryListParams> clps = new HashMap<CategoryPath,CategoryListParams>();\n    for (String dim : dimensions) {\n      CategoryPath cp = new CategoryPath(dim);\n      CategoryListParams clp = new CategoryListParams(\"$\" + dim);\n      clps.put(cp, clp);\n    }\n    PerDimensionIndexingParams indexingParams = new PerDimensionIndexingParams(clps);\n    \n    // index some documents\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null).setMaxBufferedDocs(2));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    FacetFields facetFields = new FacetFields(taxoWriter, indexingParams);\n    int ndocs = atLeast(random, 10);\n    for (int i = 0; i < ndocs; i++) {\n      Document doc = new Document();\n      int numCategories = random.nextInt(numDimensions) + 1;\n      ArrayList<CategoryPath> categories = new ArrayList<CategoryPath>();\n      for (int j = 0; j < numCategories; j++) {\n        String dimension = dimensions[random.nextInt(dimensions.length)];\n        categories.add(new CategoryPath(dimension, Integer.toString(i)));\n      }\n      facetFields.addFields(doc, categories);\n      indexWriter.addDocument(doc);\n    }\n    IOUtils.close(indexWriter, taxoWriter);\n    \n    // test the multi iterator\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n    CategoryListIterator[] iterators = new CategoryListIterator[numDimensions];\n    for (int i = 0; i < iterators.length; i++) {\n      CategoryListParams clp = indexingParams.getCategoryListParams(new CategoryPath(dimensions[i]));\n      IntDecoder decoder = clp.createEncoder().createMatchingDecoder();\n      iterators[i] = new DocValuesCategoryListIterator(clp.field, decoder);\n    }\n    MultiCategoryListIterator cli = new MultiCategoryListIterator(iterators);\n    for (AtomicReaderContext context : indexReader.leaves()) {\n      assertTrue(\"failed to init multi-iterator\", cli.setNextReader(context));\n      IntsRef ordinals = new IntsRef();\n      final int maxDoc = context.reader().maxDoc();\n      for (int i = 0; i < maxDoc; i++) {\n        cli.getOrdinals(i, ordinals);\n        assertTrue(\"document \" + i + \" does not have categories\", ordinals.length > 0);\n        for (int j = 0; j < ordinals.length; j++) {\n          CategoryPath cp = taxoReader.getPath(ordinals.ints[j]);\n          assertNotNull(\"ordinal \" + ordinals.ints[j] + \" not found in taxonomy\", cp);\n          if (cp.length == 2) {\n            int globalDoc = i + context.docBase;\n            assertEquals(\"invalid category for document \" + globalDoc, globalDoc, Integer.parseInt(cp.components[1]));\n          }\n        }\n      }\n    }\n    \n    IOUtils.close(indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd45d4a2ee01a1932d33eec42f5272c2402da679","date":1359316912,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/params/MultiCategoryListIteratorTest#testMultipleCategoryLists().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/params/MultiCategoryListIteratorTest#testMultipleCategoryLists().mjava","sourceNew":"  @Test\n  public void testMultipleCategoryLists() throws Exception {\n    Random random = random();\n    int numDimensions = atLeast(random, 2); // at least 2 dimensions\n    String[] dimensions = new String[numDimensions];\n    for (int i = 0; i < numDimensions; i++) {\n      dimensions[i] = \"dim\" + i;\n    }\n    \n    // build the PerDimensionIndexingParams\n    HashMap<CategoryPath,CategoryListParams> clps = new HashMap<CategoryPath,CategoryListParams>();\n    for (String dim : dimensions) {\n      CategoryPath cp = new CategoryPath(dim);\n      CategoryListParams clp = randomCategoryListParams(\"$\" + dim);\n      clps.put(cp, clp);\n    }\n    PerDimensionIndexingParams indexingParams = new PerDimensionIndexingParams(clps);\n    \n    // index some documents\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null).setMaxBufferedDocs(2));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    FacetFields facetFields = new FacetFields(taxoWriter, indexingParams);\n    int ndocs = atLeast(random, 10);\n    for (int i = 0; i < ndocs; i++) {\n      Document doc = new Document();\n      int numCategories = random.nextInt(numDimensions) + 1;\n      ArrayList<CategoryPath> categories = new ArrayList<CategoryPath>();\n      for (int j = 0; j < numCategories; j++) {\n        String dimension = dimensions[random.nextInt(dimensions.length)];\n        categories.add(new CategoryPath(dimension, Integer.toString(i)));\n      }\n      facetFields.addFields(doc, categories);\n      indexWriter.addDocument(doc);\n    }\n    IOUtils.close(indexWriter, taxoWriter);\n    \n    // test the multi iterator\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n    CategoryListIterator[] iterators = new CategoryListIterator[numDimensions];\n    for (int i = 0; i < iterators.length; i++) {\n      CategoryListParams clp = indexingParams.getCategoryListParams(new CategoryPath(dimensions[i]));\n      IntDecoder decoder = clp.createEncoder().createMatchingDecoder();\n      iterators[i] = new DocValuesCategoryListIterator(clp.field, decoder);\n    }\n    MultiCategoryListIterator cli = new MultiCategoryListIterator(iterators);\n    for (AtomicReaderContext context : indexReader.leaves()) {\n      assertTrue(\"failed to init multi-iterator\", cli.setNextReader(context));\n      IntsRef ordinals = new IntsRef();\n      final int maxDoc = context.reader().maxDoc();\n      for (int i = 0; i < maxDoc; i++) {\n        cli.getOrdinals(i, ordinals);\n        assertTrue(\"document \" + i + \" does not have categories\", ordinals.length > 0);\n        for (int j = 0; j < ordinals.length; j++) {\n          CategoryPath cp = taxoReader.getPath(ordinals.ints[j]);\n          assertNotNull(\"ordinal \" + ordinals.ints[j] + \" not found in taxonomy\", cp);\n          if (cp.length == 2) {\n            int globalDoc = i + context.docBase;\n            assertEquals(\"invalid category for document \" + globalDoc, globalDoc, Integer.parseInt(cp.components[1]));\n          }\n        }\n      }\n    }\n    \n    IOUtils.close(indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","sourceOld":"  @Test\n  public void testMultipleCategoryLists() throws Exception {\n    Random random = random();\n    int numDimensions = atLeast(random, 2); // at least 2 dimensions\n    String[] dimensions = new String[numDimensions];\n    for (int i = 0; i < numDimensions; i++) {\n      dimensions[i] = \"dim\" + i;\n    }\n    \n    // build the PerDimensionIndexingParams\n    HashMap<CategoryPath,CategoryListParams> clps = new HashMap<CategoryPath,CategoryListParams>();\n    for (String dim : dimensions) {\n      CategoryPath cp = new CategoryPath(dim);\n      CategoryListParams clp = new CategoryListParams(\"$\" + dim);\n      clps.put(cp, clp);\n    }\n    PerDimensionIndexingParams indexingParams = new PerDimensionIndexingParams(clps);\n    \n    // index some documents\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null).setMaxBufferedDocs(2));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    FacetFields facetFields = new FacetFields(taxoWriter, indexingParams);\n    int ndocs = atLeast(random, 10);\n    for (int i = 0; i < ndocs; i++) {\n      Document doc = new Document();\n      int numCategories = random.nextInt(numDimensions) + 1;\n      ArrayList<CategoryPath> categories = new ArrayList<CategoryPath>();\n      for (int j = 0; j < numCategories; j++) {\n        String dimension = dimensions[random.nextInt(dimensions.length)];\n        categories.add(new CategoryPath(dimension, Integer.toString(i)));\n      }\n      facetFields.addFields(doc, categories);\n      indexWriter.addDocument(doc);\n    }\n    IOUtils.close(indexWriter, taxoWriter);\n    \n    // test the multi iterator\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n    CategoryListIterator[] iterators = new CategoryListIterator[numDimensions];\n    for (int i = 0; i < iterators.length; i++) {\n      CategoryListParams clp = indexingParams.getCategoryListParams(new CategoryPath(dimensions[i]));\n      IntDecoder decoder = clp.createEncoder().createMatchingDecoder();\n      iterators[i] = new DocValuesCategoryListIterator(clp.field, decoder);\n    }\n    MultiCategoryListIterator cli = new MultiCategoryListIterator(iterators);\n    for (AtomicReaderContext context : indexReader.leaves()) {\n      assertTrue(\"failed to init multi-iterator\", cli.setNextReader(context));\n      IntsRef ordinals = new IntsRef();\n      final int maxDoc = context.reader().maxDoc();\n      for (int i = 0; i < maxDoc; i++) {\n        cli.getOrdinals(i, ordinals);\n        assertTrue(\"document \" + i + \" does not have categories\", ordinals.length > 0);\n        for (int j = 0; j < ordinals.length; j++) {\n          CategoryPath cp = taxoReader.getPath(ordinals.ints[j]);\n          assertNotNull(\"ordinal \" + ordinals.ints[j] + \" not found in taxonomy\", cp);\n          if (cp.length == 2) {\n            int globalDoc = i + context.docBase;\n            assertEquals(\"invalid category for document \" + globalDoc, globalDoc, Integer.parseInt(cp.components[1]));\n          }\n        }\n      }\n    }\n    \n    IOUtils.close(indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"607428da722dcb3e86bbd11c63de8986e6275c36","date":1360334150,"type":5,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/MultiCategoryListIteratorTest#testMultipleCategoryLists().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/params/MultiCategoryListIteratorTest#testMultipleCategoryLists().mjava","sourceNew":"  @Test\n  public void testMultipleCategoryLists() throws Exception {\n    Random random = random();\n    int numDimensions = atLeast(random, 2); // at least 2 dimensions\n    String[] dimensions = new String[numDimensions];\n    for (int i = 0; i < numDimensions; i++) {\n      dimensions[i] = \"dim\" + i;\n    }\n    \n    // build the PerDimensionIndexingParams\n    HashMap<CategoryPath,CategoryListParams> clps = new HashMap<CategoryPath,CategoryListParams>();\n    for (String dim : dimensions) {\n      CategoryPath cp = new CategoryPath(dim);\n      CategoryListParams clp = randomCategoryListParams(\"$\" + dim);\n      clps.put(cp, clp);\n    }\n    PerDimensionIndexingParams indexingParams = new PerDimensionIndexingParams(clps);\n    \n    // index some documents\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null).setMaxBufferedDocs(2));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    FacetFields facetFields = new FacetFields(taxoWriter, indexingParams);\n    int ndocs = atLeast(random, 10);\n    for (int i = 0; i < ndocs; i++) {\n      Document doc = new Document();\n      int numCategories = random.nextInt(numDimensions) + 1;\n      ArrayList<CategoryPath> categories = new ArrayList<CategoryPath>();\n      for (int j = 0; j < numCategories; j++) {\n        String dimension = dimensions[random.nextInt(dimensions.length)];\n        categories.add(new CategoryPath(dimension, Integer.toString(i)));\n      }\n      facetFields.addFields(doc, categories);\n      indexWriter.addDocument(doc);\n    }\n    IOUtils.close(indexWriter, taxoWriter);\n    \n    // test the multi iterator\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n    CategoryListIterator[] iterators = new CategoryListIterator[numDimensions];\n    for (int i = 0; i < iterators.length; i++) {\n      CategoryListParams clp = indexingParams.getCategoryListParams(new CategoryPath(dimensions[i]));\n      IntDecoder decoder = clp.createEncoder().createMatchingDecoder();\n      iterators[i] = new DocValuesCategoryListIterator(clp.field, decoder);\n    }\n    MultiCategoryListIterator cli = new MultiCategoryListIterator(iterators);\n    for (AtomicReaderContext context : indexReader.leaves()) {\n      assertTrue(\"failed to init multi-iterator\", cli.setNextReader(context));\n      IntsRef ordinals = new IntsRef();\n      final int maxDoc = context.reader().maxDoc();\n      for (int i = 0; i < maxDoc; i++) {\n        cli.getOrdinals(i, ordinals);\n        assertTrue(\"document \" + i + \" does not have categories\", ordinals.length > 0);\n        for (int j = 0; j < ordinals.length; j++) {\n          CategoryPath cp = taxoReader.getPath(ordinals.ints[j]);\n          assertNotNull(\"ordinal \" + ordinals.ints[j] + \" not found in taxonomy\", cp);\n          if (cp.length == 2) {\n            int globalDoc = i + context.docBase;\n            assertEquals(\"invalid category for document \" + globalDoc, globalDoc, Integer.parseInt(cp.components[1]));\n          }\n        }\n      }\n    }\n    \n    IOUtils.close(indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","sourceOld":"  @Test\n  public void testMultipleCategoryLists() throws Exception {\n    Random random = random();\n    int numDimensions = atLeast(random, 2); // at least 2 dimensions\n    String[] dimensions = new String[numDimensions];\n    for (int i = 0; i < numDimensions; i++) {\n      dimensions[i] = \"dim\" + i;\n    }\n    \n    // build the PerDimensionIndexingParams\n    HashMap<CategoryPath,CategoryListParams> clps = new HashMap<CategoryPath,CategoryListParams>();\n    for (String dim : dimensions) {\n      CategoryPath cp = new CategoryPath(dim);\n      CategoryListParams clp = randomCategoryListParams(\"$\" + dim);\n      clps.put(cp, clp);\n    }\n    PerDimensionIndexingParams indexingParams = new PerDimensionIndexingParams(clps);\n    \n    // index some documents\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null).setMaxBufferedDocs(2));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    FacetFields facetFields = new FacetFields(taxoWriter, indexingParams);\n    int ndocs = atLeast(random, 10);\n    for (int i = 0; i < ndocs; i++) {\n      Document doc = new Document();\n      int numCategories = random.nextInt(numDimensions) + 1;\n      ArrayList<CategoryPath> categories = new ArrayList<CategoryPath>();\n      for (int j = 0; j < numCategories; j++) {\n        String dimension = dimensions[random.nextInt(dimensions.length)];\n        categories.add(new CategoryPath(dimension, Integer.toString(i)));\n      }\n      facetFields.addFields(doc, categories);\n      indexWriter.addDocument(doc);\n    }\n    IOUtils.close(indexWriter, taxoWriter);\n    \n    // test the multi iterator\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n    CategoryListIterator[] iterators = new CategoryListIterator[numDimensions];\n    for (int i = 0; i < iterators.length; i++) {\n      CategoryListParams clp = indexingParams.getCategoryListParams(new CategoryPath(dimensions[i]));\n      IntDecoder decoder = clp.createEncoder().createMatchingDecoder();\n      iterators[i] = new DocValuesCategoryListIterator(clp.field, decoder);\n    }\n    MultiCategoryListIterator cli = new MultiCategoryListIterator(iterators);\n    for (AtomicReaderContext context : indexReader.leaves()) {\n      assertTrue(\"failed to init multi-iterator\", cli.setNextReader(context));\n      IntsRef ordinals = new IntsRef();\n      final int maxDoc = context.reader().maxDoc();\n      for (int i = 0; i < maxDoc; i++) {\n        cli.getOrdinals(i, ordinals);\n        assertTrue(\"document \" + i + \" does not have categories\", ordinals.length > 0);\n        for (int j = 0; j < ordinals.length; j++) {\n          CategoryPath cp = taxoReader.getPath(ordinals.ints[j]);\n          assertNotNull(\"ordinal \" + ordinals.ints[j] + \" not found in taxonomy\", cp);\n          if (cp.length == 2) {\n            int globalDoc = i + context.docBase;\n            assertEquals(\"invalid category for document \" + globalDoc, globalDoc, Integer.parseInt(cp.components[1]));\n          }\n        }\n      }\n    }\n    \n    IOUtils.close(indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"607428da722dcb3e86bbd11c63de8986e6275c36":["90213788e5007cc5e2b3d88200a8265de9d4e6d4"],"90213788e5007cc5e2b3d88200a8265de9d4e6d4":["6c2cd18c7da6f499a33f06fc89c07a463ec074c0"],"42f51b3ab4258ff4623227b0db011b8bb83db5c7":["bceb02c33032dd9bbf107cd06d0b74e5db4f110a"],"c4015cd39dff8d4dec562d909f9766debac53aa6":["8917bfede3b4ca30f4305c1e391e9218959cd723","6c2cd18c7da6f499a33f06fc89c07a463ec074c0"],"bceb02c33032dd9bbf107cd06d0b74e5db4f110a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8917bfede3b4ca30f4305c1e391e9218959cd723":["4e6354dd7c71fe122926fc53d7d29f715b1283db","42f51b3ab4258ff4623227b0db011b8bb83db5c7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"dd45d4a2ee01a1932d33eec42f5272c2402da679":["c4015cd39dff8d4dec562d909f9766debac53aa6","90213788e5007cc5e2b3d88200a8265de9d4e6d4"],"6c2cd18c7da6f499a33f06fc89c07a463ec074c0":["42f51b3ab4258ff4623227b0db011b8bb83db5c7"],"4e6354dd7c71fe122926fc53d7d29f715b1283db":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","bceb02c33032dd9bbf107cd06d0b74e5db4f110a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["607428da722dcb3e86bbd11c63de8986e6275c36"]},"commit2Childs":{"607428da722dcb3e86bbd11c63de8986e6275c36":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"90213788e5007cc5e2b3d88200a8265de9d4e6d4":["607428da722dcb3e86bbd11c63de8986e6275c36","dd45d4a2ee01a1932d33eec42f5272c2402da679"],"42f51b3ab4258ff4623227b0db011b8bb83db5c7":["8917bfede3b4ca30f4305c1e391e9218959cd723","6c2cd18c7da6f499a33f06fc89c07a463ec074c0"],"c4015cd39dff8d4dec562d909f9766debac53aa6":["dd45d4a2ee01a1932d33eec42f5272c2402da679"],"bceb02c33032dd9bbf107cd06d0b74e5db4f110a":["42f51b3ab4258ff4623227b0db011b8bb83db5c7","4e6354dd7c71fe122926fc53d7d29f715b1283db"],"8917bfede3b4ca30f4305c1e391e9218959cd723":["c4015cd39dff8d4dec562d909f9766debac53aa6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bceb02c33032dd9bbf107cd06d0b74e5db4f110a","4e6354dd7c71fe122926fc53d7d29f715b1283db"],"dd45d4a2ee01a1932d33eec42f5272c2402da679":[],"6c2cd18c7da6f499a33f06fc89c07a463ec074c0":["90213788e5007cc5e2b3d88200a8265de9d4e6d4","c4015cd39dff8d4dec562d909f9766debac53aa6"],"4e6354dd7c71fe122926fc53d7d29f715b1283db":["8917bfede3b4ca30f4305c1e391e9218959cd723"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["dd45d4a2ee01a1932d33eec42f5272c2402da679","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}