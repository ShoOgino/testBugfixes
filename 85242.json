{"path":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(HttpServletRequest,HttpServletResponse,AtomicReference[HttpServletRequest]).mjava","commits":[{"id":"61d55d0cc95bfc03461b5c355153ca28c49076eb","date":1515469157,"type":1,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(HttpServletRequest,HttpServletResponse,AtomicReference[HttpServletRequest]).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(ServletRequest,ServletResponse,AtomicReference[ServletRequest]).mjava","sourceNew":"  private boolean authenticateRequest(HttpServletRequest request, HttpServletResponse response, final AtomicReference<HttpServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      // /admin/info/key must be always open. see SOLR-9188\n      // tests work only w/ getPathInfo\n      //otherwise it's just enough to have getServletPath()\n      if (PKIAuthenticationPlugin.PATH.equals(request.getServletPath()) ||\n          PKIAuthenticationPlugin.PATH.equals(request.getPathInfo())) return true;\n      String header = request.getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.doAuthenticate(request, response, (req, rsp) -> {\n          isAuthenticated.set(true);\n          wrappedRequest.set((HttpServletRequest) req);\n        });\n      } catch (Exception e) {\n        log.info(\"Error authenticating\", e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean authenticateRequest(ServletRequest request, ServletResponse response, final AtomicReference<ServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      // /admin/info/key must be always open. see SOLR-9188\n      // tests work only w/ getPathInfo\n      //otherwise it's just enough to have getServletPath()\n      if (PKIAuthenticationPlugin.PATH.equals(((HttpServletRequest) request).getServletPath()) ||\n          PKIAuthenticationPlugin.PATH.equals(((HttpServletRequest) request).getPathInfo())) return true;\n      String header = ((HttpServletRequest) request).getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.doAuthenticate(request, response, (req, rsp) -> {\n          isAuthenticated.set(true);\n          wrappedRequest.set(req);\n        });\n      } catch (Exception e) {\n        log.info(\"Error authenticating\", e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(HttpServletRequest,HttpServletResponse,AtomicReference[HttpServletRequest]).mjava","pathOld":"/dev/null","sourceNew":"  private boolean authenticateRequest(HttpServletRequest request, HttpServletResponse response, final AtomicReference<HttpServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      // /admin/info/key must be always open. see SOLR-9188\n      // tests work only w/ getPathInfo\n      //otherwise it's just enough to have getServletPath()\n      if (PKIAuthenticationPlugin.PATH.equals(request.getServletPath()) ||\n          PKIAuthenticationPlugin.PATH.equals(request.getPathInfo())) return true;\n      String header = request.getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.doAuthenticate(request, response, (req, rsp) -> {\n          isAuthenticated.set(true);\n          wrappedRequest.set((HttpServletRequest) req);\n        });\n      } catch (Exception e) {\n        log.info(\"Error authenticating\", e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"946009ad0fba506337041a368b0a74d2edd59e2c","date":1528114477,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(HttpServletRequest,HttpServletResponse,AtomicReference[HttpServletRequest]).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(HttpServletRequest,HttpServletResponse,AtomicReference[HttpServletRequest]).mjava","sourceNew":"  private boolean authenticateRequest(HttpServletRequest request, HttpServletResponse response, final AtomicReference<HttpServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      // /admin/info/key must be always open. see SOLR-9188\n      // tests work only w/ getPathInfo\n      //otherwise it's just enough to have getServletPath()\n      if (PublicKeyHandler.PATH.equals(request.getServletPath()) ||\n          PublicKeyHandler.PATH.equals(request.getPathInfo())) return true;\n      String header = request.getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.doAuthenticate(request, response, (req, rsp) -> {\n          isAuthenticated.set(true);\n          wrappedRequest.set((HttpServletRequest) req);\n        });\n      } catch (Exception e) {\n        log.info(\"Error authenticating\", e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean authenticateRequest(HttpServletRequest request, HttpServletResponse response, final AtomicReference<HttpServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      // /admin/info/key must be always open. see SOLR-9188\n      // tests work only w/ getPathInfo\n      //otherwise it's just enough to have getServletPath()\n      if (PKIAuthenticationPlugin.PATH.equals(request.getServletPath()) ||\n          PKIAuthenticationPlugin.PATH.equals(request.getPathInfo())) return true;\n      String header = request.getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.doAuthenticate(request, response, (req, rsp) -> {\n          isAuthenticated.set(true);\n          wrappedRequest.set((HttpServletRequest) req);\n        });\n      } catch (Exception e) {\n        log.info(\"Error authenticating\", e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":["61d55d0cc95bfc03461b5c355153ca28c49076eb"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(HttpServletRequest,HttpServletResponse,AtomicReference[HttpServletRequest]).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(HttpServletRequest,HttpServletResponse,AtomicReference[HttpServletRequest]).mjava","sourceNew":"  private boolean authenticateRequest(HttpServletRequest request, HttpServletResponse response, final AtomicReference<HttpServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      // /admin/info/key must be always open. see SOLR-9188\n      // tests work only w/ getPathInfo\n      //otherwise it's just enough to have getServletPath()\n      if (PublicKeyHandler.PATH.equals(request.getServletPath()) ||\n          PublicKeyHandler.PATH.equals(request.getPathInfo())) return true;\n      String header = request.getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.doAuthenticate(request, response, (req, rsp) -> {\n          isAuthenticated.set(true);\n          wrappedRequest.set((HttpServletRequest) req);\n        });\n      } catch (Exception e) {\n        log.info(\"Error authenticating\", e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean authenticateRequest(HttpServletRequest request, HttpServletResponse response, final AtomicReference<HttpServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      // /admin/info/key must be always open. see SOLR-9188\n      // tests work only w/ getPathInfo\n      //otherwise it's just enough to have getServletPath()\n      if (PKIAuthenticationPlugin.PATH.equals(request.getServletPath()) ||\n          PKIAuthenticationPlugin.PATH.equals(request.getPathInfo())) return true;\n      String header = request.getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.doAuthenticate(request, response, (req, rsp) -> {\n          isAuthenticated.set(true);\n          wrappedRequest.set((HttpServletRequest) req);\n        });\n      } catch (Exception e) {\n        log.info(\"Error authenticating\", e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(HttpServletRequest,HttpServletResponse,AtomicReference[HttpServletRequest]).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(HttpServletRequest,HttpServletResponse,AtomicReference[HttpServletRequest]).mjava","sourceNew":"  private boolean authenticateRequest(HttpServletRequest request, HttpServletResponse response, final AtomicReference<HttpServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      // /admin/info/key must be always open. see SOLR-9188\n      // tests work only w/ getPathInfo\n      //otherwise it's just enough to have getServletPath()\n      if (PublicKeyHandler.PATH.equals(request.getServletPath()) ||\n          PublicKeyHandler.PATH.equals(request.getPathInfo())) return true;\n      String header = request.getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.doAuthenticate(request, response, (req, rsp) -> {\n          isAuthenticated.set(true);\n          wrappedRequest.set((HttpServletRequest) req);\n        });\n      } catch (Exception e) {\n        log.info(\"Error authenticating\", e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean authenticateRequest(HttpServletRequest request, HttpServletResponse response, final AtomicReference<HttpServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      // /admin/info/key must be always open. see SOLR-9188\n      // tests work only w/ getPathInfo\n      //otherwise it's just enough to have getServletPath()\n      if (PKIAuthenticationPlugin.PATH.equals(request.getServletPath()) ||\n          PKIAuthenticationPlugin.PATH.equals(request.getPathInfo())) return true;\n      String header = request.getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.doAuthenticate(request, response, (req, rsp) -> {\n          isAuthenticated.set(true);\n          wrappedRequest.set((HttpServletRequest) req);\n        });\n      } catch (Exception e) {\n        log.info(\"Error authenticating\", e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4e5b14c1a3febf27d88acf3083b7551876933aa5","date":1544607443,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(HttpServletRequest,HttpServletResponse,AtomicReference[HttpServletRequest]).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(HttpServletRequest,HttpServletResponse,AtomicReference[HttpServletRequest]).mjava","sourceNew":"  private boolean authenticateRequest(HttpServletRequest request, HttpServletResponse response, final AtomicReference<HttpServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      // /admin/info/key must be always open. see SOLR-9188\n      // tests work only w/ getPathInfo\n      //otherwise it's just enough to have getServletPath()\n      String requestPath = request.getPathInfo();\n      if (requestPath == null) \n        requestPath = request.getServletPath();\n      if (PublicKeyHandler.PATH.equals(requestPath)) {\n        if (log.isDebugEnabled())\n          log.debug(\"Pass through PKI authentication endpoint\");\n        return true;\n      }\n      // /solr/ (Admin UI) must be always open to allow displaying Admin UI with login page  \n      if (\"/solr/\".equals(requestPath) || \"/\".equals(requestPath)) {\n        if (log.isDebugEnabled())\n          log.debug(\"Pass through Admin UI entry point\");\n        return true;\n      }\n      String header = request.getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.doAuthenticate(request, response, (req, rsp) -> {\n          isAuthenticated.set(true);\n          wrappedRequest.set((HttpServletRequest) req);\n        });\n      } catch (Exception e) {\n        log.info(\"Error authenticating\", e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean authenticateRequest(HttpServletRequest request, HttpServletResponse response, final AtomicReference<HttpServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      // /admin/info/key must be always open. see SOLR-9188\n      // tests work only w/ getPathInfo\n      //otherwise it's just enough to have getServletPath()\n      if (PublicKeyHandler.PATH.equals(request.getServletPath()) ||\n          PublicKeyHandler.PATH.equals(request.getPathInfo())) return true;\n      String header = request.getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.doAuthenticate(request, response, (req, rsp) -> {\n          isAuthenticated.set(true);\n          wrappedRequest.set((HttpServletRequest) req);\n        });\n      } catch (Exception e) {\n        log.info(\"Error authenticating\", e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":["50fd776bfdfbf1b644edd777d559f521b4e8319e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"85397dd93927c17347c6bf89800cd0fc566c2d03","date":1544610812,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(HttpServletRequest,HttpServletResponse,AtomicReference[HttpServletRequest]).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(HttpServletRequest,HttpServletResponse,AtomicReference[HttpServletRequest]).mjava","sourceNew":"  private boolean authenticateRequest(HttpServletRequest request, HttpServletResponse response, final AtomicReference<HttpServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      // /admin/info/key must be always open. see SOLR-9188\n      // tests work only w/ getPathInfo\n      //otherwise it's just enough to have getServletPath()\n      String requestPath = request.getPathInfo();\n      if (requestPath == null) \n        requestPath = request.getServletPath();\n      if (PublicKeyHandler.PATH.equals(requestPath)) {\n        if (log.isDebugEnabled())\n          log.debug(\"Pass through PKI authentication endpoint\");\n        return true;\n      }\n      // /solr/ (Admin UI) must be always open to allow displaying Admin UI with login page  \n      if (\"/solr/\".equals(requestPath) || \"/\".equals(requestPath)) {\n        if (log.isDebugEnabled())\n          log.debug(\"Pass through Admin UI entry point\");\n        return true;\n      }\n      String header = request.getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.authenticate(request, response, (req, rsp) -> {\n          isAuthenticated.set(true);\n          wrappedRequest.set((HttpServletRequest) req);\n        });\n      } catch (Exception e) {\n        log.info(\"Error authenticating\", e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean authenticateRequest(HttpServletRequest request, HttpServletResponse response, final AtomicReference<HttpServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      // /admin/info/key must be always open. see SOLR-9188\n      // tests work only w/ getPathInfo\n      //otherwise it's just enough to have getServletPath()\n      String requestPath = request.getPathInfo();\n      if (requestPath == null) \n        requestPath = request.getServletPath();\n      if (PublicKeyHandler.PATH.equals(requestPath)) {\n        if (log.isDebugEnabled())\n          log.debug(\"Pass through PKI authentication endpoint\");\n        return true;\n      }\n      // /solr/ (Admin UI) must be always open to allow displaying Admin UI with login page  \n      if (\"/solr/\".equals(requestPath) || \"/\".equals(requestPath)) {\n        if (log.isDebugEnabled())\n          log.debug(\"Pass through Admin UI entry point\");\n        return true;\n      }\n      String header = request.getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.doAuthenticate(request, response, (req, rsp) -> {\n          isAuthenticated.set(true);\n          wrappedRequest.set((HttpServletRequest) req);\n        });\n      } catch (Exception e) {\n        log.info(\"Error authenticating\", e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"12ddd922ea96c1d0ea68a68506b6984a246cfb22","date":1554385731,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(HttpServletRequest,HttpServletResponse,AtomicReference[HttpServletRequest]).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(HttpServletRequest,HttpServletResponse,AtomicReference[HttpServletRequest]).mjava","sourceNew":"  private boolean authenticateRequest(HttpServletRequest request, HttpServletResponse response, final AtomicReference<HttpServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      if (shouldAudit(EventType.ANONYMOUS)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.ANONYMOUS, request));\n      }\n      return true;\n    } else {\n      // /admin/info/key must be always open. see SOLR-9188\n      // tests work only w/ getPathInfo\n      //otherwise it's just enough to have getServletPath()\n      String requestPath = request.getPathInfo();\n      if (requestPath == null) \n        requestPath = request.getServletPath();\n      if (PublicKeyHandler.PATH.equals(requestPath)) {\n        if (log.isDebugEnabled())\n          log.debug(\"Pass through PKI authentication endpoint\");\n        return true;\n      }\n      // /solr/ (Admin UI) must be always open to allow displaying Admin UI with login page  \n      if (\"/solr/\".equals(requestPath) || \"/\".equals(requestPath)) {\n        if (log.isDebugEnabled())\n          log.debug(\"Pass through Admin UI entry point\");\n        return true;\n      }\n      String header = request.getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.authenticate(request, response, (req, rsp) -> {\n          isAuthenticated.set(true);\n          wrappedRequest.set((HttpServletRequest) req);\n        });\n      } catch (Exception e) {\n        log.info(\"Error authenticating\", e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      if (shouldAudit(EventType.REJECTED)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.REJECTED, request));\n      }\n      return false;\n    }\n    if (shouldAudit(EventType.AUTHENTICATED)) {\n      cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.AUTHENTICATED, request));\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean authenticateRequest(HttpServletRequest request, HttpServletResponse response, final AtomicReference<HttpServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      // /admin/info/key must be always open. see SOLR-9188\n      // tests work only w/ getPathInfo\n      //otherwise it's just enough to have getServletPath()\n      String requestPath = request.getPathInfo();\n      if (requestPath == null) \n        requestPath = request.getServletPath();\n      if (PublicKeyHandler.PATH.equals(requestPath)) {\n        if (log.isDebugEnabled())\n          log.debug(\"Pass through PKI authentication endpoint\");\n        return true;\n      }\n      // /solr/ (Admin UI) must be always open to allow displaying Admin UI with login page  \n      if (\"/solr/\".equals(requestPath) || \"/\".equals(requestPath)) {\n        if (log.isDebugEnabled())\n          log.debug(\"Pass through Admin UI entry point\");\n        return true;\n      }\n      String header = request.getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.authenticate(request, response, (req, rsp) -> {\n          isAuthenticated.set(true);\n          wrappedRequest.set((HttpServletRequest) req);\n        });\n      } catch (Exception e) {\n        log.info(\"Error authenticating\", e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"de1f4f89cef95d8efa9877bdd893d1b542c9b140","date":1574241654,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(HttpServletRequest,HttpServletResponse,AtomicReference[HttpServletRequest]).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(HttpServletRequest,HttpServletResponse,AtomicReference[HttpServletRequest]).mjava","sourceNew":"  private boolean authenticateRequest(HttpServletRequest request, HttpServletResponse response, final AtomicReference<HttpServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      if (shouldAudit(EventType.ANONYMOUS)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.ANONYMOUS, request));\n      }\n      return true;\n    } else {\n      // /admin/info/key must be always open. see SOLR-9188\n      String requestPath = ServletUtils.getPathAfterContext(request);\n      if (PublicKeyHandler.PATH.equals(requestPath)) {\n        if (log.isDebugEnabled())\n          log.debug(\"Pass through PKI authentication endpoint\");\n        return true;\n      }\n      // /solr/ (Admin UI) must be always open to allow displaying Admin UI with login page  \n      if (\"/solr/\".equals(requestPath) || \"/\".equals(requestPath)) {\n        if (log.isDebugEnabled())\n          log.debug(\"Pass through Admin UI entry point\");\n        return true;\n      }\n      String header = request.getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.authenticate(request, response, (req, rsp) -> {\n          isAuthenticated.set(true);\n          wrappedRequest.set((HttpServletRequest) req);\n        });\n      } catch (Exception e) {\n        log.info(\"Error authenticating\", e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      if (shouldAudit(EventType.REJECTED)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.REJECTED, request));\n      }\n      return false;\n    }\n    if (shouldAudit(EventType.AUTHENTICATED)) {\n      cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.AUTHENTICATED, request));\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean authenticateRequest(HttpServletRequest request, HttpServletResponse response, final AtomicReference<HttpServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      if (shouldAudit(EventType.ANONYMOUS)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.ANONYMOUS, request));\n      }\n      return true;\n    } else {\n      // /admin/info/key must be always open. see SOLR-9188\n      // tests work only w/ getPathInfo\n      //otherwise it's just enough to have getServletPath()\n      String requestPath = request.getPathInfo();\n      if (requestPath == null) \n        requestPath = request.getServletPath();\n      if (PublicKeyHandler.PATH.equals(requestPath)) {\n        if (log.isDebugEnabled())\n          log.debug(\"Pass through PKI authentication endpoint\");\n        return true;\n      }\n      // /solr/ (Admin UI) must be always open to allow displaying Admin UI with login page  \n      if (\"/solr/\".equals(requestPath) || \"/\".equals(requestPath)) {\n        if (log.isDebugEnabled())\n          log.debug(\"Pass through Admin UI entry point\");\n        return true;\n      }\n      String header = request.getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.authenticate(request, response, (req, rsp) -> {\n          isAuthenticated.set(true);\n          wrappedRequest.set((HttpServletRequest) req);\n        });\n      } catch (Exception e) {\n        log.info(\"Error authenticating\", e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      if (shouldAudit(EventType.REJECTED)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.REJECTED, request));\n      }\n      return false;\n    }\n    if (shouldAudit(EventType.AUTHENTICATED)) {\n      cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.AUTHENTICATED, request));\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"50fd776bfdfbf1b644edd777d559f521b4e8319e","date":1584646004,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(HttpServletRequest,HttpServletResponse,AtomicReference[HttpServletRequest]).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(HttpServletRequest,HttpServletResponse,AtomicReference[HttpServletRequest]).mjava","sourceNew":"  private boolean authenticateRequest(HttpServletRequest request, HttpServletResponse response, final AtomicReference<HttpServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      if (shouldAudit(EventType.ANONYMOUS)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.ANONYMOUS, request));\n      }\n      return true;\n    } else {\n      // /admin/info/key must be always open. see SOLR-9188\n      String requestPath = ServletUtils.getPathAfterContext(request);\n      if (PublicKeyHandler.PATH.equals(requestPath)) {\n        log.debug(\"Pass through PKI authentication endpoint\");\n        return true;\n      }\n      // /solr/ (Admin UI) must be always open to allow displaying Admin UI with login page  \n      if (\"/solr/\".equals(requestPath) || \"/\".equals(requestPath)) {\n        log.debug(\"Pass through Admin UI entry point\");\n        return true;\n      }\n      String header = request.getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        if (log.isDebugEnabled()) {\n          log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        }\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.authenticate(request, response, (req, rsp) -> {\n          isAuthenticated.set(true);\n          wrappedRequest.set((HttpServletRequest) req);\n        });\n      } catch (Exception e) {\n        log.info(\"Error authenticating\", e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      if (shouldAudit(EventType.REJECTED)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.REJECTED, request));\n      }\n      return false;\n    }\n    if (shouldAudit(EventType.AUTHENTICATED)) {\n      cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.AUTHENTICATED, request));\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean authenticateRequest(HttpServletRequest request, HttpServletResponse response, final AtomicReference<HttpServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      if (shouldAudit(EventType.ANONYMOUS)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.ANONYMOUS, request));\n      }\n      return true;\n    } else {\n      // /admin/info/key must be always open. see SOLR-9188\n      String requestPath = ServletUtils.getPathAfterContext(request);\n      if (PublicKeyHandler.PATH.equals(requestPath)) {\n        if (log.isDebugEnabled())\n          log.debug(\"Pass through PKI authentication endpoint\");\n        return true;\n      }\n      // /solr/ (Admin UI) must be always open to allow displaying Admin UI with login page  \n      if (\"/solr/\".equals(requestPath) || \"/\".equals(requestPath)) {\n        if (log.isDebugEnabled())\n          log.debug(\"Pass through Admin UI entry point\");\n        return true;\n      }\n      String header = request.getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.authenticate(request, response, (req, rsp) -> {\n          isAuthenticated.set(true);\n          wrappedRequest.set((HttpServletRequest) req);\n        });\n      } catch (Exception e) {\n        log.info(\"Error authenticating\", e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      if (shouldAudit(EventType.REJECTED)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.REJECTED, request));\n      }\n      return false;\n    }\n    if (shouldAudit(EventType.AUTHENTICATED)) {\n      cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.AUTHENTICATED, request));\n    }\n    return true;\n  }\n\n","bugFix":["896e12033d56085efdb7b88bd289beb2645361dc","4e5b14c1a3febf27d88acf3083b7551876933aa5"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","61d55d0cc95bfc03461b5c355153ca28c49076eb"],"61d55d0cc95bfc03461b5c355153ca28c49076eb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"50fd776bfdfbf1b644edd777d559f521b4e8319e":["de1f4f89cef95d8efa9877bdd893d1b542c9b140"],"12ddd922ea96c1d0ea68a68506b6984a246cfb22":["85397dd93927c17347c6bf89800cd0fc566c2d03"],"85397dd93927c17347c6bf89800cd0fc566c2d03":["4e5b14c1a3febf27d88acf3083b7551876933aa5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["b94236357aaa22b76c10629851fe4e376e0cea82","946009ad0fba506337041a368b0a74d2edd59e2c"],"4e5b14c1a3febf27d88acf3083b7551876933aa5":["946009ad0fba506337041a368b0a74d2edd59e2c"],"de1f4f89cef95d8efa9877bdd893d1b542c9b140":["12ddd922ea96c1d0ea68a68506b6984a246cfb22"],"f592209545c71895260367152601e9200399776d":["b94236357aaa22b76c10629851fe4e376e0cea82","946009ad0fba506337041a368b0a74d2edd59e2c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["50fd776bfdfbf1b644edd777d559f521b4e8319e"],"946009ad0fba506337041a368b0a74d2edd59e2c":["b94236357aaa22b76c10629851fe4e376e0cea82"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","946009ad0fba506337041a368b0a74d2edd59e2c"],"61d55d0cc95bfc03461b5c355153ca28c49076eb":["b94236357aaa22b76c10629851fe4e376e0cea82"],"50fd776bfdfbf1b644edd777d559f521b4e8319e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"12ddd922ea96c1d0ea68a68506b6984a246cfb22":["de1f4f89cef95d8efa9877bdd893d1b542c9b140"],"85397dd93927c17347c6bf89800cd0fc566c2d03":["12ddd922ea96c1d0ea68a68506b6984a246cfb22"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b94236357aaa22b76c10629851fe4e376e0cea82","61d55d0cc95bfc03461b5c355153ca28c49076eb"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"4e5b14c1a3febf27d88acf3083b7551876933aa5":["85397dd93927c17347c6bf89800cd0fc566c2d03"],"de1f4f89cef95d8efa9877bdd893d1b542c9b140":["50fd776bfdfbf1b644edd777d559f521b4e8319e"],"f592209545c71895260367152601e9200399776d":[],"946009ad0fba506337041a368b0a74d2edd59e2c":["b70042a8a492f7054d480ccdd2be9796510d4327","4e5b14c1a3febf27d88acf3083b7551876933aa5","f592209545c71895260367152601e9200399776d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}