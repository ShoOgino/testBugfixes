{"path":"src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter).mjava","commits":[{"id":"4350b17bd363cd13a95171b8df1ca62ea4c3e71c","date":1183562198,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter).mjava","pathOld":"src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  The incoming\n   * segmentInfos must have been loaded from a commit point\n   * and not yet modified.  This will remove any files not\n   * referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    IndexFileNameFilter filter = IndexFileNameFilter.getFilter();\n\n    String[] files = directory.list();\n    if (files == null)\n      throw new IOException(\"cannot read directory \" + directory + \": list() returned null\");\n\n    CommitPoint currentCommitPoint = null;\n\n    for(int i=0;i<files.length;i++) {\n\n      String fileName = files[i];\n\n      if (filter.accept(null, fileName) && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n            if (infoStream != null) {\n              message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            sis.read(directory, fileName);\n            CommitPoint commitPoint = new CommitPoint(sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null) {\n      throw new CorruptIndexException(\"failed to locate current segments_N file\");\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    Iterator it = refCounts.keySet().iterator();\n    while(it.hasNext()) {\n      String fileName = (String) it.next();\n      RefCount rc = (RefCount) refCounts.get(fileName);\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // It's OK for the onInit to remove the current commit\n    // point; we just have to checkpoint our in-memory\n    // SegmentInfos to protect those files that it uses:\n    if (currentCommitPoint.deleted) {\n      checkpoint(segmentInfos, false);\n    }\n    \n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  The incoming\n   * segmentInfos must have been loaded from a commit point\n   * and not yet modified.  This will remove any files not\n   * referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream)\n    throws CorruptIndexException, IOException {\n\n    this.infoStream = infoStream;\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    IndexFileNameFilter filter = IndexFileNameFilter.getFilter();\n\n    String[] files = directory.list();\n    if (files == null)\n      throw new IOException(\"cannot read directory \" + directory + \": list() returned null\");\n\n    CommitPoint currentCommitPoint = null;\n\n    for(int i=0;i<files.length;i++) {\n\n      String fileName = files[i];\n\n      if (filter.accept(null, fileName) && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n            if (infoStream != null) {\n              message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            sis.read(directory, fileName);\n            CommitPoint commitPoint = new CommitPoint(sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null) {\n      throw new CorruptIndexException(\"failed to locate current segments_N file\");\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    Iterator it = refCounts.keySet().iterator();\n    while(it.hasNext()) {\n      String fileName = (String) it.next();\n      RefCount rc = (RefCount) refCounts.get(fileName);\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // It's OK for the onInit to remove the current commit\n    // point; we just have to checkpoint our in-memory\n    // SegmentInfos to protect those files that it uses:\n    if (currentCommitPoint.deleted) {\n      checkpoint(segmentInfos, false);\n    }\n    \n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7dc11e5e2e108e6cdd85ae2693383a15f41cbf35","date":1186166482,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter).mjava","pathOld":"src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  The incoming\n   * segmentInfos must have been loaded from a commit point\n   * and not yet modified.  This will remove any files not\n   * referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + segmentInfos.getCurrentSegmentFileName() + \"\\\"\");\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    IndexFileNameFilter filter = IndexFileNameFilter.getFilter();\n\n    String[] files = directory.list();\n    if (files == null)\n      throw new IOException(\"cannot read directory \" + directory + \": list() returned null\");\n\n    CommitPoint currentCommitPoint = null;\n\n    for(int i=0;i<files.length;i++) {\n\n      String fileName = files[i];\n\n      if (filter.accept(null, fileName) && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n            if (infoStream != null) {\n              message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException e) {\n              // LUCENE-948: on NFS (and maybe others), if\n              // you have writers switching back and forth\n              // between machines, it's very likely that the\n              // dir listing will be stale and will claim a\n              // file segments_X exists when in fact it\n              // doesn't.  So, we catch this and handle it\n              // as if the file does not exist\n              if (infoStream != null) {\n                message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            }\n            if (sis != null) {\n              CommitPoint commitPoint = new CommitPoint(sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null) {\n      throw new CorruptIndexException(\"failed to locate current segments_N file\");\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    Iterator it = refCounts.keySet().iterator();\n    while(it.hasNext()) {\n      String fileName = (String) it.next();\n      RefCount rc = (RefCount) refCounts.get(fileName);\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // It's OK for the onInit to remove the current commit\n    // point; we just have to checkpoint our in-memory\n    // SegmentInfos to protect those files that it uses:\n    if (currentCommitPoint.deleted) {\n      checkpoint(segmentInfos, false);\n    }\n    \n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  The incoming\n   * segmentInfos must have been loaded from a commit point\n   * and not yet modified.  This will remove any files not\n   * referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    IndexFileNameFilter filter = IndexFileNameFilter.getFilter();\n\n    String[] files = directory.list();\n    if (files == null)\n      throw new IOException(\"cannot read directory \" + directory + \": list() returned null\");\n\n    CommitPoint currentCommitPoint = null;\n\n    for(int i=0;i<files.length;i++) {\n\n      String fileName = files[i];\n\n      if (filter.accept(null, fileName) && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n            if (infoStream != null) {\n              message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            sis.read(directory, fileName);\n            CommitPoint commitPoint = new CommitPoint(sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null) {\n      throw new CorruptIndexException(\"failed to locate current segments_N file\");\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    Iterator it = refCounts.keySet().iterator();\n    while(it.hasNext()) {\n      String fileName = (String) it.next();\n      RefCount rc = (RefCount) refCounts.get(fileName);\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // It's OK for the onInit to remove the current commit\n    // point; we just have to checkpoint our in-memory\n    // SegmentInfos to protect those files that it uses:\n    if (currentCommitPoint.deleted) {\n      checkpoint(segmentInfos, false);\n    }\n    \n    deleteCommits();\n  }\n\n","bugFix":["8b6187898fc4413ccd18229711786550a280383c"],"bugIntro":["67006a60923e2124212d3baa0d29b444bcbd8373"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"67006a60923e2124212d3baa0d29b444bcbd8373","date":1191425052,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter).mjava","pathOld":"src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  The incoming\n   * segmentInfos must have been loaded from a commit point\n   * and not yet modified.  This will remove any files not\n   * referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + segmentInfos.getCurrentSegmentFileName() + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    IndexFileNameFilter filter = IndexFileNameFilter.getFilter();\n\n    String[] files = directory.list();\n    if (files == null)\n      throw new IOException(\"cannot read directory \" + directory + \": list() returned null\");\n\n    CommitPoint currentCommitPoint = null;\n\n    for(int i=0;i<files.length;i++) {\n\n      String fileName = files[i];\n\n      if (filter.accept(null, fileName) && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n            if (infoStream != null) {\n              message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException e) {\n              // LUCENE-948: on NFS (and maybe others), if\n              // you have writers switching back and forth\n              // between machines, it's very likely that the\n              // dir listing will be stale and will claim a\n              // file segments_X exists when in fact it\n              // doesn't.  So, we catch this and handle it\n              // as if the file does not exist\n              if (infoStream != null) {\n                message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            }\n            if (sis != null) {\n              CommitPoint commitPoint = new CommitPoint(sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, segmentInfos.getCurrentSegmentFileName());\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    Iterator it = refCounts.keySet().iterator();\n    while(it.hasNext()) {\n      String fileName = (String) it.next();\n      RefCount rc = (RefCount) refCounts.get(fileName);\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // It's OK for the onInit to remove the current commit\n    // point; we just have to checkpoint our in-memory\n    // SegmentInfos to protect those files that it uses:\n    if (currentCommitPoint.deleted) {\n      checkpoint(segmentInfos, false);\n    }\n    \n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  The incoming\n   * segmentInfos must have been loaded from a commit point\n   * and not yet modified.  This will remove any files not\n   * referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + segmentInfos.getCurrentSegmentFileName() + \"\\\"\");\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    IndexFileNameFilter filter = IndexFileNameFilter.getFilter();\n\n    String[] files = directory.list();\n    if (files == null)\n      throw new IOException(\"cannot read directory \" + directory + \": list() returned null\");\n\n    CommitPoint currentCommitPoint = null;\n\n    for(int i=0;i<files.length;i++) {\n\n      String fileName = files[i];\n\n      if (filter.accept(null, fileName) && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n            if (infoStream != null) {\n              message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException e) {\n              // LUCENE-948: on NFS (and maybe others), if\n              // you have writers switching back and forth\n              // between machines, it's very likely that the\n              // dir listing will be stale and will claim a\n              // file segments_X exists when in fact it\n              // doesn't.  So, we catch this and handle it\n              // as if the file does not exist\n              if (infoStream != null) {\n                message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            }\n            if (sis != null) {\n              CommitPoint commitPoint = new CommitPoint(sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null) {\n      throw new CorruptIndexException(\"failed to locate current segments_N file\");\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    Iterator it = refCounts.keySet().iterator();\n    while(it.hasNext()) {\n      String fileName = (String) it.next();\n      RefCount rc = (RefCount) refCounts.get(fileName);\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // It's OK for the onInit to remove the current commit\n    // point; we just have to checkpoint our in-memory\n    // SegmentInfos to protect those files that it uses:\n    if (currentCommitPoint.deleted) {\n      checkpoint(segmentInfos, false);\n    }\n    \n    deleteCommits();\n  }\n\n","bugFix":["8b6187898fc4413ccd18229711786550a280383c","7dc11e5e2e108e6cdd85ae2693383a15f41cbf35"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d60f4e15b3e2fb549c23c8f2096249d439876df8","date":1204035825,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter).mjava","pathOld":"src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  The incoming\n   * segmentInfos must have been loaded from a commit point\n   * and not yet modified.  This will remove any files not\n   * referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + segmentInfos.getCurrentSegmentFileName() + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    IndexFileNameFilter filter = IndexFileNameFilter.getFilter();\n\n    String[] files = directory.list();\n    if (files == null)\n      throw new IOException(\"cannot read directory \" + directory + \": list() returned null\");\n\n    CommitPoint currentCommitPoint = null;\n\n    for(int i=0;i<files.length;i++) {\n\n      String fileName = files[i];\n\n      if (filter.accept(null, fileName) && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n            if (infoStream != null) {\n              message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException e) {\n              // LUCENE-948: on NFS (and maybe others), if\n              // you have writers switching back and forth\n              // between machines, it's very likely that the\n              // dir listing will be stale and will claim a\n              // file segments_X exists when in fact it\n              // doesn't.  So, we catch this and handle it\n              // as if the file does not exist\n              if (infoStream != null) {\n                message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            }\n            if (sis != null) {\n              CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, segmentInfos.getCurrentSegmentFileName());\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    Iterator it = refCounts.keySet().iterator();\n    while(it.hasNext()) {\n      String fileName = (String) it.next();\n      RefCount rc = (RefCount) refCounts.get(fileName);\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // It's OK for the onInit to remove the current commit\n    // point; we just have to checkpoint our in-memory\n    // SegmentInfos to protect those files that it uses:\n    if (currentCommitPoint.deleted) {\n      checkpoint(segmentInfos, false);\n    }\n    \n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  The incoming\n   * segmentInfos must have been loaded from a commit point\n   * and not yet modified.  This will remove any files not\n   * referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + segmentInfos.getCurrentSegmentFileName() + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    IndexFileNameFilter filter = IndexFileNameFilter.getFilter();\n\n    String[] files = directory.list();\n    if (files == null)\n      throw new IOException(\"cannot read directory \" + directory + \": list() returned null\");\n\n    CommitPoint currentCommitPoint = null;\n\n    for(int i=0;i<files.length;i++) {\n\n      String fileName = files[i];\n\n      if (filter.accept(null, fileName) && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n            if (infoStream != null) {\n              message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException e) {\n              // LUCENE-948: on NFS (and maybe others), if\n              // you have writers switching back and forth\n              // between machines, it's very likely that the\n              // dir listing will be stale and will claim a\n              // file segments_X exists when in fact it\n              // doesn't.  So, we catch this and handle it\n              // as if the file does not exist\n              if (infoStream != null) {\n                message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            }\n            if (sis != null) {\n              CommitPoint commitPoint = new CommitPoint(sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, segmentInfos.getCurrentSegmentFileName());\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    Iterator it = refCounts.keySet().iterator();\n    while(it.hasNext()) {\n      String fileName = (String) it.next();\n      RefCount rc = (RefCount) refCounts.get(fileName);\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // It's OK for the onInit to remove the current commit\n    // point; we just have to checkpoint our in-memory\n    // SegmentInfos to protect those files that it uses:\n    if (currentCommitPoint.deleted) {\n      checkpoint(segmentInfos, false);\n    }\n    \n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d99092e7a9892440b9da55d5b75d3d77206ee80e","date":1224496135,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter).mjava","pathOld":"src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + segmentInfos.getCurrentSegmentFileName() + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    IndexFileNameFilter filter = IndexFileNameFilter.getFilter();\n\n    String[] files = directory.list();\n    if (files == null)\n      throw new IOException(\"cannot read directory \" + directory + \": list() returned null\");\n\n    CommitPoint currentCommitPoint = null;\n\n    for(int i=0;i<files.length;i++) {\n\n      String fileName = files[i];\n\n      if (filter.accept(null, fileName) && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n            if (infoStream != null) {\n              message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException e) {\n              // LUCENE-948: on NFS (and maybe others), if\n              // you have writers switching back and forth\n              // between machines, it's very likely that the\n              // dir listing will be stale and will claim a\n              // file segments_X exists when in fact it\n              // doesn't.  So, we catch this and handle it\n              // as if the file does not exist\n              if (infoStream != null) {\n                message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            }\n            if (sis != null) {\n              CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, segmentInfos.getCurrentSegmentFileName());\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    Iterator it = refCounts.keySet().iterator();\n    while(it.hasNext()) {\n      String fileName = (String) it.next();\n      RefCount rc = (RefCount) refCounts.get(fileName);\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  The incoming\n   * segmentInfos must have been loaded from a commit point\n   * and not yet modified.  This will remove any files not\n   * referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + segmentInfos.getCurrentSegmentFileName() + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    IndexFileNameFilter filter = IndexFileNameFilter.getFilter();\n\n    String[] files = directory.list();\n    if (files == null)\n      throw new IOException(\"cannot read directory \" + directory + \": list() returned null\");\n\n    CommitPoint currentCommitPoint = null;\n\n    for(int i=0;i<files.length;i++) {\n\n      String fileName = files[i];\n\n      if (filter.accept(null, fileName) && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n            if (infoStream != null) {\n              message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException e) {\n              // LUCENE-948: on NFS (and maybe others), if\n              // you have writers switching back and forth\n              // between machines, it's very likely that the\n              // dir listing will be stale and will claim a\n              // file segments_X exists when in fact it\n              // doesn't.  So, we catch this and handle it\n              // as if the file does not exist\n              if (infoStream != null) {\n                message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            }\n            if (sis != null) {\n              CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, segmentInfos.getCurrentSegmentFileName());\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    Iterator it = refCounts.keySet().iterator();\n    while(it.hasNext()) {\n      String fileName = (String) it.next();\n      RefCount rc = (RefCount) refCounts.get(fileName);\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // It's OK for the onInit to remove the current commit\n    // point; we just have to checkpoint our in-memory\n    // SegmentInfos to protect those files that it uses:\n    if (currentCommitPoint.deleted) {\n      checkpoint(segmentInfos, false);\n    }\n    \n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b8b3b526542a07c380e03ce642edd7ca82ac961f","date":1226443334,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter).mjava","pathOld":"src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + segmentInfos.getCurrentSegmentFileName() + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    IndexFileNameFilter filter = IndexFileNameFilter.getFilter();\n\n    String[] files = directory.list();\n    if (files == null)\n      throw new IOException(\"cannot read directory \" + directory + \": list() returned null\");\n\n    CommitPoint currentCommitPoint = null;\n\n    for(int i=0;i<files.length;i++) {\n\n      String fileName = files[i];\n\n      if (filter.accept(null, fileName) && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n            if (infoStream != null) {\n              message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException e) {\n              // LUCENE-948: on NFS (and maybe others), if\n              // you have writers switching back and forth\n              // between machines, it's very likely that the\n              // dir listing will be stale and will claim a\n              // file segments_X exists when in fact it\n              // doesn't.  So, we catch this and handle it\n              // as if the file does not exist\n              if (infoStream != null) {\n                message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            }\n            if (sis != null) {\n              CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, segmentInfos.getCurrentSegmentFileName());\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    Iterator it = refCounts.keySet().iterator();\n    while(it.hasNext()) {\n      String fileName = (String) it.next();\n      RefCount rc = (RefCount) refCounts.get(fileName);\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + segmentInfos.getCurrentSegmentFileName() + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    IndexFileNameFilter filter = IndexFileNameFilter.getFilter();\n\n    String[] files = directory.list();\n    if (files == null)\n      throw new IOException(\"cannot read directory \" + directory + \": list() returned null\");\n\n    CommitPoint currentCommitPoint = null;\n\n    for(int i=0;i<files.length;i++) {\n\n      String fileName = files[i];\n\n      if (filter.accept(null, fileName) && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n            if (infoStream != null) {\n              message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException e) {\n              // LUCENE-948: on NFS (and maybe others), if\n              // you have writers switching back and forth\n              // between machines, it's very likely that the\n              // dir listing will be stale and will claim a\n              // file segments_X exists when in fact it\n              // doesn't.  So, we catch this and handle it\n              // as if the file does not exist\n              if (infoStream != null) {\n                message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            }\n            if (sis != null) {\n              CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, segmentInfos.getCurrentSegmentFileName());\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    Iterator it = refCounts.keySet().iterator();\n    while(it.hasNext()) {\n      String fileName = (String) it.next();\n      RefCount rc = (RefCount) refCounts.get(fileName);\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d54c7739bfe85d68f0352823cd70c10c619fad38","date":1228496593,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter).mjava","pathOld":"src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + segmentInfos.getCurrentSegmentFileName() + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    IndexFileNameFilter filter = IndexFileNameFilter.getFilter();\n\n    String[] files = directory.listAll();\n\n    CommitPoint currentCommitPoint = null;\n\n    for(int i=0;i<files.length;i++) {\n\n      String fileName = files[i];\n\n      if (filter.accept(null, fileName) && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n            if (infoStream != null) {\n              message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException e) {\n              // LUCENE-948: on NFS (and maybe others), if\n              // you have writers switching back and forth\n              // between machines, it's very likely that the\n              // dir listing will be stale and will claim a\n              // file segments_X exists when in fact it\n              // doesn't.  So, we catch this and handle it\n              // as if the file does not exist\n              if (infoStream != null) {\n                message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            }\n            if (sis != null) {\n              CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, segmentInfos.getCurrentSegmentFileName());\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    Iterator it = refCounts.keySet().iterator();\n    while(it.hasNext()) {\n      String fileName = (String) it.next();\n      RefCount rc = (RefCount) refCounts.get(fileName);\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + segmentInfos.getCurrentSegmentFileName() + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    IndexFileNameFilter filter = IndexFileNameFilter.getFilter();\n\n    String[] files = directory.list();\n    if (files == null)\n      throw new IOException(\"cannot read directory \" + directory + \": list() returned null\");\n\n    CommitPoint currentCommitPoint = null;\n\n    for(int i=0;i<files.length;i++) {\n\n      String fileName = files[i];\n\n      if (filter.accept(null, fileName) && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n            if (infoStream != null) {\n              message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException e) {\n              // LUCENE-948: on NFS (and maybe others), if\n              // you have writers switching back and forth\n              // between machines, it's very likely that the\n              // dir listing will be stale and will claim a\n              // file segments_X exists when in fact it\n              // doesn't.  So, we catch this and handle it\n              // as if the file does not exist\n              if (infoStream != null) {\n                message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            }\n            if (sis != null) {\n              CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, segmentInfos.getCurrentSegmentFileName());\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    Iterator it = refCounts.keySet().iterator();\n    while(it.hasNext()) {\n      String fileName = (String) it.next();\n      RefCount rc = (RefCount) refCounts.get(fileName);\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","bugFix":["8b6187898fc4413ccd18229711786550a280383c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ef82ff03e4016c705811b2658e81471a645c0e49","date":1255900293,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter).mjava","pathOld":"src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + segmentInfos.getCurrentSegmentFileName() + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    IndexFileNameFilter filter = IndexFileNameFilter.getFilter();\n\n    String[] files = directory.listAll();\n\n    CommitPoint currentCommitPoint = null;\n\n    for(int i=0;i<files.length;i++) {\n\n      String fileName = files[i];\n\n      if (filter.accept(null, fileName) && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n            if (infoStream != null) {\n              message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException e) {\n              // LUCENE-948: on NFS (and maybe others), if\n              // you have writers switching back and forth\n              // between machines, it's very likely that the\n              // dir listing will be stale and will claim a\n              // file segments_X exists when in fact it\n              // doesn't.  So, we catch this and handle it\n              // as if the file does not exist\n              if (infoStream != null) {\n                message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            }\n            if (sis != null) {\n              CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, segmentInfos.getCurrentSegmentFileName());\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {  \n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + segmentInfos.getCurrentSegmentFileName() + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    IndexFileNameFilter filter = IndexFileNameFilter.getFilter();\n\n    String[] files = directory.listAll();\n\n    CommitPoint currentCommitPoint = null;\n\n    for(int i=0;i<files.length;i++) {\n\n      String fileName = files[i];\n\n      if (filter.accept(null, fileName) && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n            if (infoStream != null) {\n              message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException e) {\n              // LUCENE-948: on NFS (and maybe others), if\n              // you have writers switching back and forth\n              // between machines, it's very likely that the\n              // dir listing will be stale and will claim a\n              // file segments_X exists when in fact it\n              // doesn't.  So, we catch this and handle it\n              // as if the file does not exist\n              if (infoStream != null) {\n                message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            }\n            if (sis != null) {\n              CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, segmentInfos.getCurrentSegmentFileName());\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    Iterator it = refCounts.keySet().iterator();\n    while(it.hasNext()) {\n      String fileName = (String) it.next();\n      RefCount rc = (RefCount) refCounts.get(fileName);\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter).mjava","pathOld":"src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,PrintStream,DocumentsWriter).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + segmentInfos.getCurrentSegmentFileName() + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    IndexFileNameFilter filter = IndexFileNameFilter.getFilter();\n\n    String[] files = directory.listAll();\n\n    CommitPoint currentCommitPoint = null;\n\n    for(int i=0;i<files.length;i++) {\n\n      String fileName = files[i];\n\n      if (filter.accept(null, fileName) && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n            if (infoStream != null) {\n              message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException e) {\n              // LUCENE-948: on NFS (and maybe others), if\n              // you have writers switching back and forth\n              // between machines, it's very likely that the\n              // dir listing will be stale and will claim a\n              // file segments_X exists when in fact it\n              // doesn't.  So, we catch this and handle it\n              // as if the file does not exist\n              if (infoStream != null) {\n                message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            }\n            if (sis != null) {\n              CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, segmentInfos.getCurrentSegmentFileName());\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {  \n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, PrintStream infoStream, DocumentsWriter docWriter)\n    throws CorruptIndexException, IOException {\n\n    this.docWriter = docWriter;\n    this.infoStream = infoStream;\n\n    if (infoStream != null)\n      message(\"init: current segments file is \\\"\" + segmentInfos.getCurrentSegmentFileName() + \"\\\"; deletionPolicy=\" + policy);\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n    IndexFileNameFilter filter = IndexFileNameFilter.getFilter();\n\n    String[] files = directory.listAll();\n\n    CommitPoint currentCommitPoint = null;\n\n    for(int i=0;i<files.length;i++) {\n\n      String fileName = files[i];\n\n      if (filter.accept(null, fileName) && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {\n            if (infoStream != null) {\n              message(\"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException e) {\n              // LUCENE-948: on NFS (and maybe others), if\n              // you have writers switching back and forth\n              // between machines, it's very likely that the\n              // dir listing will be stale and will claim a\n              // file segments_X exists when in fact it\n              // doesn't.  So, we catch this and handle it\n              // as if the file does not exist\n              if (infoStream != null) {\n                message(\"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            }\n            if (sis != null) {\n              CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, segmentInfos.getCurrentSegmentFileName());\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream != null)\n        message(\"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    Collections.sort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {  \n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream != null) {\n          message(\"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    policy.onInit(commits);\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n    \n    startingCommitDeleted = currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d60f4e15b3e2fb549c23c8f2096249d439876df8":["67006a60923e2124212d3baa0d29b444bcbd8373"],"d54c7739bfe85d68f0352823cd70c10c619fad38":["b8b3b526542a07c380e03ce642edd7ca82ac961f"],"7dc11e5e2e108e6cdd85ae2693383a15f41cbf35":["4350b17bd363cd13a95171b8df1ca62ea4c3e71c"],"ef82ff03e4016c705811b2658e81471a645c0e49":["d54c7739bfe85d68f0352823cd70c10c619fad38"],"67006a60923e2124212d3baa0d29b444bcbd8373":["7dc11e5e2e108e6cdd85ae2693383a15f41cbf35"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b8b3b526542a07c380e03ce642edd7ca82ac961f":["d99092e7a9892440b9da55d5b75d3d77206ee80e"],"4350b17bd363cd13a95171b8df1ca62ea4c3e71c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["ef82ff03e4016c705811b2658e81471a645c0e49"],"d99092e7a9892440b9da55d5b75d3d77206ee80e":["d60f4e15b3e2fb549c23c8f2096249d439876df8"]},"commit2Childs":{"d60f4e15b3e2fb549c23c8f2096249d439876df8":["d99092e7a9892440b9da55d5b75d3d77206ee80e"],"d54c7739bfe85d68f0352823cd70c10c619fad38":["ef82ff03e4016c705811b2658e81471a645c0e49"],"7dc11e5e2e108e6cdd85ae2693383a15f41cbf35":["67006a60923e2124212d3baa0d29b444bcbd8373"],"67006a60923e2124212d3baa0d29b444bcbd8373":["d60f4e15b3e2fb549c23c8f2096249d439876df8"],"ef82ff03e4016c705811b2658e81471a645c0e49":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4350b17bd363cd13a95171b8df1ca62ea4c3e71c"],"b8b3b526542a07c380e03ce642edd7ca82ac961f":["d54c7739bfe85d68f0352823cd70c10c619fad38"],"4350b17bd363cd13a95171b8df1ca62ea4c3e71c":["7dc11e5e2e108e6cdd85ae2693383a15f41cbf35"],"d99092e7a9892440b9da55d5b75d3d77206ee80e":["b8b3b526542a07c380e03ce642edd7ca82ac961f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}