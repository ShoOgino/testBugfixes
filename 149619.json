{"path":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","commits":[{"id":"729cb470f975115d4c60517b2cb7c42e37a7a2e1","date":1492041760,"type":1,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    this.coreContainer = coreContainer;\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    coreContainer.solrCores.addCoreDescriptor(cd);\n\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), null);\n\n    SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n    // this is registered at the CONTAINER level because it's not core-specific - for now we\n    // also register it here for back-compat\n    solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), \"core\");\n    infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to report metrics\n    if (directoryFactory instanceof SolrMetricProducer) {\n      ((SolrMetricProducer)directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(), \"directoryFactory\");\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = this.coreDescriptor.getCoreContainer().getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), null);\n\n    SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n    // this is registered at the CONTAINER level because it's not core-specific - for now we\n    // also register it here for back-compat\n    solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), \"core\");\n    infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to report metrics\n    if (directoryFactory instanceof SolrMetricProducer) {\n      ((SolrMetricProducer)directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(), \"directoryFactory\");\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    this.coreContainer = coreContainer;\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    coreContainer.solrCores.addCoreDescriptor(cd);\n\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), null);\n\n    SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n    // this is registered at the CONTAINER level because it's not core-specific - for now we\n    // also register it here for back-compat\n    solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), \"core\");\n    infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to report metrics\n    if (directoryFactory instanceof SolrMetricProducer) {\n      ((SolrMetricProducer)directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(), \"directoryFactory\");\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"39fdbc59d893f5a211736e861fe145798a40b9ff","date":1498161919,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    this.coreContainer = coreContainer;\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    coreContainer.solrCores.addCoreDescriptor(cd);\n\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), null);\n\n    SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n    // this is registered at the CONTAINER level because it's not core-specific - for now we\n    // also register it here for back-compat\n    solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), \"core\");\n    infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to report metrics\n    if (directoryFactory instanceof SolrMetricProducer) {\n      ((SolrMetricProducer)directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(), \"directoryFactory\");\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    this.coreContainer = coreContainer;\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    coreContainer.solrCores.addCoreDescriptor(cd);\n\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), null);\n\n    SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n    // this is registered at the CONTAINER level because it's not core-specific - for now we\n    // also register it here for back-compat\n    solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), \"core\");\n    infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to report metrics\n    if (directoryFactory instanceof SolrMetricProducer) {\n      ((SolrMetricProducer)directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(), \"directoryFactory\");\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    this.coreContainer = coreContainer;\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    coreContainer.solrCores.addCoreDescriptor(cd);\n\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), null);\n\n    SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n    // this is registered at the CONTAINER level because it's not core-specific - for now we\n    // also register it here for back-compat\n    solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), \"core\");\n    infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to report metrics\n    if (directoryFactory instanceof SolrMetricProducer) {\n      ((SolrMetricProducer)directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(), \"directoryFactory\");\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    this.coreContainer = coreContainer;\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    coreContainer.solrCores.addCoreDescriptor(cd);\n\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), null);\n\n    SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n    // this is registered at the CONTAINER level because it's not core-specific - for now we\n    // also register it here for back-compat\n    solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), \"core\");\n    infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to report metrics\n    if (directoryFactory instanceof SolrMetricProducer) {\n      ((SolrMetricProducer)directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(), \"directoryFactory\");\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    this.coreContainer = coreContainer;\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    coreContainer.solrCores.addCoreDescriptor(cd);\n\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), null);\n\n    SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n    // this is registered at the CONTAINER level because it's not core-specific - for now we\n    // also register it here for back-compat\n    solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), \"core\");\n    infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to report metrics\n    if (directoryFactory instanceof SolrMetricProducer) {\n      ((SolrMetricProducer)directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(), \"directoryFactory\");\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    this.coreContainer = coreContainer;\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    coreContainer.solrCores.addCoreDescriptor(cd);\n\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), null);\n\n    SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n    // this is registered at the CONTAINER level because it's not core-specific - for now we\n    // also register it here for back-compat\n    solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), \"core\");\n    infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to report metrics\n    if (directoryFactory instanceof SolrMetricProducer) {\n      ((SolrMetricProducer)directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(), \"directoryFactory\");\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"96e0d4494fe54b31c7f0151f3a632124ab806351","date":1512410218,"type":3,"author":"Erick","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    this.coreContainer = coreContainer;\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    coreContainer.solrCores.addCoreDescriptor(cd);\n\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), null);\n\n    SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n    // this is registered at the CONTAINER level because it's not core-specific - for now we\n    // also register it here for back-compat\n    solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), \"core\");\n    infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to report metrics\n    if (directoryFactory instanceof SolrMetricProducer) {\n      ((SolrMetricProducer)directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(), \"directoryFactory\");\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    this.coreContainer = coreContainer;\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    coreContainer.solrCores.addCoreDescriptor(cd);\n\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), null);\n\n    SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n    // this is registered at the CONTAINER level because it's not core-specific - for now we\n    // also register it here for back-compat\n    solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), \"core\");\n    infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to report metrics\n    if (directoryFactory instanceof SolrMetricProducer) {\n      ((SolrMetricProducer)directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(), \"directoryFactory\");\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":["54bb8da55080e4569804e0661b83a3c72cbd8d4d"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bfc52860e6d13d034226a760813c59d984c6817a","date":1522229027,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    this.coreContainer = coreContainer;\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    coreContainer.solrCores.addCoreDescriptor(cd);\n\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, null);\n\n    SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n    // this is registered at the CONTAINER level because it's not core-specific - for now we\n    // also register it here for back-compat\n    solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"core\");\n    infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to report metrics\n    if (directoryFactory instanceof SolrMetricProducer) {\n      ((SolrMetricProducer)directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"directoryFactory\");\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    this.coreContainer = coreContainer;\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    coreContainer.solrCores.addCoreDescriptor(cd);\n\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), null);\n\n    SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n    // this is registered at the CONTAINER level because it's not core-specific - for now we\n    // also register it here for back-compat\n    solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), \"core\");\n    infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to report metrics\n    if (directoryFactory instanceof SolrMetricProducer) {\n      ((SolrMetricProducer)directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(), \"directoryFactory\");\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":["f34d83c894e07c24f5f957820777b5da2cc29e5a","816521ebaad5add9cb96bb88c577394e2938c40b"],"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"43564cbb30b064675027cfb569564e8531096e97","date":1522334265,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    this.coreContainer = coreContainer;\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    coreContainer.solrCores.addCoreDescriptor(cd);\n\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, null);\n\n    SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n    // this is registered at the CONTAINER level because it's not core-specific - for now we\n    // also register it here for back-compat\n    solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"core\");\n    infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to report metrics\n    if (directoryFactory instanceof SolrMetricProducer) {\n      ((SolrMetricProducer)directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"directoryFactory\");\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    this.coreContainer = coreContainer;\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    coreContainer.solrCores.addCoreDescriptor(cd);\n\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), null);\n\n    SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n    // this is registered at the CONTAINER level because it's not core-specific - for now we\n    // also register it here for back-compat\n    solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), \"core\");\n    infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to report metrics\n    if (directoryFactory instanceof SolrMetricProducer) {\n      ((SolrMetricProducer)directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(), \"directoryFactory\");\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bf6d72d9a6aa495633b49f3d36910c508b8ccf77","date":1528225892,"type":3,"author":"Jeff","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    this.coreContainer = coreContainer;\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    coreContainer.solrCores.addCoreDescriptor(cd);\n\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, null);\n\n    SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n    // this is registered at the CONTAINER level because it's not core-specific - for now we\n    // also register it here for back-compat\n    solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"core\");\n    infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to report metrics\n    if (directoryFactory instanceof SolrMetricProducer) {\n      ((SolrMetricProducer)directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"directoryFactory\");\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    this.coreContainer = coreContainer;\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    coreContainer.solrCores.addCoreDescriptor(cd);\n\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, null);\n\n    SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n    // this is registered at the CONTAINER level because it's not core-specific - for now we\n    // also register it here for back-compat\n    solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"core\");\n    infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to report metrics\n    if (directoryFactory instanceof SolrMetricProducer) {\n      ((SolrMetricProducer)directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"directoryFactory\");\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    this.coreContainer = coreContainer;\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    coreContainer.solrCores.addCoreDescriptor(cd);\n\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, null);\n\n    SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n    // this is registered at the CONTAINER level because it's not core-specific - for now we\n    // also register it here for back-compat\n    solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"core\");\n    infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to report metrics\n    if (directoryFactory instanceof SolrMetricProducer) {\n      ((SolrMetricProducer)directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"directoryFactory\");\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    this.coreContainer = coreContainer;\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    coreContainer.solrCores.addCoreDescriptor(cd);\n\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, null);\n\n    SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n    // this is registered at the CONTAINER level because it's not core-specific - for now we\n    // also register it here for back-compat\n    solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"core\");\n    infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to report metrics\n    if (directoryFactory instanceof SolrMetricProducer) {\n      ((SolrMetricProducer)directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"directoryFactory\");\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    this.coreContainer = coreContainer;\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    coreContainer.solrCores.addCoreDescriptor(cd);\n\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, null);\n\n    SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n    // this is registered at the CONTAINER level because it's not core-specific - for now we\n    // also register it here for back-compat\n    solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"core\");\n    infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to report metrics\n    if (directoryFactory instanceof SolrMetricProducer) {\n      ((SolrMetricProducer)directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"directoryFactory\");\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    this.coreContainer = coreContainer;\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    coreContainer.solrCores.addCoreDescriptor(cd);\n\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, null);\n\n    SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n    // this is registered at the CONTAINER level because it's not core-specific - for now we\n    // also register it here for back-compat\n    solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"core\");\n    infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to report metrics\n    if (directoryFactory instanceof SolrMetricProducer) {\n      ((SolrMetricProducer)directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"directoryFactory\");\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    this.coreContainer = coreContainer;\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    coreContainer.solrCores.addCoreDescriptor(cd);\n\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, null);\n\n    SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n    // this is registered at the CONTAINER level because it's not core-specific - for now we\n    // also register it here for back-compat\n    solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"core\");\n    infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n   \n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(),\n            metricTag, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    this.coreContainer = coreContainer;\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    coreContainer.solrCores.addCoreDescriptor(cd);\n\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, null);\n\n    SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n    // this is registered at the CONTAINER level because it's not core-specific - for now we\n    // also register it here for back-compat\n    solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"core\");\n    infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to report metrics\n    if (directoryFactory instanceof SolrMetricProducer) {\n      ((SolrMetricProducer)directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"directoryFactory\");\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":["311a0c9037fb7a2baefb9e262121d8f866e1c56f","da888af1ab894358122a22229051215f58cf4d54","bfc52860e6d13d034226a760813c59d984c6817a","3e13696c44d3e2405098726359ab81dab178e7bc","b5a70f7ff0756e3668447bffbbf8bce8e7c361b9","54bb8da55080e4569804e0661b83a3c72cbd8d4d","7a71a0b2d4be2299a163f60626729852d81a8e02","7da173d341edb3a56705e0ee852574c69d83aa6f","877f1e09b9299ce0757f4d83768da944803baf04","816521ebaad5add9cb96bb88c577394e2938c40b","9aea0485ecacb6734c17da2d02569816c23a69c1"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dff274f347ef702a3c44718e8801230a478a8f73","date":1544662146,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n      MDCLoggingContext.setCore(this);\n\n      resourceLoader = config.getResourceLoader();\n      this.solrConfig = config;\n      this.configSetProperties = configSetProperties;\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(config);\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(),\n          this.dataDir);\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n      SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n      // initialize searcher-related metrics\n      initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      initSchema(config, schema);\n\n      this.maxWarmingSearchers = config.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(),\n            metricTag, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    this.coreContainer = coreContainer;\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    coreContainer.solrCores.addCoreDescriptor(cd);\n\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, null);\n\n    SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n    // this is registered at the CONTAINER level because it's not core-specific - for now we\n    // also register it here for back-compat\n    solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"core\");\n    infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n   \n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(),\n            metricTag, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"627e70d5711ab39d080a080f089685268525f54d","date":1560754171,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n      MDCLoggingContext.setCore(this);\n\n      resourceLoader = config.getResourceLoader();\n      this.solrConfig = config;\n      this.configSetProperties = configSetProperties;\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(config);\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(),\n          this.dataDir);\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n      SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n      // initialize searcher-related metrics\n      initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      initSchema(config, schema);\n\n      this.maxWarmingSearchers = config.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(),\n            metricTag, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n      MDCLoggingContext.setCore(this);\n\n      resourceLoader = config.getResourceLoader();\n      this.solrConfig = config;\n      this.configSetProperties = configSetProperties;\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(config);\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(),\n          this.dataDir);\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n      SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n      // initialize searcher-related metrics\n      initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      initSchema(config, schema);\n\n      this.maxWarmingSearchers = config.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(),\n            metricTag, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2668c99990e4c94a78bac005aa682b7c5986d23a","date":1561446137,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir the index directory\n   * @param config  a solr config instance\n   * @param schema  a solr schema instance\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n      MDCLoggingContext.setCore(this);\n\n      resourceLoader = config.getResourceLoader();\n      this.solrConfig = config;\n      this.configSetProperties = configSetProperties;\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(config);\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(),\n          this.dataDir);\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n      SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n      // initialize searcher-related metrics\n      initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      initSchema(config, schema);\n\n      this.maxWarmingSearchers = config.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(),\n            metricTag, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n      MDCLoggingContext.setCore(this);\n\n      resourceLoader = config.getResourceLoader();\n      this.solrConfig = config;\n      this.configSetProperties = configSetProperties;\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(config);\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(),\n          this.dataDir);\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n      SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n      // initialize searcher-related metrics\n      initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      initSchema(config, schema);\n\n      this.maxWarmingSearchers = config.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(),\n            metricTag, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fb50877dc038c021eba3a70999fd1f6ed85001c1","date":1563596432,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir the index directory\n   * @param config  a solr config instance\n   * @param schema  a solr schema instance\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n      MDCLoggingContext.setCore(this);\n\n      resourceLoader = config.getResourceLoader();\n      this.solrConfig = config;\n      this.configSetProperties = configSetProperties;\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(config);\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(),\n          this.dataDir);\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n      SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n      // initialize searcher-related metrics\n      initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      initSchema(config, schema);\n\n      this.maxWarmingSearchers = config.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(),\n            metricTag, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir the index directory\n   * @param config  a solr config instance\n   * @param schema  a solr schema instance\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n      MDCLoggingContext.setCore(this);\n\n      resourceLoader = config.getResourceLoader();\n      this.solrConfig = config;\n      this.configSetProperties = configSetProperties;\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(config);\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(),\n          this.dataDir);\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n      SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n      // initialize searcher-related metrics\n      initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      initSchema(config, schema);\n\n      this.maxWarmingSearchers = config.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(),\n            metricTag, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c44cc06c26e456fe9c215072b79fce30babe3975","date":1570365040,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir the index directory\n   * @param config  a solr config instance\n   * @param schema  a solr schema instance\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n      MDCLoggingContext.setCore(this);\n\n      resourceLoader = config.getResourceLoader();\n      this.solrConfig = config;\n      this.configSetProperties = configSetProperties;\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(config);\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(),\n          this.dataDir);\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n      SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n      // initialize searcher-related metrics\n      initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      initSchema(config, schema);\n\n      this.maxWarmingSearchers = config.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(),\n            metricTag, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir the index directory\n   * @param config  a solr config instance\n   * @param schema  a solr schema instance\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n      MDCLoggingContext.setCore(this);\n\n      resourceLoader = config.getResourceLoader();\n      this.solrConfig = config;\n      this.configSetProperties = configSetProperties;\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(config);\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(),\n          this.dataDir);\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n      SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n      // initialize searcher-related metrics\n      initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      initSchema(config, schema);\n\n      this.maxWarmingSearchers = config.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(),\n            metricTag, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"df72a23fb74bebe914e3f3972063a884327c0436","date":1570470832,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir the index directory\n   * @param config  a solr config instance\n   * @param schema  a solr schema instance\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n      MDCLoggingContext.setCore(this);\n\n      resourceLoader = config.getResourceLoader();\n      this.solrConfig = config;\n      this.configSetProperties = configSetProperties;\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(config);\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(),\n          this.dataDir);\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n      SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n      // initialize searcher-related metrics\n      initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      initSchema(config, schema);\n\n      this.maxWarmingSearchers = config.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(),\n            metricTag, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir the index directory\n   * @param config  a solr config instance\n   * @param schema  a solr schema instance\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n      MDCLoggingContext.setCore(this);\n\n      resourceLoader = config.getResourceLoader();\n      this.solrConfig = config;\n      this.configSetProperties = configSetProperties;\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(config);\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(),\n          this.dataDir);\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n      SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n      // initialize searcher-related metrics\n      initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      initSchema(config, schema);\n\n      this.maxWarmingSearchers = config.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(),\n            metricTag, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":["a94e45463a0089149b0d148ae5369140e7f54b8c","9aea0485ecacb6734c17da2d02569816c23a69c1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir the index directory\n   * @param config  a solr config instance\n   * @param schema  a solr schema instance\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n      MDCLoggingContext.setCore(this);\n\n      resourceLoader = config.getResourceLoader();\n      this.solrConfig = config;\n      this.configSetProperties = configSetProperties;\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(config);\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(),\n          this.dataDir);\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n      SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n      // initialize searcher-related metrics\n      initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      initSchema(config, schema);\n\n      this.maxWarmingSearchers = config.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(),\n            metricTag, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir the index directory\n   * @param config  a solr config instance\n   * @param schema  a solr schema instance\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n      MDCLoggingContext.setCore(this);\n\n      resourceLoader = config.getResourceLoader();\n      this.solrConfig = config;\n      this.configSetProperties = configSetProperties;\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(config);\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(),\n          this.dataDir);\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n      SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n      // initialize searcher-related metrics\n      initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      initSchema(config, schema);\n\n      this.maxWarmingSearchers = config.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(),\n            metricTag, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c959a64c5b52cc12eb8daa17f4f0ed9cf2dfcaaa","date":1571411704,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir the index directory\n   * @param config  a solr config instance\n   * @param schema  a solr schema instance\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n      MDCLoggingContext.setCore(this);\n\n      resourceLoader = config.getResourceLoader();\n      this.solrConfig = config;\n      this.configSetProperties = configSetProperties;\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(config);\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(),\n          this.dataDir);\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n      // initialize searcher-related metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      initSchema(config, schema);\n\n      this.maxWarmingSearchers = config.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        // XXX use deprecated method for back-compat, remove in 9.0\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(\n            solrMetricsContext.metricManager, solrMetricsContext.registry, solrMetricsContext.tag, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir the index directory\n   * @param config  a solr config instance\n   * @param schema  a solr schema instance\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n      MDCLoggingContext.setCore(this);\n\n      resourceLoader = config.getResourceLoader();\n      this.solrConfig = config;\n      this.configSetProperties = configSetProperties;\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(config);\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(),\n          this.dataDir);\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n      SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n      // initialize searcher-related metrics\n      initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), metricTag, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      initSchema(config, schema);\n\n      this.maxWarmingSearchers = config.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(),\n            metricTag, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e9e5eaf280a6aa21423126b8232aa157a9b7366","date":1571772228,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir the index directory\n   * @param config  a solr config instance\n   * @param schema  a solr schema instance\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n      MDCLoggingContext.setCore(this);\n\n      resourceLoader = config.getResourceLoader();\n      this.solrConfig = config;\n      this.configSetProperties = configSetProperties;\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(config);\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(),\n          this.dataDir);\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n      // initialize searcher-related metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      initSchema(config, schema);\n\n      this.maxWarmingSearchers = config.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir the index directory\n   * @param config  a solr config instance\n   * @param schema  a solr schema instance\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n      MDCLoggingContext.setCore(this);\n\n      resourceLoader = config.getResourceLoader();\n      this.solrConfig = config;\n      this.configSetProperties = configSetProperties;\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(config);\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(),\n          this.dataDir);\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n      // initialize searcher-related metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      initSchema(config, schema);\n\n      this.maxWarmingSearchers = config.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        // XXX use deprecated method for back-compat, remove in 9.0\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(\n            solrMetricsContext.metricManager, solrMetricsContext.registry, solrMetricsContext.tag, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c2af5a711bd6e2d33e0221ced0f47ac596ed275","date":1572877903,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir the index directory\n   * @param config  a solr config instance\n   * @param schema  a solr schema instance\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n      MDCLoggingContext.setCore(this);\n\n      resourceLoader = config.getResourceLoader();\n      this.solrConfig = config;\n      this.configSetProperties = configSetProperties;\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(config);\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(),\n          this.dataDir);\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      initSchema(config, schema);\n\n      this.maxWarmingSearchers = config.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir the index directory\n   * @param config  a solr config instance\n   * @param schema  a solr schema instance\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n      MDCLoggingContext.setCore(this);\n\n      resourceLoader = config.getResourceLoader();\n      this.solrConfig = config;\n      this.configSetProperties = configSetProperties;\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(config);\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(),\n          this.dataDir);\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n      // initialize searcher-related metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      initSchema(config, schema);\n\n      this.maxWarmingSearchers = config.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3","date":1583932828,"type":5,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,ConfigSet,CoreDescriptor,String,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   */\n  private SolrCore(CoreContainer coreContainer, String name, ConfigSet configSet, CoreDescriptor coreDescriptor,\n                  String dataDir, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      IndexSchema schema = configSet.getIndexSchema();\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n      MDCLoggingContext.setCore(this);\n\n      this.solrConfig = configSet.getSolrConfig();\n      this.resourceLoader = configSet.getSolrConfig().getResourceLoader();\n      this.configSetProperties = configSet.getProperties();\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(solrConfig);\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, solrConfig, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, getInstancePath(), this.dataDir);\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n      setLatestSchema(schema);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      this.maxWarmingSearchers = solrConfig.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = solrConfig.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir the index directory\n   * @param config  a solr config instance\n   * @param schema  a solr schema instance\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n      MDCLoggingContext.setCore(this);\n\n      resourceLoader = config.getResourceLoader();\n      this.solrConfig = config;\n      this.configSetProperties = configSetProperties;\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(config);\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(),\n          this.dataDir);\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      initSchema(config, schema);\n\n      this.maxWarmingSearchers = config.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"96e0d4494fe54b31c7f0151f3a632124ab806351":["28288370235ed02234a64753cdbf0c6ec096304a"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["bf6d72d9a6aa495633b49f3d36910c508b8ccf77"],"39fdbc59d893f5a211736e861fe145798a40b9ff":["729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"c44cc06c26e456fe9c215072b79fce30babe3975":["fb50877dc038c021eba3a70999fd1f6ed85001c1"],"dff274f347ef702a3c44718e8801230a478a8f73":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3":["7c2af5a711bd6e2d33e0221ced0f47ac596ed275"],"2668c99990e4c94a78bac005aa682b7c5986d23a":["627e70d5711ab39d080a080f089685268525f54d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["43564cbb30b064675027cfb569564e8531096e97","bf6d72d9a6aa495633b49f3d36910c508b8ccf77"],"627e70d5711ab39d080a080f089685268525f54d":["dff274f347ef702a3c44718e8801230a478a8f73"],"bf6d72d9a6aa495633b49f3d36910c508b8ccf77":["43564cbb30b064675027cfb569564e8531096e97"],"c959a64c5b52cc12eb8daa17f4f0ed9cf2dfcaaa":["df72a23fb74bebe914e3f3972063a884327c0436"],"43564cbb30b064675027cfb569564e8531096e97":["96e0d4494fe54b31c7f0151f3a632124ab806351","bfc52860e6d13d034226a760813c59d984c6817a"],"2e9e5eaf280a6aa21423126b8232aa157a9b7366":["c959a64c5b52cc12eb8daa17f4f0ed9cf2dfcaaa"],"df72a23fb74bebe914e3f3972063a884327c0436":["c44cc06c26e456fe9c215072b79fce30babe3975"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","39fdbc59d893f5a211736e861fe145798a40b9ff"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"28288370235ed02234a64753cdbf0c6ec096304a":["729cb470f975115d4c60517b2cb7c42e37a7a2e1","39fdbc59d893f5a211736e861fe145798a40b9ff"],"bfc52860e6d13d034226a760813c59d984c6817a":["96e0d4494fe54b31c7f0151f3a632124ab806351"],"7c2af5a711bd6e2d33e0221ced0f47ac596ed275":["2e9e5eaf280a6aa21423126b8232aa157a9b7366"],"fb50877dc038c021eba3a70999fd1f6ed85001c1":["2668c99990e4c94a78bac005aa682b7c5986d23a"],"f592209545c71895260367152601e9200399776d":["43564cbb30b064675027cfb569564e8531096e97","bf6d72d9a6aa495633b49f3d36910c508b8ccf77"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3"],"b0b597c65628ca9e73913a07e81691f8229bae35":["fb50877dc038c021eba3a70999fd1f6ed85001c1","df72a23fb74bebe914e3f3972063a884327c0436"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1"],"96e0d4494fe54b31c7f0151f3a632124ab806351":["43564cbb30b064675027cfb569564e8531096e97","bfc52860e6d13d034226a760813c59d984c6817a"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["dff274f347ef702a3c44718e8801230a478a8f73"],"39fdbc59d893f5a211736e861fe145798a40b9ff":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"c44cc06c26e456fe9c215072b79fce30babe3975":["df72a23fb74bebe914e3f3972063a884327c0436"],"dff274f347ef702a3c44718e8801230a478a8f73":["627e70d5711ab39d080a080f089685268525f54d"],"ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2668c99990e4c94a78bac005aa682b7c5986d23a":["fb50877dc038c021eba3a70999fd1f6ed85001c1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"627e70d5711ab39d080a080f089685268525f54d":["2668c99990e4c94a78bac005aa682b7c5986d23a"],"bf6d72d9a6aa495633b49f3d36910c508b8ccf77":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d"],"43564cbb30b064675027cfb569564e8531096e97":["b70042a8a492f7054d480ccdd2be9796510d4327","bf6d72d9a6aa495633b49f3d36910c508b8ccf77","f592209545c71895260367152601e9200399776d"],"c959a64c5b52cc12eb8daa17f4f0ed9cf2dfcaaa":["2e9e5eaf280a6aa21423126b8232aa157a9b7366"],"2e9e5eaf280a6aa21423126b8232aa157a9b7366":["7c2af5a711bd6e2d33e0221ced0f47ac596ed275"],"df72a23fb74bebe914e3f3972063a884327c0436":["c959a64c5b52cc12eb8daa17f4f0ed9cf2dfcaaa","b0b597c65628ca9e73913a07e81691f8229bae35"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["96e0d4494fe54b31c7f0151f3a632124ab806351"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["39fdbc59d893f5a211736e861fe145798a40b9ff","28288370235ed02234a64753cdbf0c6ec096304a"],"bfc52860e6d13d034226a760813c59d984c6817a":["43564cbb30b064675027cfb569564e8531096e97"],"fb50877dc038c021eba3a70999fd1f6ed85001c1":["c44cc06c26e456fe9c215072b79fce30babe3975","b0b597c65628ca9e73913a07e81691f8229bae35"],"7c2af5a711bd6e2d33e0221ced0f47ac596ed275":["ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3"],"f592209545c71895260367152601e9200399776d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["b70042a8a492f7054d480ccdd2be9796510d4327","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}