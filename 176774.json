{"path":"solr/core/src/test/org/apache/solr/cloud/api/collections/AbstractCloudBackupRestoreTestCase#testRestoreFailure().mjava","commits":[{"id":"ab6131420a270c49b653c969cc1dbbaf7d1b36e7","date":1550697886,"type":0,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/AbstractCloudBackupRestoreTestCase#testRestoreFailure().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testRestoreFailure() throws Exception {\n    setTestSuffix(\"testfailure\");\n    replFactor = TestUtil.nextInt(random(), 1, 2);\n    numTlogReplicas = TestUtil.nextInt(random(), 0, 1);\n    numPullReplicas = TestUtil.nextInt(random(), 0, 1);\n\n    CollectionAdminRequest.Create create =\n        CollectionAdminRequest.createCollection(getCollectionName(), \"conf1\", NUM_SHARDS, replFactor, numTlogReplicas, numPullReplicas);\n\n    if (NUM_SHARDS * (replFactor + numTlogReplicas + numPullReplicas) > cluster.getJettySolrRunners().size()) {\n      create.setMaxShardsPerNode((int)Math.ceil(NUM_SHARDS * (replFactor + numTlogReplicas + numPullReplicas) / cluster.getJettySolrRunners().size())); //just to assert it survives the restoration\n    }\n\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.process(solrClient);\n\n    indexDocs(getCollectionName(), false);\n\n\n    String backupLocation = getBackupLocation();\n    String backupName = BACKUPNAME_PREFIX + testSuffix;\n\n    DocCollection backupCollection = solrClient.getZkStateReader().getClusterState().getCollection(getCollectionName());\n\n    log.info(\"Triggering Backup command\");\n\n    {\n      CollectionAdminRequest.Backup backup = CollectionAdminRequest.backupCollection(getCollectionName(), backupName)\n          .setLocation(backupLocation).setRepositoryName(getBackupRepoName());\n      assertEquals(0, backup.process(solrClient).getStatus());\n    }\n\n    log.info(\"Triggering Restore command\");\n\n    String restoreCollectionName = getCollectionName() + \"_restored\";\n\n    {\n      CollectionAdminRequest.Restore restore = CollectionAdminRequest.restoreCollection(restoreCollectionName, backupName)\n          .setLocation(backupLocation).setRepositoryName(getBackupRepoName());\n      if (backupCollection.getReplicas().size() > cluster.getJettySolrRunners().size()) {\n        // may need to increase maxShardsPerNode (e.g. if it was shard split, then now we need more)\n        restore.setMaxShardsPerNode((int)Math.ceil(backupCollection.getReplicas().size()/cluster.getJettySolrRunners().size()));\n      }\n\n      restore.setConfigName(\"confFaulty\");\n      assertEquals(RequestStatusState.FAILED, restore.processAndWait(solrClient, 30));\n      assertThat(\"Failed collection is still in the clusterstate: \" + cluster.getSolrClient().getClusterStateProvider().getClusterState().getCollectionOrNull(restoreCollectionName), \n          CollectionAdminRequest.listCollections(solrClient), not(hasItem(restoreCollectionName)));\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/AbstractCloudBackupRestoreTestCase#testRestoreFailure().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/AbstractCloudBackupRestoreTestCase#testRestoreFailure().mjava","sourceNew":"  @Test\n  public void testRestoreFailure() throws Exception {\n    setTestSuffix(\"testfailure\");\n    replFactor = TestUtil.nextInt(random(), 1, 2);\n    numTlogReplicas = TestUtil.nextInt(random(), 0, 1);\n    numPullReplicas = TestUtil.nextInt(random(), 0, 1);\n\n    CollectionAdminRequest.Create create =\n        CollectionAdminRequest.createCollection(getCollectionName(), \"conf1\", NUM_SHARDS, replFactor, numTlogReplicas, numPullReplicas);\n\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.process(solrClient);\n\n    indexDocs(getCollectionName(), false);\n\n\n    String backupLocation = getBackupLocation();\n    String backupName = BACKUPNAME_PREFIX + testSuffix;\n\n    DocCollection backupCollection = solrClient.getZkStateReader().getClusterState().getCollection(getCollectionName());\n\n    log.info(\"Triggering Backup command\");\n\n    {\n      CollectionAdminRequest.Backup backup = CollectionAdminRequest.backupCollection(getCollectionName(), backupName)\n          .setLocation(backupLocation).setRepositoryName(getBackupRepoName());\n      assertEquals(0, backup.process(solrClient).getStatus());\n    }\n\n    log.info(\"Triggering Restore command\");\n\n    String restoreCollectionName = getCollectionName() + \"_restored\";\n\n    {\n      CollectionAdminRequest.Restore restore = CollectionAdminRequest.restoreCollection(restoreCollectionName, backupName)\n          .setLocation(backupLocation).setRepositoryName(getBackupRepoName());\n\n      restore.setConfigName(\"confFaulty\");\n      assertEquals(RequestStatusState.FAILED, restore.processAndWait(solrClient, 30));\n      assertThat(\"Failed collection is still in the clusterstate: \" + cluster.getSolrClient().getClusterStateProvider().getClusterState().getCollectionOrNull(restoreCollectionName), \n          CollectionAdminRequest.listCollections(solrClient), not(hasItem(restoreCollectionName)));\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testRestoreFailure() throws Exception {\n    setTestSuffix(\"testfailure\");\n    replFactor = TestUtil.nextInt(random(), 1, 2);\n    numTlogReplicas = TestUtil.nextInt(random(), 0, 1);\n    numPullReplicas = TestUtil.nextInt(random(), 0, 1);\n\n    CollectionAdminRequest.Create create =\n        CollectionAdminRequest.createCollection(getCollectionName(), \"conf1\", NUM_SHARDS, replFactor, numTlogReplicas, numPullReplicas);\n\n    if (NUM_SHARDS * (replFactor + numTlogReplicas + numPullReplicas) > cluster.getJettySolrRunners().size()) {\n      create.setMaxShardsPerNode((int)Math.ceil(NUM_SHARDS * (replFactor + numTlogReplicas + numPullReplicas) / cluster.getJettySolrRunners().size())); //just to assert it survives the restoration\n    }\n\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    create.process(solrClient);\n\n    indexDocs(getCollectionName(), false);\n\n\n    String backupLocation = getBackupLocation();\n    String backupName = BACKUPNAME_PREFIX + testSuffix;\n\n    DocCollection backupCollection = solrClient.getZkStateReader().getClusterState().getCollection(getCollectionName());\n\n    log.info(\"Triggering Backup command\");\n\n    {\n      CollectionAdminRequest.Backup backup = CollectionAdminRequest.backupCollection(getCollectionName(), backupName)\n          .setLocation(backupLocation).setRepositoryName(getBackupRepoName());\n      assertEquals(0, backup.process(solrClient).getStatus());\n    }\n\n    log.info(\"Triggering Restore command\");\n\n    String restoreCollectionName = getCollectionName() + \"_restored\";\n\n    {\n      CollectionAdminRequest.Restore restore = CollectionAdminRequest.restoreCollection(restoreCollectionName, backupName)\n          .setLocation(backupLocation).setRepositoryName(getBackupRepoName());\n      if (backupCollection.getReplicas().size() > cluster.getJettySolrRunners().size()) {\n        // may need to increase maxShardsPerNode (e.g. if it was shard split, then now we need more)\n        restore.setMaxShardsPerNode((int)Math.ceil(backupCollection.getReplicas().size()/cluster.getJettySolrRunners().size()));\n      }\n\n      restore.setConfigName(\"confFaulty\");\n      assertEquals(RequestStatusState.FAILED, restore.processAndWait(solrClient, 30));\n      assertThat(\"Failed collection is still in the clusterstate: \" + cluster.getSolrClient().getClusterStateProvider().getClusterState().getCollectionOrNull(restoreCollectionName), \n          CollectionAdminRequest.listCollections(solrClient), not(hasItem(restoreCollectionName)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ab6131420a270c49b653c969cc1dbbaf7d1b36e7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["ab6131420a270c49b653c969cc1dbbaf7d1b36e7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"]},"commit2Childs":{"ab6131420a270c49b653c969cc1dbbaf7d1b36e7":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ab6131420a270c49b653c969cc1dbbaf7d1b36e7"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}