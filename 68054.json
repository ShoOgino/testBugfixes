{"path":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByArray#findTopSlots().mjava","commits":[{"id":"79759974460bc59933cd169acc94f5c6b16368d5","date":1471318443,"type":1,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByArray#findTopSlots().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorFCBase[FacetField]#findTopSlots().mjava","sourceNew":"  private SimpleOrderedMap<Object> findTopSlots() throws IOException {\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList<>(100);\n    }\n\n    int off = fcontext.isShard() ? 0 : (int) freq.offset;\n    // add a modest amount of over-request if this is a shard request\n    int lim = freq.limit >= 0 ? (fcontext.isShard() ? (int)(freq.limit*1.1+4) : (int)freq.limit) : Integer.MAX_VALUE;\n\n    int maxsize = (int)(freq.limit >= 0 ?  freq.offset + lim : Integer.MAX_VALUE - 1);\n    maxsize = Math.min(maxsize, nTerms);\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n    final SlotAcc sortAcc = this.sortAcc;\n\n    PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxsize) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      }\n    };\n\n    Slot bottom = null;\n    for (int i = 0; i < nTerms; i++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(i) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        int ord = startTermIndex + i;\n        BytesRef br = lookupOrd(ord);\n        Object val = sf.getType().toObject(sf, br);\n        bucketVals.add(val);\n      }\n\n      if (bottom != null) {\n        if (sortAcc.compare(bottom.slot, i) * sortMul < 0) {\n          bottom.slot = i;\n          bottom = queue.updateTop();\n        }\n      } else if (lim > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = i;\n        queue.add(s);\n        if (queue.size() >= maxsize) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap<Object> map = new SimpleOrderedMap<>(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= lim;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      if (allBucketsAcc != null) {\n        allBucketsAcc.setValues(allBuckets, allBucketsSlot);\n      }\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    ArrayList<SimpleOrderedMap<Object>> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    // TODO: do this with a callback instead?\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n\n      // get the ord of the slot...\n      int ord = startTermIndex + slotNum;\n\n      BytesRef br = lookupOrd(ord);\n      Object val = sf.getType().toObject(sf, br);\n\n      bucket.add(\"val\", val);\n\n      TermQuery filter = needFilter ? new TermQuery(new Term(sf.getName(), br)) : null;\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    if (freq.missing) {\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  protected SimpleOrderedMap<Object> findTopSlots() throws IOException {\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList(100);\n    }\n\n    int off = fcontext.isShard() ? 0 : (int) freq.offset;\n    // add a modest amount of over-request if this is a shard request\n    int lim = freq.limit >= 0 ? (fcontext.isShard() ? (int)(freq.limit*1.1+4) : (int)freq.limit) : Integer.MAX_VALUE;\n\n    int maxsize = (int)(freq.limit >= 0 ?  freq.offset + lim : Integer.MAX_VALUE - 1);\n    maxsize = Math.min(maxsize, nTerms);\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n    final SlotAcc sortAcc = this.sortAcc;\n\n    PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxsize) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      }\n    };\n\n    Slot bottom = null;\n    for (int i = 0; i < nTerms; i++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(i) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        int ord = startTermIndex + i;\n        BytesRef br = lookupOrd(ord);\n        Object val = sf.getType().toObject(sf, br);\n        bucketVals.add(val);\n      }\n\n\n      if (bottom != null) {\n        if (sortAcc.compare(bottom.slot, i) * sortMul < 0) {\n          bottom.slot = i;\n          bottom = queue.updateTop();\n        }\n      } else if (lim > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = i;\n        queue.add(s);\n        if (queue.size() >= maxsize) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap map = new SimpleOrderedMap(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", new Long(numBuckets));\n    \n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= lim;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      if (allBucketsAcc != null) {\n        allBucketsAcc.setValues(allBuckets, allBucketsSlot);\n      }\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    ArrayList bucketList = new ArrayList(collectCount);\n    res.add(\"buckets\", bucketList);\n\n\n    // TODO: do this with a callback instead?\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n\n      // get the ord of the slot...\n      int ord = startTermIndex + slotNum;\n\n      BytesRef br = lookupOrd(ord);\n      Object val = sf.getType().toObject(sf, br);\n\n      bucket.add(\"val\", val);\n\n      TermQuery filter = needFilter ? new TermQuery(new Term(sf.getName(), br)) : null;\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    if (freq.missing) {\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6","date":1471496851,"type":1,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByArray#findTopSlots().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorFCBase[FacetField]#findTopSlots().mjava","sourceNew":"  private SimpleOrderedMap<Object> findTopSlots() throws IOException {\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList<>(100);\n    }\n\n    int off = fcontext.isShard() ? 0 : (int) freq.offset;\n    // add a modest amount of over-request if this is a shard request\n    int lim = freq.limit >= 0 ? (fcontext.isShard() ? (int)(freq.limit*1.1+4) : (int)freq.limit) : Integer.MAX_VALUE;\n\n    int maxsize = (int)(freq.limit >= 0 ?  freq.offset + lim : Integer.MAX_VALUE - 1);\n    maxsize = Math.min(maxsize, nTerms);\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n    final SlotAcc sortAcc = this.sortAcc;\n\n    PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxsize) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      }\n    };\n\n    Slot bottom = null;\n    for (int i = 0; i < nTerms; i++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(i) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        int ord = startTermIndex + i;\n        BytesRef br = lookupOrd(ord);\n        Object val = sf.getType().toObject(sf, br);\n        bucketVals.add(val);\n      }\n\n      if (bottom != null) {\n        if (sortAcc.compare(bottom.slot, i) * sortMul < 0) {\n          bottom.slot = i;\n          bottom = queue.updateTop();\n        }\n      } else if (lim > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = i;\n        queue.add(s);\n        if (queue.size() >= maxsize) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap<Object> map = new SimpleOrderedMap<>(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= lim;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      if (allBucketsAcc != null) {\n        allBucketsAcc.setValues(allBuckets, allBucketsSlot);\n      }\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    ArrayList<SimpleOrderedMap<Object>> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    // TODO: do this with a callback instead?\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n\n      // get the ord of the slot...\n      int ord = startTermIndex + slotNum;\n\n      BytesRef br = lookupOrd(ord);\n      Object val = sf.getType().toObject(sf, br);\n\n      bucket.add(\"val\", val);\n\n      TermQuery filter = needFilter ? new TermQuery(new Term(sf.getName(), br)) : null;\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    if (freq.missing) {\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  protected SimpleOrderedMap<Object> findTopSlots() throws IOException {\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList(100);\n    }\n\n    int off = fcontext.isShard() ? 0 : (int) freq.offset;\n    // add a modest amount of over-request if this is a shard request\n    int lim = freq.limit >= 0 ? (fcontext.isShard() ? (int)(freq.limit*1.1+4) : (int)freq.limit) : Integer.MAX_VALUE;\n\n    int maxsize = (int)(freq.limit >= 0 ?  freq.offset + lim : Integer.MAX_VALUE - 1);\n    maxsize = Math.min(maxsize, nTerms);\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n    final SlotAcc sortAcc = this.sortAcc;\n\n    PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxsize) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      }\n    };\n\n    Slot bottom = null;\n    for (int i = 0; i < nTerms; i++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(i) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        int ord = startTermIndex + i;\n        BytesRef br = lookupOrd(ord);\n        Object val = sf.getType().toObject(sf, br);\n        bucketVals.add(val);\n      }\n\n\n      if (bottom != null) {\n        if (sortAcc.compare(bottom.slot, i) * sortMul < 0) {\n          bottom.slot = i;\n          bottom = queue.updateTop();\n        }\n      } else if (lim > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = i;\n        queue.add(s);\n        if (queue.size() >= maxsize) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap map = new SimpleOrderedMap(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", new Long(numBuckets));\n    \n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= lim;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      if (allBucketsAcc != null) {\n        allBucketsAcc.setValues(allBuckets, allBucketsSlot);\n      }\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    ArrayList bucketList = new ArrayList(collectCount);\n    res.add(\"buckets\", bucketList);\n\n\n    // TODO: do this with a callback instead?\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n\n      // get the ord of the slot...\n      int ord = startTermIndex + slotNum;\n\n      BytesRef br = lookupOrd(ord);\n      Object val = sf.getType().toObject(sf, br);\n\n      bucket.add(\"val\", val);\n\n      TermQuery filter = needFilter ? new TermQuery(new Term(sf.getName(), br)) : null;\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    if (freq.missing) {\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"403d05f7f8d69b65659157eff1bc1d2717f04c66","date":1471692961,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByArray#findTopSlots().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorFCBase[FacetField]#findTopSlots().mjava","sourceNew":"  private SimpleOrderedMap<Object> findTopSlots() throws IOException {\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList<>(100);\n    }\n\n    int off = fcontext.isShard() ? 0 : (int) freq.offset;\n    // add a modest amount of over-request if this is a shard request\n    int lim = freq.limit >= 0 ? (fcontext.isShard() ? (int)(freq.limit*1.1+4) : (int)freq.limit) : Integer.MAX_VALUE;\n\n    int maxsize = (int)(freq.limit >= 0 ?  freq.offset + lim : Integer.MAX_VALUE - 1);\n    maxsize = Math.min(maxsize, nTerms);\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n    final SlotAcc sortAcc = this.sortAcc;\n\n    PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxsize) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      }\n    };\n\n    Slot bottom = null;\n    for (int i = 0; i < nTerms; i++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(i) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        int ord = startTermIndex + i;\n        BytesRef br = lookupOrd(ord);\n        Object val = sf.getType().toObject(sf, br);\n        bucketVals.add(val);\n      }\n\n      if (bottom != null) {\n        if (sortAcc.compare(bottom.slot, i) * sortMul < 0) {\n          bottom.slot = i;\n          bottom = queue.updateTop();\n        }\n      } else if (lim > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = i;\n        queue.add(s);\n        if (queue.size() >= maxsize) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap<Object> map = new SimpleOrderedMap<>(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= lim;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      if (allBucketsAcc != null) {\n        allBucketsAcc.setValues(allBuckets, allBucketsSlot);\n      }\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    ArrayList<SimpleOrderedMap<Object>> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    // TODO: do this with a callback instead?\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n\n      // get the ord of the slot...\n      int ord = startTermIndex + slotNum;\n\n      BytesRef br = lookupOrd(ord);\n      Object val = sf.getType().toObject(sf, br);\n\n      bucket.add(\"val\", val);\n\n      TermQuery filter = needFilter ? new TermQuery(new Term(sf.getName(), br)) : null;\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    if (freq.missing) {\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  protected SimpleOrderedMap<Object> findTopSlots() throws IOException {\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList(100);\n    }\n\n    int off = fcontext.isShard() ? 0 : (int) freq.offset;\n    // add a modest amount of over-request if this is a shard request\n    int lim = freq.limit >= 0 ? (fcontext.isShard() ? (int)(freq.limit*1.1+4) : (int)freq.limit) : Integer.MAX_VALUE;\n\n    int maxsize = (int)(freq.limit >= 0 ?  freq.offset + lim : Integer.MAX_VALUE - 1);\n    maxsize = Math.min(maxsize, nTerms);\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n    final SlotAcc sortAcc = this.sortAcc;\n\n    PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxsize) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      }\n    };\n\n    Slot bottom = null;\n    for (int i = 0; i < nTerms; i++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(i) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        int ord = startTermIndex + i;\n        BytesRef br = lookupOrd(ord);\n        Object val = sf.getType().toObject(sf, br);\n        bucketVals.add(val);\n      }\n\n\n      if (bottom != null) {\n        if (sortAcc.compare(bottom.slot, i) * sortMul < 0) {\n          bottom.slot = i;\n          bottom = queue.updateTop();\n        }\n      } else if (lim > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = i;\n        queue.add(s);\n        if (queue.size() >= maxsize) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap map = new SimpleOrderedMap(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", new Long(numBuckets));\n    \n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= lim;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      if (allBucketsAcc != null) {\n        allBucketsAcc.setValues(allBuckets, allBucketsSlot);\n      }\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    ArrayList bucketList = new ArrayList(collectCount);\n    res.add(\"buckets\", bucketList);\n\n\n    // TODO: do this with a callback instead?\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n\n      // get the ord of the slot...\n      int ord = startTermIndex + slotNum;\n\n      BytesRef br = lookupOrd(ord);\n      Object val = sf.getType().toObject(sf, br);\n\n      bucket.add(\"val\", val);\n\n      TermQuery filter = needFilter ? new TermQuery(new Term(sf.getName(), br)) : null;\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    if (freq.missing) {\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3661d6742eed69ff6cc30ea2538d572624a7cdf8","date":1472676864,"type":5,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByArray#findTopSlots().mjava","sourceNew":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList<>(100);\n    }\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n    // add a modest amount of over-request if this is a shard request\n    final int lim = freq.limit >= 0 ? (fcontext.isShard() ? (int)(freq.limit*1.1+4) : (int)freq.limit) : Integer.MAX_VALUE;\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (lim >= 0 ? (long) off + lim : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(slotNum) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        Object val = bucketValFromSlotNumFunc.apply(slotNum);\n        bucketVals.add(val);\n      }\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (lim > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap<Object> map = new SimpleOrderedMap<>(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= lim;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? sf.getType().getFieldQuery(null, sf, fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  private SimpleOrderedMap<Object> findTopSlots() throws IOException {\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList<>(100);\n    }\n\n    int off = fcontext.isShard() ? 0 : (int) freq.offset;\n    // add a modest amount of over-request if this is a shard request\n    int lim = freq.limit >= 0 ? (fcontext.isShard() ? (int)(freq.limit*1.1+4) : (int)freq.limit) : Integer.MAX_VALUE;\n\n    int maxsize = (int)(freq.limit >= 0 ?  freq.offset + lim : Integer.MAX_VALUE - 1);\n    maxsize = Math.min(maxsize, nTerms);\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n    final SlotAcc sortAcc = this.sortAcc;\n\n    PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxsize) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      }\n    };\n\n    Slot bottom = null;\n    for (int i = 0; i < nTerms; i++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(i) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        int ord = startTermIndex + i;\n        BytesRef br = lookupOrd(ord);\n        Object val = sf.getType().toObject(sf, br);\n        bucketVals.add(val);\n      }\n\n      if (bottom != null) {\n        if (sortAcc.compare(bottom.slot, i) * sortMul < 0) {\n          bottom.slot = i;\n          bottom = queue.updateTop();\n        }\n      } else if (lim > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = i;\n        queue.add(s);\n        if (queue.size() >= maxsize) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap<Object> map = new SimpleOrderedMap<>(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= lim;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      if (allBucketsAcc != null) {\n        allBucketsAcc.setValues(allBuckets, allBucketsSlot);\n      }\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    ArrayList<SimpleOrderedMap<Object>> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    // TODO: do this with a callback instead?\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n\n      // get the ord of the slot...\n      int ord = startTermIndex + slotNum;\n\n      BytesRef br = lookupOrd(ord);\n      Object val = sf.getType().toObject(sf, br);\n\n      bucket.add(\"val\", val);\n\n      TermQuery filter = needFilter ? new TermQuery(new Term(sf.getName(), br)) : null;\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    if (freq.missing) {\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":["1c841e27891873cab110ebeb89f124a8ec470176","1c841e27891873cab110ebeb89f124a8ec470176","055706edcc08dfbacd42d8ed4144209d3dc05b67","055706edcc08dfbacd42d8ed4144209d3dc05b67","b65e1e1139651e98138d35a941b15107427618e3","b65e1e1139651e98138d35a941b15107427618e3","7cb985c6555057b5e71cb07eb5862b9a7a65ca1d","7cb985c6555057b5e71cb07eb5862b9a7a65ca1d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bc8f206328a706450934717bec7ccc22ad166fc0","date":1473142172,"type":5,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByArray#findTopSlots().mjava","sourceNew":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList<>(100);\n    }\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n    // add a modest amount of over-request if this is a shard request\n    final int lim = freq.limit >= 0 ? (fcontext.isShard() ? (int)(freq.limit*1.1+4) : (int)freq.limit) : Integer.MAX_VALUE;\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (lim >= 0 ? (long) off + lim : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(slotNum) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        Object val = bucketValFromSlotNumFunc.apply(slotNum);\n        bucketVals.add(val);\n      }\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (lim > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap<Object> map = new SimpleOrderedMap<>(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= lim;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? sf.getType().getFieldQuery(null, sf, fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  private SimpleOrderedMap<Object> findTopSlots() throws IOException {\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList<>(100);\n    }\n\n    int off = fcontext.isShard() ? 0 : (int) freq.offset;\n    // add a modest amount of over-request if this is a shard request\n    int lim = freq.limit >= 0 ? (fcontext.isShard() ? (int)(freq.limit*1.1+4) : (int)freq.limit) : Integer.MAX_VALUE;\n\n    int maxsize = (int)(freq.limit >= 0 ?  freq.offset + lim : Integer.MAX_VALUE - 1);\n    maxsize = Math.min(maxsize, nTerms);\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n    final SlotAcc sortAcc = this.sortAcc;\n\n    PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxsize) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      }\n    };\n\n    Slot bottom = null;\n    for (int i = 0; i < nTerms; i++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(i) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        int ord = startTermIndex + i;\n        BytesRef br = lookupOrd(ord);\n        Object val = sf.getType().toObject(sf, br);\n        bucketVals.add(val);\n      }\n\n      if (bottom != null) {\n        if (sortAcc.compare(bottom.slot, i) * sortMul < 0) {\n          bottom.slot = i;\n          bottom = queue.updateTop();\n        }\n      } else if (lim > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = i;\n        queue.add(s);\n        if (queue.size() >= maxsize) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap<Object> map = new SimpleOrderedMap<>(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= lim;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      if (allBucketsAcc != null) {\n        allBucketsAcc.setValues(allBuckets, allBucketsSlot);\n      }\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    ArrayList<SimpleOrderedMap<Object>> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    // TODO: do this with a callback instead?\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n\n      // get the ord of the slot...\n      int ord = startTermIndex + slotNum;\n\n      BytesRef br = lookupOrd(ord);\n      Object val = sf.getType().toObject(sf, br);\n\n      bucket.add(\"val\", val);\n\n      TermQuery filter = needFilter ? new TermQuery(new Term(sf.getName(), br)) : null;\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    if (freq.missing) {\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":4,"author":"Karl Wright","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByArray#findTopSlots().mjava","sourceNew":null,"sourceOld":"  private SimpleOrderedMap<Object> findTopSlots() throws IOException {\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList<>(100);\n    }\n\n    int off = fcontext.isShard() ? 0 : (int) freq.offset;\n    // add a modest amount of over-request if this is a shard request\n    int lim = freq.limit >= 0 ? (fcontext.isShard() ? (int)(freq.limit*1.1+4) : (int)freq.limit) : Integer.MAX_VALUE;\n\n    int maxsize = (int)(freq.limit >= 0 ?  freq.offset + lim : Integer.MAX_VALUE - 1);\n    maxsize = Math.min(maxsize, nTerms);\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n    final SlotAcc sortAcc = this.sortAcc;\n\n    PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxsize) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      }\n    };\n\n    Slot bottom = null;\n    for (int i = 0; i < nTerms; i++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(i) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        int ord = startTermIndex + i;\n        BytesRef br = lookupOrd(ord);\n        Object val = sf.getType().toObject(sf, br);\n        bucketVals.add(val);\n      }\n\n      if (bottom != null) {\n        if (sortAcc.compare(bottom.slot, i) * sortMul < 0) {\n          bottom.slot = i;\n          bottom = queue.updateTop();\n        }\n      } else if (lim > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = i;\n        queue.add(s);\n        if (queue.size() >= maxsize) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap<Object> map = new SimpleOrderedMap<>(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= lim;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      if (allBucketsAcc != null) {\n        allBucketsAcc.setValues(allBuckets, allBucketsSlot);\n      }\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    ArrayList<SimpleOrderedMap<Object>> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    // TODO: do this with a callback instead?\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n\n      // get the ord of the slot...\n      int ord = startTermIndex + slotNum;\n\n      BytesRef br = lookupOrd(ord);\n      Object val = sf.getType().toObject(sf, br);\n\n      bucket.add(\"val\", val);\n\n      TermQuery filter = needFilter ? new TermQuery(new Term(sf.getName(), br)) : null;\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    if (freq.missing) {\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"403d05f7f8d69b65659157eff1bc1d2717f04c66":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c8bedceb91e64a3f0e831450058fc4a76d2c0a6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["403d05f7f8d69b65659157eff1bc1d2717f04c66","3661d6742eed69ff6cc30ea2538d572624a7cdf8"],"3661d6742eed69ff6cc30ea2538d572624a7cdf8":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","79759974460bc59933cd169acc94f5c6b16368d5"],"79759974460bc59933cd169acc94f5c6b16368d5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"bc8f206328a706450934717bec7ccc22ad166fc0":["403d05f7f8d69b65659157eff1bc1d2717f04c66","3661d6742eed69ff6cc30ea2538d572624a7cdf8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"]},"commit2Childs":{"403d05f7f8d69b65659157eff1bc1d2717f04c66":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","3661d6742eed69ff6cc30ea2538d572624a7cdf8","bc8f206328a706450934717bec7ccc22ad166fc0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["403d05f7f8d69b65659157eff1bc1d2717f04c66","2c8bedceb91e64a3f0e831450058fc4a76d2c0a6","79759974460bc59933cd169acc94f5c6b16368d5"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3661d6742eed69ff6cc30ea2538d572624a7cdf8":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","bc8f206328a706450934717bec7ccc22ad166fc0"],"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"79759974460bc59933cd169acc94f5c6b16368d5":["2c8bedceb91e64a3f0e831450058fc4a76d2c0a6"],"bc8f206328a706450934717bec7ccc22ad166fc0":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["bc8f206328a706450934717bec7ccc22ad166fc0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}