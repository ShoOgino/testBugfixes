{"path":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#replaceSep(Automaton).mjava","commits":[{"id":"6ce825e9276493231308229152c48f755ce1a0a5","date":1348871483,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#replaceSep(Automaton).mjava","pathOld":"/dev/null","sourceNew":"  // Replaces SEP with epsilon or remaps them if\n  // we were asked to preserve them:\n  private void replaceSep(Automaton a) {\n\n    State[] states = a.getNumberedStates();\n\n    // Go in reverse topo sort so we know we only have to\n    // make one pass:\n    for(int stateNumber=states.length-1;stateNumber >=0;stateNumber--) {\n      final State state = states[stateNumber];\n      List<Transition> newTransitions = new ArrayList<Transition>();\n      for(Transition t : state.getTransitions()) {\n        assert t.getMin() == t.getMax();\n        if (t.getMin() == TokenStreamToAutomaton.POS_SEP) {\n          if (preserveSep) {\n            // Remap to SEP_LABEL:\n            t = new Transition(SEP_LABEL, t.getDest());\n          } else {\n            // NOTE: sort of weird because this will grow\n            // the transition array we are iterating over,\n            // but because we are going in reverse topo sort\n            // it will not add any SEP/HOLE transitions:\n            state.addEpsilon(t.getDest());\n            t = null;\n          }\n        } else if (t.getMin() == TokenStreamToAutomaton.HOLE) {\n\n          // Just remove the hole: there will then be two\n          // SEP tokens next to each other, which will only\n          // match another hole at search time.  Note that\n          // it will also match an empty-string token ... if\n          // that's somehow a problem we can always map HOLE\n          // to a dedicated byte (and escape it in the\n          // input).\n\n          // NOTE: sort of weird because this will grow\n          // the transition array we are iterating over,\n          // but because we are going in reverse topo sort\n          // it will not add any SEP/HOLE transitions:\n          state.addEpsilon(t.getDest());\n          t = null;\n        }\n        if (t != null) {\n          newTransitions.add(t);\n        }\n      }\n      state.resetTransitions();\n      state.setTransitions(newTransitions.toArray(new Transition[newTransitions.size()]));\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"65621ac5927a7c2f23e9cd59b09f56addd5ed2bf","date":1348876189,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#replaceSep(Automaton).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#replaceSep(Automaton).mjava","sourceNew":"  // Replaces SEP with epsilon or remaps them if\n  // we were asked to preserve them:\n  private void replaceSep(Automaton a) {\n\n    State[] states = a.getNumberedStates();\n\n    // Go in reverse topo sort so we know we only have to\n    // make one pass:\n    for(int stateNumber=states.length-1;stateNumber >=0;stateNumber--) {\n      final State state = states[stateNumber];\n      List<Transition> newTransitions = new ArrayList<Transition>();\n      for(Transition t : state.getTransitions()) {\n        assert t.getMin() == t.getMax();\n        if (t.getMin() == TokenStreamToAutomaton.POS_SEP) {\n          if (preserveSep) {\n            // Remap to SEP_LABEL:\n            t = new Transition(SEP_LABEL, t.getDest());\n          } else {\n            // NOTE: sort of weird because this will grow\n            // the transition array we are iterating over,\n            // but because we are going in reverse topo sort\n            // it will not add any SEP/HOLE transitions:\n            state.addEpsilon(t.getDest());\n            a.setDeterministic(false);\n            t = null;\n          }\n        } else if (t.getMin() == TokenStreamToAutomaton.HOLE) {\n\n          // Just remove the hole: there will then be two\n          // SEP tokens next to each other, which will only\n          // match another hole at search time.  Note that\n          // it will also match an empty-string token ... if\n          // that's somehow a problem we can always map HOLE\n          // to a dedicated byte (and escape it in the\n          // input).\n\n          // NOTE: sort of weird because this will grow\n          // the transition array we are iterating over,\n          // but because we are going in reverse topo sort\n          // it will not add any SEP/HOLE transitions:\n          state.addEpsilon(t.getDest());\n          a.setDeterministic(false);\n          t = null;\n        }\n        if (t != null) {\n          newTransitions.add(t);\n        }\n      }\n      state.resetTransitions();\n      state.setTransitions(newTransitions.toArray(new Transition[newTransitions.size()]));\n    }\n  }\n\n","sourceOld":"  // Replaces SEP with epsilon or remaps them if\n  // we were asked to preserve them:\n  private void replaceSep(Automaton a) {\n\n    State[] states = a.getNumberedStates();\n\n    // Go in reverse topo sort so we know we only have to\n    // make one pass:\n    for(int stateNumber=states.length-1;stateNumber >=0;stateNumber--) {\n      final State state = states[stateNumber];\n      List<Transition> newTransitions = new ArrayList<Transition>();\n      for(Transition t : state.getTransitions()) {\n        assert t.getMin() == t.getMax();\n        if (t.getMin() == TokenStreamToAutomaton.POS_SEP) {\n          if (preserveSep) {\n            // Remap to SEP_LABEL:\n            t = new Transition(SEP_LABEL, t.getDest());\n          } else {\n            // NOTE: sort of weird because this will grow\n            // the transition array we are iterating over,\n            // but because we are going in reverse topo sort\n            // it will not add any SEP/HOLE transitions:\n            state.addEpsilon(t.getDest());\n            t = null;\n          }\n        } else if (t.getMin() == TokenStreamToAutomaton.HOLE) {\n\n          // Just remove the hole: there will then be two\n          // SEP tokens next to each other, which will only\n          // match another hole at search time.  Note that\n          // it will also match an empty-string token ... if\n          // that's somehow a problem we can always map HOLE\n          // to a dedicated byte (and escape it in the\n          // input).\n\n          // NOTE: sort of weird because this will grow\n          // the transition array we are iterating over,\n          // but because we are going in reverse topo sort\n          // it will not add any SEP/HOLE transitions:\n          state.addEpsilon(t.getDest());\n          t = null;\n        }\n        if (t != null) {\n          newTransitions.add(t);\n        }\n      }\n      state.resetTransitions();\n      state.setTransitions(newTransitions.toArray(new Transition[newTransitions.size()]));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5cc37084489c2a7ca417a147a21ba3a24e1c3e8b","date":1348877743,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#replaceSep(Automaton).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#replaceSep(Automaton).mjava","sourceNew":"  // Replaces SEP with epsilon or remaps them if\n  // we were asked to preserve them:\n  private void replaceSep(Automaton a) {\n\n    State[] states = a.getNumberedStates();\n\n    // Go in reverse topo sort so we know we only have to\n    // make one pass:\n    for(int stateNumber=states.length-1;stateNumber >=0;stateNumber--) {\n      final State state = states[stateNumber];\n      List<Transition> newTransitions = new ArrayList<Transition>();\n      for(Transition t : state.getTransitions()) {\n        assert t.getMin() == t.getMax();\n        if (t.getMin() == TokenStreamToAutomaton.POS_SEP) {\n          if (preserveSep) {\n            // Remap to SEP_LABEL:\n            newTransitions.add(new Transition(SEP_LABEL, t.getDest()));\n          } else {\n            copyDestTransitions(state, t.getDest(), newTransitions);\n            a.setDeterministic(false);\n          }\n        } else if (t.getMin() == TokenStreamToAutomaton.HOLE) {\n\n          // Just remove the hole: there will then be two\n          // SEP tokens next to each other, which will only\n          // match another hole at search time.  Note that\n          // it will also match an empty-string token ... if\n          // that's somehow a problem we can always map HOLE\n          // to a dedicated byte (and escape it in the\n          // input).\n          copyDestTransitions(state, t.getDest(), newTransitions);\n          a.setDeterministic(false);\n        } else {\n          newTransitions.add(t);\n        }\n      }\n      state.setTransitions(newTransitions.toArray(new Transition[newTransitions.size()]));\n    }\n  }\n\n","sourceOld":"  // Replaces SEP with epsilon or remaps them if\n  // we were asked to preserve them:\n  private void replaceSep(Automaton a) {\n\n    State[] states = a.getNumberedStates();\n\n    // Go in reverse topo sort so we know we only have to\n    // make one pass:\n    for(int stateNumber=states.length-1;stateNumber >=0;stateNumber--) {\n      final State state = states[stateNumber];\n      List<Transition> newTransitions = new ArrayList<Transition>();\n      for(Transition t : state.getTransitions()) {\n        assert t.getMin() == t.getMax();\n        if (t.getMin() == TokenStreamToAutomaton.POS_SEP) {\n          if (preserveSep) {\n            // Remap to SEP_LABEL:\n            t = new Transition(SEP_LABEL, t.getDest());\n          } else {\n            // NOTE: sort of weird because this will grow\n            // the transition array we are iterating over,\n            // but because we are going in reverse topo sort\n            // it will not add any SEP/HOLE transitions:\n            state.addEpsilon(t.getDest());\n            a.setDeterministic(false);\n            t = null;\n          }\n        } else if (t.getMin() == TokenStreamToAutomaton.HOLE) {\n\n          // Just remove the hole: there will then be two\n          // SEP tokens next to each other, which will only\n          // match another hole at search time.  Note that\n          // it will also match an empty-string token ... if\n          // that's somehow a problem we can always map HOLE\n          // to a dedicated byte (and escape it in the\n          // input).\n\n          // NOTE: sort of weird because this will grow\n          // the transition array we are iterating over,\n          // but because we are going in reverse topo sort\n          // it will not add any SEP/HOLE transitions:\n          state.addEpsilon(t.getDest());\n          a.setDeterministic(false);\n          t = null;\n        }\n        if (t != null) {\n          newTransitions.add(t);\n        }\n      }\n      state.resetTransitions();\n      state.setTransitions(newTransitions.toArray(new Transition[newTransitions.size()]));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#replaceSep(Automaton).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#replaceSep(Automaton).mjava","sourceNew":"  // Replaces SEP with epsilon or remaps them if\n  // we were asked to preserve them:\n  private void replaceSep(Automaton a) {\n\n    State[] states = a.getNumberedStates();\n\n    // Go in reverse topo sort so we know we only have to\n    // make one pass:\n    for(int stateNumber=states.length-1;stateNumber >=0;stateNumber--) {\n      final State state = states[stateNumber];\n      List<Transition> newTransitions = new ArrayList<>();\n      for(Transition t : state.getTransitions()) {\n        assert t.getMin() == t.getMax();\n        if (t.getMin() == TokenStreamToAutomaton.POS_SEP) {\n          if (preserveSep) {\n            // Remap to SEP_LABEL:\n            newTransitions.add(new Transition(SEP_LABEL, t.getDest()));\n          } else {\n            copyDestTransitions(state, t.getDest(), newTransitions);\n            a.setDeterministic(false);\n          }\n        } else if (t.getMin() == TokenStreamToAutomaton.HOLE) {\n\n          // Just remove the hole: there will then be two\n          // SEP tokens next to each other, which will only\n          // match another hole at search time.  Note that\n          // it will also match an empty-string token ... if\n          // that's somehow a problem we can always map HOLE\n          // to a dedicated byte (and escape it in the\n          // input).\n          copyDestTransitions(state, t.getDest(), newTransitions);\n          a.setDeterministic(false);\n        } else {\n          newTransitions.add(t);\n        }\n      }\n      state.setTransitions(newTransitions.toArray(new Transition[newTransitions.size()]));\n    }\n  }\n\n","sourceOld":"  // Replaces SEP with epsilon or remaps them if\n  // we were asked to preserve them:\n  private void replaceSep(Automaton a) {\n\n    State[] states = a.getNumberedStates();\n\n    // Go in reverse topo sort so we know we only have to\n    // make one pass:\n    for(int stateNumber=states.length-1;stateNumber >=0;stateNumber--) {\n      final State state = states[stateNumber];\n      List<Transition> newTransitions = new ArrayList<Transition>();\n      for(Transition t : state.getTransitions()) {\n        assert t.getMin() == t.getMax();\n        if (t.getMin() == TokenStreamToAutomaton.POS_SEP) {\n          if (preserveSep) {\n            // Remap to SEP_LABEL:\n            newTransitions.add(new Transition(SEP_LABEL, t.getDest()));\n          } else {\n            copyDestTransitions(state, t.getDest(), newTransitions);\n            a.setDeterministic(false);\n          }\n        } else if (t.getMin() == TokenStreamToAutomaton.HOLE) {\n\n          // Just remove the hole: there will then be two\n          // SEP tokens next to each other, which will only\n          // match another hole at search time.  Note that\n          // it will also match an empty-string token ... if\n          // that's somehow a problem we can always map HOLE\n          // to a dedicated byte (and escape it in the\n          // input).\n          copyDestTransitions(state, t.getDest(), newTransitions);\n          a.setDeterministic(false);\n        } else {\n          newTransitions.add(t);\n        }\n      }\n      state.setTransitions(newTransitions.toArray(new Transition[newTransitions.size()]));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"75ac8571c2d82c574e446c3729251b994c69a55c","date":1402523781,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#replaceSep(LightAutomaton).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#replaceSep(Automaton).mjava","sourceNew":"  // Replaces SEP with epsilon or remaps them if\n  // we were asked to preserve them:\n  private LightAutomaton replaceSep(LightAutomaton a) {\n\n    LightAutomaton result = new LightAutomaton();\n\n    // Copy all states over\n    int numStates = a.getNumStates();\n    for(int s=0;s<numStates;s++) {\n      result.createState();\n      result.setAccept(s, a.isAccept(s));\n    }\n\n    // Go in reverse topo sort so we know we only have to\n    // make one pass:\n    LightAutomaton.Transition t = new LightAutomaton.Transition();\n    int[] topoSortStates = topoSortStates(a);\n    for(int i=0;i<topoSortStates.length;i++) {\n      int state = topoSortStates[topoSortStates.length-1-i];\n      List<Transition> newTransitions = new ArrayList<>();\n      int count = a.initTransition(state, t);\n      for(int j=0;j<count;j++) {\n        a.getNextTransition(t);\n        if (t.min == TokenStreamToAutomaton.POS_SEP) {\n          assert t.max == TokenStreamToAutomaton.POS_SEP;\n          if (preserveSep) {\n            // Remap to SEP_LABEL:\n            result.addTransition(state, t.dest, SEP_LABEL);\n          } else {\n            result.addEpsilon(state, t.dest);\n          }\n        } else if (t.min == TokenStreamToAutomaton.HOLE) {\n          assert t.max == TokenStreamToAutomaton.HOLE;\n\n          // Just remove the hole: there will then be two\n          // SEP tokens next to each other, which will only\n          // match another hole at search time.  Note that\n          // it will also match an empty-string token ... if\n          // that's somehow a problem we can always map HOLE\n          // to a dedicated byte (and escape it in the\n          // input).\n          result.addEpsilon(state, t.dest);\n        } else {\n          result.addTransition(state, t.dest, t.min, t.max);\n        }\n      }\n    }\n\n    result.finish();\n\n    return result;\n  }\n\n","sourceOld":"  // Replaces SEP with epsilon or remaps them if\n  // we were asked to preserve them:\n  private void replaceSep(Automaton a) {\n\n    State[] states = a.getNumberedStates();\n\n    // Go in reverse topo sort so we know we only have to\n    // make one pass:\n    for(int stateNumber=states.length-1;stateNumber >=0;stateNumber--) {\n      final State state = states[stateNumber];\n      List<Transition> newTransitions = new ArrayList<>();\n      for(Transition t : state.getTransitions()) {\n        assert t.getMin() == t.getMax();\n        if (t.getMin() == TokenStreamToAutomaton.POS_SEP) {\n          if (preserveSep) {\n            // Remap to SEP_LABEL:\n            newTransitions.add(new Transition(SEP_LABEL, t.getDest()));\n          } else {\n            copyDestTransitions(state, t.getDest(), newTransitions);\n            a.setDeterministic(false);\n          }\n        } else if (t.getMin() == TokenStreamToAutomaton.HOLE) {\n\n          // Just remove the hole: there will then be two\n          // SEP tokens next to each other, which will only\n          // match another hole at search time.  Note that\n          // it will also match an empty-string token ... if\n          // that's somehow a problem we can always map HOLE\n          // to a dedicated byte (and escape it in the\n          // input).\n          copyDestTransitions(state, t.getDest(), newTransitions);\n          a.setDeterministic(false);\n        } else {\n          newTransitions.add(t);\n        }\n      }\n      state.setTransitions(newTransitions.toArray(new Transition[newTransitions.size()]));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ca1c732df8923f5624f6c06b1dcca9e69d98c96","date":1402957391,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#replaceSep(Automaton).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#replaceSep(LightAutomaton).mjava","sourceNew":"  // Replaces SEP with epsilon or remaps them if\n  // we were asked to preserve them:\n  private Automaton replaceSep(Automaton a) {\n\n    Automaton result = new Automaton();\n\n    // Copy all states over\n    int numStates = a.getNumStates();\n    for(int s=0;s<numStates;s++) {\n      result.createState();\n      result.setAccept(s, a.isAccept(s));\n    }\n\n    // Go in reverse topo sort so we know we only have to\n    // make one pass:\n    Transition t = new Transition();\n    int[] topoSortStates = topoSortStates(a);\n    for(int i=0;i<topoSortStates.length;i++) {\n      int state = topoSortStates[topoSortStates.length-1-i];\n      int count = a.initTransition(state, t);\n      for(int j=0;j<count;j++) {\n        a.getNextTransition(t);\n        if (t.min == TokenStreamToAutomaton.POS_SEP) {\n          assert t.max == TokenStreamToAutomaton.POS_SEP;\n          if (preserveSep) {\n            // Remap to SEP_LABEL:\n            result.addTransition(state, t.dest, SEP_LABEL);\n          } else {\n            result.addEpsilon(state, t.dest);\n          }\n        } else if (t.min == TokenStreamToAutomaton.HOLE) {\n          assert t.max == TokenStreamToAutomaton.HOLE;\n\n          // Just remove the hole: there will then be two\n          // SEP tokens next to each other, which will only\n          // match another hole at search time.  Note that\n          // it will also match an empty-string token ... if\n          // that's somehow a problem we can always map HOLE\n          // to a dedicated byte (and escape it in the\n          // input).\n          result.addEpsilon(state, t.dest);\n        } else {\n          result.addTransition(state, t.dest, t.min, t.max);\n        }\n      }\n    }\n\n    result.finishState();\n\n    return result;\n  }\n\n","sourceOld":"  // Replaces SEP with epsilon or remaps them if\n  // we were asked to preserve them:\n  private LightAutomaton replaceSep(LightAutomaton a) {\n\n    LightAutomaton result = new LightAutomaton();\n\n    // Copy all states over\n    int numStates = a.getNumStates();\n    for(int s=0;s<numStates;s++) {\n      result.createState();\n      result.setAccept(s, a.isAccept(s));\n    }\n\n    // Go in reverse topo sort so we know we only have to\n    // make one pass:\n    Transition t = new Transition();\n    int[] topoSortStates = topoSortStates(a);\n    for(int i=0;i<topoSortStates.length;i++) {\n      int state = topoSortStates[topoSortStates.length-1-i];\n      int count = a.initTransition(state, t);\n      for(int j=0;j<count;j++) {\n        a.getNextTransition(t);\n        if (t.min == TokenStreamToAutomaton.POS_SEP) {\n          assert t.max == TokenStreamToAutomaton.POS_SEP;\n          if (preserveSep) {\n            // Remap to SEP_LABEL:\n            result.addTransition(state, t.dest, SEP_LABEL);\n          } else {\n            result.addEpsilon(state, t.dest);\n          }\n        } else if (t.min == TokenStreamToAutomaton.HOLE) {\n          assert t.max == TokenStreamToAutomaton.HOLE;\n\n          // Just remove the hole: there will then be two\n          // SEP tokens next to each other, which will only\n          // match another hole at search time.  Note that\n          // it will also match an empty-string token ... if\n          // that's somehow a problem we can always map HOLE\n          // to a dedicated byte (and escape it in the\n          // input).\n          result.addEpsilon(state, t.dest);\n        } else {\n          result.addTransition(state, t.dest, t.min, t.max);\n        }\n      }\n    }\n\n    result.finishState();\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c84485629d80d203608e8975a1139de9933cc38","date":1403166128,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#replaceSep(Automaton).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#replaceSep(Automaton).mjava","sourceNew":"  // Replaces SEP with epsilon or remaps them if\n  // we were asked to preserve them:\n  private Automaton replaceSep(Automaton a) {\n\n    Automaton result = new Automaton();\n\n    // Copy all states over\n    int numStates = a.getNumStates();\n    for(int s=0;s<numStates;s++) {\n      result.createState();\n      result.setAccept(s, a.isAccept(s));\n    }\n\n    // Go in reverse topo sort so we know we only have to\n    // make one pass:\n    Transition t = new Transition();\n    int[] topoSortStates = topoSortStates(a);\n    for(int i=0;i<topoSortStates.length;i++) {\n      int state = topoSortStates[topoSortStates.length-1-i];\n      int count = a.initTransition(state, t);\n      for(int j=0;j<count;j++) {\n        a.getNextTransition(t);\n        if (t.min == TokenStreamToAutomaton.POS_SEP) {\n          assert t.max == TokenStreamToAutomaton.POS_SEP;\n          if (preserveSep) {\n            // Remap to SEP_LABEL:\n            result.addTransition(state, t.dest, SEP_LABEL);\n          } else {\n            result.addEpsilon(state, t.dest);\n          }\n        } else if (t.min == TokenStreamToAutomaton.HOLE) {\n          assert t.max == TokenStreamToAutomaton.HOLE;\n\n          // Just remove the hole: there will then be two\n          // SEP tokens next to each other, which will only\n          // match another hole at search time.  Note that\n          // it will also match an empty-string token ... if\n          // that's somehow a problem we can always map HOLE\n          // to a dedicated byte (and escape it in the\n          // input).\n          result.addEpsilon(state, t.dest);\n        } else {\n          result.addTransition(state, t.dest, t.min, t.max);\n        }\n      }\n    }\n\n    result.finishState();\n\n    return result;\n  }\n\n","sourceOld":"  // Replaces SEP with epsilon or remaps them if\n  // we were asked to preserve them:\n  private void replaceSep(Automaton a) {\n\n    State[] states = a.getNumberedStates();\n\n    // Go in reverse topo sort so we know we only have to\n    // make one pass:\n    for(int stateNumber=states.length-1;stateNumber >=0;stateNumber--) {\n      final State state = states[stateNumber];\n      List<Transition> newTransitions = new ArrayList<>();\n      for(Transition t : state.getTransitions()) {\n        assert t.getMin() == t.getMax();\n        if (t.getMin() == TokenStreamToAutomaton.POS_SEP) {\n          if (preserveSep) {\n            // Remap to SEP_LABEL:\n            newTransitions.add(new Transition(SEP_LABEL, t.getDest()));\n          } else {\n            copyDestTransitions(state, t.getDest(), newTransitions);\n            a.setDeterministic(false);\n          }\n        } else if (t.getMin() == TokenStreamToAutomaton.HOLE) {\n\n          // Just remove the hole: there will then be two\n          // SEP tokens next to each other, which will only\n          // match another hole at search time.  Note that\n          // it will also match an empty-string token ... if\n          // that's somehow a problem we can always map HOLE\n          // to a dedicated byte (and escape it in the\n          // input).\n          copyDestTransitions(state, t.getDest(), newTransitions);\n          a.setDeterministic(false);\n        } else {\n          newTransitions.add(t);\n        }\n      }\n      state.setTransitions(newTransitions.toArray(new Transition[newTransitions.size()]));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf14aa4e44c71553ea90d5f57b653b4caaddfd7f","date":1411139053,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#replaceSep(Automaton).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#replaceSep(Automaton).mjava","sourceNew":"  // Replaces SEP with epsilon or remaps them if\n  // we were asked to preserve them:\n  private Automaton replaceSep(Automaton a) {\n\n    int numStates = a.getNumStates();\n    Automaton.Builder result = new Automaton.Builder(numStates, a.getNumTransitions());\n    // Copy all states over\n    result.copyStates(a);\n\n    // Go in reverse topo sort so we know we only have to\n    // make one pass:\n    Transition t = new Transition();\n    int[] topoSortStates = topoSortStates(a);\n    for(int i=0;i<topoSortStates.length;i++) {\n      int state = topoSortStates[topoSortStates.length-1-i];\n      int count = a.initTransition(state, t);\n      for(int j=0;j<count;j++) {\n        a.getNextTransition(t);\n        if (t.min == TokenStreamToAutomaton.POS_SEP) {\n          assert t.max == TokenStreamToAutomaton.POS_SEP;\n          if (preserveSep) {\n            // Remap to SEP_LABEL:\n            result.addTransition(state, t.dest, SEP_LABEL);\n          } else {\n            result.addEpsilon(state, t.dest);\n          }\n        } else if (t.min == TokenStreamToAutomaton.HOLE) {\n          assert t.max == TokenStreamToAutomaton.HOLE;\n\n          // Just remove the hole: there will then be two\n          // SEP tokens next to each other, which will only\n          // match another hole at search time.  Note that\n          // it will also match an empty-string token ... if\n          // that's somehow a problem we can always map HOLE\n          // to a dedicated byte (and escape it in the\n          // input).\n          result.addEpsilon(state, t.dest);\n        } else {\n          result.addTransition(state, t.dest, t.min, t.max);\n        }\n      }\n    }\n\n    return result.finish();\n  }\n\n","sourceOld":"  // Replaces SEP with epsilon or remaps them if\n  // we were asked to preserve them:\n  private Automaton replaceSep(Automaton a) {\n\n    Automaton result = new Automaton();\n\n    // Copy all states over\n    int numStates = a.getNumStates();\n    for(int s=0;s<numStates;s++) {\n      result.createState();\n      result.setAccept(s, a.isAccept(s));\n    }\n\n    // Go in reverse topo sort so we know we only have to\n    // make one pass:\n    Transition t = new Transition();\n    int[] topoSortStates = topoSortStates(a);\n    for(int i=0;i<topoSortStates.length;i++) {\n      int state = topoSortStates[topoSortStates.length-1-i];\n      int count = a.initTransition(state, t);\n      for(int j=0;j<count;j++) {\n        a.getNextTransition(t);\n        if (t.min == TokenStreamToAutomaton.POS_SEP) {\n          assert t.max == TokenStreamToAutomaton.POS_SEP;\n          if (preserveSep) {\n            // Remap to SEP_LABEL:\n            result.addTransition(state, t.dest, SEP_LABEL);\n          } else {\n            result.addEpsilon(state, t.dest);\n          }\n        } else if (t.min == TokenStreamToAutomaton.HOLE) {\n          assert t.max == TokenStreamToAutomaton.HOLE;\n\n          // Just remove the hole: there will then be two\n          // SEP tokens next to each other, which will only\n          // match another hole at search time.  Note that\n          // it will also match an empty-string token ... if\n          // that's somehow a problem we can always map HOLE\n          // to a dedicated byte (and escape it in the\n          // input).\n          result.addEpsilon(state, t.dest);\n        } else {\n          result.addTransition(state, t.dest, t.min, t.max);\n        }\n      }\n    }\n\n    result.finishState();\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"363efd5f833e8e194f8c9b8a3199eca1bc684c38","date":1435941197,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#replaceSep(Automaton).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#replaceSep(Automaton).mjava","sourceNew":"  // Replaces SEP with epsilon or remaps them if\n  // we were asked to preserve them:\n  private Automaton replaceSep(Automaton a) {\n\n    int numStates = a.getNumStates();\n    Automaton.Builder result = new Automaton.Builder(numStates, a.getNumTransitions());\n    // Copy all states over\n    result.copyStates(a);\n\n    // Go in reverse topo sort so we know we only have to\n    // make one pass:\n    Transition t = new Transition();\n    int[] topoSortStates = Operations.topoSortStates(a);\n    for(int i=0;i<topoSortStates.length;i++) {\n      int state = topoSortStates[topoSortStates.length-1-i];\n      int count = a.initTransition(state, t);\n      for(int j=0;j<count;j++) {\n        a.getNextTransition(t);\n        if (t.min == TokenStreamToAutomaton.POS_SEP) {\n          assert t.max == TokenStreamToAutomaton.POS_SEP;\n          if (preserveSep) {\n            // Remap to SEP_LABEL:\n            result.addTransition(state, t.dest, SEP_LABEL);\n          } else {\n            result.addEpsilon(state, t.dest);\n          }\n        } else if (t.min == TokenStreamToAutomaton.HOLE) {\n          assert t.max == TokenStreamToAutomaton.HOLE;\n\n          // Just remove the hole: there will then be two\n          // SEP tokens next to each other, which will only\n          // match another hole at search time.  Note that\n          // it will also match an empty-string token ... if\n          // that's somehow a problem we can always map HOLE\n          // to a dedicated byte (and escape it in the\n          // input).\n          result.addEpsilon(state, t.dest);\n        } else {\n          result.addTransition(state, t.dest, t.min, t.max);\n        }\n      }\n    }\n\n    return result.finish();\n  }\n\n","sourceOld":"  // Replaces SEP with epsilon or remaps them if\n  // we were asked to preserve them:\n  private Automaton replaceSep(Automaton a) {\n\n    int numStates = a.getNumStates();\n    Automaton.Builder result = new Automaton.Builder(numStates, a.getNumTransitions());\n    // Copy all states over\n    result.copyStates(a);\n\n    // Go in reverse topo sort so we know we only have to\n    // make one pass:\n    Transition t = new Transition();\n    int[] topoSortStates = topoSortStates(a);\n    for(int i=0;i<topoSortStates.length;i++) {\n      int state = topoSortStates[topoSortStates.length-1-i];\n      int count = a.initTransition(state, t);\n      for(int j=0;j<count;j++) {\n        a.getNextTransition(t);\n        if (t.min == TokenStreamToAutomaton.POS_SEP) {\n          assert t.max == TokenStreamToAutomaton.POS_SEP;\n          if (preserveSep) {\n            // Remap to SEP_LABEL:\n            result.addTransition(state, t.dest, SEP_LABEL);\n          } else {\n            result.addEpsilon(state, t.dest);\n          }\n        } else if (t.min == TokenStreamToAutomaton.HOLE) {\n          assert t.max == TokenStreamToAutomaton.HOLE;\n\n          // Just remove the hole: there will then be two\n          // SEP tokens next to each other, which will only\n          // match another hole at search time.  Note that\n          // it will also match an empty-string token ... if\n          // that's somehow a problem we can always map HOLE\n          // to a dedicated byte (and escape it in the\n          // input).\n          result.addEpsilon(state, t.dest);\n        } else {\n          result.addTransition(state, t.dest, t.min, t.max);\n        }\n      }\n    }\n\n    return result.finish();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"75ac8571c2d82c574e446c3729251b994c69a55c":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"363efd5f833e8e194f8c9b8a3199eca1bc684c38":["cf14aa4e44c71553ea90d5f57b653b4caaddfd7f"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["5cc37084489c2a7ca417a147a21ba3a24e1c3e8b"],"65621ac5927a7c2f23e9cd59b09f56addd5ed2bf":["6ce825e9276493231308229152c48f755ce1a0a5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["75ac8571c2d82c574e446c3729251b994c69a55c"],"cf14aa4e44c71553ea90d5f57b653b4caaddfd7f":["5c84485629d80d203608e8975a1139de9933cc38"],"6ce825e9276493231308229152c48f755ce1a0a5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5c84485629d80d203608e8975a1139de9933cc38":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["363efd5f833e8e194f8c9b8a3199eca1bc684c38"],"5cc37084489c2a7ca417a147a21ba3a24e1c3e8b":["65621ac5927a7c2f23e9cd59b09f56addd5ed2bf"]},"commit2Childs":{"75ac8571c2d82c574e446c3729251b994c69a55c":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["75ac8571c2d82c574e446c3729251b994c69a55c","5c84485629d80d203608e8975a1139de9933cc38"],"363efd5f833e8e194f8c9b8a3199eca1bc684c38":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"65621ac5927a7c2f23e9cd59b09f56addd5ed2bf":["5cc37084489c2a7ca417a147a21ba3a24e1c3e8b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6ce825e9276493231308229152c48f755ce1a0a5"],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["5c84485629d80d203608e8975a1139de9933cc38"],"cf14aa4e44c71553ea90d5f57b653b4caaddfd7f":["363efd5f833e8e194f8c9b8a3199eca1bc684c38"],"6ce825e9276493231308229152c48f755ce1a0a5":["65621ac5927a7c2f23e9cd59b09f56addd5ed2bf"],"5c84485629d80d203608e8975a1139de9933cc38":["cf14aa4e44c71553ea90d5f57b653b4caaddfd7f"],"5cc37084489c2a7ca417a147a21ba3a24e1c3e8b":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}