{"path":"solr/core/src/test/org/apache/solr/cloud/TestTolerantUpdateProcessorCloud#testAddsMixedWithDeletes(SolrClient).mjava","commits":[{"id":"f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef","date":1458928975,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestTolerantUpdateProcessorCloud#testAddsMixedWithDeletes(SolrClient).mjava","pathOld":"/dev/null","sourceNew":"  protected static void testAddsMixedWithDeletes(SolrClient client) throws Exception {\n    assertNotNull(\"client not initialized\", client);\n\n    // 3 doc ids, exactly one on shard1\n    final String docId1  = S_ONE_PRE + \"42\";\n    final String docId21 = S_TWO_PRE + \"42\";\n    final String docId22 = S_TWO_PRE + \"666\";\n    \n    UpdateResponse rsp = null;\n    \n    // add 2 docs, one to each shard\n    rsp = update(params(\"update.chain\", \"tolerant-chain-max-errors-10\",\n                        \"commit\", \"true\"),\n                 doc(f(\"id\", docId1), f(\"foo_i\", \"2001\")),\n                 doc(f(\"id\", docId21), f(\"foo_i\", \"1976\"))).process(client);\n    assertEquals(0, rsp.getStatus());\n\n    // add failure on shard2, delete failure on shard1\n    rsp = update(params(\"update.chain\", \"tolerant-chain-max-errors-10\",\n                        \"commit\", \"true\"),\n                 doc(f(\"id\", docId22), f(\"foo_i\", \"not_a_num\")))\n      .deleteById(docId1, -1L)\n      .process(client);\n    assertEquals(0, rsp.getStatus());\n    assertUpdateTolerantErrors(\"shard2 add fail, shard1 delI fail\", rsp,\n                               delIErr(docId1, \"version conflict\"),\n                               addErr(docId22,\"not_a_num\"));\n    \n    // attempt a request containing 4 errors of various types (add, delI, delQ)\n    for (String maxErrors : new String[] {\"4\", \"-1\", \"100\"}) {\n      // for all of these maxErrors values, the overall request should still succeed\n      rsp = update(params(\"update.chain\", \"tolerant-chain-max-errors-10\",\n                          \"maxErrors\", maxErrors,\n                          \"commit\", \"true\"),\n                   doc(f(\"id\", docId22), f(\"foo_i\", \"bogus_val\")))\n        .deleteById(docId1, -1L)\n        .deleteByQuery(\"malformed:[\")\n        .deleteById(docId21, -1L)\n        .process(client);\n      \n      assertEquals(0, rsp.getStatus());\n      assertUpdateTolerantErrors(\"failed variety of updates\", rsp,\n                                 delIErr(docId1, \"version conflict\"),\n                                 delQErr(\"malformed:[\", \"SyntaxError\"),\n                                 delIErr(docId21,\"version conflict\"),\n                                 addErr(docId22,\"bogus_val\"));\n    }\n    \n    // attempt a request containing 4 errors of various types (add, delI, delQ) .. 1 too many\n    try {\n      rsp = update(params(\"update.chain\", \"tolerant-chain-max-errors-10\",\n                          \"maxErrors\", \"3\",\n                          \"commit\", \"true\"),\n                   doc(f(\"id\", docId22), f(\"foo_i\", \"bogus_val\")))\n        .deleteById(docId1, -1L)\n        .deleteByQuery(\"malformed:[\")\n        .deleteById(docId21, -1L)\n        .process(client);\n      fail(\"did not get a top level exception when more then 4 updates failed: \" + rsp.toString());\n    } catch (SolrException e) {\n      // we can't make any reliable assertions about the error message, because\n      // it varies based on how the request was routed -- see SOLR-8830\n      \n      // likewise, we can't make a firm(er) assertion about the response code...\n      assertTrue(\"not the type of error we were expecting (\"+e.code()+\"): \" + e.toString(),\n                 // should be one these 2 depending on order that the async errors were hit...\n                 // on a single node setup -- a 5xx type error isn't something we should have triggered\n                 400 == e.code() || 409 == e.code());\n\n      // verify that the Exceptions metadata can tell us what failed.\n      NamedList<String> remoteErrMetadata = e.getMetadata();\n      assertNotNull(\"no metadata in: \" + e.toString(), remoteErrMetadata);\n      Set<ToleratedUpdateError> actualKnownErrs\n        = new LinkedHashSet<ToleratedUpdateError>(remoteErrMetadata.size());\n      int actualKnownErrsCount = 0;\n      for (int i = 0; i < remoteErrMetadata.size(); i++) {\n        ToleratedUpdateError err =\n          ToleratedUpdateError.parseMetadataIfToleratedUpdateError(remoteErrMetadata.getName(i),\n                                                                   remoteErrMetadata.getVal(i));\n        if (null == err) {\n          // some metadata unrelated to this update processor\n          continue;\n        }\n        actualKnownErrsCount++;\n        actualKnownErrs.add(err);\n      }\n      assertEquals(\"wrong number of errors in metadata: \" + remoteErrMetadata.toString(),\n                   4, actualKnownErrsCount);\n      assertEquals(\"at least one dup error in metadata: \" + remoteErrMetadata.toString(),\n                   actualKnownErrsCount, actualKnownErrs.size());\n    }\n\n    // sanity check our 2 existing docs are still here\n    assertQueryDocIds(client, true, docId1, docId21);\n    assertQueryDocIds(client, false, docId22);\n\n    // tolerate some failures along with a DELQ that should succeed\n    rsp = update(params(\"update.chain\", \"tolerant-chain-max-errors-10\",\n                        \"commit\", \"true\"),\n                 doc(f(\"id\", docId22), f(\"foo_i\", \"not_a_num\")))\n      .deleteById(docId1, -1L)\n      .deleteByQuery(\"zot_i:[42 to gibberish...\")\n      .deleteByQuery(\"foo_i:[50 TO 2000}\")\n      .process(client);\n    assertEquals(0, rsp.getStatus());\n    assertUpdateTolerantErrors(\"mix fails with one valid DELQ\", rsp,\n                               delIErr(docId1, \"version conflict\"),\n                               delQErr(\"zot_i:[42 to gibberish...\"),\n                               addErr(docId22,\"not_a_num\"));\n    // one of our previous docs should have been deleted now\n    assertQueryDocIds(client, true, docId1);\n    assertQueryDocIds(client, false, docId21, docId22);\n                      \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"92f789dbd1886e4b468e61b0def88b29a3f55228","date":1533844010,"type":3,"author":"Jason Gerlowski","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestTolerantUpdateProcessorCloud#testAddsMixedWithDeletes(SolrClient).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestTolerantUpdateProcessorCloud#testAddsMixedWithDeletes(SolrClient).mjava","sourceNew":"  protected static void testAddsMixedWithDeletes(SolrClient client) throws Exception {\n    assertNotNull(\"client not initialized\", client);\n\n    // 3 doc ids, exactly one on shard1\n    final String docId1  = S_ONE_PRE + \"42\";\n    final String docId21 = S_TWO_PRE + \"42\";\n    final String docId22 = S_TWO_PRE + \"666\";\n    \n    UpdateResponse rsp = null;\n    \n    // add 2 docs, one to each shard\n    rsp = update(params(\"update.chain\", \"tolerant-chain-max-errors-10\",\n                        \"commit\", \"true\"),\n                 doc(f(\"id\", docId1), f(\"foo_i\", \"2001\")),\n                 doc(f(\"id\", docId21), f(\"foo_i\", \"1976\"))).process(client);\n    assertEquals(0, rsp.getStatus());\n\n    // add failure on shard2, delete failure on shard1\n    rsp = update(params(\"update.chain\", \"tolerant-chain-max-errors-10\",\n                        \"commit\", \"true\"),\n                 doc(f(\"id\", docId22), f(\"foo_i\", \"not_a_num\")))\n      .deleteById(docId1, -1L)\n      .process(client);\n    assertEquals(0, rsp.getStatus());\n    assertUpdateTolerantErrors(\"shard2 add fail, shard1 delI fail\", rsp,\n                               delIErr(docId1, \"version conflict\"),\n                               addErr(docId22,\"not_a_num\"));\n    \n    // attempt a request containing 4 errors of various types (add, delI, delQ)\n    for (String maxErrors : new String[] {\"4\", \"-1\", \"100\"}) {\n      // for all of these maxErrors values, the overall request should still succeed\n      rsp = update(params(\"update.chain\", \"tolerant-chain-max-errors-10\",\n                          \"maxErrors\", maxErrors,\n                          \"commit\", \"true\"),\n                   doc(f(\"id\", docId22), f(\"foo_i\", \"bogus_val\")))\n        .deleteById(docId1, -1L)\n        .deleteByQuery(\"malformed:[\")\n        .deleteById(docId21, -1L)\n        .process(client);\n      \n      assertEquals(0, rsp.getStatus());\n      assertUpdateTolerantErrors(\"failed variety of updates\", rsp,\n                                 delIErr(docId1, \"version conflict\"),\n                                 delQErr(\"malformed:[\", \"SyntaxError\"),\n                                 delIErr(docId21,\"version conflict\"),\n                                 addErr(docId22,\"bogus_val\"));\n    }\n    \n    // attempt a request containing 4 errors of various types (add, delI, delQ) .. 1 too many\n\n    SolrException e = expectThrows(SolrException.class,\n        \"did not get a top level exception when more then 4 updates failed\",\n        () -> update(params(\"update.chain\", \"tolerant-chain-max-errors-10\",\n            \"maxErrors\", \"3\",\n            \"commit\", \"true\"),\n            doc(f(\"id\", docId22), f(\"foo_i\", \"bogus_val\")))\n            .deleteById(docId1, -1L)\n            .deleteByQuery(\"malformed:[\")\n            .deleteById(docId21, -1L)\n            .process(client)\n    );\n\n    {\n      // we can't make any reliable assertions about the error message, because\n      // it varies based on how the request was routed -- see SOLR-8830\n\n      // likewise, we can't make a firm(er) assertion about the response code...\n      assertTrue(\"not the type of error we were expecting (\"+e.code()+\"): \" + e.toString(),\n          // should be one these 2 depending on order that the async errors were hit...\n          // on a single node setup -- a 5xx type error isn't something we should have triggered\n          400 == e.code() || 409 == e.code());\n\n      // verify that the Exceptions metadata can tell us what failed.\n      NamedList<String> remoteErrMetadata = e.getMetadata();\n      assertNotNull(\"no metadata in: \" + e.toString(), remoteErrMetadata);\n      Set<ToleratedUpdateError> actualKnownErrs\n          = new LinkedHashSet<ToleratedUpdateError>(remoteErrMetadata.size());\n      int actualKnownErrsCount = 0;\n      for (int i = 0; i < remoteErrMetadata.size(); i++) {\n        ToleratedUpdateError err =\n            ToleratedUpdateError.parseMetadataIfToleratedUpdateError(remoteErrMetadata.getName(i),\n                remoteErrMetadata.getVal(i));\n        if (null == err) {\n          // some metadata unrelated to this update processor\n          continue;\n        }\n        actualKnownErrsCount++;\n        actualKnownErrs.add(err);\n      }\n      assertEquals(\"wrong number of errors in metadata: \" + remoteErrMetadata.toString(),\n          4, actualKnownErrsCount);\n      assertEquals(\"at least one dup error in metadata: \" + remoteErrMetadata.toString(),\n          actualKnownErrsCount, actualKnownErrs.size());\n    }\n\n    // sanity check our 2 existing docs are still here\n    assertQueryDocIds(client, true, docId1, docId21);\n    assertQueryDocIds(client, false, docId22);\n\n    // tolerate some failures along with a DELQ that should succeed\n    rsp = update(params(\"update.chain\", \"tolerant-chain-max-errors-10\",\n                        \"commit\", \"true\"),\n                 doc(f(\"id\", docId22), f(\"foo_i\", \"not_a_num\")))\n      .deleteById(docId1, -1L)\n      .deleteByQuery(\"zot_i:[42 to gibberish...\")\n      .deleteByQuery(\"foo_i:[50 TO 2000}\")\n      .process(client);\n    assertEquals(0, rsp.getStatus());\n    assertUpdateTolerantErrors(\"mix fails with one valid DELQ\", rsp,\n                               delIErr(docId1, \"version conflict\"),\n                               delQErr(\"zot_i:[42 to gibberish...\"),\n                               addErr(docId22,\"not_a_num\"));\n    // one of our previous docs should have been deleted now\n    assertQueryDocIds(client, true, docId1);\n    assertQueryDocIds(client, false, docId21, docId22);\n                      \n  }\n\n","sourceOld":"  protected static void testAddsMixedWithDeletes(SolrClient client) throws Exception {\n    assertNotNull(\"client not initialized\", client);\n\n    // 3 doc ids, exactly one on shard1\n    final String docId1  = S_ONE_PRE + \"42\";\n    final String docId21 = S_TWO_PRE + \"42\";\n    final String docId22 = S_TWO_PRE + \"666\";\n    \n    UpdateResponse rsp = null;\n    \n    // add 2 docs, one to each shard\n    rsp = update(params(\"update.chain\", \"tolerant-chain-max-errors-10\",\n                        \"commit\", \"true\"),\n                 doc(f(\"id\", docId1), f(\"foo_i\", \"2001\")),\n                 doc(f(\"id\", docId21), f(\"foo_i\", \"1976\"))).process(client);\n    assertEquals(0, rsp.getStatus());\n\n    // add failure on shard2, delete failure on shard1\n    rsp = update(params(\"update.chain\", \"tolerant-chain-max-errors-10\",\n                        \"commit\", \"true\"),\n                 doc(f(\"id\", docId22), f(\"foo_i\", \"not_a_num\")))\n      .deleteById(docId1, -1L)\n      .process(client);\n    assertEquals(0, rsp.getStatus());\n    assertUpdateTolerantErrors(\"shard2 add fail, shard1 delI fail\", rsp,\n                               delIErr(docId1, \"version conflict\"),\n                               addErr(docId22,\"not_a_num\"));\n    \n    // attempt a request containing 4 errors of various types (add, delI, delQ)\n    for (String maxErrors : new String[] {\"4\", \"-1\", \"100\"}) {\n      // for all of these maxErrors values, the overall request should still succeed\n      rsp = update(params(\"update.chain\", \"tolerant-chain-max-errors-10\",\n                          \"maxErrors\", maxErrors,\n                          \"commit\", \"true\"),\n                   doc(f(\"id\", docId22), f(\"foo_i\", \"bogus_val\")))\n        .deleteById(docId1, -1L)\n        .deleteByQuery(\"malformed:[\")\n        .deleteById(docId21, -1L)\n        .process(client);\n      \n      assertEquals(0, rsp.getStatus());\n      assertUpdateTolerantErrors(\"failed variety of updates\", rsp,\n                                 delIErr(docId1, \"version conflict\"),\n                                 delQErr(\"malformed:[\", \"SyntaxError\"),\n                                 delIErr(docId21,\"version conflict\"),\n                                 addErr(docId22,\"bogus_val\"));\n    }\n    \n    // attempt a request containing 4 errors of various types (add, delI, delQ) .. 1 too many\n    try {\n      rsp = update(params(\"update.chain\", \"tolerant-chain-max-errors-10\",\n                          \"maxErrors\", \"3\",\n                          \"commit\", \"true\"),\n                   doc(f(\"id\", docId22), f(\"foo_i\", \"bogus_val\")))\n        .deleteById(docId1, -1L)\n        .deleteByQuery(\"malformed:[\")\n        .deleteById(docId21, -1L)\n        .process(client);\n      fail(\"did not get a top level exception when more then 4 updates failed: \" + rsp.toString());\n    } catch (SolrException e) {\n      // we can't make any reliable assertions about the error message, because\n      // it varies based on how the request was routed -- see SOLR-8830\n      \n      // likewise, we can't make a firm(er) assertion about the response code...\n      assertTrue(\"not the type of error we were expecting (\"+e.code()+\"): \" + e.toString(),\n                 // should be one these 2 depending on order that the async errors were hit...\n                 // on a single node setup -- a 5xx type error isn't something we should have triggered\n                 400 == e.code() || 409 == e.code());\n\n      // verify that the Exceptions metadata can tell us what failed.\n      NamedList<String> remoteErrMetadata = e.getMetadata();\n      assertNotNull(\"no metadata in: \" + e.toString(), remoteErrMetadata);\n      Set<ToleratedUpdateError> actualKnownErrs\n        = new LinkedHashSet<ToleratedUpdateError>(remoteErrMetadata.size());\n      int actualKnownErrsCount = 0;\n      for (int i = 0; i < remoteErrMetadata.size(); i++) {\n        ToleratedUpdateError err =\n          ToleratedUpdateError.parseMetadataIfToleratedUpdateError(remoteErrMetadata.getName(i),\n                                                                   remoteErrMetadata.getVal(i));\n        if (null == err) {\n          // some metadata unrelated to this update processor\n          continue;\n        }\n        actualKnownErrsCount++;\n        actualKnownErrs.add(err);\n      }\n      assertEquals(\"wrong number of errors in metadata: \" + remoteErrMetadata.toString(),\n                   4, actualKnownErrsCount);\n      assertEquals(\"at least one dup error in metadata: \" + remoteErrMetadata.toString(),\n                   actualKnownErrsCount, actualKnownErrs.size());\n    }\n\n    // sanity check our 2 existing docs are still here\n    assertQueryDocIds(client, true, docId1, docId21);\n    assertQueryDocIds(client, false, docId22);\n\n    // tolerate some failures along with a DELQ that should succeed\n    rsp = update(params(\"update.chain\", \"tolerant-chain-max-errors-10\",\n                        \"commit\", \"true\"),\n                 doc(f(\"id\", docId22), f(\"foo_i\", \"not_a_num\")))\n      .deleteById(docId1, -1L)\n      .deleteByQuery(\"zot_i:[42 to gibberish...\")\n      .deleteByQuery(\"foo_i:[50 TO 2000}\")\n      .process(client);\n    assertEquals(0, rsp.getStatus());\n    assertUpdateTolerantErrors(\"mix fails with one valid DELQ\", rsp,\n                               delIErr(docId1, \"version conflict\"),\n                               delQErr(\"zot_i:[42 to gibberish...\"),\n                               addErr(docId22,\"not_a_num\"));\n    // one of our previous docs should have been deleted now\n    assertQueryDocIds(client, true, docId1);\n    assertQueryDocIds(client, false, docId21, docId22);\n                      \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"92f789dbd1886e4b468e61b0def88b29a3f55228":["f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef"],"f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["92f789dbd1886e4b468e61b0def88b29a3f55228"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef"],"92f789dbd1886e4b468e61b0def88b29a3f55228":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef":["92f789dbd1886e4b468e61b0def88b29a3f55228"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}