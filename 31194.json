{"path":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDeleteByQuery(DeleteUpdateCommand).mjava","commits":[{"id":"86290366cefc1b9d4eced13b430858c4a4c0421d","date":1432321109,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDeleteByQuery(DeleteUpdateCommand).mjava","pathOld":"/dev/null","sourceNew":"  protected void versionDeleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    vinfo.blockUpdates();\n    try {\n\n      if (versionsStored) {\n        if (leaderLogic) {\n          long version = vinfo.getNewClock();\n          cmd.setVersion(-version);\n          // TODO update versions in all buckets\n\n          doLocalDelete(cmd);\n\n        } else {\n          cmd.setVersion(-versionOnUpdate);\n\n          if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.deleteByQuery(cmd);\n            return;\n          }\n\n          doLocalDelete(cmd);\n        }\n      }\n\n      // since we don't know which documents were deleted, the easiest thing to do is to invalidate\n      // all real-time caches (i.e. UpdateLog) which involves also getting a new version of the IndexReader\n      // (so cache misses will see up-to-date data)\n\n    } finally {\n      vinfo.unblockUpdates();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c835cc1a7b07477a469cdb1bf6c67bc05b85c07","date":1471849333,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDeleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDeleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  protected void versionDeleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    vinfo.blockUpdates();\n    try {\n\n      if (versionsStored) {\n        if (leaderLogic) {\n          long version = vinfo.getNewClock();\n          cmd.setVersion(-version);\n          // TODO update versions in all buckets\n\n          doLocalDelete(cmd);\n\n        } else {\n          cmd.setVersion(-versionOnUpdate);\n\n          if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.deleteByQuery(cmd);\n            return;\n          }\n\n          doLocalDelete(cmd);\n        }\n      }\n\n      // since we don't know which documents were deleted, the easiest thing to do is to invalidate\n      // all real-time caches (i.e. UpdateLog) which involves also getting a new version of the IndexReader\n      // (so cache misses will see up-to-date data)\n\n    } finally {\n      vinfo.unblockUpdates();\n    }\n  }\n\n","sourceOld":"  protected void versionDeleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    vinfo.blockUpdates();\n    try {\n\n      if (versionsStored) {\n        if (leaderLogic) {\n          long version = vinfo.getNewClock();\n          cmd.setVersion(-version);\n          // TODO update versions in all buckets\n\n          doLocalDelete(cmd);\n\n        } else {\n          cmd.setVersion(-versionOnUpdate);\n\n          if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.deleteByQuery(cmd);\n            return;\n          }\n\n          doLocalDelete(cmd);\n        }\n      }\n\n      // since we don't know which documents were deleted, the easiest thing to do is to invalidate\n      // all real-time caches (i.e. UpdateLog) which involves also getting a new version of the IndexReader\n      // (so cache misses will see up-to-date data)\n\n    } finally {\n      vinfo.unblockUpdates();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a","date":1472163016,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDeleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDeleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  protected void versionDeleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    vinfo.blockUpdates();\n    try {\n\n      if (versionsStored) {\n        if (leaderLogic) {\n          long version = vinfo.getNewClock();\n          cmd.setVersion(-version);\n          // TODO update versions in all buckets\n\n          doLocalDelete(cmd);\n\n        } else {\n          cmd.setVersion(-versionOnUpdate);\n\n          if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.deleteByQuery(cmd);\n            return;\n          }\n\n          doLocalDelete(cmd);\n        }\n      }\n\n      // since we don't know which documents were deleted, the easiest thing to do is to invalidate\n      // all real-time caches (i.e. UpdateLog) which involves also getting a new version of the IndexReader\n      // (so cache misses will see up-to-date data)\n\n    } finally {\n      vinfo.unblockUpdates();\n    }\n  }\n\n","sourceOld":"  protected void versionDeleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    vinfo.blockUpdates();\n    try {\n\n      if (versionsStored) {\n        if (leaderLogic) {\n          long version = vinfo.getNewClock();\n          cmd.setVersion(-version);\n          // TODO update versions in all buckets\n\n          doLocalDelete(cmd);\n\n        } else {\n          cmd.setVersion(-versionOnUpdate);\n\n          if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.deleteByQuery(cmd);\n            return;\n          }\n\n          doLocalDelete(cmd);\n        }\n      }\n\n      // since we don't know which documents were deleted, the easiest thing to do is to invalidate\n      // all real-time caches (i.e. UpdateLog) which involves also getting a new version of the IndexReader\n      // (so cache misses will see up-to-date data)\n\n    } finally {\n      vinfo.unblockUpdates();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDeleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDeleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  protected void versionDeleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    vinfo.blockUpdates();\n    try {\n\n      if (versionsStored) {\n        if (leaderLogic) {\n          long version = vinfo.getNewClock();\n          cmd.setVersion(-version);\n          // TODO update versions in all buckets\n\n          doLocalDelete(cmd);\n\n        } else {\n          cmd.setVersion(-versionOnUpdate);\n\n          if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.deleteByQuery(cmd);\n            return;\n          }\n\n          doLocalDelete(cmd);\n        }\n      }\n\n      // since we don't know which documents were deleted, the easiest thing to do is to invalidate\n      // all real-time caches (i.e. UpdateLog) which involves also getting a new version of the IndexReader\n      // (so cache misses will see up-to-date data)\n\n    } finally {\n      vinfo.unblockUpdates();\n    }\n  }\n\n","sourceOld":"  protected void versionDeleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    vinfo.blockUpdates();\n    try {\n\n      if (versionsStored) {\n        if (leaderLogic) {\n          long version = vinfo.getNewClock();\n          cmd.setVersion(-version);\n          // TODO update versions in all buckets\n\n          doLocalDelete(cmd);\n\n        } else {\n          cmd.setVersion(-versionOnUpdate);\n\n          if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.deleteByQuery(cmd);\n            return;\n          }\n\n          doLocalDelete(cmd);\n        }\n      }\n\n      // since we don't know which documents were deleted, the easiest thing to do is to invalidate\n      // all real-time caches (i.e. UpdateLog) which involves also getting a new version of the IndexReader\n      // (so cache misses will see up-to-date data)\n\n    } finally {\n      vinfo.unblockUpdates();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"be320990bdc77e643388fa801e75017f19289c42","date":1489477067,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDeleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDeleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  protected void versionDeleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    vinfo.blockUpdates();\n    try {\n\n      if (versionsStored) {\n        if (leaderLogic) {\n          long version = vinfo.getNewClock();\n          cmd.setVersion(-version);\n          // TODO update versions in all buckets\n\n          doLocalDelete(cmd);\n\n        } else {\n          cmd.setVersion(-versionOnUpdate);\n\n          if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.deleteByQuery(cmd);\n            return;\n          }\n\n          if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n\n          doLocalDelete(cmd);\n        }\n      }\n\n      // since we don't know which documents were deleted, the easiest thing to do is to invalidate\n      // all real-time caches (i.e. UpdateLog) which involves also getting a new version of the IndexReader\n      // (so cache misses will see up-to-date data)\n\n    } finally {\n      vinfo.unblockUpdates();\n    }\n  }\n\n","sourceOld":"  protected void versionDeleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    vinfo.blockUpdates();\n    try {\n\n      if (versionsStored) {\n        if (leaderLogic) {\n          long version = vinfo.getNewClock();\n          cmd.setVersion(-version);\n          // TODO update versions in all buckets\n\n          doLocalDelete(cmd);\n\n        } else {\n          cmd.setVersion(-versionOnUpdate);\n\n          if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.deleteByQuery(cmd);\n            return;\n          }\n\n          doLocalDelete(cmd);\n        }\n      }\n\n      // since we don't know which documents were deleted, the easiest thing to do is to invalidate\n      // all real-time caches (i.e. UpdateLog) which involves also getting a new version of the IndexReader\n      // (so cache misses will see up-to-date data)\n\n    } finally {\n      vinfo.unblockUpdates();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f996f8177b9204bdc92f7164460c6cefad9ac99a","date":1489482690,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDeleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDeleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  protected void versionDeleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    vinfo.blockUpdates();\n    try {\n\n      if (versionsStored) {\n        if (leaderLogic) {\n          long version = vinfo.getNewClock();\n          cmd.setVersion(-version);\n          // TODO update versions in all buckets\n\n          doLocalDelete(cmd);\n\n        } else {\n          cmd.setVersion(-versionOnUpdate);\n\n          if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.deleteByQuery(cmd);\n            return;\n          }\n\n          if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n\n          doLocalDelete(cmd);\n        }\n      }\n\n      // since we don't know which documents were deleted, the easiest thing to do is to invalidate\n      // all real-time caches (i.e. UpdateLog) which involves also getting a new version of the IndexReader\n      // (so cache misses will see up-to-date data)\n\n    } finally {\n      vinfo.unblockUpdates();\n    }\n  }\n\n","sourceOld":"  protected void versionDeleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    vinfo.blockUpdates();\n    try {\n\n      if (versionsStored) {\n        if (leaderLogic) {\n          long version = vinfo.getNewClock();\n          cmd.setVersion(-version);\n          // TODO update versions in all buckets\n\n          doLocalDelete(cmd);\n\n        } else {\n          cmd.setVersion(-versionOnUpdate);\n\n          if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.deleteByQuery(cmd);\n            return;\n          }\n\n          doLocalDelete(cmd);\n        }\n      }\n\n      // since we don't know which documents were deleted, the easiest thing to do is to invalidate\n      // all real-time caches (i.e. UpdateLog) which involves also getting a new version of the IndexReader\n      // (so cache misses will see up-to-date data)\n\n    } finally {\n      vinfo.unblockUpdates();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab68488225b6a6c357dda72ed11dedca9914a192","date":1490013111,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDeleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDeleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  protected void versionDeleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    vinfo.blockUpdates();\n    try {\n\n      if (versionsStored) {\n        if (leaderLogic) {\n          long version = vinfo.getNewClock();\n          cmd.setVersion(-version);\n          // TODO update versions in all buckets\n\n          doLocalDelete(cmd);\n\n        } else {\n          cmd.setVersion(-versionOnUpdate);\n\n          if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.deleteByQuery(cmd);\n            return;\n          }\n\n          if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n\n          doLocalDelete(cmd);\n        }\n      }\n\n      // since we don't know which documents were deleted, the easiest thing to do is to invalidate\n      // all real-time caches (i.e. UpdateLog) which involves also getting a new version of the IndexReader\n      // (so cache misses will see up-to-date data)\n\n    } finally {\n      vinfo.unblockUpdates();\n    }\n  }\n\n","sourceOld":"  protected void versionDeleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    vinfo.blockUpdates();\n    try {\n\n      if (versionsStored) {\n        if (leaderLogic) {\n          long version = vinfo.getNewClock();\n          cmd.setVersion(-version);\n          // TODO update versions in all buckets\n\n          doLocalDelete(cmd);\n\n        } else {\n          cmd.setVersion(-versionOnUpdate);\n\n          if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.deleteByQuery(cmd);\n            return;\n          }\n\n          doLocalDelete(cmd);\n        }\n      }\n\n      // since we don't know which documents were deleted, the easiest thing to do is to invalidate\n      // all real-time caches (i.e. UpdateLog) which involves also getting a new version of the IndexReader\n      // (so cache misses will see up-to-date data)\n\n    } finally {\n      vinfo.unblockUpdates();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6d2dadc1f5ca8703d8659f4964961f9967935d75","date":1490231750,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDeleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDeleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  protected void versionDeleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    vinfo.blockUpdates();\n    try {\n\n      if (versionsStored) {\n        if (leaderLogic) {\n          long version = vinfo.getNewClock();\n          cmd.setVersion(-version);\n          // TODO update versions in all buckets\n\n          doLocalDelete(cmd);\n\n        } else {\n          cmd.setVersion(-versionOnUpdate);\n\n          if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.deleteByQuery(cmd);\n            return;\n          }\n\n          if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n\n          doLocalDelete(cmd);\n        }\n      }\n\n      // since we don't know which documents were deleted, the easiest thing to do is to invalidate\n      // all real-time caches (i.e. UpdateLog) which involves also getting a new version of the IndexReader\n      // (so cache misses will see up-to-date data)\n\n    } finally {\n      vinfo.unblockUpdates();\n    }\n  }\n\n","sourceOld":"  protected void versionDeleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    vinfo.blockUpdates();\n    try {\n\n      if (versionsStored) {\n        if (leaderLogic) {\n          long version = vinfo.getNewClock();\n          cmd.setVersion(-version);\n          // TODO update versions in all buckets\n\n          doLocalDelete(cmd);\n\n        } else {\n          cmd.setVersion(-versionOnUpdate);\n\n          if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.deleteByQuery(cmd);\n            return;\n          }\n\n          if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n\n          doLocalDelete(cmd);\n        }\n      }\n\n      // since we don't know which documents were deleted, the easiest thing to do is to invalidate\n      // all real-time caches (i.e. UpdateLog) which involves also getting a new version of the IndexReader\n      // (so cache misses will see up-to-date data)\n\n    } finally {\n      vinfo.unblockUpdates();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e5fa6615014cd2288fe930f8c8bb726f9504961d","date":1490280013,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDeleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDeleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  protected void versionDeleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    vinfo.blockUpdates();\n    try {\n\n      if (versionsStored) {\n        if (leaderLogic) {\n          long version = vinfo.getNewClock();\n          cmd.setVersion(-version);\n          // TODO update versions in all buckets\n\n          doLocalDelete(cmd);\n\n        } else {\n          cmd.setVersion(-versionOnUpdate);\n\n          if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.deleteByQuery(cmd);\n            return;\n          }\n\n          if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n\n          doLocalDelete(cmd);\n        }\n      }\n\n      // since we don't know which documents were deleted, the easiest thing to do is to invalidate\n      // all real-time caches (i.e. UpdateLog) which involves also getting a new version of the IndexReader\n      // (so cache misses will see up-to-date data)\n\n    } finally {\n      vinfo.unblockUpdates();\n    }\n  }\n\n","sourceOld":"  protected void versionDeleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    vinfo.blockUpdates();\n    try {\n\n      if (versionsStored) {\n        if (leaderLogic) {\n          long version = vinfo.getNewClock();\n          cmd.setVersion(-version);\n          // TODO update versions in all buckets\n\n          doLocalDelete(cmd);\n\n        } else {\n          cmd.setVersion(-versionOnUpdate);\n\n          if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.deleteByQuery(cmd);\n            return;\n          }\n\n          if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n\n          doLocalDelete(cmd);\n        }\n      }\n\n      // since we don't know which documents were deleted, the easiest thing to do is to invalidate\n      // all real-time caches (i.e. UpdateLog) which involves also getting a new version of the IndexReader\n      // (so cache misses will see up-to-date data)\n\n    } finally {\n      vinfo.unblockUpdates();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61c45e99cf6676da48f19d7511c73712ad39402b","date":1495508331,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDeleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDeleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  protected void versionDeleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    vinfo.blockUpdates();\n    try {\n\n      if (versionsStored) {\n        if (leaderLogic) {\n          long version = vinfo.getNewClock();\n          cmd.setVersion(-version);\n          // TODO update versions in all buckets\n\n          doLocalDelete(cmd);\n\n        } else {\n          cmd.setVersion(-versionOnUpdate);\n\n          if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.deleteByQuery(cmd);\n            return;\n          }\n\n          if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            // TLOG replica not leader, don't write the DBQ to IW\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n          doLocalDelete(cmd);\n        }\n      }\n\n      // since we don't know which documents were deleted, the easiest thing to do is to invalidate\n      // all real-time caches (i.e. UpdateLog) which involves also getting a new version of the IndexReader\n      // (so cache misses will see up-to-date data)\n\n    } finally {\n      vinfo.unblockUpdates();\n    }\n  }\n\n","sourceOld":"  protected void versionDeleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    vinfo.blockUpdates();\n    try {\n\n      if (versionsStored) {\n        if (leaderLogic) {\n          long version = vinfo.getNewClock();\n          cmd.setVersion(-version);\n          // TODO update versions in all buckets\n\n          doLocalDelete(cmd);\n\n        } else {\n          cmd.setVersion(-versionOnUpdate);\n\n          if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.deleteByQuery(cmd);\n            return;\n          }\n\n          if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n\n          doLocalDelete(cmd);\n        }\n      }\n\n      // since we don't know which documents were deleted, the easiest thing to do is to invalidate\n      // all real-time caches (i.e. UpdateLog) which involves also getting a new version of the IndexReader\n      // (so cache misses will see up-to-date data)\n\n    } finally {\n      vinfo.unblockUpdates();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDeleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDeleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  protected void versionDeleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    vinfo.blockUpdates();\n    try {\n\n      if (versionsStored) {\n        if (leaderLogic) {\n          long version = vinfo.getNewClock();\n          cmd.setVersion(-version);\n          // TODO update versions in all buckets\n\n          doLocalDelete(cmd);\n\n        } else {\n          cmd.setVersion(-versionOnUpdate);\n\n          if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.deleteByQuery(cmd);\n            return;\n          }\n\n          if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            // TLOG replica not leader, don't write the DBQ to IW\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n          doLocalDelete(cmd);\n        }\n      }\n\n      // since we don't know which documents were deleted, the easiest thing to do is to invalidate\n      // all real-time caches (i.e. UpdateLog) which involves also getting a new version of the IndexReader\n      // (so cache misses will see up-to-date data)\n\n    } finally {\n      vinfo.unblockUpdates();\n    }\n  }\n\n","sourceOld":"  protected void versionDeleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    vinfo.blockUpdates();\n    try {\n\n      if (versionsStored) {\n        if (leaderLogic) {\n          long version = vinfo.getNewClock();\n          cmd.setVersion(-version);\n          // TODO update versions in all buckets\n\n          doLocalDelete(cmd);\n\n        } else {\n          cmd.setVersion(-versionOnUpdate);\n\n          if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.deleteByQuery(cmd);\n            return;\n          }\n\n          if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n\n          doLocalDelete(cmd);\n        }\n      }\n\n      // since we don't know which documents were deleted, the easiest thing to do is to invalidate\n      // all real-time caches (i.e. UpdateLog) which involves also getting a new version of the IndexReader\n      // (so cache misses will see up-to-date data)\n\n    } finally {\n      vinfo.unblockUpdates();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2ffc8d70d9f57a62a24c3dd15b66e353de935054","date":1533178472,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDeleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDeleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  protected void versionDeleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    vinfo.blockUpdates();\n    try {\n\n      if (versionsStored) {\n        if (leaderLogic) {\n          long version = vinfo.getNewClock();\n          cmd.setVersion(-version);\n          // TODO update versions in all buckets\n\n          doLocalDelete(cmd);\n\n        } else {\n          cmd.setVersion(-versionOnUpdate);\n\n          if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.deleteByQuery(cmd);\n            return;\n          }\n\n          if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            // TLOG replica not leader, don't write the DBQ to IW\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n          doLocalDelete(cmd);\n        }\n      }\n\n      // since we don't know which documents were deleted, the easiest thing to do is to invalidate\n      // all real-time caches (i.e. UpdateLog) which involves also getting a new version of the IndexReader\n      // (so cache misses will see up-to-date data)\n\n    } finally {\n      vinfo.unblockUpdates();\n    }\n  }\n\n","sourceOld":"  protected void versionDeleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    vinfo.blockUpdates();\n    try {\n\n      if (versionsStored) {\n        if (leaderLogic) {\n          long version = vinfo.getNewClock();\n          cmd.setVersion(-version);\n          // TODO update versions in all buckets\n\n          doLocalDelete(cmd);\n\n        } else {\n          cmd.setVersion(-versionOnUpdate);\n\n          if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.deleteByQuery(cmd);\n            return;\n          }\n\n          if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            // TLOG replica not leader, don't write the DBQ to IW\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n          doLocalDelete(cmd);\n        }\n      }\n\n      // since we don't know which documents were deleted, the easiest thing to do is to invalidate\n      // all real-time caches (i.e. UpdateLog) which involves also getting a new version of the IndexReader\n      // (so cache misses will see up-to-date data)\n\n    } finally {\n      vinfo.unblockUpdates();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"07749612bed4eb54dd05255c1434c301133310c1","date":1554879779,"type":3,"author":"Moshe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDeleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDeleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  protected void versionDeleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    // Find the version\n    long versionOnUpdate = findVersionOnUpdate(cmd);\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    vinfo.blockUpdates();\n    try {\n\n      doLocalDeleteByQuery(cmd, versionOnUpdate, isReplayOrPeersync);\n\n      // since we don't know which documents were deleted, the easiest thing to do is to invalidate\n      // all real-time caches (i.e. UpdateLog) which involves also getting a new version of the IndexReader\n      // (so cache misses will see up-to-date data)\n\n    } finally {\n      vinfo.unblockUpdates();\n    }\n  }\n\n","sourceOld":"  protected void versionDeleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    vinfo.blockUpdates();\n    try {\n\n      if (versionsStored) {\n        if (leaderLogic) {\n          long version = vinfo.getNewClock();\n          cmd.setVersion(-version);\n          // TODO update versions in all buckets\n\n          doLocalDelete(cmd);\n\n        } else {\n          cmd.setVersion(-versionOnUpdate);\n\n          if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n            // we're not in an active state, and this update isn't from a replay, so buffer it.\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n            ulog.deleteByQuery(cmd);\n            return;\n          }\n\n          if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n            // TLOG replica not leader, don't write the DBQ to IW\n            cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n          }\n          doLocalDelete(cmd);\n        }\n      }\n\n      // since we don't know which documents were deleted, the easiest thing to do is to invalidate\n      // all real-time caches (i.e. UpdateLog) which involves also getting a new version of the IndexReader\n      // (so cache misses will see up-to-date data)\n\n    } finally {\n      vinfo.unblockUpdates();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"61c45e99cf6676da48f19d7511c73712ad39402b":["6d2dadc1f5ca8703d8659f4964961f9967935d75"],"6d2dadc1f5ca8703d8659f4964961f9967935d75":["be320990bdc77e643388fa801e75017f19289c42"],"07749612bed4eb54dd05255c1434c301133310c1":["2ffc8d70d9f57a62a24c3dd15b66e353de935054"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["86290366cefc1b9d4eced13b430858c4a4c0421d","e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"e5fa6615014cd2288fe930f8c8bb726f9504961d":["ab68488225b6a6c357dda72ed11dedca9914a192"],"86290366cefc1b9d4eced13b430858c4a4c0421d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["e5fa6615014cd2288fe930f8c8bb726f9504961d","61c45e99cf6676da48f19d7511c73712ad39402b"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"4c835cc1a7b07477a469cdb1bf6c67bc05b85c07":["86290366cefc1b9d4eced13b430858c4a4c0421d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2ffc8d70d9f57a62a24c3dd15b66e353de935054":["61c45e99cf6676da48f19d7511c73712ad39402b"],"be320990bdc77e643388fa801e75017f19289c42":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"ab68488225b6a6c357dda72ed11dedca9914a192":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a","f996f8177b9204bdc92f7164460c6cefad9ac99a"],"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a":["86290366cefc1b9d4eced13b430858c4a4c0421d","4c835cc1a7b07477a469cdb1bf6c67bc05b85c07"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["07749612bed4eb54dd05255c1434c301133310c1"]},"commit2Childs":{"61c45e99cf6676da48f19d7511c73712ad39402b":["e9017cf144952056066919f1ebc7897ff9bd71b1","2ffc8d70d9f57a62a24c3dd15b66e353de935054"],"6d2dadc1f5ca8703d8659f4964961f9967935d75":["61c45e99cf6676da48f19d7511c73712ad39402b"],"07749612bed4eb54dd05255c1434c301133310c1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"e5fa6615014cd2288fe930f8c8bb726f9504961d":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"86290366cefc1b9d4eced13b430858c4a4c0421d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","4c835cc1a7b07477a469cdb1bf6c67bc05b85c07","e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["ab68488225b6a6c357dda72ed11dedca9914a192"],"4c835cc1a7b07477a469cdb1bf6c67bc05b85c07":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["86290366cefc1b9d4eced13b430858c4a4c0421d"],"be320990bdc77e643388fa801e75017f19289c42":["6d2dadc1f5ca8703d8659f4964961f9967935d75"],"2ffc8d70d9f57a62a24c3dd15b66e353de935054":["07749612bed4eb54dd05255c1434c301133310c1"],"ab68488225b6a6c357dda72ed11dedca9914a192":["e5fa6615014cd2288fe930f8c8bb726f9504961d"],"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","f996f8177b9204bdc92f7164460c6cefad9ac99a","be320990bdc77e643388fa801e75017f19289c42","ab68488225b6a6c357dda72ed11dedca9914a192"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}