{"path":"lucene/core/src/java/org/apache/lucene/index/ParallelCompositeReader#validate(CompositeReader[],int,int[]).mjava","commits":[{"id":"6e09a3a223be07d75777515a717312813221fe58","date":1328908385,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelCompositeReader#validate(CompositeReader[],int,int[]).mjava","pathOld":"/dev/null","sourceNew":"  private static void validate(CompositeReader[] readers, int maxDoc, int[] childMaxDoc) {\n    for (int i = 0; i < readers.length; i++) {\n      final CompositeReader reader = readers[i];\n      final IndexReader[] subs = reader.getSequentialSubReaders();\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n      if (subs.length != childMaxDoc.length) {\n        throw new IllegalArgumentException(\"All readers must have same number of subReaders\");\n      }\n      for (int subIDX = 0; subIDX < subs.length; subIDX++) {\n        if (subs[subIDX].maxDoc() != childMaxDoc[subIDX]) {\n          throw new IllegalArgumentException(\"All readers must have same subReader maxDoc\");\n        }\n      }\n    }    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8be807b98a5aab36b690a9bd4ef0e4b5d33b8689","date":1329492225,"type":5,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelCompositeReader#validate(CompositeReader[],int,int[],boolean[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelCompositeReader#validate(CompositeReader[],int,int[]).mjava","sourceNew":"  private static void validate(CompositeReader[] readers, int maxDoc, int[] childMaxDoc, boolean[] childAtomic) {\n    for (int i = 0; i < readers.length; i++) {\n      final CompositeReader reader = readers[i];\n      final IndexReader[] subs = reader.getSequentialSubReaders();\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n      if (subs.length != childMaxDoc.length) {\n        throw new IllegalArgumentException(\"All readers must have same number of subReaders\");\n      }\n      for (int subIDX = 0; subIDX < subs.length; subIDX++) {\n        if (subs[subIDX].maxDoc() != childMaxDoc[subIDX]) {\n          throw new IllegalArgumentException(\"All readers must have same corresponding subReader maxDoc\");\n        }\n        if (!(childAtomic[subIDX] ? (subs[subIDX] instanceof AtomicReader) : (subs[subIDX] instanceof CompositeReader))) {\n          throw new IllegalArgumentException(\"All readers must have same corresponding subReader types (atomic or composite)\");\n        }\n      }\n    }    \n  }\n\n","sourceOld":"  private static void validate(CompositeReader[] readers, int maxDoc, int[] childMaxDoc) {\n    for (int i = 0; i < readers.length; i++) {\n      final CompositeReader reader = readers[i];\n      final IndexReader[] subs = reader.getSequentialSubReaders();\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n      if (subs.length != childMaxDoc.length) {\n        throw new IllegalArgumentException(\"All readers must have same number of subReaders\");\n      }\n      for (int subIDX = 0; subIDX < subs.length; subIDX++) {\n        if (subs[subIDX].maxDoc() != childMaxDoc[subIDX]) {\n          throw new IllegalArgumentException(\"All readers must have same subReader maxDoc\");\n        }\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f6279d779b4584858af04f499e8aac0ae132c29","date":1432729989,"type":1,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelCompositeReader#validate(CompositeReader[],int,int[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelCompositeReader#validate(CompositeReader[],int,int[],boolean[]).mjava","sourceNew":"  private static void validate(CompositeReader[] readers, int maxDoc, int[] leafMaxDoc) {\n    for (int i = 0; i < readers.length; i++) {\n      final CompositeReader reader = readers[i];\n      final List<? extends LeafReaderContext> subs = reader.leaves();\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n      final int noSubs = subs.size();\n      if (noSubs != leafMaxDoc.length) {\n        throw new IllegalArgumentException(\"All readers must have same number of leaf readers\");\n      }\n      for (int subIDX = 0; subIDX < noSubs; subIDX++) {\n        final LeafReader r = subs.get(subIDX).reader();\n        if (r.maxDoc() != leafMaxDoc[subIDX]) {\n          throw new IllegalArgumentException(\"All leaf readers must have same corresponding subReader maxDoc\");\n        }\n      }\n    }    \n  }\n\n","sourceOld":"  private static void validate(CompositeReader[] readers, int maxDoc, int[] childMaxDoc, boolean[] childAtomic) {\n    for (int i = 0; i < readers.length; i++) {\n      final CompositeReader reader = readers[i];\n      final List<? extends IndexReader> subs = reader.getSequentialSubReaders();\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n      final int noSubs = subs.size();\n      if (noSubs != childMaxDoc.length) {\n        throw new IllegalArgumentException(\"All readers must have same number of subReaders\");\n      }\n      for (int subIDX = 0; subIDX < noSubs; subIDX++) {\n        final IndexReader r = subs.get(subIDX);\n        if (r.maxDoc() != childMaxDoc[subIDX]) {\n          throw new IllegalArgumentException(\"All readers must have same corresponding subReader maxDoc\");\n        }\n        if (!(childAtomic[subIDX] ? (r instanceof LeafReader) : (r instanceof CompositeReader))) {\n          throw new IllegalArgumentException(\"All readers must have same corresponding subReader types (atomic or composite)\");\n        }\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5f6279d779b4584858af04f499e8aac0ae132c29":["8be807b98a5aab36b690a9bd4ef0e4b5d33b8689"],"6e09a3a223be07d75777515a717312813221fe58":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8be807b98a5aab36b690a9bd4ef0e4b5d33b8689":["6e09a3a223be07d75777515a717312813221fe58"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5f6279d779b4584858af04f499e8aac0ae132c29"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6e09a3a223be07d75777515a717312813221fe58"],"5f6279d779b4584858af04f499e8aac0ae132c29":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6e09a3a223be07d75777515a717312813221fe58":["8be807b98a5aab36b690a9bd4ef0e4b5d33b8689"],"8be807b98a5aab36b690a9bd4ef0e4b5d33b8689":["5f6279d779b4584858af04f499e8aac0ae132c29"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}