{"path":"lucene/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node).mjava","commits":[{"id":"327863a2fd61e831028b6c56c8fef6b00a44eb0b","date":1302686439,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node).mjava","pathOld":"/dev/null","sourceNew":"  void add(Node item) {\n    /*\n     * this non-blocking / 'wait-free' linked list add was inspired by Apache\n     * Harmony's ConcurrentLinkedQueue Implementation.\n     */\n    while (true) {\n      final Node currentTail = this.tail;\n      final Node tailNext = currentTail.next;\n      if (tail == currentTail) {\n        if (tailNext != null) {\n          /*\n           * we are in intermediate state here. the tails next pointer has been\n           * advanced but the tail itself might not be updated yet. help to\n           * advance the tail and try again updating it.\n           */\n          tailUpdater.compareAndSet(this, currentTail, tailNext); // can fail\n        } else {\n          /*\n           * we are in quiescent state and can try to insert the item to the\n           * current tail if we fail to insert we just retry the operation since\n           * somebody else has already added its item\n           */\n          if (currentTail.casNext(null, item)) {\n            /*\n             * now that we are done we need to advance the tail while another\n             * thread could have advanced it already so we can ignore the return\n             * type of this CAS call\n             */\n            tailUpdater.compareAndSet(this, currentTail, item);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b3e06be49006ecac364d39d12b9c9f74882f9b9f","date":1304289513,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node).mjava","pathOld":"/dev/null","sourceNew":"  void add(Node item) {\n    /*\n     * this non-blocking / 'wait-free' linked list add was inspired by Apache\n     * Harmony's ConcurrentLinkedQueue Implementation.\n     */\n    while (true) {\n      final Node currentTail = this.tail;\n      final Node tailNext = currentTail.next;\n      if (tail == currentTail) {\n        if (tailNext != null) {\n          /*\n           * we are in intermediate state here. the tails next pointer has been\n           * advanced but the tail itself might not be updated yet. help to\n           * advance the tail and try again updating it.\n           */\n          tailUpdater.compareAndSet(this, currentTail, tailNext); // can fail\n        } else {\n          /*\n           * we are in quiescent state and can try to insert the item to the\n           * current tail if we fail to insert we just retry the operation since\n           * somebody else has already added its item\n           */\n          if (currentTail.casNext(null, item)) {\n            /*\n             * now that we are done we need to advance the tail while another\n             * thread could have advanced it already so we can ignore the return\n             * type of this CAS call\n             */\n            tailUpdater.compareAndSet(this, currentTail, item);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node).mjava","pathOld":"/dev/null","sourceNew":"  void add(Node item) {\n    /*\n     * this non-blocking / 'wait-free' linked list add was inspired by Apache\n     * Harmony's ConcurrentLinkedQueue Implementation.\n     */\n    while (true) {\n      final Node currentTail = this.tail;\n      final Node tailNext = currentTail.next;\n      if (tail == currentTail) {\n        if (tailNext != null) {\n          /*\n           * we are in intermediate state here. the tails next pointer has been\n           * advanced but the tail itself might not be updated yet. help to\n           * advance the tail and try again updating it.\n           */\n          tailUpdater.compareAndSet(this, currentTail, tailNext); // can fail\n        } else {\n          /*\n           * we are in quiescent state and can try to insert the item to the\n           * current tail if we fail to insert we just retry the operation since\n           * somebody else has already added its item\n           */\n          if (currentTail.casNext(null, item)) {\n            /*\n             * now that we are done we need to advance the tail while another\n             * thread could have advanced it already so we can ignore the return\n             * type of this CAS call\n             */\n            tailUpdater.compareAndSet(this, currentTail, item);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"142adfa88e132bc04810e7cc3a3bb3e9e5750777","date":1304693157,"type":5,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node).mjava","sourceNew":"  void add(Node<?> item) {\n    /*\n     * this non-blocking / 'wait-free' linked list add was inspired by Apache\n     * Harmony's ConcurrentLinkedQueue Implementation.\n     */\n    while (true) {\n      final Node<?> currentTail = this.tail;\n      final Node<?> tailNext = currentTail.next;\n      if (tail == currentTail) {\n        if (tailNext != null) {\n          /*\n           * we are in intermediate state here. the tails next pointer has been\n           * advanced but the tail itself might not be updated yet. help to\n           * advance the tail and try again updating it.\n           */\n          tailUpdater.compareAndSet(this, currentTail, tailNext); // can fail\n        } else {\n          /*\n           * we are in quiescent state and can try to insert the item to the\n           * current tail if we fail to insert we just retry the operation since\n           * somebody else has already added its item\n           */\n          if (currentTail.casNext(null, item)) {\n            /*\n             * now that we are done we need to advance the tail while another\n             * thread could have advanced it already so we can ignore the return\n             * type of this CAS call\n             */\n            tailUpdater.compareAndSet(this, currentTail, item);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  void add(Node item) {\n    /*\n     * this non-blocking / 'wait-free' linked list add was inspired by Apache\n     * Harmony's ConcurrentLinkedQueue Implementation.\n     */\n    while (true) {\n      final Node currentTail = this.tail;\n      final Node tailNext = currentTail.next;\n      if (tail == currentTail) {\n        if (tailNext != null) {\n          /*\n           * we are in intermediate state here. the tails next pointer has been\n           * advanced but the tail itself might not be updated yet. help to\n           * advance the tail and try again updating it.\n           */\n          tailUpdater.compareAndSet(this, currentTail, tailNext); // can fail\n        } else {\n          /*\n           * we are in quiescent state and can try to insert the item to the\n           * current tail if we fail to insert we just retry the operation since\n           * somebody else has already added its item\n           */\n          if (currentTail.casNext(null, item)) {\n            /*\n             * now that we are done we need to advance the tail while another\n             * thread could have advanced it already so we can ignore the return\n             * type of this CAS call\n             */\n            tailUpdater.compareAndSet(this, currentTail, item);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c700f8d0842d3e52bb2bdfbfdc046a137e836edb","date":1305285499,"type":5,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node[#]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#add(Node).mjava","sourceNew":"  void add(Node<?> item) {\n    /*\n     * this non-blocking / 'wait-free' linked list add was inspired by Apache\n     * Harmony's ConcurrentLinkedQueue Implementation.\n     */\n    while (true) {\n      final Node<?> currentTail = this.tail;\n      final Node<?> tailNext = currentTail.next;\n      if (tail == currentTail) {\n        if (tailNext != null) {\n          /*\n           * we are in intermediate state here. the tails next pointer has been\n           * advanced but the tail itself might not be updated yet. help to\n           * advance the tail and try again updating it.\n           */\n          tailUpdater.compareAndSet(this, currentTail, tailNext); // can fail\n        } else {\n          /*\n           * we are in quiescent state and can try to insert the item to the\n           * current tail if we fail to insert we just retry the operation since\n           * somebody else has already added its item\n           */\n          if (currentTail.casNext(null, item)) {\n            /*\n             * now that we are done we need to advance the tail while another\n             * thread could have advanced it already so we can ignore the return\n             * type of this CAS call\n             */\n            tailUpdater.compareAndSet(this, currentTail, item);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  void add(Node item) {\n    /*\n     * this non-blocking / 'wait-free' linked list add was inspired by Apache\n     * Harmony's ConcurrentLinkedQueue Implementation.\n     */\n    while (true) {\n      final Node currentTail = this.tail;\n      final Node tailNext = currentTail.next;\n      if (tail == currentTail) {\n        if (tailNext != null) {\n          /*\n           * we are in intermediate state here. the tails next pointer has been\n           * advanced but the tail itself might not be updated yet. help to\n           * advance the tail and try again updating it.\n           */\n          tailUpdater.compareAndSet(this, currentTail, tailNext); // can fail\n        } else {\n          /*\n           * we are in quiescent state and can try to insert the item to the\n           * current tail if we fail to insert we just retry the operation since\n           * somebody else has already added its item\n           */\n          if (currentTail.casNext(null, item)) {\n            /*\n             * now that we are done we need to advance the tail while another\n             * thread could have advanced it already so we can ignore the return\n             * type of this CAS call\n             */\n            tailUpdater.compareAndSet(this, currentTail, item);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"142adfa88e132bc04810e7cc3a3bb3e9e5750777":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","327863a2fd61e831028b6c56c8fef6b00a44eb0b"],"c700f8d0842d3e52bb2bdfbfdc046a137e836edb":["135621f3a0670a9394eb563224a3b76cc4dddc0f","142adfa88e132bc04810e7cc3a3bb3e9e5750777"],"327863a2fd61e831028b6c56c8fef6b00a44eb0b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["142adfa88e132bc04810e7cc3a3bb3e9e5750777"]},"commit2Childs":{"142adfa88e132bc04810e7cc3a3bb3e9e5750777":["c700f8d0842d3e52bb2bdfbfdc046a137e836edb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["135621f3a0670a9394eb563224a3b76cc4dddc0f","b3e06be49006ecac364d39d12b9c9f74882f9b9f","327863a2fd61e831028b6c56c8fef6b00a44eb0b"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["c700f8d0842d3e52bb2bdfbfdc046a137e836edb"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["142adfa88e132bc04810e7cc3a3bb3e9e5750777","135621f3a0670a9394eb563224a3b76cc4dddc0f"],"c700f8d0842d3e52bb2bdfbfdc046a137e836edb":[],"327863a2fd61e831028b6c56c8fef6b00a44eb0b":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c700f8d0842d3e52bb2bdfbfdc046a137e836edb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}