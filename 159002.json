{"path":"src/java/org/apache/lucene/index/IndexWriter#deleteSegments(Vector).mjava","commits":[{"id":"91109046a59c58ee0ee5d0d2767b08d1f30d6702","date":1000830588,"type":0,"author":"Jason van Zyl","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#deleteSegments(Vector).mjava","pathOld":"/dev/null","sourceNew":"  private final void deleteSegments(Vector segments) throws IOException {\n    Vector deletable = new Vector();\n\n    deleteFiles(readDeleteableFiles(), deletable); // try to delete deleteable\n    \n    for (int i = 0; i < segments.size(); i++) {\n      SegmentReader reader = (SegmentReader)segments.elementAt(i);\n      if (reader.directory == this.directory)\n\tdeleteFiles(reader.files(), deletable);\t  // try to delete our files\n      else\n\tdeleteFiles(reader.files(), reader.directory); // delete, eg, RAM files\n    }\n\n    writeDeleteableFiles(deletable);\t\t  // note files we can't delete\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8ac4052920fcd27b00a09b0f354a72da109d5d01","date":1049855256,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#deleteSegments(Vector).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#deleteSegments(Vector).mjava","sourceNew":"  private final void deleteSegments(Vector segments) throws IOException {\n    Vector deletable = new Vector();\n\n    deleteFiles(readDeleteableFiles(), deletable); // try to delete deleteable\n\n    for (int i = 0; i < segments.size(); i++) {\n      SegmentReader reader = (SegmentReader)segments.elementAt(i);\n      if (reader.directory == this.directory)\n\tdeleteFiles(reader.files(), deletable);\t  // try to delete our files\n      else\n\tdeleteFiles(reader.files(), reader.directory); // delete, eg, RAM files\n    }\n\n    writeDeleteableFiles(deletable);\t\t  // note files we can't delete\n  }\n\n","sourceOld":"  private final void deleteSegments(Vector segments) throws IOException {\n    Vector deletable = new Vector();\n\n    deleteFiles(readDeleteableFiles(), deletable); // try to delete deleteable\n    \n    for (int i = 0; i < segments.size(); i++) {\n      SegmentReader reader = (SegmentReader)segments.elementAt(i);\n      if (reader.directory == this.directory)\n\tdeleteFiles(reader.files(), deletable);\t  // try to delete our files\n      else\n\tdeleteFiles(reader.files(), reader.directory); // delete, eg, RAM files\n    }\n\n    writeDeleteableFiles(deletable);\t\t  // note files we can't delete\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8fb95844e4ba5160067c64c5eb1cd8a09f7a94f1","date":1064527311,"type":3,"author":"Dmitry Serebrennikov","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#deleteSegments(Vector).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#deleteSegments(Vector).mjava","sourceNew":"  private final void deleteSegments(Vector segments) throws IOException {\n    Vector deletable = new Vector();\n\n    deleteFiles(readDeleteableFiles(), deletable); // try to delete deleteable\n\n    for (int i = 0; i < segments.size(); i++) {\n      SegmentReader reader = (SegmentReader)segments.elementAt(i);\n      if (reader.directory == this.directory)\n        deleteFiles(reader.files(), deletable);\t  // try to delete our files\n      else\n        deleteFiles(reader.files(), reader.directory); // delete, eg, RAM files\n    }\n\n    writeDeleteableFiles(deletable);\t\t  // note files we can't delete\n  }\n\n","sourceOld":"  private final void deleteSegments(Vector segments) throws IOException {\n    Vector deletable = new Vector();\n\n    deleteFiles(readDeleteableFiles(), deletable); // try to delete deleteable\n\n    for (int i = 0; i < segments.size(); i++) {\n      SegmentReader reader = (SegmentReader)segments.elementAt(i);\n      if (reader.directory == this.directory)\n\tdeleteFiles(reader.files(), deletable);\t  // try to delete our files\n      else\n\tdeleteFiles(reader.files(), reader.directory); // delete, eg, RAM files\n    }\n\n    writeDeleteableFiles(deletable);\t\t  // note files we can't delete\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7fb6d70db034a5456ae560175dd1b821eea9ff4","date":1066759157,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#deleteSegments(Vector).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#deleteSegments(Vector).mjava","sourceNew":"  private final void deleteSegments(Vector segments) throws IOException {\n    Vector deletable = new Vector();\n\n    deleteFiles(readDeleteableFiles(), deletable); // try to delete deleteable\n\n    for (int i = 0; i < segments.size(); i++) {\n      SegmentReader reader = (SegmentReader)segments.elementAt(i);\n      if (reader.directory() == this.directory)\n\tdeleteFiles(reader.files(), deletable);\t  // try to delete our files\n      else\n\tdeleteFiles(reader.files(), reader.directory()); // delete other files\n    }\n\n    writeDeleteableFiles(deletable);\t\t  // note files we can't delete\n  }\n\n","sourceOld":"  private final void deleteSegments(Vector segments) throws IOException {\n    Vector deletable = new Vector();\n\n    deleteFiles(readDeleteableFiles(), deletable); // try to delete deleteable\n\n    for (int i = 0; i < segments.size(); i++) {\n      SegmentReader reader = (SegmentReader)segments.elementAt(i);\n      if (reader.directory == this.directory)\n        deleteFiles(reader.files(), deletable);\t  // try to delete our files\n      else\n        deleteFiles(reader.files(), reader.directory); // delete, eg, RAM files\n    }\n\n    writeDeleteableFiles(deletable);\t\t  // note files we can't delete\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a2ebafe4b791cc3938e53b13379dc7b19ba1f75","date":1110599454,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#deleteSegments(Vector).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#deleteSegments(Vector).mjava","sourceNew":"  private final void deleteSegments(Vector segments) throws IOException {\n    Vector deletable = new Vector();\n\n    deleteFiles(readDeleteableFiles(), deletable); // try to delete deleteable\n\n    for (int i = 0; i < segments.size(); i++) {\n      SegmentReader reader = (SegmentReader)segments.elementAt(i);\n      if (reader.directory() == this.directory)\n        deleteFiles(reader.files(), deletable);\t  // try to delete our files\n      else\n        deleteFiles(reader.files(), reader.directory()); // delete other files\n    }\n\n    writeDeleteableFiles(deletable);\t\t  // note files we can't delete\n  }\n\n","sourceOld":"  private final void deleteSegments(Vector segments) throws IOException {\n    Vector deletable = new Vector();\n\n    deleteFiles(readDeleteableFiles(), deletable); // try to delete deleteable\n\n    for (int i = 0; i < segments.size(); i++) {\n      SegmentReader reader = (SegmentReader)segments.elementAt(i);\n      if (reader.directory() == this.directory)\n\tdeleteFiles(reader.files(), deletable);\t  // try to delete our files\n      else\n\tdeleteFiles(reader.files(), reader.directory()); // delete other files\n    }\n\n    writeDeleteableFiles(deletable);\t\t  // note files we can't delete\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1507a324c1f939ed71e01297733a49b9c36e5688","date":1155783141,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#deleteSegments(Vector).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#deleteSegments(Vector).mjava","sourceNew":"  /***\n  private synchronized void testInvariants() {\n    // index segments should decrease in size\n    int maxSegLevel = 0;\n    for (int i=segmentInfos.size()-1; i>=0; i--) {\n      SegmentInfo si = segmentInfos.info(i);\n      int segLevel = (si.docCount)/minMergeDocs;\n      if (segLevel < maxSegLevel) {\n\n        throw new RuntimeException(\"Segment #\" + i + \" is too small. \" + segInfo());\n      }\n      maxSegLevel = Math.max(maxSegLevel,segLevel);\n    }\n\n    // check if merges needed\n    long targetMergeDocs = minMergeDocs;\n    int minSegment = segmentInfos.size();\n\n    while (targetMergeDocs <= maxMergeDocs && minSegment>=0) {\n      int mergeDocs = 0;\n      while (--minSegment >= 0) {\n        SegmentInfo si = segmentInfos.info(minSegment);\n        if (si.docCount >= targetMergeDocs) break;\n        mergeDocs += si.docCount;\n      }\n\n      if (mergeDocs >= targetMergeDocs) {\n        throw new RuntimeException(\"Merge needed at level \"+targetMergeDocs + \" :\"+segInfo());\n      }\n\n      targetMergeDocs *= mergeFactor;\t\t  // increase target size\n    }\n  }\n\n  private String segInfo() {\n    StringBuffer sb = new StringBuffer(\"minMergeDocs=\"+minMergeDocs+\" singleDocSegmentsCount=\"+singleDocSegmentsCount+\" segsizes:\");\n    for (int i=0; i<segmentInfos.size(); i++) {\n      sb.append(segmentInfos.info(i).docCount);\n      sb.append(\",\");\n    }\n    return sb.toString();\n  }\n  ***/\n\n  /*\n   * Some operating systems (e.g. Windows) don't permit a file to be deleted\n   * while it is opened for read (e.g. by another process or thread). So we\n   * assume that when a delete fails it is because the file is open in another\n   * process, and queue the file for subsequent deletion.\n   */\n\n  private final void deleteSegments(Vector segments) throws IOException {\n    Vector deletable = new Vector();\n\n    deleteFiles(readDeleteableFiles(), deletable); // try to delete deleteable\n\n    for (int i = 0; i < segments.size(); i++) {\n      SegmentReader reader = (SegmentReader)segments.elementAt(i);\n      if (reader.directory() == this.directory)\n        deleteFiles(reader.files(), deletable);\t  // try to delete our files\n      else\n        deleteFiles(reader.files(), reader.directory()); // delete other files\n    }\n\n    writeDeleteableFiles(deletable);\t\t  // note files we can't delete\n  }\n\n","sourceOld":"  private final void deleteSegments(Vector segments) throws IOException {\n    Vector deletable = new Vector();\n\n    deleteFiles(readDeleteableFiles(), deletable); // try to delete deleteable\n\n    for (int i = 0; i < segments.size(); i++) {\n      SegmentReader reader = (SegmentReader)segments.elementAt(i);\n      if (reader.directory() == this.directory)\n        deleteFiles(reader.files(), deletable);\t  // try to delete our files\n      else\n        deleteFiles(reader.files(), reader.directory()); // delete other files\n    }\n\n    writeDeleteableFiles(deletable);\t\t  // note files we can't delete\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d7052f725a053aa55424f966831826f61b798bf1","date":1158258681,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#deleteSegments(Vector).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#deleteSegments(Vector).mjava","sourceNew":"  private final void deleteSegments(Vector segments) throws IOException {\n    Vector deletable = new Vector();\n\n    deleteFiles(readDeleteableFiles(), deletable); // try to delete deleteable\n\n    for (int i = 0; i < segments.size(); i++) {\n      SegmentReader reader = (SegmentReader)segments.elementAt(i);\n      if (reader.directory() == this.directory)\n        deleteFiles(reader.files(), deletable);\t  // try to delete our files\n      else\n        deleteFiles(reader.files(), reader.directory()); // delete other files\n    }\n\n    writeDeleteableFiles(deletable);\t\t  // note files we can't delete\n  }\n\n","sourceOld":"  /***\n  private synchronized void testInvariants() {\n    // index segments should decrease in size\n    int maxSegLevel = 0;\n    for (int i=segmentInfos.size()-1; i>=0; i--) {\n      SegmentInfo si = segmentInfos.info(i);\n      int segLevel = (si.docCount)/minMergeDocs;\n      if (segLevel < maxSegLevel) {\n\n        throw new RuntimeException(\"Segment #\" + i + \" is too small. \" + segInfo());\n      }\n      maxSegLevel = Math.max(maxSegLevel,segLevel);\n    }\n\n    // check if merges needed\n    long targetMergeDocs = minMergeDocs;\n    int minSegment = segmentInfos.size();\n\n    while (targetMergeDocs <= maxMergeDocs && minSegment>=0) {\n      int mergeDocs = 0;\n      while (--minSegment >= 0) {\n        SegmentInfo si = segmentInfos.info(minSegment);\n        if (si.docCount >= targetMergeDocs) break;\n        mergeDocs += si.docCount;\n      }\n\n      if (mergeDocs >= targetMergeDocs) {\n        throw new RuntimeException(\"Merge needed at level \"+targetMergeDocs + \" :\"+segInfo());\n      }\n\n      targetMergeDocs *= mergeFactor;\t\t  // increase target size\n    }\n  }\n\n  private String segInfo() {\n    StringBuffer sb = new StringBuffer(\"minMergeDocs=\"+minMergeDocs+\" singleDocSegmentsCount=\"+singleDocSegmentsCount+\" segsizes:\");\n    for (int i=0; i<segmentInfos.size(); i++) {\n      sb.append(segmentInfos.info(i).docCount);\n      sb.append(\",\");\n    }\n    return sb.toString();\n  }\n  ***/\n\n  /*\n   * Some operating systems (e.g. Windows) don't permit a file to be deleted\n   * while it is opened for read (e.g. by another process or thread). So we\n   * assume that when a delete fails it is because the file is open in another\n   * process, and queue the file for subsequent deletion.\n   */\n\n  private final void deleteSegments(Vector segments) throws IOException {\n    Vector deletable = new Vector();\n\n    deleteFiles(readDeleteableFiles(), deletable); // try to delete deleteable\n\n    for (int i = 0; i < segments.size(); i++) {\n      SegmentReader reader = (SegmentReader)segments.elementAt(i);\n      if (reader.directory() == this.directory)\n        deleteFiles(reader.files(), deletable);\t  // try to delete our files\n      else\n        deleteFiles(reader.files(), reader.directory()); // delete other files\n    }\n\n    writeDeleteableFiles(deletable);\t\t  // note files we can't delete\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"284c1d3c8b19931bf6f312fae7470487f5d9e580","date":1163805527,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexFileDeleter#deleteSegments(Vector).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#deleteSegments(Vector).mjava","sourceNew":"  public final void deleteSegments(Vector segments) throws IOException {\n\n    deleteFiles();                                // try to delete files that we couldn't before\n\n    for (int i = 0; i < segments.size(); i++) {\n      SegmentReader reader = (SegmentReader)segments.elementAt(i);\n      if (reader.directory() == this.directory)\n        deleteFiles(reader.files()); // try to delete our files\n      else\n        deleteFiles(reader.files(), reader.directory()); // delete other files\n    }\n  }\n\n","sourceOld":"  private final void deleteSegments(Vector segments) throws IOException {\n    Vector deletable = new Vector();\n\n    deleteFiles(readDeleteableFiles(), deletable); // try to delete deleteable\n\n    for (int i = 0; i < segments.size(); i++) {\n      SegmentReader reader = (SegmentReader)segments.elementAt(i);\n      if (reader.directory() == this.directory)\n        deleteFiles(reader.files(), deletable);\t  // try to delete our files\n      else\n        deleteFiles(reader.files(), reader.directory()); // delete other files\n    }\n\n    writeDeleteableFiles(deletable);\t\t  // note files we can't delete\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d7052f725a053aa55424f966831826f61b798bf1":["1507a324c1f939ed71e01297733a49b9c36e5688"],"8ac4052920fcd27b00a09b0f354a72da109d5d01":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"],"91109046a59c58ee0ee5d0d2767b08d1f30d6702":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"284c1d3c8b19931bf6f312fae7470487f5d9e580":["d7052f725a053aa55424f966831826f61b798bf1"],"e7fb6d70db034a5456ae560175dd1b821eea9ff4":["8fb95844e4ba5160067c64c5eb1cd8a09f7a94f1"],"1507a324c1f939ed71e01297733a49b9c36e5688":["7a2ebafe4b791cc3938e53b13379dc7b19ba1f75"],"7a2ebafe4b791cc3938e53b13379dc7b19ba1f75":["e7fb6d70db034a5456ae560175dd1b821eea9ff4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8fb95844e4ba5160067c64c5eb1cd8a09f7a94f1":["8ac4052920fcd27b00a09b0f354a72da109d5d01"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["284c1d3c8b19931bf6f312fae7470487f5d9e580"]},"commit2Childs":{"d7052f725a053aa55424f966831826f61b798bf1":["284c1d3c8b19931bf6f312fae7470487f5d9e580"],"8ac4052920fcd27b00a09b0f354a72da109d5d01":["8fb95844e4ba5160067c64c5eb1cd8a09f7a94f1"],"91109046a59c58ee0ee5d0d2767b08d1f30d6702":["8ac4052920fcd27b00a09b0f354a72da109d5d01"],"284c1d3c8b19931bf6f312fae7470487f5d9e580":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e7fb6d70db034a5456ae560175dd1b821eea9ff4":["7a2ebafe4b791cc3938e53b13379dc7b19ba1f75"],"1507a324c1f939ed71e01297733a49b9c36e5688":["d7052f725a053aa55424f966831826f61b798bf1"],"7a2ebafe4b791cc3938e53b13379dc7b19ba1f75":["1507a324c1f939ed71e01297733a49b9c36e5688"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"],"8fb95844e4ba5160067c64c5eb1cd8a09f7a94f1":["e7fb6d70db034a5456ae560175dd1b821eea9ff4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}