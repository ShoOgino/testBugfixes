{"path":"lucene/facet/src/java/org/apache/lucene/facet/associations/AssociationsListBuilder#build(IntsRef,Iterable[CategoryPath]).mjava","commits":[{"id":"bceb02c33032dd9bbf107cd06d0b74e5db4f110a","date":1357909746,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/associations/AssociationsListBuilder#build(IntsRef,Iterable[CategoryPath]).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Map<String,BytesRef> build(IntsRef ordinals, Iterable<CategoryPath> categories) throws IOException {\n    final HashMap<String,BytesRef> res = new HashMap<String,BytesRef>();\n    int idx = 0;\n    for (CategoryPath cp : categories) {\n      // build per-association key BytesRef\n      CategoryAssociation association = associations.getAssociation(cp);\n      \n      if (association == null) {\n        // it is ok to set a null association for a category - it's treated as a\n        // regular category in that case.\n        ++idx;\n        continue;\n      }\n\n      BytesRef bytes = res.get(association.getCategoryListID());\n      if (bytes == null) {\n        bytes = new BytesRef(32);\n        res.put(association.getCategoryListID(), bytes);\n      }\n      \n      int maxBytesNeeded = 4 /* int */ + association.maxBytesNeeded() + bytes.length;\n      if (bytes.bytes.length < maxBytesNeeded) {\n        bytes.grow(maxBytesNeeded);\n      }\n      \n      // reset the output to write from bytes.length (current position) until the end\n      output.reset(bytes.bytes, bytes.length, bytes.bytes.length - bytes.length);\n      output.writeInt(ordinals.ints[idx++]);\n      \n      // encode the association bytes\n      association.serialize(output);\n      \n      // update BytesRef\n      bytes.length = output.getPosition();\n    }\n\n    return res;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["c4c0c02bba324d871be523a32f441ebdb835ca9a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4e6354dd7c71fe122926fc53d7d29f715b1283db","date":1357915185,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/associations/AssociationsListBuilder#build(IntsRef,Iterable[CategoryPath]).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Map<String,BytesRef> build(IntsRef ordinals, Iterable<CategoryPath> categories) throws IOException {\n    final HashMap<String,BytesRef> res = new HashMap<String,BytesRef>();\n    int idx = 0;\n    for (CategoryPath cp : categories) {\n      // build per-association key BytesRef\n      CategoryAssociation association = associations.getAssociation(cp);\n      \n      if (association == null) {\n        // it is ok to set a null association for a category - it's treated as a\n        // regular category in that case.\n        ++idx;\n        continue;\n      }\n\n      BytesRef bytes = res.get(association.getCategoryListID());\n      if (bytes == null) {\n        bytes = new BytesRef(32);\n        res.put(association.getCategoryListID(), bytes);\n      }\n      \n      int maxBytesNeeded = 4 /* int */ + association.maxBytesNeeded() + bytes.length;\n      if (bytes.bytes.length < maxBytesNeeded) {\n        bytes.grow(maxBytesNeeded);\n      }\n      \n      // reset the output to write from bytes.length (current position) until the end\n      output.reset(bytes.bytes, bytes.length, bytes.bytes.length - bytes.length);\n      output.writeInt(ordinals.ints[idx++]);\n      \n      // encode the association bytes\n      association.serialize(output);\n      \n      // update BytesRef\n      bytes.length = output.getPosition();\n    }\n\n    return res;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c4c0c02bba324d871be523a32f441ebdb835ca9a","date":1374669770,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/associations/AssociationsListBuilder#build(IntsRef,Iterable[CategoryPath]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/associations/AssociationsListBuilder#build(IntsRef,Iterable[CategoryPath]).mjava","sourceNew":"  @Override\n  public Map<String,BytesRef> build(IntsRef ordinals, Iterable<CategoryPath> categories) throws IOException {\n    final HashMap<String,BytesRef> res = new HashMap<String,BytesRef>();\n    int idx = 0;\n    for (CategoryPath cp : categories) {\n      // build per-association key BytesRef\n      CategoryAssociation association = associations.getAssociation(cp);\n      \n      BytesRef bytes = res.get(association.getCategoryListID());\n      if (bytes == null) {\n        bytes = new BytesRef(32);\n        res.put(association.getCategoryListID(), bytes);\n      }\n      \n      int maxBytesNeeded = 4 /* int */ + association.maxBytesNeeded() + bytes.length;\n      if (bytes.bytes.length < maxBytesNeeded) {\n        bytes.grow(maxBytesNeeded);\n      }\n      \n      // reset the output to write from bytes.length (current position) until the end\n      output.reset(bytes.bytes, bytes.length, bytes.bytes.length - bytes.length);\n      output.writeInt(ordinals.ints[idx++]);\n      \n      // encode the association bytes\n      association.serialize(output);\n      \n      // update BytesRef\n      bytes.length = output.getPosition();\n    }\n\n    return res;\n  }\n\n","sourceOld":"  @Override\n  public Map<String,BytesRef> build(IntsRef ordinals, Iterable<CategoryPath> categories) throws IOException {\n    final HashMap<String,BytesRef> res = new HashMap<String,BytesRef>();\n    int idx = 0;\n    for (CategoryPath cp : categories) {\n      // build per-association key BytesRef\n      CategoryAssociation association = associations.getAssociation(cp);\n      \n      if (association == null) {\n        // it is ok to set a null association for a category - it's treated as a\n        // regular category in that case.\n        ++idx;\n        continue;\n      }\n\n      BytesRef bytes = res.get(association.getCategoryListID());\n      if (bytes == null) {\n        bytes = new BytesRef(32);\n        res.put(association.getCategoryListID(), bytes);\n      }\n      \n      int maxBytesNeeded = 4 /* int */ + association.maxBytesNeeded() + bytes.length;\n      if (bytes.bytes.length < maxBytesNeeded) {\n        bytes.grow(maxBytesNeeded);\n      }\n      \n      // reset the output to write from bytes.length (current position) until the end\n      output.reset(bytes.bytes, bytes.length, bytes.bytes.length - bytes.length);\n      output.writeInt(ordinals.ints[idx++]);\n      \n      // encode the association bytes\n      association.serialize(output);\n      \n      // update BytesRef\n      bytes.length = output.getPosition();\n    }\n\n    return res;\n  }\n\n","bugFix":["bceb02c33032dd9bbf107cd06d0b74e5db4f110a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/associations/AssociationsListBuilder#build(IntsRef,Iterable[CategoryPath]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/associations/AssociationsListBuilder#build(IntsRef,Iterable[CategoryPath]).mjava","sourceNew":"  @Override\n  public Map<String,BytesRef> build(IntsRef ordinals, Iterable<CategoryPath> categories) throws IOException {\n    final HashMap<String,BytesRef> res = new HashMap<String,BytesRef>();\n    int idx = 0;\n    for (CategoryPath cp : categories) {\n      // build per-association key BytesRef\n      CategoryAssociation association = associations.getAssociation(cp);\n      \n      BytesRef bytes = res.get(association.getCategoryListID());\n      if (bytes == null) {\n        bytes = new BytesRef(32);\n        res.put(association.getCategoryListID(), bytes);\n      }\n      \n      int maxBytesNeeded = 4 /* int */ + association.maxBytesNeeded() + bytes.length;\n      if (bytes.bytes.length < maxBytesNeeded) {\n        bytes.grow(maxBytesNeeded);\n      }\n      \n      // reset the output to write from bytes.length (current position) until the end\n      output.reset(bytes.bytes, bytes.length, bytes.bytes.length - bytes.length);\n      output.writeInt(ordinals.ints[idx++]);\n      \n      // encode the association bytes\n      association.serialize(output);\n      \n      // update BytesRef\n      bytes.length = output.getPosition();\n    }\n\n    return res;\n  }\n\n","sourceOld":"  @Override\n  public Map<String,BytesRef> build(IntsRef ordinals, Iterable<CategoryPath> categories) throws IOException {\n    final HashMap<String,BytesRef> res = new HashMap<String,BytesRef>();\n    int idx = 0;\n    for (CategoryPath cp : categories) {\n      // build per-association key BytesRef\n      CategoryAssociation association = associations.getAssociation(cp);\n      \n      if (association == null) {\n        // it is ok to set a null association for a category - it's treated as a\n        // regular category in that case.\n        ++idx;\n        continue;\n      }\n\n      BytesRef bytes = res.get(association.getCategoryListID());\n      if (bytes == null) {\n        bytes = new BytesRef(32);\n        res.put(association.getCategoryListID(), bytes);\n      }\n      \n      int maxBytesNeeded = 4 /* int */ + association.maxBytesNeeded() + bytes.length;\n      if (bytes.bytes.length < maxBytesNeeded) {\n        bytes.grow(maxBytesNeeded);\n      }\n      \n      // reset the output to write from bytes.length (current position) until the end\n      output.reset(bytes.bytes, bytes.length, bytes.bytes.length - bytes.length);\n      output.writeInt(ordinals.ints[idx++]);\n      \n      // encode the association bytes\n      association.serialize(output);\n      \n      // update BytesRef\n      bytes.length = output.getPosition();\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c190847801a50f4dd20fd639bdc29b54ea3b288b","date":1384461522,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/associations/AssociationsListBuilder#build(IntsRef,Iterable[FacetLabel]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/associations/AssociationsListBuilder#build(IntsRef,Iterable[CategoryPath]).mjava","sourceNew":"  @Override\n  public Map<String,BytesRef> build(IntsRef ordinals, Iterable<FacetLabel> categories) throws IOException {\n    final HashMap<String,BytesRef> res = new HashMap<String,BytesRef>();\n    int idx = 0;\n    for (FacetLabel cp : categories) {\n      // build per-association key BytesRef\n      CategoryAssociation association = associations.getAssociation(cp);\n      \n      BytesRef bytes = res.get(association.getCategoryListID());\n      if (bytes == null) {\n        bytes = new BytesRef(32);\n        res.put(association.getCategoryListID(), bytes);\n      }\n      \n      int maxBytesNeeded = 4 /* int */ + association.maxBytesNeeded() + bytes.length;\n      if (bytes.bytes.length < maxBytesNeeded) {\n        bytes.grow(maxBytesNeeded);\n      }\n      \n      // reset the output to write from bytes.length (current position) until the end\n      output.reset(bytes.bytes, bytes.length, bytes.bytes.length - bytes.length);\n      output.writeInt(ordinals.ints[idx++]);\n      \n      // encode the association bytes\n      association.serialize(output);\n      \n      // update BytesRef\n      bytes.length = output.getPosition();\n    }\n\n    return res;\n  }\n\n","sourceOld":"  @Override\n  public Map<String,BytesRef> build(IntsRef ordinals, Iterable<CategoryPath> categories) throws IOException {\n    final HashMap<String,BytesRef> res = new HashMap<String,BytesRef>();\n    int idx = 0;\n    for (CategoryPath cp : categories) {\n      // build per-association key BytesRef\n      CategoryAssociation association = associations.getAssociation(cp);\n      \n      BytesRef bytes = res.get(association.getCategoryListID());\n      if (bytes == null) {\n        bytes = new BytesRef(32);\n        res.put(association.getCategoryListID(), bytes);\n      }\n      \n      int maxBytesNeeded = 4 /* int */ + association.maxBytesNeeded() + bytes.length;\n      if (bytes.bytes.length < maxBytesNeeded) {\n        bytes.grow(maxBytesNeeded);\n      }\n      \n      // reset the output to write from bytes.length (current position) until the end\n      output.reset(bytes.bytes, bytes.length, bytes.bytes.length - bytes.length);\n      output.writeInt(ordinals.ints[idx++]);\n      \n      // encode the association bytes\n      association.serialize(output);\n      \n      // update BytesRef\n      bytes.length = output.getPosition();\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":4,"author":"Michael McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/associations/AssociationsListBuilder#build(IntsRef,Iterable[CategoryPath]).mjava","sourceNew":null,"sourceOld":"  @Override\n  public Map<String,BytesRef> build(IntsRef ordinals, Iterable<CategoryPath> categories) throws IOException {\n    final HashMap<String,BytesRef> res = new HashMap<String,BytesRef>();\n    int idx = 0;\n    for (CategoryPath cp : categories) {\n      // build per-association key BytesRef\n      CategoryAssociation association = associations.getAssociation(cp);\n      \n      BytesRef bytes = res.get(association.getCategoryListID());\n      if (bytes == null) {\n        bytes = new BytesRef(32);\n        res.put(association.getCategoryListID(), bytes);\n      }\n      \n      int maxBytesNeeded = 4 /* int */ + association.maxBytesNeeded() + bytes.length;\n      if (bytes.bytes.length < maxBytesNeeded) {\n        bytes.grow(maxBytesNeeded);\n      }\n      \n      // reset the output to write from bytes.length (current position) until the end\n      output.reset(bytes.bytes, bytes.length, bytes.bytes.length - bytes.length);\n      output.writeInt(ordinals.ints[idx++]);\n      \n      // encode the association bytes\n      association.serialize(output);\n      \n      // update BytesRef\n      bytes.length = output.getPosition();\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bceb02c33032dd9bbf107cd06d0b74e5db4f110a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c4c0c02bba324d871be523a32f441ebdb835ca9a":["bceb02c33032dd9bbf107cd06d0b74e5db4f110a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["bceb02c33032dd9bbf107cd06d0b74e5db4f110a"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["c4c0c02bba324d871be523a32f441ebdb835ca9a","c190847801a50f4dd20fd639bdc29b54ea3b288b"],"4e6354dd7c71fe122926fc53d7d29f715b1283db":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","bceb02c33032dd9bbf107cd06d0b74e5db4f110a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["c4c0c02bba324d871be523a32f441ebdb835ca9a"]},"commit2Childs":{"bceb02c33032dd9bbf107cd06d0b74e5db4f110a":["c4c0c02bba324d871be523a32f441ebdb835ca9a","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","4e6354dd7c71fe122926fc53d7d29f715b1283db"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bceb02c33032dd9bbf107cd06d0b74e5db4f110a","4e6354dd7c71fe122926fc53d7d29f715b1283db"],"c4c0c02bba324d871be523a32f441ebdb835ca9a":["3cc728b07df73b197e6d940d27f9b08b63918f13","c190847801a50f4dd20fd639bdc29b54ea3b288b"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"3cc728b07df73b197e6d940d27f9b08b63918f13":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4e6354dd7c71fe122926fc53d7d29f715b1283db":[],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","4e6354dd7c71fe122926fc53d7d29f715b1283db","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}