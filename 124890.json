{"path":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random, directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","bugFix":["dd86d8c5713fc65e119372f12a3c5fdc47987b56","486cfd5a3f7481938475c113415d896f7a74a4a9"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ea8268d5f00bb25a4ea1d0bac6e2ffe238712c45","date":1342645458,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() { return 0; }\n      @Override public float freq()  { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() { return 0; }\n      @Override public float freq()  { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() throws IOException { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() throws IOException {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) throws IOException {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) throws IOException {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() { return 0; }\n      @Override public float freq()  { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"05a9119f665d52b16e936bb48c5b836609aadbc5","date":1351605383,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() { return 0; }\n      @Override public int freq()  { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() { return 0; }\n      @Override public float freq()  { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"757496f10c991c553a874f78fb06c3f0dc110dff","date":1351616733,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() { return 0; }\n      @Override public int freq()  { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() { return 0; }\n      @Override public float freq()  { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b9f056598bc578796f7c2eaa4b2bb8eaab5c23a","date":1363294103,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() { return 0; }\n      @Override public int freq()  { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n      @Override\n      public long cost() {\n        return 1;\n      }\n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() { return 0; }\n      @Override public int freq()  { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e18c86f811939bfa8cd24046c96ed026f2e9b34","date":1393893071,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    TopScorer[] scorers = new TopScorer[] {new TopScorer() {\n      private int doc = -1;\n\n      @Override\n      public boolean score(Collector c, int maxDoc) throws IOException {\n        assert doc == -1;\n        doc = 3000;\n        c.setScorer(new Scorer(null) {\n            @Override\n            public int advance(int target) {\n              throw new UnsupportedOperationException(\"FakeScorer doesn't support advance(int)\");\n            }\n\n            @Override\n            public int docID() {\n              return doc;\n            }\n\n            @Override\n            public int freq() {\n              throw new UnsupportedOperationException(\"FakeScorer doesn't support freq()\");\n            }\n\n            @Override\n            public int nextDoc() {\n              throw new UnsupportedOperationException(\"FakeScorer doesn't support nextDoc()\");\n            }\n    \n            @Override\n            public float score() {\n              return 1.0f;\n            }\n\n            @Override\n            public long cost() {\n              return 1;\n            }\n          });\n        c.collect(3000);\n        return false;\n      }\n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), Collections.<TopScorer>emptyList(), scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() { return 0; }\n      @Override public int freq()  { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n      @Override\n      public long cost() {\n        return 1;\n      }\n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5794e5c995c57444b154b01a9f3c837cd530a77","date":1394190201,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    BulkScorer[] scorers = new BulkScorer[] {new BulkScorer() {\n      private int doc = -1;\n\n      @Override\n      public boolean score(Collector c, int maxDoc) throws IOException {\n        assert doc == -1;\n        doc = 3000;\n        c.setScorer(new Scorer(null) {\n            @Override\n            public int advance(int target) {\n              throw new UnsupportedOperationException(\"FakeScorer doesn't support advance(int)\");\n            }\n\n            @Override\n            public int docID() {\n              return doc;\n            }\n\n            @Override\n            public int freq() {\n              throw new UnsupportedOperationException(\"FakeScorer doesn't support freq()\");\n            }\n\n            @Override\n            public int nextDoc() {\n              throw new UnsupportedOperationException(\"FakeScorer doesn't support nextDoc()\");\n            }\n    \n            @Override\n            public float score() {\n              return 1.0f;\n            }\n\n            @Override\n            public long cost() {\n              return 1;\n            }\n          });\n        c.collect(3000);\n        return false;\n      }\n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), Collections.<BulkScorer>emptyList(), scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    TopScorer[] scorers = new TopScorer[] {new TopScorer() {\n      private int doc = -1;\n\n      @Override\n      public boolean score(Collector c, int maxDoc) throws IOException {\n        assert doc == -1;\n        doc = 3000;\n        c.setScorer(new Scorer(null) {\n            @Override\n            public int advance(int target) {\n              throw new UnsupportedOperationException(\"FakeScorer doesn't support advance(int)\");\n            }\n\n            @Override\n            public int docID() {\n              return doc;\n            }\n\n            @Override\n            public int freq() {\n              throw new UnsupportedOperationException(\"FakeScorer doesn't support freq()\");\n            }\n\n            @Override\n            public int nextDoc() {\n              throw new UnsupportedOperationException(\"FakeScorer doesn't support nextDoc()\");\n            }\n    \n            @Override\n            public float score() {\n              return 1.0f;\n            }\n\n            @Override\n            public long cost() {\n              return 1;\n            }\n          });\n        c.collect(3000);\n        return false;\n      }\n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), Collections.<TopScorer>emptyList(), scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"956ed30f06fa518bc14a442f5dadfa7a0ef51c69","date":1394534863,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    BulkScorer[] scorers = new BulkScorer[] {new BulkScorer() {\n      private int doc = -1;\n\n      @Override\n      public boolean score(Collector c, int maxDoc) throws IOException {\n        assert doc == -1;\n        doc = 3000;\n        FakeScorer fs = new FakeScorer();\n        fs.doc = doc;\n        fs.score = 1.0f;\n        c.setScorer(fs);\n        c.collect(3000);\n        return false;\n      }\n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), Collections.<BulkScorer>emptyList(), scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    BulkScorer[] scorers = new BulkScorer[] {new BulkScorer() {\n      private int doc = -1;\n\n      @Override\n      public boolean score(Collector c, int maxDoc) throws IOException {\n        assert doc == -1;\n        doc = 3000;\n        c.setScorer(new Scorer(null) {\n            @Override\n            public int advance(int target) {\n              throw new UnsupportedOperationException(\"FakeScorer doesn't support advance(int)\");\n            }\n\n            @Override\n            public int docID() {\n              return doc;\n            }\n\n            @Override\n            public int freq() {\n              throw new UnsupportedOperationException(\"FakeScorer doesn't support freq()\");\n            }\n\n            @Override\n            public int nextDoc() {\n              throw new UnsupportedOperationException(\"FakeScorer doesn't support nextDoc()\");\n            }\n    \n            @Override\n            public float score() {\n              return 1.0f;\n            }\n\n            @Override\n            public long cost() {\n              return 1;\n            }\n          });\n        c.collect(3000);\n        return false;\n      }\n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), Collections.<BulkScorer>emptyList(), scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"acf00221f44c5f08ccea014f2492b53af15ecd66","date":1394568293,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    BulkScorer[] scorers = new BulkScorer[] {new BulkScorer() {\n      private int doc = -1;\n\n      @Override\n      public boolean score(Collector c, int maxDoc) throws IOException {\n        assert doc == -1;\n        doc = 3000;\n        FakeScorer fs = new FakeScorer();\n        fs.doc = doc;\n        fs.score = 1.0f;\n        c.setScorer(fs);\n        c.collect(3000);\n        return false;\n      }\n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), Collections.<BulkScorer>emptyList(), scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    Scorer[] scorers = new Scorer[] {new Scorer(weight) {\n      private int doc = -1;\n      @Override public float score() { return 0; }\n      @Override public int freq()  { return 0; }\n      @Override public int docID() { return doc; }\n      \n      @Override public int nextDoc() {\n        return doc = doc == -1 ? 3000 : NO_MORE_DOCS;\n      }\n\n      @Override public int advance(int target) {\n        return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;\n      }\n      \n      @Override\n      public long cost() {\n        return 1;\n      }\n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), null, scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    BulkScorer[] scorers = new BulkScorer[] {new BulkScorer() {\n      private int doc = -1;\n\n      @Override\n      public boolean score(Collector c, int maxDoc) throws IOException {\n        assert doc == -1;\n        doc = 3000;\n        FakeScorer fs = new FakeScorer();\n        fs.doc = doc;\n        fs.score = 1.0f;\n        c.setScorer(fs);\n        c.collect(3000);\n        return false;\n      }\n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), Collections.<BulkScorer>emptyList(), scorers.length);\n\n    final List<Integer> hits = new ArrayList<>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    BulkScorer[] scorers = new BulkScorer[] {new BulkScorer() {\n      private int doc = -1;\n\n      @Override\n      public boolean score(Collector c, int maxDoc) throws IOException {\n        assert doc == -1;\n        doc = 3000;\n        FakeScorer fs = new FakeScorer();\n        fs.doc = doc;\n        fs.score = 1.0f;\n        c.setScorer(fs);\n        c.collect(3000);\n        return false;\n      }\n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), Collections.<BulkScorer>emptyList(), scorers.length);\n\n    final List<Integer> hits = new ArrayList<Integer>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae73da626f97850c922c42736f808d0378e165f0","date":1396625460,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    BulkScorer[] scorers = new BulkScorer[] {new BulkScorer() {\n      private int doc = -1;\n\n      @Override\n      public boolean score(LeafCollector c, int maxDoc) throws IOException {\n        assert doc == -1;\n        doc = 3000;\n        FakeScorer fs = new FakeScorer();\n        fs.doc = doc;\n        fs.score = 1.0f;\n        c.setScorer(fs);\n        c.collect(3000);\n        return false;\n      }\n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), Collections.<BulkScorer>emptyList(), scorers.length);\n\n    final List<Integer> hits = new ArrayList<>();\n    bs.score(new SimpleCollector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    BulkScorer[] scorers = new BulkScorer[] {new BulkScorer() {\n      private int doc = -1;\n\n      @Override\n      public boolean score(Collector c, int maxDoc) throws IOException {\n        assert doc == -1;\n        doc = 3000;\n        FakeScorer fs = new FakeScorer();\n        fs.doc = doc;\n        fs.score = 1.0f;\n        c.setScorer(fs);\n        c.collect(3000);\n        return false;\n      }\n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), Collections.<BulkScorer>emptyList(), scorers.length);\n\n    final List<Integer> hits = new ArrayList<>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15e323346eac5e4685c0a9f2df85eb96b4239bbb","date":1396688577,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    BulkScorer[] scorers = new BulkScorer[] {new BulkScorer() {\n      private int doc = -1;\n\n      @Override\n      public boolean score(LeafCollector c, int maxDoc) throws IOException {\n        assert doc == -1;\n        doc = 3000;\n        FakeScorer fs = new FakeScorer();\n        fs.doc = doc;\n        fs.score = 1.0f;\n        c.setScorer(fs);\n        c.collect(3000);\n        return false;\n      }\n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), Collections.<BulkScorer>emptyList(), scorers.length);\n\n    final List<Integer> hits = new ArrayList<>();\n    bs.score(new SimpleCollector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    BulkScorer[] scorers = new BulkScorer[] {new BulkScorer() {\n      private int doc = -1;\n\n      @Override\n      public boolean score(Collector c, int maxDoc) throws IOException {\n        assert doc == -1;\n        doc = 3000;\n        FakeScorer fs = new FakeScorer();\n        fs.doc = doc;\n        fs.score = 1.0f;\n        c.setScorer(fs);\n        c.collect(3000);\n        return false;\n      }\n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), Collections.<BulkScorer>emptyList(), scorers.length);\n\n    final List<Integer> hits = new ArrayList<>();\n    bs.score(new Collector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      public void setNextReader(AtomicReaderContext context) {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.shutdown();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    BulkScorer[] scorers = new BulkScorer[] {new BulkScorer() {\n      private int doc = -1;\n\n      @Override\n      public boolean score(LeafCollector c, int maxDoc) throws IOException {\n        assert doc == -1;\n        doc = 3000;\n        FakeScorer fs = new FakeScorer();\n        fs.doc = doc;\n        fs.score = 1.0f;\n        c.setScorer(fs);\n        c.collect(3000);\n        return false;\n      }\n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), Collections.<BulkScorer>emptyList(), scorers.length);\n\n    final List<Integer> hits = new ArrayList<>();\n    bs.score(new SimpleCollector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    BulkScorer[] scorers = new BulkScorer[] {new BulkScorer() {\n      private int doc = -1;\n\n      @Override\n      public boolean score(LeafCollector c, int maxDoc) throws IOException {\n        assert doc == -1;\n        doc = 3000;\n        FakeScorer fs = new FakeScorer();\n        fs.doc = doc;\n        fs.score = 1.0f;\n        c.setScorer(fs);\n        c.collect(3000);\n        return false;\n      }\n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), Collections.<BulkScorer>emptyList(), scorers.length);\n\n    final List<Integer> hits = new ArrayList<>();\n    bs.score(new SimpleCollector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0cf15d89c400585df630cb62449fb4d6cb58434f","date":1397643074,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.shutdown();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    BulkScorer[] scorers = new BulkScorer[] {new BulkScorer() {\n      private int doc = -1;\n\n      @Override\n      public boolean score(LeafCollector c, int maxDoc) throws IOException {\n        assert doc == -1;\n        doc = 3000;\n        FakeScorer fs = new FakeScorer();\n        fs.doc = doc;\n        fs.score = 1.0f;\n        c.setScorer(fs);\n        c.collect(3000);\n        return false;\n      }\n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Collections.<Scorer>emptyList(), Arrays.asList(scorers), Collections.<BulkScorer>emptyList(), scorers.length);\n\n    final List<Integer> hits = new ArrayList<>();\n    bs.score(new SimpleCollector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.shutdown();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    BulkScorer[] scorers = new BulkScorer[] {new BulkScorer() {\n      private int doc = -1;\n\n      @Override\n      public boolean score(LeafCollector c, int maxDoc) throws IOException {\n        assert doc == -1;\n        doc = 3000;\n        FakeScorer fs = new FakeScorer();\n        fs.doc = doc;\n        fs.score = 1.0f;\n        c.setScorer(fs);\n        c.collect(3000);\n        return false;\n      }\n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), Collections.<BulkScorer>emptyList(), scorers.length);\n\n    final List<Integer> hits = new ArrayList<>();\n    bs.score(new SimpleCollector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"158bf4b301557fdddcd1f665fa0700b7f19678d0","date":1397643258,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.shutdown();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    BulkScorer[] scorers = new BulkScorer[] {new BulkScorer() {\n      private int doc = -1;\n\n      @Override\n      public boolean score(LeafCollector c, int maxDoc) throws IOException {\n        assert doc == -1;\n        doc = 3000;\n        FakeScorer fs = new FakeScorer();\n        fs.doc = doc;\n        fs.score = 1.0f;\n        c.setScorer(fs);\n        c.collect(3000);\n        return false;\n      }\n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), Collections.<BulkScorer>emptyList(), scorers.length);\n\n    final List<Integer> hits = new ArrayList<>();\n    bs.score(new SimpleCollector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.shutdown();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    BulkScorer[] scorers = new BulkScorer[] {new BulkScorer() {\n      private int doc = -1;\n\n      @Override\n      public boolean score(LeafCollector c, int maxDoc) throws IOException {\n        assert doc == -1;\n        doc = 3000;\n        FakeScorer fs = new FakeScorer();\n        fs.doc = doc;\n        fs.score = 1.0f;\n        c.setScorer(fs);\n        c.collect(3000);\n        return false;\n      }\n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Collections.<Scorer>emptyList(), Arrays.asList(scorers), Collections.<BulkScorer>emptyList(), scorers.length);\n\n    final List<Integer> hits = new ArrayList<>();\n    bs.score(new SimpleCollector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    BulkScorer[] scorers = new BulkScorer[] {new BulkScorer() {\n      private int doc = -1;\n\n      @Override\n      public boolean score(LeafCollector c, int maxDoc) throws IOException {\n        assert doc == -1;\n        doc = 3000;\n        FakeScorer fs = new FakeScorer();\n        fs.doc = doc;\n        fs.score = 1.0f;\n        c.setScorer(fs);\n        c.collect(3000);\n        return false;\n      }\n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), Collections.<BulkScorer>emptyList(), scorers.length);\n\n    final List<Integer> hits = new ArrayList<>();\n    bs.score(new SimpleCollector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.shutdown();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    BulkScorer[] scorers = new BulkScorer[] {new BulkScorer() {\n      private int doc = -1;\n\n      @Override\n      public boolean score(LeafCollector c, int maxDoc) throws IOException {\n        assert doc == -1;\n        doc = 3000;\n        FakeScorer fs = new FakeScorer();\n        fs.doc = doc;\n        fs.score = 1.0f;\n        c.setScorer(fs);\n        c.collect(3000);\n        return false;\n      }\n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), Collections.<BulkScorer>emptyList(), scorers.length);\n\n    final List<Integer> hits = new ArrayList<>();\n    bs.score(new SimpleCollector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    BulkScorer[] scorers = new BulkScorer[] {new BulkScorer() {\n      private int doc = -1;\n\n      @Override\n      public boolean score(LeafCollector c, int maxDoc) throws IOException {\n        assert doc == -1;\n        doc = 3000;\n        FakeScorer fs = new FakeScorer();\n        fs.doc = doc;\n        fs.score = 1.0f;\n        c.setScorer(fs);\n        c.collect(3000);\n        return false;\n      }\n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), Collections.<BulkScorer>emptyList(), scorers.length);\n\n    final List<Integer> hits = new ArrayList<>();\n    bs.score(new SimpleCollector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    BulkScorer[] scorers = new BulkScorer[] {new BulkScorer() {\n      private int doc = -1;\n\n      @Override\n      public boolean score(LeafCollector c, int maxDoc) throws IOException {\n        assert doc == -1;\n        doc = 3000;\n        FakeScorer fs = new FakeScorer();\n        fs.doc = doc;\n        fs.score = 1.0f;\n        c.setScorer(fs);\n        c.collect(3000);\n        return false;\n      }\n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), Collections.<BulkScorer>emptyList(), scorers.length);\n\n    final List<Integer> hits = new ArrayList<>();\n    bs.score(new SimpleCollector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f","date":1421314520,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer#testEmptyBucketWithMoreDocs().mjava","sourceNew":null,"sourceOld":"  public void testEmptyBucketWithMoreDocs() throws Exception {\n    // This test checks the logic of nextDoc() when all sub scorers have docs\n    // beyond the first bucket (for example). Currently, the code relies on the\n    // 'more' variable to work properly, and this test ensures that if the logic\n    // changes, we have a test to back it up.\n    \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    writer.commit();\n    IndexReader ir = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(ir);\n    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);\n    BulkScorer[] scorers = new BulkScorer[] {new BulkScorer() {\n      private int doc = -1;\n\n      @Override\n      public boolean score(LeafCollector c, int maxDoc) throws IOException {\n        assert doc == -1;\n        doc = 3000;\n        FakeScorer fs = new FakeScorer();\n        fs.doc = doc;\n        fs.score = 1.0f;\n        c.setScorer(fs);\n        c.collect(3000);\n        return false;\n      }\n    }};\n    \n    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), Collections.<BulkScorer>emptyList(), scorers.length);\n\n    final List<Integer> hits = new ArrayList<>();\n    bs.score(new SimpleCollector() {\n      int docBase;\n      @Override\n      public void setScorer(Scorer scorer) {\n      }\n      \n      @Override\n      public void collect(int doc) {\n        hits.add(docBase+doc);\n      }\n      \n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        docBase = context.docBase;\n      }\n      \n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n      });\n\n    assertEquals(\"should have only 1 hit\", 1, hits.size());\n    assertEquals(\"hit should have been docID=3000\", 3000, hits.get(0).intValue());\n    ir.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2e18c86f811939bfa8cd24046c96ed026f2e9b34":["7b9f056598bc578796f7c2eaa4b2bb8eaab5c23a"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["acf00221f44c5f08ccea014f2492b53af15ecd66"],"158bf4b301557fdddcd1f665fa0700b7f19678d0":["0cf15d89c400585df630cb62449fb4d6cb58434f"],"ea8268d5f00bb25a4ea1d0bac6e2ffe238712c45":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"757496f10c991c553a874f78fb06c3f0dc110dff":["ea8268d5f00bb25a4ea1d0bac6e2ffe238712c45","05a9119f665d52b16e936bb48c5b836609aadbc5"],"7b9f056598bc578796f7c2eaa4b2bb8eaab5c23a":["757496f10c991c553a874f78fb06c3f0dc110dff"],"05a9119f665d52b16e936bb48c5b836609aadbc5":["ea8268d5f00bb25a4ea1d0bac6e2ffe238712c45"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"956ed30f06fa518bc14a442f5dadfa7a0ef51c69":["a5794e5c995c57444b154b01a9f3c837cd530a77"],"0cf15d89c400585df630cb62449fb4d6cb58434f":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"aba371508186796cc6151d8223a5b4e16d02e26e":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","ea8268d5f00bb25a4ea1d0bac6e2ffe238712c45"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","ae73da626f97850c922c42736f808d0378e165f0"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["629c38c4ae4e303d0617e05fbfe508140b32f0a3","ea8268d5f00bb25a4ea1d0bac6e2ffe238712c45"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["158bf4b301557fdddcd1f665fa0700b7f19678d0"],"ae73da626f97850c922c42736f808d0378e165f0":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a5794e5c995c57444b154b01a9f3c837cd530a77":["2e18c86f811939bfa8cd24046c96ed026f2e9b34"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["ae73da626f97850c922c42736f808d0378e165f0"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"acf00221f44c5f08ccea014f2492b53af15ecd66":["7b9f056598bc578796f7c2eaa4b2bb8eaab5c23a","956ed30f06fa518bc14a442f5dadfa7a0ef51c69"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"]},"commit2Childs":{"2e18c86f811939bfa8cd24046c96ed026f2e9b34":["a5794e5c995c57444b154b01a9f3c837cd530a77"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","ae73da626f97850c922c42736f808d0378e165f0"],"158bf4b301557fdddcd1f665fa0700b7f19678d0":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"ea8268d5f00bb25a4ea1d0bac6e2ffe238712c45":["757496f10c991c553a874f78fb06c3f0dc110dff","05a9119f665d52b16e936bb48c5b836609aadbc5","aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"757496f10c991c553a874f78fb06c3f0dc110dff":["7b9f056598bc578796f7c2eaa4b2bb8eaab5c23a"],"7b9f056598bc578796f7c2eaa4b2bb8eaab5c23a":["2e18c86f811939bfa8cd24046c96ed026f2e9b34","acf00221f44c5f08ccea014f2492b53af15ecd66"],"05a9119f665d52b16e936bb48c5b836609aadbc5":["757496f10c991c553a874f78fb06c3f0dc110dff"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"956ed30f06fa518bc14a442f5dadfa7a0ef51c69":["acf00221f44c5f08ccea014f2492b53af15ecd66"],"0cf15d89c400585df630cb62449fb4d6cb58434f":["158bf4b301557fdddcd1f665fa0700b7f19678d0"],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":[],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"ae73da626f97850c922c42736f808d0378e165f0":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"a5794e5c995c57444b154b01a9f3c837cd530a77":["956ed30f06fa518bc14a442f5dadfa7a0ef51c69"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["0cf15d89c400585df630cb62449fb4d6cb58434f"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["ea8268d5f00bb25a4ea1d0bac6e2ffe238712c45","aba371508186796cc6151d8223a5b4e16d02e26e"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["fe33227f6805edab2036cbb80645cc4e2d1fa424","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"acf00221f44c5f08ccea014f2492b53af15ecd66":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["aba371508186796cc6151d8223a5b4e16d02e26e","15e323346eac5e4685c0a9f2df85eb96b4239bbb","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}