{"path":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","commits":[{"id":"b5c559c875836474bafae7243263d93b1b1965db","date":1289581659,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestIndexValues#runTestNumerics(IndexWriterConfig,boolean).mjava","sourceNew":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 350;\n    final List<Values> numVariantList = new ArrayList<Values>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Values val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case PACKED_INTS:\n      case PACKED_INTS_FIXED: {\n        DocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n\n        ValuesEnum intsEnum = intsReader.getEnum();\n        assertNotNull(intsEnum);\n        LongsRef enumRef = intsEnum.addAttribute(ValuesAttribute.class).ints();\n        for (int i = 0; i < base; i++) {\n          assertEquals(\"index \" + i, 0, ints.getInt(i));\n          assertEquals(val.name() + \" base: \" + base + \" index: \" + i, i,\n              random.nextBoolean() ? intsEnum.advance(i) : intsEnum.nextDoc());\n          assertEquals(0, enumRef.get());\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, enumRef.get());\n          assertEquals(expected, ints.getInt(i));\n\n        }\n      }\n        break;\n      case SIMPLE_FLOAT_4BYTE:\n      case SIMPLE_FLOAT_8BYTE: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        ValuesEnum floatEnum = floatReader.getEnum();\n        assertNotNull(floatEnum);\n        FloatsRef enumRef = floatEnum.addAttribute(ValuesAttribute.class)\n            .floats();\n\n        for (int i = 0; i < base; i++) {\n          assertEquals(\" floats failed for doc: \" + i + \" base: \" + base, 0.0d,\n              floats.getFloat(i), 0.0d);\n          assertEquals(i, random.nextBoolean() ? floatEnum.advance(i)\n              : floatEnum.nextDoc());\n          assertEquals(\"index \" + i, 0.0, enumRef.get(), 0.0);\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(\"index \" + i, 2.0 * expected, enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","sourceOld":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 350;\n    final List<Values> numVariantList = new ArrayList<Values>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Values val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case PACKED_INTS:\n      case PACKED_INTS_FIXED: {\n        DocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n        \n        ValuesEnum intsEnum = intsReader.getEnum();\n        assertNotNull(intsEnum);\n        LongsRef enumRef = intsEnum.addAttribute(ValuesAttribute.class).ints();\n        for (int i = 0; i < base; i++) {\n          assertEquals(\"index \" + i, 0, ints.getInt(i));\n          assertEquals(val.name() + \" base: \" + base + \" index: \" + i, i,\n              random.nextBoolean() ? intsEnum.advance(i) : intsEnum.nextDoc());\n          assertEquals(0, enumRef.get());\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, enumRef.get());\n          assertEquals(expected, ints.getInt(i));\n\n        }\n      }\n        break;\n      case SIMPLE_FLOAT_4BYTE:\n      case SIMPLE_FLOAT_8BYTE: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        ValuesEnum floatEnum = floatReader.getEnum();\n        assertNotNull(floatEnum);\n        FloatsRef enumRef = floatEnum.addAttribute(ValuesAttribute.class)\n            .floats();\n\n        for (int i = 0; i < base; i++) {\n          assertEquals(\" floats failed for doc: \" + i + \" base: \" + base, 0.0d,\n              floats.getFloat(i), 0.0d);\n          assertEquals(i, random.nextBoolean() ? floatEnum.advance(i)\n              : floatEnum.nextDoc());\n          assertEquals(\"index \" + i, 0.0, enumRef.get(), 0.0);\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(\"index \" + i, 2.0 * expected, enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2d84736c4614acce6720851cbd2c823d7cd516e4","date":1290551630,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","sourceNew":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 179 + random.nextInt(151);\n    final List<Values> numVariantList = new ArrayList<Values>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Values val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case PACKED_INTS: {\n        DocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n        MissingValues missing = ints.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, missing.longValue, value);\n        }\n\n        ValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(0) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, enumRef.get());\n          assertEquals(expected, ints.getInt(i));\n\n        }\n      }\n        break;\n      case SIMPLE_FLOAT_4BYTE:\n      case SIMPLE_FLOAT_8BYTE: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        MissingValues missing = floats.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(\" floats failed for doc: \" + i + \" base: \" + base,\n              missing.doubleValue, value, 0.0d);\n        }\n        ValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(0) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(\"index \" + i, 2.0 * expected, enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","sourceOld":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 350;\n    final List<Values> numVariantList = new ArrayList<Values>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Values val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case PACKED_INTS:\n      case PACKED_INTS_FIXED: {\n        DocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n\n        ValuesEnum intsEnum = intsReader.getEnum();\n        assertNotNull(intsEnum);\n        LongsRef enumRef = intsEnum.addAttribute(ValuesAttribute.class).ints();\n        for (int i = 0; i < base; i++) {\n          assertEquals(\"index \" + i, 0, ints.getInt(i));\n          assertEquals(val.name() + \" base: \" + base + \" index: \" + i, i,\n              random.nextBoolean() ? intsEnum.advance(i) : intsEnum.nextDoc());\n          assertEquals(0, enumRef.get());\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, enumRef.get());\n          assertEquals(expected, ints.getInt(i));\n\n        }\n      }\n        break;\n      case SIMPLE_FLOAT_4BYTE:\n      case SIMPLE_FLOAT_8BYTE: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        ValuesEnum floatEnum = floatReader.getEnum();\n        assertNotNull(floatEnum);\n        FloatsRef enumRef = floatEnum.addAttribute(ValuesAttribute.class)\n            .floats();\n\n        for (int i = 0; i < base; i++) {\n          assertEquals(\" floats failed for doc: \" + i + \" base: \" + base, 0.0d,\n              floats.getFloat(i), 0.0d);\n          assertEquals(i, random.nextBoolean() ? floatEnum.advance(i)\n              : floatEnum.nextDoc());\n          assertEquals(\"index \" + i, 0.0, enumRef.get(), 0.0);\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(\"index \" + i, 2.0 * expected, enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a98a65bdb67cd0b27d18a5564d63bd3e944d3f4","date":1291128345,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","sourceNew":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 179 + random.nextInt(151);\n    final List<Values> numVariantList = new ArrayList<Values>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Values val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case PACKED_INTS: {\n        DocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n        MissingValue missing = ints.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, missing.longValue, value);\n        }\n\n        ValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(0) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, enumRef.get());\n          assertEquals(expected, ints.getInt(i));\n\n        }\n      }\n        break;\n      case SIMPLE_FLOAT_4BYTE:\n      case SIMPLE_FLOAT_8BYTE: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        MissingValue missing = floats.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(\" floats failed for doc: \" + i + \" base: \" + base,\n              missing.doubleValue, value, 0.0d);\n        }\n        ValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(0) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(\"index \" + i, 2.0 * expected, enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","sourceOld":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 179 + random.nextInt(151);\n    final List<Values> numVariantList = new ArrayList<Values>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Values val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case PACKED_INTS: {\n        DocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n        MissingValues missing = ints.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, missing.longValue, value);\n        }\n\n        ValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(0) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, enumRef.get());\n          assertEquals(expected, ints.getInt(i));\n\n        }\n      }\n        break;\n      case SIMPLE_FLOAT_4BYTE:\n      case SIMPLE_FLOAT_8BYTE: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        MissingValues missing = floats.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(\" floats failed for doc: \" + i + \" base: \" + base,\n              missing.doubleValue, value, 0.0d);\n        }\n        ValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(0) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(\"index \" + i, 2.0 * expected, enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3bb13258feba31ab676502787ab2e1779f129b7a","date":1291596436,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","sourceNew":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 179 + random.nextInt(151);\n    final List<Values> numVariantList = new ArrayList<Values>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Values val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case PACKED_INTS: {\n        DocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n        MissingValue missing = ints.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, missing.longValue, value);\n        }\n\n        ValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(0) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, enumRef.get());\n          assertEquals(expected, ints.getInt(i));\n\n        }\n      }\n        break;\n      case SIMPLE_FLOAT_4BYTE:\n      case SIMPLE_FLOAT_8BYTE: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        MissingValue missing = floats.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(\" floats failed for doc: \" + i + \" base: \" + base,\n              missing.doubleValue, value, 0.0d);\n        }\n        ValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(0) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected, enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","sourceOld":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 179 + random.nextInt(151);\n    final List<Values> numVariantList = new ArrayList<Values>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Values val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case PACKED_INTS: {\n        DocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n        MissingValue missing = ints.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, missing.longValue, value);\n        }\n\n        ValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(0) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, enumRef.get());\n          assertEquals(expected, ints.getInt(i));\n\n        }\n      }\n        break;\n      case SIMPLE_FLOAT_4BYTE:\n      case SIMPLE_FLOAT_8BYTE: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        MissingValue missing = floats.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(\" floats failed for doc: \" + i + \" base: \" + base,\n              missing.doubleValue, value, 0.0d);\n        }\n        ValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(0) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(\"index \" + i, 2.0 * expected, enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa2fc2eb37a1f19e90850f787d9e085950ebfa04","date":1291597075,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","sourceNew":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 179 + random.nextInt(151);\n    final List<Type> numVariantList = new ArrayList<Type>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Type val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case PACKED_INTS: {\n        DocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n        MissingValue missing = ints.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, missing.longValue, value);\n        }\n\n        DocValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(0) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, enumRef.get());\n          assertEquals(expected, ints.getInt(i));\n\n        }\n      }\n        break;\n      case SIMPLE_FLOAT_4BYTE:\n      case SIMPLE_FLOAT_8BYTE: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        MissingValue missing = floats.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(\" floats failed for doc: \" + i + \" base: \" + base,\n              missing.doubleValue, value, 0.0d);\n        }\n        DocValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(0) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected, enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","sourceOld":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 179 + random.nextInt(151);\n    final List<Values> numVariantList = new ArrayList<Values>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Values val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case PACKED_INTS: {\n        DocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n        MissingValue missing = ints.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, missing.longValue, value);\n        }\n\n        ValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(0) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, enumRef.get());\n          assertEquals(expected, ints.getInt(i));\n\n        }\n      }\n        break;\n      case SIMPLE_FLOAT_4BYTE:\n      case SIMPLE_FLOAT_8BYTE: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        MissingValue missing = floats.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(\" floats failed for doc: \" + i + \" base: \" + base,\n              missing.doubleValue, value, 0.0d);\n        }\n        ValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(0) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected, enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4bd5d0a5ac72666f0bcbd50b535d2cc70dbf584b","date":1291778725,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","sourceNew":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 179 + random.nextInt(151);\n    final List<Type> numVariantList = new ArrayList<Type>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Type val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case PACKED_INTS: {\n        DocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n        MissingValue missing = ints.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, missing.longValue, value);\n        }\n\n        DocValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(0) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, enumRef.get());\n          assertEquals(expected, ints.getInt(i));\n\n        }\n      }\n        break;\n      case SIMPLE_FLOAT_4BYTE:\n      case SIMPLE_FLOAT_8BYTE: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        MissingValue missing = floats.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(\" floats failed for doc: \" + i + \" base: \" + base,\n              missing.doubleValue, value, 0.0d);\n        }\n        DocValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(0) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected,\n              enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","sourceOld":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 179 + random.nextInt(151);\n    final List<Type> numVariantList = new ArrayList<Type>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Type val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case PACKED_INTS: {\n        DocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n        MissingValue missing = ints.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, missing.longValue, value);\n        }\n\n        DocValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(0) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, enumRef.get());\n          assertEquals(expected, ints.getInt(i));\n\n        }\n      }\n        break;\n      case SIMPLE_FLOAT_4BYTE:\n      case SIMPLE_FLOAT_8BYTE: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        MissingValue missing = floats.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(\" floats failed for doc: \" + i + \" base: \" + base,\n              missing.doubleValue, value, 0.0d);\n        }\n        DocValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(0) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected, enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85130289d2ed101fcc2d8798511c7c5b020ffab4","date":1297239859,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","sourceNew":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 179 + random.nextInt(151);\n    final List<Type> numVariantList = new ArrayList<Type>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Type val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case INTS: {\n        DocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n        MissingValue missing = ints.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, missing.longValue, value);\n        }\n\n        DocValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(0) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, enumRef.get());\n          assertEquals(expected, ints.getInt(i));\n\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        MissingValue missing = floats.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(\" floats failed for doc: \" + i + \" base: \" + base,\n              missing.doubleValue, value, 0.0d);\n        }\n        DocValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(0) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected,\n              enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","sourceOld":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 179 + random.nextInt(151);\n    final List<Type> numVariantList = new ArrayList<Type>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Type val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case PACKED_INTS: {\n        DocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n        MissingValue missing = ints.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, missing.longValue, value);\n        }\n\n        DocValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(0) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, enumRef.get());\n          assertEquals(expected, ints.getInt(i));\n\n        }\n      }\n        break;\n      case SIMPLE_FLOAT_4BYTE:\n      case SIMPLE_FLOAT_8BYTE: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        MissingValue missing = floats.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(\" floats failed for doc: \" + i + \" base: \" + base,\n              missing.doubleValue, value, 0.0d);\n        }\n        DocValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(0) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected,\n              enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","sourceNew":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory2();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 179 + random.nextInt(151);\n    final List<Type> numVariantList = new ArrayList<Type>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Type val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case INTS: {\n        DocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n        MissingValue missing = ints.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, missing.longValue, value);\n        }\n\n        DocValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(0) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, enumRef.get());\n          assertEquals(expected, ints.getInt(i));\n\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        MissingValue missing = floats.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(\" floats failed for doc: \" + i + \" base: \" + base,\n              missing.doubleValue, value, 0.0d);\n        }\n        DocValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(0) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected,\n              enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","sourceOld":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 179 + random.nextInt(151);\n    final List<Type> numVariantList = new ArrayList<Type>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Type val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case INTS: {\n        DocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n        MissingValue missing = ints.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, missing.longValue, value);\n        }\n\n        DocValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(0) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, enumRef.get());\n          assertEquals(expected, ints.getInt(i));\n\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        MissingValue missing = floats.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(\" floats failed for doc: \" + i + \" base: \" + base,\n              missing.doubleValue, value, 0.0d);\n        }\n        DocValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(0) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected,\n              enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9235b9d4454a46c066cda47fed7ca0a34e614529","date":1304414372,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","sourceNew":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 179 + random.nextInt(151);\n    final List<Type> numVariantList = new ArrayList<Type>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Type val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case INTS: {\n        DocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n        MissingValue missing = ints.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, missing.longValue, value);\n        }\n\n        DocValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(0) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, enumRef.get());\n          assertEquals(expected, ints.getInt(i));\n\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        MissingValue missing = floats.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(\" floats failed for doc: \" + i + \" base: \" + base,\n              missing.doubleValue, value, 0.0d);\n        }\n        DocValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(0) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected,\n              enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","sourceOld":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory2();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 179 + random.nextInt(151);\n    final List<Type> numVariantList = new ArrayList<Type>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Type val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case INTS: {\n        DocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n        MissingValue missing = ints.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, missing.longValue, value);\n        }\n\n        DocValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(0) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, enumRef.get());\n          assertEquals(expected, ints.getInt(i));\n\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        MissingValue missing = floats.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(\" floats failed for doc: \" + i + \" base: \" + base,\n              missing.doubleValue, value, 0.0d);\n        }\n        DocValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(0) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected,\n              enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"39d51e9acac1e629cffe47855e85dc6dedc4754d","date":1305711497,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","sourceNew":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 179 + random.nextInt(151);\n    final List<ValueType> numVariantList = new ArrayList<ValueType>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (ValueType val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case INTS: {\n        DocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n        MissingValue missing = ints.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, missing.longValue, value);\n        }\n\n        DocValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(0) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, enumRef.get());\n          assertEquals(expected, ints.getInt(i));\n\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        MissingValue missing = floats.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(\" floats failed for doc: \" + i + \" base: \" + base,\n              missing.doubleValue, value, 0.0d);\n        }\n        DocValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(0) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected,\n              enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","sourceOld":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 179 + random.nextInt(151);\n    final List<Type> numVariantList = new ArrayList<Type>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Type val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case INTS: {\n        DocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n        MissingValue missing = ints.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, missing.longValue, value);\n        }\n\n        DocValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(0) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, enumRef.get());\n          assertEquals(expected, ints.getInt(i));\n\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        MissingValue missing = floats.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(\" floats failed for doc: \" + i + \" base: \" + base,\n              missing.doubleValue, value, 0.0d);\n        }\n        DocValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(0) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected,\n              enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"874088165d9cc50370b30219daa24a1946758ee6","date":1306148325,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","sourceNew":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 179 + random.nextInt(151);\n    final List<ValueType> numVariantList = new ArrayList<ValueType>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (ValueType val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case INTS: {\n        DocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n        MissingValue missing = ints.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, missing.longValue, value);\n        }\n\n        DocValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(0) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, enumRef.get());\n          assertEquals(expected, ints.getInt(i));\n\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        MissingValue missing = floats.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(val + \" failed for doc: \" + i + \" base: \" + base,\n              missing.doubleValue, value, 0.0d);\n        }\n        DocValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(0) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected,\n              enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","sourceOld":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 179 + random.nextInt(151);\n    final List<ValueType> numVariantList = new ArrayList<ValueType>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (ValueType val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case INTS: {\n        DocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n        MissingValue missing = ints.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, missing.longValue, value);\n        }\n\n        DocValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(0) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, enumRef.get());\n          assertEquals(expected, ints.getInt(i));\n\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        MissingValue missing = floats.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(\" floats failed for doc: \" + i + \" base: \" + base,\n              missing.doubleValue, value, 0.0d);\n        }\n        DocValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(0) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected,\n              enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4034ca0f8f74fdf56e25be73822f2441fc1c1b46","date":1307111599,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","sourceNew":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 179 + random.nextInt(151);\n    final List<ValueType> numVariantList = new ArrayList<ValueType>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (ValueType val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case INTS: {\n        DocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, 0, value);\n        }\n\n        DocValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(base) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, ints.getInt(i));\n          assertEquals(expected, enumRef.get());\n\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(val + \" failed for doc: \" + i + \" base: \" + base,\n              0.0d, value, 0.0d);\n        }\n        DocValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(base) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected,\n              enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","sourceOld":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 179 + random.nextInt(151);\n    final List<ValueType> numVariantList = new ArrayList<ValueType>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (ValueType val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case INTS: {\n        DocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n        MissingValue missing = ints.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, missing.longValue, value);\n        }\n\n        DocValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(0) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, enumRef.get());\n          assertEquals(expected, ints.getInt(i));\n\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        MissingValue missing = floats.getMissing();\n\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(val + \" failed for doc: \" + i + \" base: \" + base,\n              missing.doubleValue, value, 0.0d);\n        }\n        DocValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(0) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected,\n              enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"41e5bbad683f7546e96f08ffe8bc50cf447f2586","date":1307113213,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","sourceNew":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 179 + random.nextInt(151);\n    final List<ValueType> numVariantList = new ArrayList<ValueType>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (ValueType val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case INTS: {\n        IndexDocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, 0, value);\n        }\n\n        DocValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(base) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, ints.getInt(i));\n          assertEquals(expected, enumRef.get());\n\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        IndexDocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(val + \" failed for doc: \" + i + \" base: \" + base,\n              0.0d, value, 0.0d);\n        }\n        DocValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(base) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected,\n              enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","sourceOld":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 179 + random.nextInt(151);\n    final List<ValueType> numVariantList = new ArrayList<ValueType>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (ValueType val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case INTS: {\n        DocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, 0, value);\n        }\n\n        DocValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(base) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, ints.getInt(i));\n          assertEquals(expected, enumRef.get());\n\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(val + \" failed for doc: \" + i + \" base: \" + base,\n              0.0d, value, 0.0d);\n        }\n        DocValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(base) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected,\n              enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"605b061fadf71aa6458c0005eaae83a98350c403","date":1307117658,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","sourceNew":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 179 + random.nextInt(151);\n    final List<ValueType> numVariantList = new ArrayList<ValueType>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (ValueType val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case INTS: {\n        IndexDocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, 0, value);\n        }\n\n        ValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(base) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, ints.getInt(i));\n          assertEquals(expected, enumRef.get());\n\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        IndexDocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(val + \" failed for doc: \" + i + \" base: \" + base,\n              0.0d, value, 0.0d);\n        }\n        ValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(base) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected,\n              enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","sourceOld":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 179 + random.nextInt(151);\n    final List<ValueType> numVariantList = new ArrayList<ValueType>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (ValueType val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case INTS: {\n        IndexDocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, 0, value);\n        }\n\n        DocValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(base) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, ints.getInt(i));\n          assertEquals(expected, enumRef.get());\n\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        IndexDocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(val + \" failed for doc: \" + i + \" base: \" + base,\n              0.0d, value, 0.0d);\n        }\n        DocValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(base) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected,\n              enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e8d7ba2175f47e280231533f7d3016249cea88b","date":1307711934,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","pathOld":"/dev/null","sourceNew":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 179 + random.nextInt(151);\n    final List<ValueType> numVariantList = new ArrayList<ValueType>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (ValueType val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case INTS: {\n        IndexDocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, 0, value);\n        }\n\n        ValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(base) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, ints.getInt(i));\n          assertEquals(expected, enumRef.get());\n\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        IndexDocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(val + \" failed for doc: \" + i + \" base: \" + base,\n              0.0d, value, 0.0d);\n        }\n        ValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(base) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected,\n              enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","date":1307729864,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","pathOld":"/dev/null","sourceNew":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 179 + random.nextInt(151);\n    final List<ValueType> numVariantList = new ArrayList<ValueType>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (ValueType val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case INTS: {\n        IndexDocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, 0, value);\n        }\n\n        ValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(base) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, ints.getInt(i));\n          assertEquals(expected, enumRef.get());\n\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        IndexDocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(val + \" failed for doc: \" + i + \" base: \" + base,\n              0.0d, value, 0.0d);\n        }\n        ValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(base) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected,\n              enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93c59ad5034eecd863f267bd75e1df7b8a51e427","date":1309162882,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","sourceNew":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 50 + atLeast(10);\n    final List<ValueType> numVariantList = new ArrayList<ValueType>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (ValueType val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      // for FIXED_INTS_8 we use value mod 128 - to enable testing in \n      // one go we simply use numValues as the mod for all other INT types\n      int mod = numValues;\n      switch (val) {\n      case FIXED_INTS_8:\n        mod = 128;\n      case FIXED_INTS_16:\n      case FIXED_INTS_32:\n      case FIXED_INTS_64:\n      case VAR_INTS: {\n        IndexDocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, 0, value);\n        }\n\n        ValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(base) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(val + \"\" + mod + \" \" +  i, expected%mod, ints.getInt(i));\n          assertEquals(expected%mod, enumRef.get());\n\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        IndexDocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(val + \" failed for doc: \" + i + \" base: \" + base,\n              0.0d, value, 0.0d);\n        }\n        ValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(base) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected,\n              enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","sourceOld":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 179 + random.nextInt(151);\n    final List<ValueType> numVariantList = new ArrayList<ValueType>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (ValueType val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case INTS: {\n        IndexDocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, 0, value);\n        }\n\n        ValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(base) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, ints.getInt(i));\n          assertEquals(expected, enumRef.get());\n\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        IndexDocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(val + \" failed for doc: \" + i + \" base: \" + base,\n              0.0d, value, 0.0d);\n        }\n        ValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(base) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected,\n              enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f709d06503a0d7b88fbc7fe89cdc51caadfdaa7","date":1309190785,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","sourceNew":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 50 + atLeast(10);\n    final List<ValueType> numVariantList = new ArrayList<ValueType>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (ValueType val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      // for FIXED_INTS_8 we use value mod 128 - to enable testing in \n      // one go we simply use numValues as the mod for all other INT types\n      int mod = numValues;\n      switch (val) {\n      case FIXED_INTS_8:\n        mod = 128;\n      case FIXED_INTS_16:\n      case FIXED_INTS_32:\n      case FIXED_INTS_64:\n      case VAR_INTS: {\n        IndexDocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, 0, value);\n        }\n\n        ValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(base) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(val + \" mod: \" + mod + \" index: \" +  i, expected%mod, ints.getInt(i));\n          assertEquals(expected%mod, enumRef.get());\n\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        IndexDocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(val + \" failed for doc: \" + i + \" base: \" + base,\n              0.0d, value, 0.0d);\n        }\n        ValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(base) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected,\n              enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","sourceOld":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 50 + atLeast(10);\n    final List<ValueType> numVariantList = new ArrayList<ValueType>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (ValueType val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      // for FIXED_INTS_8 we use value mod 128 - to enable testing in \n      // one go we simply use numValues as the mod for all other INT types\n      int mod = numValues;\n      switch (val) {\n      case FIXED_INTS_8:\n        mod = 128;\n      case FIXED_INTS_16:\n      case FIXED_INTS_32:\n      case FIXED_INTS_64:\n      case VAR_INTS: {\n        IndexDocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, 0, value);\n        }\n\n        ValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(base) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(val + \"\" + mod + \" \" +  i, expected%mod, ints.getInt(i));\n          assertEquals(expected%mod, enumRef.get());\n\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        IndexDocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(val + \" failed for doc: \" + i + \" base: \" + base,\n              0.0d, value, 0.0d);\n        }\n        ValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(base) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected,\n              enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2553b00f699380c64959ccb27991289aae87be2e","date":1309290151,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","sourceNew":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 50 + atLeast(10);\n    final List<ValueType> numVariantList = new ArrayList<ValueType>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (ValueType val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      // for FIXED_INTS_8 we use value mod 128 - to enable testing in \n      // one go we simply use numValues as the mod for all other INT types\n      int mod = numValues;\n      switch (val) {\n      case FIXED_INTS_8:\n        mod = 128;\n      case FIXED_INTS_16:\n      case FIXED_INTS_32:\n      case FIXED_INTS_64:\n      case VAR_INTS: {\n        IndexDocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, 0, value);\n        }\n\n        ValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(base) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(val + \" mod: \" + mod + \" index: \" +  i, expected%mod, ints.getInt(i));\n          assertEquals(expected%mod, enumRef.get());\n\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        IndexDocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(val + \" failed for doc: \" + i + \" base: \" + base,\n              0.0d, value, 0.0d);\n        }\n        ValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(base) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected,\n              enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","sourceOld":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 179 + random.nextInt(151);\n    final List<ValueType> numVariantList = new ArrayList<ValueType>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (ValueType val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case INTS: {\n        IndexDocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, 0, value);\n        }\n\n        ValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(base) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, ints.getInt(i));\n          assertEquals(expected, enumRef.get());\n\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        IndexDocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(val + \" failed for doc: \" + i + \" base: \" + base,\n              0.0d, value, 0.0d);\n        }\n        ValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(base) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected,\n              enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","sourceNew":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 50 + atLeast(10);\n    final List<ValueType> numVariantList = new ArrayList<ValueType>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (ValueType val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      // for FIXED_INTS_8 we use value mod 128 - to enable testing in \n      // one go we simply use numValues as the mod for all other INT types\n      int mod = numValues;\n      switch (val) {\n      case FIXED_INTS_8:\n        mod = 128;\n      case FIXED_INTS_16:\n      case FIXED_INTS_32:\n      case FIXED_INTS_64:\n      case VAR_INTS: {\n        IndexDocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, 0, value);\n        }\n\n        ValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(base) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(val + \" mod: \" + mod + \" index: \" +  i, expected%mod, ints.getInt(i));\n          assertEquals(expected%mod, enumRef.get());\n\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        IndexDocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(val + \" failed for doc: \" + i + \" base: \" + base,\n              0.0d, value, 0.0d);\n        }\n        ValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(base) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected,\n              enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","sourceOld":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 179 + random.nextInt(151);\n    final List<ValueType> numVariantList = new ArrayList<ValueType>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (ValueType val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case INTS: {\n        IndexDocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, 0, value);\n        }\n\n        ValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(base) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, ints.getInt(i));\n          assertEquals(expected, enumRef.get());\n\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        IndexDocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(val + \" failed for doc: \" + i + \" base: \" + base,\n              0.0d, value, 0.0d);\n        }\n        ValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(base) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected,\n              enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0d520cd04d39f8caa0a53ed23e60beb30e8fb9f","date":1310403131,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","sourceNew":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 50 + atLeast(10);\n    final List<ValueType> numVariantList = new ArrayList<ValueType>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (ValueType val : numVariantList) {\n      FixedBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = numValues - deleted.cardinality();\n      final int base = r.numDocs() - numRemainingValues;\n      // for FIXED_INTS_8 we use value mod 128 - to enable testing in \n      // one go we simply use numValues as the mod for all other INT types\n      int mod = numValues;\n      switch (val) {\n      case FIXED_INTS_8:\n        mod = 128;\n      case FIXED_INTS_16:\n      case FIXED_INTS_32:\n      case FIXED_INTS_64:\n      case VAR_INTS: {\n        IndexDocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, 0, value);\n        }\n\n        ValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(base) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(val + \" mod: \" + mod + \" index: \" +  i, expected%mod, ints.getInt(i));\n          assertEquals(expected%mod, enumRef.get());\n\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        IndexDocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(val + \" failed for doc: \" + i + \" base: \" + base,\n              0.0d, value, 0.0d);\n        }\n        ValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(base) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected,\n              enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","sourceOld":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 50 + atLeast(10);\n    final List<ValueType> numVariantList = new ArrayList<ValueType>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (ValueType val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      // for FIXED_INTS_8 we use value mod 128 - to enable testing in \n      // one go we simply use numValues as the mod for all other INT types\n      int mod = numValues;\n      switch (val) {\n      case FIXED_INTS_8:\n        mod = 128;\n      case FIXED_INTS_16:\n      case FIXED_INTS_32:\n      case FIXED_INTS_64:\n      case VAR_INTS: {\n        IndexDocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, 0, value);\n        }\n\n        ValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(base) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(val + \" mod: \" + mod + \" index: \" +  i, expected%mod, ints.getInt(i));\n          assertEquals(expected%mod, enumRef.get());\n\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        IndexDocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(val + \" failed for doc: \" + i + \" base: \" + base,\n              0.0d, value, 0.0d);\n        }\n        ValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(base) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected,\n              enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60ba444201d2570214b6fcf1d15600dc1a01f548","date":1313868045,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","sourceNew":"  @SuppressWarnings(\"fallthrough\")\n  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 50 + atLeast(10);\n    final List<ValueType> numVariantList = new ArrayList<ValueType>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (ValueType val : numVariantList) {\n      FixedBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = numValues - deleted.cardinality();\n      final int base = r.numDocs() - numRemainingValues;\n      // for FIXED_INTS_8 we use value mod 128 - to enable testing in \n      // one go we simply use numValues as the mod for all other INT types\n      int mod = numValues;\n      switch (val) {\n      case FIXED_INTS_8:\n        mod = 128;\n      case FIXED_INTS_16:\n      case FIXED_INTS_32:\n      case FIXED_INTS_64:\n      case VAR_INTS: {\n        IndexDocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, 0, value);\n        }\n\n        ValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(base) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(val + \" mod: \" + mod + \" index: \" +  i, expected%mod, ints.getInt(i));\n          assertEquals(expected%mod, enumRef.get());\n\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        IndexDocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(val + \" failed for doc: \" + i + \" base: \" + base,\n              0.0d, value, 0.0d);\n        }\n        ValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(base) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected,\n              enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","sourceOld":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 50 + atLeast(10);\n    final List<ValueType> numVariantList = new ArrayList<ValueType>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (ValueType val : numVariantList) {\n      FixedBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = numValues - deleted.cardinality();\n      final int base = r.numDocs() - numRemainingValues;\n      // for FIXED_INTS_8 we use value mod 128 - to enable testing in \n      // one go we simply use numValues as the mod for all other INT types\n      int mod = numValues;\n      switch (val) {\n      case FIXED_INTS_8:\n        mod = 128;\n      case FIXED_INTS_16:\n      case FIXED_INTS_32:\n      case FIXED_INTS_64:\n      case VAR_INTS: {\n        IndexDocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, 0, value);\n        }\n\n        ValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(base) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(val + \" mod: \" + mod + \" index: \" +  i, expected%mod, ints.getInt(i));\n          assertEquals(expected%mod, enumRef.get());\n\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        IndexDocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(val + \" failed for doc: \" + i + \" base: \" + base,\n              0.0d, value, 0.0d);\n        }\n        ValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(base) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected,\n              enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e128967bca58657bc0039d4bfe631e63e81f1977","date":1317978310,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","sourceNew":"  @SuppressWarnings(\"fallthrough\")\n  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 50 + atLeast(10);\n    final List<ValueType> numVariantList = new ArrayList<ValueType>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (ValueType val : numVariantList) {\n      FixedBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = numValues - deleted.cardinality();\n      final int base = r.numDocs() - numRemainingValues;\n      // for FIXED_INTS_8 we use value mod 128 - to enable testing in \n      // one go we simply use numValues as the mod for all other INT types\n      int mod = numValues;\n      switch (val) {\n      case FIXED_INTS_8:\n        mod = 128;\n      case FIXED_INTS_16:\n      case FIXED_INTS_32:\n      case FIXED_INTS_64:\n      case VAR_INTS: {\n        IndexDocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, 0, value);\n        }\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(val + \" mod: \" + mod + \" index: \" +  i, expected%mod, ints.getInt(i));\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        IndexDocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(val + \" failed for doc: \" + i + \" base: \" + base,\n              0.0d, value, 0.0d);\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","sourceOld":"  @SuppressWarnings(\"fallthrough\")\n  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 50 + atLeast(10);\n    final List<ValueType> numVariantList = new ArrayList<ValueType>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (ValueType val : numVariantList) {\n      FixedBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = numValues - deleted.cardinality();\n      final int base = r.numDocs() - numRemainingValues;\n      // for FIXED_INTS_8 we use value mod 128 - to enable testing in \n      // one go we simply use numValues as the mod for all other INT types\n      int mod = numValues;\n      switch (val) {\n      case FIXED_INTS_8:\n        mod = 128;\n      case FIXED_INTS_16:\n      case FIXED_INTS_32:\n      case FIXED_INTS_64:\n      case VAR_INTS: {\n        IndexDocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, 0, value);\n        }\n\n        ValuesEnum intsEnum = getValuesEnum(intsReader);\n        assertTrue(intsEnum.advance(base) >= base);\n\n        intsEnum = getValuesEnum(intsReader);\n        LongsRef enumRef = intsEnum.getInt();\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(val + \" mod: \" + mod + \" index: \" +  i, expected%mod, ints.getInt(i));\n          assertEquals(expected%mod, enumRef.get());\n\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        IndexDocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(val + \" failed for doc: \" + i + \" base: \" + base,\n              0.0d, value, 0.0d);\n        }\n        ValuesEnum floatEnum = getValuesEnum(floatReader);\n        assertTrue(floatEnum.advance(base) >= base);\n\n        floatEnum = getValuesEnum(floatReader);\n        FloatsRef enumRef = floatEnum.getFloat();\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(floatEnum.getClass() + \" index \" + i, 2.0 * expected,\n              enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe","date":1323449025,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","sourceNew":"  @SuppressWarnings(\"fallthrough\")\n  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 50 + atLeast(10);\n    final List<Type> numVariantList = new ArrayList<Type>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Type val : numVariantList) {\n      FixedBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = numValues - deleted.cardinality();\n      final int base = r.numDocs() - numRemainingValues;\n      // for FIXED_INTS_8 we use value mod 128 - to enable testing in \n      // one go we simply use numValues as the mod for all other INT types\n      int mod = numValues;\n      switch (val) {\n      case FIXED_INTS_8:\n        mod = 128;\n      case FIXED_INTS_16:\n      case FIXED_INTS_32:\n      case FIXED_INTS_64:\n      case VAR_INTS: {\n        DocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, 0, value);\n        }\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(val + \" mod: \" + mod + \" index: \" +  i, expected%mod, ints.getInt(i));\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(val + \" failed for doc: \" + i + \" base: \" + base,\n              0.0d, value, 0.0d);\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","sourceOld":"  @SuppressWarnings(\"fallthrough\")\n  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 50 + atLeast(10);\n    final List<ValueType> numVariantList = new ArrayList<ValueType>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (ValueType val : numVariantList) {\n      FixedBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = numValues - deleted.cardinality();\n      final int base = r.numDocs() - numRemainingValues;\n      // for FIXED_INTS_8 we use value mod 128 - to enable testing in \n      // one go we simply use numValues as the mod for all other INT types\n      int mod = numValues;\n      switch (val) {\n      case FIXED_INTS_8:\n        mod = 128;\n      case FIXED_INTS_16:\n      case FIXED_INTS_32:\n      case FIXED_INTS_64:\n      case VAR_INTS: {\n        IndexDocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, 0, value);\n        }\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(val + \" mod: \" + mod + \" index: \" +  i, expected%mod, ints.getInt(i));\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        IndexDocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(val + \" failed for doc: \" + i + \" base: \" + base,\n              0.0d, value, 0.0d);\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d638301ad1cfcae567b681b893bc8781f0ee48a5","date":1323801546,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","sourceNew":"  @SuppressWarnings(\"fallthrough\")\n  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 50 + atLeast(10);\n    final List<Type> numVariantList = new ArrayList<Type>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Type val : numVariantList) {\n      FixedBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = numValues - deleted.cardinality();\n      final int base = r.numDocs() - numRemainingValues;\n      // for FIXED_INTS_8 we use value mod 128 - to enable testing in \n      // one go we simply use numValues as the mod for all other INT types\n      int mod = numValues;\n      switch (val) {\n      case FIXED_INTS_8:\n        mod = 128;\n      case FIXED_INTS_16:\n      case FIXED_INTS_32:\n      case FIXED_INTS_64:\n      case VAR_INTS: {\n        DocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, 0, value);\n        }\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(val + \" mod: \" + mod + \" index: \" +  i, expected%mod, ints.getInt(i));\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(val + \" failed for doc: \" + i + \" base: \" + base,\n              0.0d, value, 0.0d);\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","sourceOld":"  @SuppressWarnings(\"fallthrough\")\n  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 50 + atLeast(10);\n    final List<ValueType> numVariantList = new ArrayList<ValueType>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (ValueType val : numVariantList) {\n      FixedBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = numValues - deleted.cardinality();\n      final int base = r.numDocs() - numRemainingValues;\n      // for FIXED_INTS_8 we use value mod 128 - to enable testing in \n      // one go we simply use numValues as the mod for all other INT types\n      int mod = numValues;\n      switch (val) {\n      case FIXED_INTS_8:\n        mod = 128;\n      case FIXED_INTS_16:\n      case FIXED_INTS_32:\n      case FIXED_INTS_64:\n      case VAR_INTS: {\n        IndexDocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, 0, value);\n        }\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(val + \" mod: \" + mod + \" index: \" +  i, expected%mod, ints.getInt(i));\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        IndexDocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(val + \" failed for doc: \" + i + \" base: \" + base,\n              0.0d, value, 0.0d);\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0ae5e3ed1232483b7b8a014f175a5fe43595982","date":1324062192,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","sourceNew":"  @SuppressWarnings(\"fallthrough\")\n  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 50 + atLeast(10);\n    final List<Type> numVariantList = new ArrayList<Type>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Type val : numVariantList) {\n      FixedBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = numValues - deleted.cardinality();\n      final int base = r.numDocs() - numRemainingValues;\n      // for FIXED_INTS_8 we use value mod 128 - to enable testing in \n      // one go we simply use numValues as the mod for all other INT types\n      int mod = numValues;\n      switch (val) {\n      case FIXED_INTS_8:\n        mod = 128;\n      case FIXED_INTS_16:\n      case FIXED_INTS_32:\n      case FIXED_INTS_64:\n      case VAR_INTS: {\n        DocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, 0, value);\n        }\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(val + \" mod: \" + mod + \" index: \" +  i, expected%mod, ints.getInt(i));\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(val + \" failed for doc: \" + i + \" base: \" + base,\n              0.0d, value, 0.0d);\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","sourceOld":"  @SuppressWarnings(\"fallthrough\")\n  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 50 + atLeast(10);\n    final List<Type> numVariantList = new ArrayList<Type>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Type val : numVariantList) {\n      FixedBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w, true);\n      final int numRemainingValues = numValues - deleted.cardinality();\n      final int base = r.numDocs() - numRemainingValues;\n      // for FIXED_INTS_8 we use value mod 128 - to enable testing in \n      // one go we simply use numValues as the mod for all other INT types\n      int mod = numValues;\n      switch (val) {\n      case FIXED_INTS_8:\n        mod = 128;\n      case FIXED_INTS_16:\n      case FIXED_INTS_32:\n      case FIXED_INTS_64:\n      case VAR_INTS: {\n        DocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n\n        for (int i = 0; i < base; i++) {\n          long value = ints.getInt(i);\n          assertEquals(\"index \" + i, 0, value);\n        }\n\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(val + \" mod: \" + mod + \" index: \" +  i, expected%mod, ints.getInt(i));\n        }\n      }\n        break;\n      case FLOAT_32:\n      case FLOAT_64: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        for (int i = 0; i < base; i++) {\n          double value = floats.getFloat(i);\n          assertEquals(val + \" failed for doc: \" + i + \" base: \" + base,\n              0.0d, value, 0.0d);\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5a98a65bdb67cd0b27d18a5564d63bd3e944d3f4":["2d84736c4614acce6720851cbd2c823d7cd516e4"],"c0d520cd04d39f8caa0a53ed23e60beb30e8fb9f":["5f709d06503a0d7b88fbc7fe89cdc51caadfdaa7"],"d638301ad1cfcae567b681b893bc8781f0ee48a5":["e128967bca58657bc0039d4bfe631e63e81f1977","1e59c344a45b9502f40ec44f5fe4e20ed2291dbe"],"9235b9d4454a46c066cda47fed7ca0a34e614529":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"2e8d7ba2175f47e280231533f7d3016249cea88b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","605b061fadf71aa6458c0005eaae83a98350c403"],"39d51e9acac1e629cffe47855e85dc6dedc4754d":["9235b9d4454a46c066cda47fed7ca0a34e614529"],"4bd5d0a5ac72666f0bcbd50b535d2cc70dbf584b":["aa2fc2eb37a1f19e90850f787d9e085950ebfa04"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["85130289d2ed101fcc2d8798511c7c5b020ffab4","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"41e5bbad683f7546e96f08ffe8bc50cf447f2586":["4034ca0f8f74fdf56e25be73822f2441fc1c1b46"],"85130289d2ed101fcc2d8798511c7c5b020ffab4":["4bd5d0a5ac72666f0bcbd50b535d2cc70dbf584b"],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["d638301ad1cfcae567b681b893bc8781f0ee48a5"],"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2e8d7ba2175f47e280231533f7d3016249cea88b"],"2553b00f699380c64959ccb27991289aae87be2e":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","5f709d06503a0d7b88fbc7fe89cdc51caadfdaa7"],"aa2fc2eb37a1f19e90850f787d9e085950ebfa04":["3bb13258feba31ab676502787ab2e1779f129b7a"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["2e8d7ba2175f47e280231533f7d3016249cea88b","5f709d06503a0d7b88fbc7fe89cdc51caadfdaa7"],"b5c559c875836474bafae7243263d93b1b1965db":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"60ba444201d2570214b6fcf1d15600dc1a01f548":["c0d520cd04d39f8caa0a53ed23e60beb30e8fb9f"],"2d84736c4614acce6720851cbd2c823d7cd516e4":["b5c559c875836474bafae7243263d93b1b1965db"],"605b061fadf71aa6458c0005eaae83a98350c403":["41e5bbad683f7546e96f08ffe8bc50cf447f2586"],"5f709d06503a0d7b88fbc7fe89cdc51caadfdaa7":["93c59ad5034eecd863f267bd75e1df7b8a51e427"],"93c59ad5034eecd863f267bd75e1df7b8a51e427":["2e8d7ba2175f47e280231533f7d3016249cea88b"],"874088165d9cc50370b30219daa24a1946758ee6":["39d51e9acac1e629cffe47855e85dc6dedc4754d"],"4034ca0f8f74fdf56e25be73822f2441fc1c1b46":["874088165d9cc50370b30219daa24a1946758ee6"],"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe":["e128967bca58657bc0039d4bfe631e63e81f1977"],"e128967bca58657bc0039d4bfe631e63e81f1977":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"3bb13258feba31ab676502787ab2e1779f129b7a":["5a98a65bdb67cd0b27d18a5564d63bd3e944d3f4","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"]},"commit2Childs":{"5a98a65bdb67cd0b27d18a5564d63bd3e944d3f4":["3bb13258feba31ab676502787ab2e1779f129b7a"],"c0d520cd04d39f8caa0a53ed23e60beb30e8fb9f":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"d638301ad1cfcae567b681b893bc8781f0ee48a5":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"],"9235b9d4454a46c066cda47fed7ca0a34e614529":["39d51e9acac1e629cffe47855e85dc6dedc4754d"],"2e8d7ba2175f47e280231533f7d3016249cea88b":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","d083e83f225b11e5fdd900e83d26ddb385b6955c","93c59ad5034eecd863f267bd75e1df7b8a51e427"],"39d51e9acac1e629cffe47855e85dc6dedc4754d":["874088165d9cc50370b30219daa24a1946758ee6"],"4bd5d0a5ac72666f0bcbd50b535d2cc70dbf584b":["85130289d2ed101fcc2d8798511c7c5b020ffab4"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["9235b9d4454a46c066cda47fed7ca0a34e614529"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2e8d7ba2175f47e280231533f7d3016249cea88b","29ef99d61cda9641b6250bf9567329a6e65f901d","a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","b5c559c875836474bafae7243263d93b1b1965db","3bb13258feba31ab676502787ab2e1779f129b7a"],"85130289d2ed101fcc2d8798511c7c5b020ffab4":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"41e5bbad683f7546e96f08ffe8bc50cf447f2586":["605b061fadf71aa6458c0005eaae83a98350c403"],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["2553b00f699380c64959ccb27991289aae87be2e"],"2553b00f699380c64959ccb27991289aae87be2e":[],"aa2fc2eb37a1f19e90850f787d9e085950ebfa04":["4bd5d0a5ac72666f0bcbd50b535d2cc70dbf584b"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"b5c559c875836474bafae7243263d93b1b1965db":["2d84736c4614acce6720851cbd2c823d7cd516e4"],"60ba444201d2570214b6fcf1d15600dc1a01f548":["e128967bca58657bc0039d4bfe631e63e81f1977"],"2d84736c4614acce6720851cbd2c823d7cd516e4":["5a98a65bdb67cd0b27d18a5564d63bd3e944d3f4"],"605b061fadf71aa6458c0005eaae83a98350c403":["2e8d7ba2175f47e280231533f7d3016249cea88b"],"5f709d06503a0d7b88fbc7fe89cdc51caadfdaa7":["c0d520cd04d39f8caa0a53ed23e60beb30e8fb9f","2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"93c59ad5034eecd863f267bd75e1df7b8a51e427":["5f709d06503a0d7b88fbc7fe89cdc51caadfdaa7"],"874088165d9cc50370b30219daa24a1946758ee6":["4034ca0f8f74fdf56e25be73822f2441fc1c1b46"],"4034ca0f8f74fdf56e25be73822f2441fc1c1b46":["41e5bbad683f7546e96f08ffe8bc50cf447f2586"],"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe":["d638301ad1cfcae567b681b893bc8781f0ee48a5"],"e128967bca58657bc0039d4bfe631e63e81f1977":["d638301ad1cfcae567b681b893bc8781f0ee48a5","1e59c344a45b9502f40ec44f5fe4e20ed2291dbe"],"3bb13258feba31ab676502787ab2e1779f129b7a":["aa2fc2eb37a1f19e90850f787d9e085950ebfa04"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}