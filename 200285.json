{"path":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#computeInPlaceUpdatableFields(AddUpdateCommand).mjava","commits":[{"id":"415bbbe7da8065dd3c477bdc3c703c6425622998","date":1485393793,"type":0,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#computeInPlaceUpdatableFields(AddUpdateCommand).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Given an add update command, compute a list of fields that can be updated in-place. If there is even a single\n   * field in the update that cannot be updated in-place, the entire update cannot be executed in-place (and empty set\n   * will be returned in that case).\n   * \n   * @return Return a set of fields that can be in-place updated.\n   */\n  public static Set<String> computeInPlaceUpdatableFields(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    IndexSchema schema = cmd.getReq().getSchema();\n    \n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    final Set<String> candidateFields = new HashSet<>();\n\n    // if _version_ field is not supported for in-place update, bail out early\n    SchemaField versionField = schema.getFieldOrNull(DistributedUpdateProcessor.VERSION_FIELD);\n    if (versionField == null || !isSupportedFieldForInPlaceUpdate(versionField)) {\n      return Collections.emptySet();\n    }\n    \n    // first pass, check the things that are virtually free,\n    // and bail out early if anything is obviously not a valid in-place update\n    for (String fieldName : sdoc.getFieldNames()) {\n      if (fieldName.equals(uniqueKeyFieldName)\n          || fieldName.equals(DistributedUpdateProcessor.VERSION_FIELD)) {\n        continue;\n      }\n      Object fieldValue = sdoc.getField(fieldName).getValue();\n      if (! (fieldValue instanceof Map) ) {\n        // not an in-place update if there are fields that are not maps\n        return Collections.emptySet();\n      }\n      // else it's a atomic update map...\n      for (String op : ((Map<String, Object>)fieldValue).keySet()) {\n        if (!op.equals(\"set\") && !op.equals(\"inc\")) {\n          // not a supported in-place update op\n          return Collections.emptySet();\n        }\n      }\n      candidateFields.add(fieldName);\n    }\n\n    if (candidateFields.isEmpty()) {\n      return Collections.emptySet();\n    }\n\n    // second pass over the candidates for in-place updates\n    // this time more expensive checks involving schema/config settings\n    for (String fieldName: candidateFields) {\n      SchemaField schemaField = schema.getField(fieldName);\n\n      if (!isSupportedFieldForInPlaceUpdate(schemaField)) {\n        return Collections.emptySet();\n      } \n\n      // if this field has copy target which is not supported for in place, then empty\n      for (CopyField copyField: schema.getCopyFieldsList(fieldName)) {\n        if (!isSupportedFieldForInPlaceUpdate(copyField.getDestination()))\n          return Collections.emptySet();\n      }\n    }\n    \n    // third pass: requiring checks against the actual IndexWriter due to internal DV update limitations\n    SolrCore core = cmd.getReq().getCore();\n    RefCounted<IndexWriter> holder = core.getSolrCoreState().getIndexWriter(core);\n    Set<String> fieldNamesFromIndexWriter = null;\n    Set<String> segmentSortingFields = null;\n    try {\n      IndexWriter iw = holder.get();\n      fieldNamesFromIndexWriter = iw.getFieldNames();\n      segmentSortingFields = iw.getConfig().getIndexSortFields();\n    } finally {\n      holder.decref();\n    }\n    for (String fieldName: candidateFields) {\n      if (! fieldNamesFromIndexWriter.contains(fieldName) ) {\n        return Collections.emptySet(); // if this field doesn't exist, DV update can't work\n      }\n      if (segmentSortingFields.contains(fieldName) ) {\n        return Collections.emptySet(); // if this is used for segment sorting, DV updates can't work\n      }\n    }\n    \n    return candidateFields;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["48924d191f1724fe63df8b6401965b79a2787c71","689f9afcb5195815904e30fd753e3db8f5fcbf29"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"598b5d23aa7c9732bf473c21a9cd309c44599394","date":1485530378,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#computeInPlaceUpdatableFields(AddUpdateCommand).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Given an add update command, compute a list of fields that can be updated in-place. If there is even a single\n   * field in the update that cannot be updated in-place, the entire update cannot be executed in-place (and empty set\n   * will be returned in that case).\n   * \n   * @return Return a set of fields that can be in-place updated.\n   */\n  public static Set<String> computeInPlaceUpdatableFields(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    IndexSchema schema = cmd.getReq().getSchema();\n    \n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    final Set<String> candidateFields = new HashSet<>();\n\n    // if _version_ field is not supported for in-place update, bail out early\n    SchemaField versionField = schema.getFieldOrNull(DistributedUpdateProcessor.VERSION_FIELD);\n    if (versionField == null || !isSupportedFieldForInPlaceUpdate(versionField)) {\n      return Collections.emptySet();\n    }\n    \n    // first pass, check the things that are virtually free,\n    // and bail out early if anything is obviously not a valid in-place update\n    for (String fieldName : sdoc.getFieldNames()) {\n      if (fieldName.equals(uniqueKeyFieldName)\n          || fieldName.equals(DistributedUpdateProcessor.VERSION_FIELD)) {\n        continue;\n      }\n      Object fieldValue = sdoc.getField(fieldName).getValue();\n      if (! (fieldValue instanceof Map) ) {\n        // not an in-place update if there are fields that are not maps\n        return Collections.emptySet();\n      }\n      // else it's a atomic update map...\n      for (String op : ((Map<String, Object>)fieldValue).keySet()) {\n        if (!op.equals(\"set\") && !op.equals(\"inc\")) {\n          // not a supported in-place update op\n          return Collections.emptySet();\n        }\n      }\n      candidateFields.add(fieldName);\n    }\n\n    if (candidateFields.isEmpty()) {\n      return Collections.emptySet();\n    }\n\n    // second pass over the candidates for in-place updates\n    // this time more expensive checks involving schema/config settings\n    for (String fieldName: candidateFields) {\n      SchemaField schemaField = schema.getField(fieldName);\n\n      if (!isSupportedFieldForInPlaceUpdate(schemaField)) {\n        return Collections.emptySet();\n      } \n\n      // if this field has copy target which is not supported for in place, then empty\n      for (CopyField copyField: schema.getCopyFieldsList(fieldName)) {\n        if (!isSupportedFieldForInPlaceUpdate(copyField.getDestination()))\n          return Collections.emptySet();\n      }\n    }\n    \n    // third pass: requiring checks against the actual IndexWriter due to internal DV update limitations\n    SolrCore core = cmd.getReq().getCore();\n    RefCounted<IndexWriter> holder = core.getSolrCoreState().getIndexWriter(core);\n    Set<String> fieldNamesFromIndexWriter = null;\n    Set<String> segmentSortingFields = null;\n    try {\n      IndexWriter iw = holder.get();\n      fieldNamesFromIndexWriter = iw.getFieldNames();\n      segmentSortingFields = iw.getConfig().getIndexSortFields();\n    } finally {\n      holder.decref();\n    }\n    for (String fieldName: candidateFields) {\n      if (! fieldNamesFromIndexWriter.contains(fieldName) ) {\n        return Collections.emptySet(); // if this field doesn't exist, DV update can't work\n      }\n      if (segmentSortingFields.contains(fieldName) ) {\n        return Collections.emptySet(); // if this is used for segment sorting, DV updates can't work\n      }\n    }\n    \n    return candidateFields;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c2795aeb0b4c10d1588f672d3d5ac7a394fc8461","date":1487476295,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#computeInPlaceUpdatableFields(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#computeInPlaceUpdatableFields(AddUpdateCommand).mjava","sourceNew":"  /**\n   * Given an add update command, compute a list of fields that can be updated in-place. If there is even a single\n   * field in the update that cannot be updated in-place, the entire update cannot be executed in-place (and empty set\n   * will be returned in that case).\n   * \n   * @return Return a set of fields that can be in-place updated.\n   */\n  public static Set<String> computeInPlaceUpdatableFields(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    IndexSchema schema = cmd.getReq().getSchema();\n    \n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    final Set<String> candidateFields = new HashSet<>();\n\n    // if _version_ field is not supported for in-place update, bail out early\n    SchemaField versionField = schema.getFieldOrNull(DistributedUpdateProcessor.VERSION_FIELD);\n    if (versionField == null || !isSupportedFieldForInPlaceUpdate(versionField)) {\n      return Collections.emptySet();\n    }\n    \n    // first pass, check the things that are virtually free,\n    // and bail out early if anything is obviously not a valid in-place update\n    for (String fieldName : sdoc.getFieldNames()) {\n      if (fieldName.equals(uniqueKeyFieldName)\n          || fieldName.equals(DistributedUpdateProcessor.VERSION_FIELD)) {\n        continue;\n      }\n      Object fieldValue = sdoc.getField(fieldName).getValue();\n      if (! (fieldValue instanceof Map) ) {\n        // not an in-place update if there are fields that are not maps\n        return Collections.emptySet();\n      }\n      // else it's a atomic update map...\n      for (String op : ((Map<String, Object>)fieldValue).keySet()) {\n        if (!op.equals(\"set\") && !op.equals(\"inc\")) {\n          // not a supported in-place update op\n          return Collections.emptySet();\n        }\n      }\n      candidateFields.add(fieldName);\n    }\n\n    if (candidateFields.isEmpty()) {\n      return Collections.emptySet();\n    }\n\n    // second pass over the candidates for in-place updates\n    // this time more expensive checks involving schema/config settings\n    for (String fieldName: candidateFields) {\n      SchemaField schemaField = schema.getField(fieldName);\n\n      if (!isSupportedFieldForInPlaceUpdate(schemaField)) {\n        return Collections.emptySet();\n      } \n\n      // if this field has copy target which is not supported for in place, then empty\n      for (CopyField copyField: schema.getCopyFieldsList(fieldName)) {\n        if (!isSupportedFieldForInPlaceUpdate(copyField.getDestination()))\n          return Collections.emptySet();\n      }\n    }\n    \n    // third pass: requiring checks against the actual IndexWriter due to internal DV update limitations\n    SolrCore core = cmd.getReq().getCore();\n    RefCounted<IndexWriter> holder = core.getSolrCoreState().getIndexWriter(core);\n    Set<String> fieldNamesFromIndexWriter = null;\n    Set<String> segmentSortingFields = null;\n    try {\n      IndexWriter iw = holder.get();\n      fieldNamesFromIndexWriter = iw.getFieldNames(); // This shouldn't be needed once LUCENE-7659 is resolved\n      segmentSortingFields = iw.getConfig().getIndexSortFields();\n    } finally {\n      holder.decref();\n    }\n    for (String fieldName: candidateFields) {\n      if (! fieldNamesFromIndexWriter.contains(fieldName) ) {\n        return Collections.emptySet(); // if this field doesn't exist, DV update can't work\n      }\n      if (segmentSortingFields.contains(fieldName) ) {\n        return Collections.emptySet(); // if this is used for segment sorting, DV updates can't work\n      }\n    }\n    \n    return candidateFields;\n  }\n\n","sourceOld":"  /**\n   * Given an add update command, compute a list of fields that can be updated in-place. If there is even a single\n   * field in the update that cannot be updated in-place, the entire update cannot be executed in-place (and empty set\n   * will be returned in that case).\n   * \n   * @return Return a set of fields that can be in-place updated.\n   */\n  public static Set<String> computeInPlaceUpdatableFields(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    IndexSchema schema = cmd.getReq().getSchema();\n    \n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    final Set<String> candidateFields = new HashSet<>();\n\n    // if _version_ field is not supported for in-place update, bail out early\n    SchemaField versionField = schema.getFieldOrNull(DistributedUpdateProcessor.VERSION_FIELD);\n    if (versionField == null || !isSupportedFieldForInPlaceUpdate(versionField)) {\n      return Collections.emptySet();\n    }\n    \n    // first pass, check the things that are virtually free,\n    // and bail out early if anything is obviously not a valid in-place update\n    for (String fieldName : sdoc.getFieldNames()) {\n      if (fieldName.equals(uniqueKeyFieldName)\n          || fieldName.equals(DistributedUpdateProcessor.VERSION_FIELD)) {\n        continue;\n      }\n      Object fieldValue = sdoc.getField(fieldName).getValue();\n      if (! (fieldValue instanceof Map) ) {\n        // not an in-place update if there are fields that are not maps\n        return Collections.emptySet();\n      }\n      // else it's a atomic update map...\n      for (String op : ((Map<String, Object>)fieldValue).keySet()) {\n        if (!op.equals(\"set\") && !op.equals(\"inc\")) {\n          // not a supported in-place update op\n          return Collections.emptySet();\n        }\n      }\n      candidateFields.add(fieldName);\n    }\n\n    if (candidateFields.isEmpty()) {\n      return Collections.emptySet();\n    }\n\n    // second pass over the candidates for in-place updates\n    // this time more expensive checks involving schema/config settings\n    for (String fieldName: candidateFields) {\n      SchemaField schemaField = schema.getField(fieldName);\n\n      if (!isSupportedFieldForInPlaceUpdate(schemaField)) {\n        return Collections.emptySet();\n      } \n\n      // if this field has copy target which is not supported for in place, then empty\n      for (CopyField copyField: schema.getCopyFieldsList(fieldName)) {\n        if (!isSupportedFieldForInPlaceUpdate(copyField.getDestination()))\n          return Collections.emptySet();\n      }\n    }\n    \n    // third pass: requiring checks against the actual IndexWriter due to internal DV update limitations\n    SolrCore core = cmd.getReq().getCore();\n    RefCounted<IndexWriter> holder = core.getSolrCoreState().getIndexWriter(core);\n    Set<String> fieldNamesFromIndexWriter = null;\n    Set<String> segmentSortingFields = null;\n    try {\n      IndexWriter iw = holder.get();\n      fieldNamesFromIndexWriter = iw.getFieldNames();\n      segmentSortingFields = iw.getConfig().getIndexSortFields();\n    } finally {\n      holder.decref();\n    }\n    for (String fieldName: candidateFields) {\n      if (! fieldNamesFromIndexWriter.contains(fieldName) ) {\n        return Collections.emptySet(); // if this field doesn't exist, DV update can't work\n      }\n      if (segmentSortingFields.contains(fieldName) ) {\n        return Collections.emptySet(); // if this is used for segment sorting, DV updates can't work\n      }\n    }\n    \n    return candidateFields;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6d2dadc1f5ca8703d8659f4964961f9967935d75","date":1490231750,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#computeInPlaceUpdatableFields(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#computeInPlaceUpdatableFields(AddUpdateCommand).mjava","sourceNew":"  /**\n   * Given an add update command, compute a list of fields that can be updated in-place. If there is even a single\n   * field in the update that cannot be updated in-place, the entire update cannot be executed in-place (and empty set\n   * will be returned in that case).\n   * \n   * @return Return a set of fields that can be in-place updated.\n   */\n  public static Set<String> computeInPlaceUpdatableFields(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    IndexSchema schema = cmd.getReq().getSchema();\n    \n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    final Set<String> candidateFields = new HashSet<>();\n\n    // if _version_ field is not supported for in-place update, bail out early\n    SchemaField versionField = schema.getFieldOrNull(CommonParams.VERSION_FIELD);\n    if (versionField == null || !isSupportedFieldForInPlaceUpdate(versionField)) {\n      return Collections.emptySet();\n    }\n    \n    // first pass, check the things that are virtually free,\n    // and bail out early if anything is obviously not a valid in-place update\n    for (String fieldName : sdoc.getFieldNames()) {\n      if (fieldName.equals(uniqueKeyFieldName)\n          || fieldName.equals(CommonParams.VERSION_FIELD)) {\n        continue;\n      }\n      Object fieldValue = sdoc.getField(fieldName).getValue();\n      if (! (fieldValue instanceof Map) ) {\n        // not an in-place update if there are fields that are not maps\n        return Collections.emptySet();\n      }\n      // else it's a atomic update map...\n      for (String op : ((Map<String, Object>)fieldValue).keySet()) {\n        if (!op.equals(\"set\") && !op.equals(\"inc\")) {\n          // not a supported in-place update op\n          return Collections.emptySet();\n        }\n      }\n      candidateFields.add(fieldName);\n    }\n\n    if (candidateFields.isEmpty()) {\n      return Collections.emptySet();\n    }\n\n    // second pass over the candidates for in-place updates\n    // this time more expensive checks involving schema/config settings\n    for (String fieldName: candidateFields) {\n      SchemaField schemaField = schema.getField(fieldName);\n\n      if (!isSupportedFieldForInPlaceUpdate(schemaField)) {\n        return Collections.emptySet();\n      } \n\n      // if this field has copy target which is not supported for in place, then empty\n      for (CopyField copyField: schema.getCopyFieldsList(fieldName)) {\n        if (!isSupportedFieldForInPlaceUpdate(copyField.getDestination()))\n          return Collections.emptySet();\n      }\n    }\n    \n    // third pass: requiring checks against the actual IndexWriter due to internal DV update limitations\n    SolrCore core = cmd.getReq().getCore();\n    RefCounted<IndexWriter> holder = core.getSolrCoreState().getIndexWriter(core);\n    Set<String> fieldNamesFromIndexWriter = null;\n    Set<String> segmentSortingFields = null;\n    try {\n      IndexWriter iw = holder.get();\n      fieldNamesFromIndexWriter = iw.getFieldNames(); // This shouldn't be needed once LUCENE-7659 is resolved\n      segmentSortingFields = iw.getConfig().getIndexSortFields();\n    } finally {\n      holder.decref();\n    }\n    for (String fieldName: candidateFields) {\n      if (! fieldNamesFromIndexWriter.contains(fieldName) ) {\n        return Collections.emptySet(); // if this field doesn't exist, DV update can't work\n      }\n      if (segmentSortingFields.contains(fieldName) ) {\n        return Collections.emptySet(); // if this is used for segment sorting, DV updates can't work\n      }\n    }\n    \n    return candidateFields;\n  }\n\n","sourceOld":"  /**\n   * Given an add update command, compute a list of fields that can be updated in-place. If there is even a single\n   * field in the update that cannot be updated in-place, the entire update cannot be executed in-place (and empty set\n   * will be returned in that case).\n   * \n   * @return Return a set of fields that can be in-place updated.\n   */\n  public static Set<String> computeInPlaceUpdatableFields(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    IndexSchema schema = cmd.getReq().getSchema();\n    \n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    final Set<String> candidateFields = new HashSet<>();\n\n    // if _version_ field is not supported for in-place update, bail out early\n    SchemaField versionField = schema.getFieldOrNull(DistributedUpdateProcessor.VERSION_FIELD);\n    if (versionField == null || !isSupportedFieldForInPlaceUpdate(versionField)) {\n      return Collections.emptySet();\n    }\n    \n    // first pass, check the things that are virtually free,\n    // and bail out early if anything is obviously not a valid in-place update\n    for (String fieldName : sdoc.getFieldNames()) {\n      if (fieldName.equals(uniqueKeyFieldName)\n          || fieldName.equals(DistributedUpdateProcessor.VERSION_FIELD)) {\n        continue;\n      }\n      Object fieldValue = sdoc.getField(fieldName).getValue();\n      if (! (fieldValue instanceof Map) ) {\n        // not an in-place update if there are fields that are not maps\n        return Collections.emptySet();\n      }\n      // else it's a atomic update map...\n      for (String op : ((Map<String, Object>)fieldValue).keySet()) {\n        if (!op.equals(\"set\") && !op.equals(\"inc\")) {\n          // not a supported in-place update op\n          return Collections.emptySet();\n        }\n      }\n      candidateFields.add(fieldName);\n    }\n\n    if (candidateFields.isEmpty()) {\n      return Collections.emptySet();\n    }\n\n    // second pass over the candidates for in-place updates\n    // this time more expensive checks involving schema/config settings\n    for (String fieldName: candidateFields) {\n      SchemaField schemaField = schema.getField(fieldName);\n\n      if (!isSupportedFieldForInPlaceUpdate(schemaField)) {\n        return Collections.emptySet();\n      } \n\n      // if this field has copy target which is not supported for in place, then empty\n      for (CopyField copyField: schema.getCopyFieldsList(fieldName)) {\n        if (!isSupportedFieldForInPlaceUpdate(copyField.getDestination()))\n          return Collections.emptySet();\n      }\n    }\n    \n    // third pass: requiring checks against the actual IndexWriter due to internal DV update limitations\n    SolrCore core = cmd.getReq().getCore();\n    RefCounted<IndexWriter> holder = core.getSolrCoreState().getIndexWriter(core);\n    Set<String> fieldNamesFromIndexWriter = null;\n    Set<String> segmentSortingFields = null;\n    try {\n      IndexWriter iw = holder.get();\n      fieldNamesFromIndexWriter = iw.getFieldNames(); // This shouldn't be needed once LUCENE-7659 is resolved\n      segmentSortingFields = iw.getConfig().getIndexSortFields();\n    } finally {\n      holder.decref();\n    }\n    for (String fieldName: candidateFields) {\n      if (! fieldNamesFromIndexWriter.contains(fieldName) ) {\n        return Collections.emptySet(); // if this field doesn't exist, DV update can't work\n      }\n      if (segmentSortingFields.contains(fieldName) ) {\n        return Collections.emptySet(); // if this is used for segment sorting, DV updates can't work\n      }\n    }\n    \n    return candidateFields;\n  }\n\n","bugFix":null,"bugIntro":["de77148275e541f915efc6e934c276a0a7ec45ea"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e5fa6615014cd2288fe930f8c8bb726f9504961d","date":1490280013,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#computeInPlaceUpdatableFields(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#computeInPlaceUpdatableFields(AddUpdateCommand).mjava","sourceNew":"  /**\n   * Given an add update command, compute a list of fields that can be updated in-place. If there is even a single\n   * field in the update that cannot be updated in-place, the entire update cannot be executed in-place (and empty set\n   * will be returned in that case).\n   * \n   * @return Return a set of fields that can be in-place updated.\n   */\n  public static Set<String> computeInPlaceUpdatableFields(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    IndexSchema schema = cmd.getReq().getSchema();\n    \n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    final Set<String> candidateFields = new HashSet<>();\n\n    // if _version_ field is not supported for in-place update, bail out early\n    SchemaField versionField = schema.getFieldOrNull(CommonParams.VERSION_FIELD);\n    if (versionField == null || !isSupportedFieldForInPlaceUpdate(versionField)) {\n      return Collections.emptySet();\n    }\n    \n    // first pass, check the things that are virtually free,\n    // and bail out early if anything is obviously not a valid in-place update\n    for (String fieldName : sdoc.getFieldNames()) {\n      if (fieldName.equals(uniqueKeyFieldName)\n          || fieldName.equals(CommonParams.VERSION_FIELD)) {\n        continue;\n      }\n      Object fieldValue = sdoc.getField(fieldName).getValue();\n      if (! (fieldValue instanceof Map) ) {\n        // not an in-place update if there are fields that are not maps\n        return Collections.emptySet();\n      }\n      // else it's a atomic update map...\n      for (String op : ((Map<String, Object>)fieldValue).keySet()) {\n        if (!op.equals(\"set\") && !op.equals(\"inc\")) {\n          // not a supported in-place update op\n          return Collections.emptySet();\n        }\n      }\n      candidateFields.add(fieldName);\n    }\n\n    if (candidateFields.isEmpty()) {\n      return Collections.emptySet();\n    }\n\n    // second pass over the candidates for in-place updates\n    // this time more expensive checks involving schema/config settings\n    for (String fieldName: candidateFields) {\n      SchemaField schemaField = schema.getField(fieldName);\n\n      if (!isSupportedFieldForInPlaceUpdate(schemaField)) {\n        return Collections.emptySet();\n      } \n\n      // if this field has copy target which is not supported for in place, then empty\n      for (CopyField copyField: schema.getCopyFieldsList(fieldName)) {\n        if (!isSupportedFieldForInPlaceUpdate(copyField.getDestination()))\n          return Collections.emptySet();\n      }\n    }\n    \n    // third pass: requiring checks against the actual IndexWriter due to internal DV update limitations\n    SolrCore core = cmd.getReq().getCore();\n    RefCounted<IndexWriter> holder = core.getSolrCoreState().getIndexWriter(core);\n    Set<String> fieldNamesFromIndexWriter = null;\n    Set<String> segmentSortingFields = null;\n    try {\n      IndexWriter iw = holder.get();\n      fieldNamesFromIndexWriter = iw.getFieldNames(); // This shouldn't be needed once LUCENE-7659 is resolved\n      segmentSortingFields = iw.getConfig().getIndexSortFields();\n    } finally {\n      holder.decref();\n    }\n    for (String fieldName: candidateFields) {\n      if (! fieldNamesFromIndexWriter.contains(fieldName) ) {\n        return Collections.emptySet(); // if this field doesn't exist, DV update can't work\n      }\n      if (segmentSortingFields.contains(fieldName) ) {\n        return Collections.emptySet(); // if this is used for segment sorting, DV updates can't work\n      }\n    }\n    \n    return candidateFields;\n  }\n\n","sourceOld":"  /**\n   * Given an add update command, compute a list of fields that can be updated in-place. If there is even a single\n   * field in the update that cannot be updated in-place, the entire update cannot be executed in-place (and empty set\n   * will be returned in that case).\n   * \n   * @return Return a set of fields that can be in-place updated.\n   */\n  public static Set<String> computeInPlaceUpdatableFields(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    IndexSchema schema = cmd.getReq().getSchema();\n    \n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    final Set<String> candidateFields = new HashSet<>();\n\n    // if _version_ field is not supported for in-place update, bail out early\n    SchemaField versionField = schema.getFieldOrNull(DistributedUpdateProcessor.VERSION_FIELD);\n    if (versionField == null || !isSupportedFieldForInPlaceUpdate(versionField)) {\n      return Collections.emptySet();\n    }\n    \n    // first pass, check the things that are virtually free,\n    // and bail out early if anything is obviously not a valid in-place update\n    for (String fieldName : sdoc.getFieldNames()) {\n      if (fieldName.equals(uniqueKeyFieldName)\n          || fieldName.equals(DistributedUpdateProcessor.VERSION_FIELD)) {\n        continue;\n      }\n      Object fieldValue = sdoc.getField(fieldName).getValue();\n      if (! (fieldValue instanceof Map) ) {\n        // not an in-place update if there are fields that are not maps\n        return Collections.emptySet();\n      }\n      // else it's a atomic update map...\n      for (String op : ((Map<String, Object>)fieldValue).keySet()) {\n        if (!op.equals(\"set\") && !op.equals(\"inc\")) {\n          // not a supported in-place update op\n          return Collections.emptySet();\n        }\n      }\n      candidateFields.add(fieldName);\n    }\n\n    if (candidateFields.isEmpty()) {\n      return Collections.emptySet();\n    }\n\n    // second pass over the candidates for in-place updates\n    // this time more expensive checks involving schema/config settings\n    for (String fieldName: candidateFields) {\n      SchemaField schemaField = schema.getField(fieldName);\n\n      if (!isSupportedFieldForInPlaceUpdate(schemaField)) {\n        return Collections.emptySet();\n      } \n\n      // if this field has copy target which is not supported for in place, then empty\n      for (CopyField copyField: schema.getCopyFieldsList(fieldName)) {\n        if (!isSupportedFieldForInPlaceUpdate(copyField.getDestination()))\n          return Collections.emptySet();\n      }\n    }\n    \n    // third pass: requiring checks against the actual IndexWriter due to internal DV update limitations\n    SolrCore core = cmd.getReq().getCore();\n    RefCounted<IndexWriter> holder = core.getSolrCoreState().getIndexWriter(core);\n    Set<String> fieldNamesFromIndexWriter = null;\n    Set<String> segmentSortingFields = null;\n    try {\n      IndexWriter iw = holder.get();\n      fieldNamesFromIndexWriter = iw.getFieldNames(); // This shouldn't be needed once LUCENE-7659 is resolved\n      segmentSortingFields = iw.getConfig().getIndexSortFields();\n    } finally {\n      holder.decref();\n    }\n    for (String fieldName: candidateFields) {\n      if (! fieldNamesFromIndexWriter.contains(fieldName) ) {\n        return Collections.emptySet(); // if this field doesn't exist, DV update can't work\n      }\n      if (segmentSortingFields.contains(fieldName) ) {\n        return Collections.emptySet(); // if this is used for segment sorting, DV updates can't work\n      }\n    }\n    \n    return candidateFields;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"07749612bed4eb54dd05255c1434c301133310c1","date":1554879779,"type":3,"author":"Moshe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#computeInPlaceUpdatableFields(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#computeInPlaceUpdatableFields(AddUpdateCommand).mjava","sourceNew":"  /**\n   * Given an add update command, compute a list of fields that can be updated in-place. If there is even a single\n   * field in the update that cannot be updated in-place, the entire update cannot be executed in-place (and empty set\n   * will be returned in that case).\n   * \n   * @return Return a set of fields that can be in-place updated.\n   */\n  public static Set<String> computeInPlaceUpdatableFields(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    IndexSchema schema = cmd.getReq().getSchema();\n    \n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    final Set<String> candidateFields = new HashSet<>();\n\n    // if _version_ field is not supported for in-place update, bail out early\n    SchemaField versionField = schema.getFieldOrNull(CommonParams.VERSION_FIELD);\n    if (versionField == null || !isSupportedFieldForInPlaceUpdate(versionField)) {\n      return Collections.emptySet();\n    }\n    \n    // first pass, check the things that are virtually free,\n    // and bail out early if anything is obviously not a valid in-place update\n    for (String fieldName : sdoc.getFieldNames()) {\n      if (fieldName.equals(uniqueKeyFieldName)\n          || fieldName.equals(CommonParams.VERSION_FIELD)) {\n        continue;\n      }\n      Object fieldValue = sdoc.getField(fieldName).getValue();\n      if (! (fieldValue instanceof Map) ) {\n        // not an in-place update if there are fields that are not maps\n        return Collections.emptySet();\n      }\n      // else it's a atomic update map...\n      for (String op : ((Map<String, Object>)fieldValue).keySet()) {\n        if (!op.equals(\"set\") && !op.equals(\"inc\")) {\n          // not a supported in-place update op\n          return Collections.emptySet();\n        }\n        // fail fast if child doc\n        if(isChildDoc(((Map<String, Object>) fieldValue).get(op))) {\n          return Collections.emptySet();\n        }\n      }\n      candidateFields.add(fieldName);\n    }\n\n    if (candidateFields.isEmpty()) {\n      return Collections.emptySet();\n    }\n\n    // second pass over the candidates for in-place updates\n    // this time more expensive checks involving schema/config settings\n    for (String fieldName: candidateFields) {\n      SchemaField schemaField = schema.getField(fieldName);\n\n      if (!isSupportedFieldForInPlaceUpdate(schemaField)) {\n        return Collections.emptySet();\n      } \n\n      // if this field has copy target which is not supported for in place, then empty\n      for (CopyField copyField: schema.getCopyFieldsList(fieldName)) {\n        if (!isSupportedFieldForInPlaceUpdate(copyField.getDestination()))\n          return Collections.emptySet();\n      }\n    }\n    \n    // third pass: requiring checks against the actual IndexWriter due to internal DV update limitations\n    SolrCore core = cmd.getReq().getCore();\n    RefCounted<IndexWriter> holder = core.getSolrCoreState().getIndexWriter(core);\n    Set<String> fieldNamesFromIndexWriter = null;\n    Set<String> segmentSortingFields = null;\n    try {\n      IndexWriter iw = holder.get();\n      fieldNamesFromIndexWriter = iw.getFieldNames(); // This shouldn't be needed once LUCENE-7659 is resolved\n      segmentSortingFields = iw.getConfig().getIndexSortFields();\n    } finally {\n      holder.decref();\n    }\n    for (String fieldName: candidateFields) {\n      if (! fieldNamesFromIndexWriter.contains(fieldName) ) {\n        return Collections.emptySet(); // if this field doesn't exist, DV update can't work\n      }\n      if (segmentSortingFields.contains(fieldName) ) {\n        return Collections.emptySet(); // if this is used for segment sorting, DV updates can't work\n      }\n    }\n    \n    return candidateFields;\n  }\n\n","sourceOld":"  /**\n   * Given an add update command, compute a list of fields that can be updated in-place. If there is even a single\n   * field in the update that cannot be updated in-place, the entire update cannot be executed in-place (and empty set\n   * will be returned in that case).\n   * \n   * @return Return a set of fields that can be in-place updated.\n   */\n  public static Set<String> computeInPlaceUpdatableFields(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    IndexSchema schema = cmd.getReq().getSchema();\n    \n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    final Set<String> candidateFields = new HashSet<>();\n\n    // if _version_ field is not supported for in-place update, bail out early\n    SchemaField versionField = schema.getFieldOrNull(CommonParams.VERSION_FIELD);\n    if (versionField == null || !isSupportedFieldForInPlaceUpdate(versionField)) {\n      return Collections.emptySet();\n    }\n    \n    // first pass, check the things that are virtually free,\n    // and bail out early if anything is obviously not a valid in-place update\n    for (String fieldName : sdoc.getFieldNames()) {\n      if (fieldName.equals(uniqueKeyFieldName)\n          || fieldName.equals(CommonParams.VERSION_FIELD)) {\n        continue;\n      }\n      Object fieldValue = sdoc.getField(fieldName).getValue();\n      if (! (fieldValue instanceof Map) ) {\n        // not an in-place update if there are fields that are not maps\n        return Collections.emptySet();\n      }\n      // else it's a atomic update map...\n      for (String op : ((Map<String, Object>)fieldValue).keySet()) {\n        if (!op.equals(\"set\") && !op.equals(\"inc\")) {\n          // not a supported in-place update op\n          return Collections.emptySet();\n        }\n      }\n      candidateFields.add(fieldName);\n    }\n\n    if (candidateFields.isEmpty()) {\n      return Collections.emptySet();\n    }\n\n    // second pass over the candidates for in-place updates\n    // this time more expensive checks involving schema/config settings\n    for (String fieldName: candidateFields) {\n      SchemaField schemaField = schema.getField(fieldName);\n\n      if (!isSupportedFieldForInPlaceUpdate(schemaField)) {\n        return Collections.emptySet();\n      } \n\n      // if this field has copy target which is not supported for in place, then empty\n      for (CopyField copyField: schema.getCopyFieldsList(fieldName)) {\n        if (!isSupportedFieldForInPlaceUpdate(copyField.getDestination()))\n          return Collections.emptySet();\n      }\n    }\n    \n    // third pass: requiring checks against the actual IndexWriter due to internal DV update limitations\n    SolrCore core = cmd.getReq().getCore();\n    RefCounted<IndexWriter> holder = core.getSolrCoreState().getIndexWriter(core);\n    Set<String> fieldNamesFromIndexWriter = null;\n    Set<String> segmentSortingFields = null;\n    try {\n      IndexWriter iw = holder.get();\n      fieldNamesFromIndexWriter = iw.getFieldNames(); // This shouldn't be needed once LUCENE-7659 is resolved\n      segmentSortingFields = iw.getConfig().getIndexSortFields();\n    } finally {\n      holder.decref();\n    }\n    for (String fieldName: candidateFields) {\n      if (! fieldNamesFromIndexWriter.contains(fieldName) ) {\n        return Collections.emptySet(); // if this field doesn't exist, DV update can't work\n      }\n      if (segmentSortingFields.contains(fieldName) ) {\n        return Collections.emptySet(); // if this is used for segment sorting, DV updates can't work\n      }\n    }\n    \n    return candidateFields;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"de77148275e541f915efc6e934c276a0a7ec45ea","date":1556190342,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#computeInPlaceUpdatableFields(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#computeInPlaceUpdatableFields(AddUpdateCommand).mjava","sourceNew":"  /**\n   * Given an add update command, compute a list of fields that can be updated in-place. If there is even a single\n   * field in the update that cannot be updated in-place, the entire update cannot be executed in-place (and empty set\n   * will be returned in that case).\n   * \n   * @return Return a set of fields that can be in-place updated.\n   */\n  public static Set<String> computeInPlaceUpdatableFields(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    IndexSchema schema = cmd.getReq().getSchema();\n    \n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    final Set<String> candidateFields = new HashSet<>();\n\n    // if _version_ field is not supported for in-place update, bail out early\n    SchemaField versionField = schema.getFieldOrNull(CommonParams.VERSION_FIELD);\n    if (versionField == null || !isSupportedFieldForInPlaceUpdate(versionField)) {\n      return Collections.emptySet();\n    }\n    \n    String routeFieldOrNull = getRouteField(cmd);\n    // first pass, check the things that are virtually free,\n    // and bail out early if anything is obviously not a valid in-place update\n    for (String fieldName : sdoc.getFieldNames()) {\n      if (fieldName.equals(uniqueKeyFieldName)\n          || fieldName.equals(CommonParams.VERSION_FIELD)\n          || fieldName.equals(routeFieldOrNull)) {\n        continue;\n      }\n      Object fieldValue = sdoc.getField(fieldName).getValue();\n      if (! (fieldValue instanceof Map) ) {\n        // not an in-place update if there are fields that are not maps\n        return Collections.emptySet();\n      }\n      // else it's a atomic update map...\n      for (String op : ((Map<String, Object>)fieldValue).keySet()) {\n        if (!op.equals(\"set\") && !op.equals(\"inc\")) {\n          // not a supported in-place update op\n          return Collections.emptySet();\n        }\n        // fail fast if child doc\n        if(isChildDoc(((Map<String, Object>) fieldValue).get(op))) {\n          return Collections.emptySet();\n        }\n      }\n      candidateFields.add(fieldName);\n    }\n\n    if (candidateFields.isEmpty()) {\n      return Collections.emptySet();\n    }\n\n    // second pass over the candidates for in-place updates\n    // this time more expensive checks involving schema/config settings\n    for (String fieldName: candidateFields) {\n      SchemaField schemaField = schema.getField(fieldName);\n\n      if (!isSupportedFieldForInPlaceUpdate(schemaField)) {\n        return Collections.emptySet();\n      } \n\n      // if this field has copy target which is not supported for in place, then empty\n      for (CopyField copyField: schema.getCopyFieldsList(fieldName)) {\n        if (!isSupportedFieldForInPlaceUpdate(copyField.getDestination()))\n          return Collections.emptySet();\n      }\n    }\n    \n    // third pass: requiring checks against the actual IndexWriter due to internal DV update limitations\n    SolrCore core = cmd.getReq().getCore();\n    RefCounted<IndexWriter> holder = core.getSolrCoreState().getIndexWriter(core);\n    Set<String> fieldNamesFromIndexWriter = null;\n    Set<String> segmentSortingFields = null;\n    try {\n      IndexWriter iw = holder.get();\n      fieldNamesFromIndexWriter = iw.getFieldNames(); // This shouldn't be needed once LUCENE-7659 is resolved\n      segmentSortingFields = iw.getConfig().getIndexSortFields();\n    } finally {\n      holder.decref();\n    }\n    for (String fieldName: candidateFields) {\n      if (! fieldNamesFromIndexWriter.contains(fieldName) ) {\n        return Collections.emptySet(); // if this field doesn't exist, DV update can't work\n      }\n      if (segmentSortingFields.contains(fieldName) ) {\n        return Collections.emptySet(); // if this is used for segment sorting, DV updates can't work\n      }\n    }\n    \n    return candidateFields;\n  }\n\n","sourceOld":"  /**\n   * Given an add update command, compute a list of fields that can be updated in-place. If there is even a single\n   * field in the update that cannot be updated in-place, the entire update cannot be executed in-place (and empty set\n   * will be returned in that case).\n   * \n   * @return Return a set of fields that can be in-place updated.\n   */\n  public static Set<String> computeInPlaceUpdatableFields(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    IndexSchema schema = cmd.getReq().getSchema();\n    \n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    final Set<String> candidateFields = new HashSet<>();\n\n    // if _version_ field is not supported for in-place update, bail out early\n    SchemaField versionField = schema.getFieldOrNull(CommonParams.VERSION_FIELD);\n    if (versionField == null || !isSupportedFieldForInPlaceUpdate(versionField)) {\n      return Collections.emptySet();\n    }\n    \n    // first pass, check the things that are virtually free,\n    // and bail out early if anything is obviously not a valid in-place update\n    for (String fieldName : sdoc.getFieldNames()) {\n      if (fieldName.equals(uniqueKeyFieldName)\n          || fieldName.equals(CommonParams.VERSION_FIELD)) {\n        continue;\n      }\n      Object fieldValue = sdoc.getField(fieldName).getValue();\n      if (! (fieldValue instanceof Map) ) {\n        // not an in-place update if there are fields that are not maps\n        return Collections.emptySet();\n      }\n      // else it's a atomic update map...\n      for (String op : ((Map<String, Object>)fieldValue).keySet()) {\n        if (!op.equals(\"set\") && !op.equals(\"inc\")) {\n          // not a supported in-place update op\n          return Collections.emptySet();\n        }\n        // fail fast if child doc\n        if(isChildDoc(((Map<String, Object>) fieldValue).get(op))) {\n          return Collections.emptySet();\n        }\n      }\n      candidateFields.add(fieldName);\n    }\n\n    if (candidateFields.isEmpty()) {\n      return Collections.emptySet();\n    }\n\n    // second pass over the candidates for in-place updates\n    // this time more expensive checks involving schema/config settings\n    for (String fieldName: candidateFields) {\n      SchemaField schemaField = schema.getField(fieldName);\n\n      if (!isSupportedFieldForInPlaceUpdate(schemaField)) {\n        return Collections.emptySet();\n      } \n\n      // if this field has copy target which is not supported for in place, then empty\n      for (CopyField copyField: schema.getCopyFieldsList(fieldName)) {\n        if (!isSupportedFieldForInPlaceUpdate(copyField.getDestination()))\n          return Collections.emptySet();\n      }\n    }\n    \n    // third pass: requiring checks against the actual IndexWriter due to internal DV update limitations\n    SolrCore core = cmd.getReq().getCore();\n    RefCounted<IndexWriter> holder = core.getSolrCoreState().getIndexWriter(core);\n    Set<String> fieldNamesFromIndexWriter = null;\n    Set<String> segmentSortingFields = null;\n    try {\n      IndexWriter iw = holder.get();\n      fieldNamesFromIndexWriter = iw.getFieldNames(); // This shouldn't be needed once LUCENE-7659 is resolved\n      segmentSortingFields = iw.getConfig().getIndexSortFields();\n    } finally {\n      holder.decref();\n    }\n    for (String fieldName: candidateFields) {\n      if (! fieldNamesFromIndexWriter.contains(fieldName) ) {\n        return Collections.emptySet(); // if this field doesn't exist, DV update can't work\n      }\n      if (segmentSortingFields.contains(fieldName) ) {\n        return Collections.emptySet(); // if this is used for segment sorting, DV updates can't work\n      }\n    }\n    \n    return candidateFields;\n  }\n\n","bugFix":["6d2dadc1f5ca8703d8659f4964961f9967935d75"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"48924d191f1724fe63df8b6401965b79a2787c71","date":1561368051,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#computeInPlaceUpdatableFields(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#computeInPlaceUpdatableFields(AddUpdateCommand).mjava","sourceNew":"  /**\n   * Given an add update command, compute a list of fields that can be updated in-place. If there is even a single\n   * field in the update that cannot be updated in-place, the entire update cannot be executed in-place (and empty set\n   * will be returned in that case).\n   * \n   * @return Return a set of fields that can be in-place updated.\n   */\n  public static Set<String> computeInPlaceUpdatableFields(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    IndexSchema schema = cmd.getReq().getSchema();\n    \n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    final Set<String> candidateFields = new HashSet<>();\n\n    // if _version_ field is not supported for in-place update, bail out early\n    SchemaField versionField = schema.getFieldOrNull(CommonParams.VERSION_FIELD);\n    if (versionField == null || !isSupportedFieldForInPlaceUpdate(versionField)) {\n      return Collections.emptySet();\n    }\n    \n    String routeFieldOrNull = getRouteField(cmd);\n    // first pass, check the things that are virtually free,\n    // and bail out early if anything is obviously not a valid in-place update\n    for (String fieldName : sdoc.getFieldNames()) {\n      if (fieldName.equals(uniqueKeyFieldName)\n          || fieldName.equals(CommonParams.VERSION_FIELD)\n          || fieldName.equals(routeFieldOrNull)) {\n        continue;\n      }\n      Object fieldValue = sdoc.getField(fieldName).getValue();\n      if (! (fieldValue instanceof Map) ) {\n        // not an in-place update if there are fields that are not maps\n        return Collections.emptySet();\n      }\n      // else it's a atomic update map...\n      Map<String, Object> fieldValueMap = (Map<String, Object>)fieldValue;\n      for (String op : fieldValueMap.keySet()) {\n        Object obj = fieldValueMap.get(op);\n        if (!op.equals(\"set\") && !op.equals(\"inc\")) {\n          // not a supported in-place update op\n          return Collections.emptySet();\n        } else if (op.equals(\"set\") && (obj == null || (obj instanceof Collection && ((Collection) obj).isEmpty()))) {\n          // when operation is set and value is either null or empty list\n          // treat the update as atomic instead of inplace\n          return Collections.emptySet();\n        }\n        // fail fast if child doc\n        if(isChildDoc(((Map<String, Object>) fieldValue).get(op))) {\n          return Collections.emptySet();\n        }\n      }\n      candidateFields.add(fieldName);\n    }\n\n    if (candidateFields.isEmpty()) {\n      return Collections.emptySet();\n    }\n\n    // second pass over the candidates for in-place updates\n    // this time more expensive checks involving schema/config settings\n    for (String fieldName: candidateFields) {\n      SchemaField schemaField = schema.getField(fieldName);\n\n      if (!isSupportedFieldForInPlaceUpdate(schemaField)) {\n        return Collections.emptySet();\n      } \n\n      // if this field has copy target which is not supported for in place, then empty\n      for (CopyField copyField: schema.getCopyFieldsList(fieldName)) {\n        if (!isSupportedFieldForInPlaceUpdate(copyField.getDestination()))\n          return Collections.emptySet();\n      }\n    }\n    \n    // third pass: requiring checks against the actual IndexWriter due to internal DV update limitations\n    SolrCore core = cmd.getReq().getCore();\n    RefCounted<IndexWriter> holder = core.getSolrCoreState().getIndexWriter(core);\n    Set<String> fieldNamesFromIndexWriter = null;\n    Set<String> segmentSortingFields = null;\n    try {\n      IndexWriter iw = holder.get();\n      fieldNamesFromIndexWriter = iw.getFieldNames(); // This shouldn't be needed once LUCENE-7659 is resolved\n      segmentSortingFields = iw.getConfig().getIndexSortFields();\n    } finally {\n      holder.decref();\n    }\n    for (String fieldName: candidateFields) {\n      if (! fieldNamesFromIndexWriter.contains(fieldName) ) {\n        return Collections.emptySet(); // if this field doesn't exist, DV update can't work\n      }\n      if (segmentSortingFields.contains(fieldName) ) {\n        return Collections.emptySet(); // if this is used for segment sorting, DV updates can't work\n      }\n    }\n    \n    return candidateFields;\n  }\n\n","sourceOld":"  /**\n   * Given an add update command, compute a list of fields that can be updated in-place. If there is even a single\n   * field in the update that cannot be updated in-place, the entire update cannot be executed in-place (and empty set\n   * will be returned in that case).\n   * \n   * @return Return a set of fields that can be in-place updated.\n   */\n  public static Set<String> computeInPlaceUpdatableFields(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    IndexSchema schema = cmd.getReq().getSchema();\n    \n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    final Set<String> candidateFields = new HashSet<>();\n\n    // if _version_ field is not supported for in-place update, bail out early\n    SchemaField versionField = schema.getFieldOrNull(CommonParams.VERSION_FIELD);\n    if (versionField == null || !isSupportedFieldForInPlaceUpdate(versionField)) {\n      return Collections.emptySet();\n    }\n    \n    String routeFieldOrNull = getRouteField(cmd);\n    // first pass, check the things that are virtually free,\n    // and bail out early if anything is obviously not a valid in-place update\n    for (String fieldName : sdoc.getFieldNames()) {\n      if (fieldName.equals(uniqueKeyFieldName)\n          || fieldName.equals(CommonParams.VERSION_FIELD)\n          || fieldName.equals(routeFieldOrNull)) {\n        continue;\n      }\n      Object fieldValue = sdoc.getField(fieldName).getValue();\n      if (! (fieldValue instanceof Map) ) {\n        // not an in-place update if there are fields that are not maps\n        return Collections.emptySet();\n      }\n      // else it's a atomic update map...\n      for (String op : ((Map<String, Object>)fieldValue).keySet()) {\n        if (!op.equals(\"set\") && !op.equals(\"inc\")) {\n          // not a supported in-place update op\n          return Collections.emptySet();\n        }\n        // fail fast if child doc\n        if(isChildDoc(((Map<String, Object>) fieldValue).get(op))) {\n          return Collections.emptySet();\n        }\n      }\n      candidateFields.add(fieldName);\n    }\n\n    if (candidateFields.isEmpty()) {\n      return Collections.emptySet();\n    }\n\n    // second pass over the candidates for in-place updates\n    // this time more expensive checks involving schema/config settings\n    for (String fieldName: candidateFields) {\n      SchemaField schemaField = schema.getField(fieldName);\n\n      if (!isSupportedFieldForInPlaceUpdate(schemaField)) {\n        return Collections.emptySet();\n      } \n\n      // if this field has copy target which is not supported for in place, then empty\n      for (CopyField copyField: schema.getCopyFieldsList(fieldName)) {\n        if (!isSupportedFieldForInPlaceUpdate(copyField.getDestination()))\n          return Collections.emptySet();\n      }\n    }\n    \n    // third pass: requiring checks against the actual IndexWriter due to internal DV update limitations\n    SolrCore core = cmd.getReq().getCore();\n    RefCounted<IndexWriter> holder = core.getSolrCoreState().getIndexWriter(core);\n    Set<String> fieldNamesFromIndexWriter = null;\n    Set<String> segmentSortingFields = null;\n    try {\n      IndexWriter iw = holder.get();\n      fieldNamesFromIndexWriter = iw.getFieldNames(); // This shouldn't be needed once LUCENE-7659 is resolved\n      segmentSortingFields = iw.getConfig().getIndexSortFields();\n    } finally {\n      holder.decref();\n    }\n    for (String fieldName: candidateFields) {\n      if (! fieldNamesFromIndexWriter.contains(fieldName) ) {\n        return Collections.emptySet(); // if this field doesn't exist, DV update can't work\n      }\n      if (segmentSortingFields.contains(fieldName) ) {\n        return Collections.emptySet(); // if this is used for segment sorting, DV updates can't work\n      }\n    }\n    \n    return candidateFields;\n  }\n\n","bugFix":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9c14208216474e190dcec6327766fd749b8aa965","date":1563380115,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#computeInPlaceUpdatableFields(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#computeInPlaceUpdatableFields(AddUpdateCommand).mjava","sourceNew":"  /**\n   * Given an add update command, compute a list of fields that can be updated in-place. If there is even a single\n   * field in the update that cannot be updated in-place, the entire update cannot be executed in-place (and empty set\n   * will be returned in that case).\n   * \n   * @return Return a set of fields that can be in-place updated.\n   */\n  public static Set<String> computeInPlaceUpdatableFields(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    IndexSchema schema = cmd.getReq().getSchema();\n    \n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    final Set<String> candidateFields = new HashSet<>();\n\n    // if _version_ field is not supported for in-place update, bail out early\n    SchemaField versionField = schema.getFieldOrNull(CommonParams.VERSION_FIELD);\n    if (versionField == null || !isSupportedFieldForInPlaceUpdate(versionField)) {\n      return Collections.emptySet();\n    }\n    \n    String routeFieldOrNull = getRouteField(cmd);\n    // first pass, check the things that are virtually free,\n    // and bail out early if anything is obviously not a valid in-place update\n    for (String fieldName : sdoc.getFieldNames()) {\n      if (fieldName.equals(uniqueKeyFieldName)\n          || fieldName.equals(CommonParams.VERSION_FIELD)\n          || fieldName.equals(routeFieldOrNull)) {\n        continue;\n      }\n      Object fieldValue = sdoc.getField(fieldName).getValue();\n      if (! (fieldValue instanceof Map) ) {\n        // not an in-place update if there are fields that are not maps\n        return Collections.emptySet();\n      }\n      // else it's a atomic update map...\n      Map<String, Object> fieldValueMap = (Map<String, Object>)fieldValue;\n      for (String op : fieldValueMap.keySet()) {\n        Object obj = fieldValueMap.get(op);\n        if (!op.equals(\"set\") && !op.equals(\"inc\")) {\n          // not a supported in-place update op\n          return Collections.emptySet();\n        } else if (op.equals(\"set\") && (obj == null || (obj instanceof Collection && ((Collection) obj).isEmpty()))) {\n          // when operation is set and value is either null or empty list\n          // treat the update as atomic instead of inplace\n          return Collections.emptySet();\n        }\n        // fail fast if child doc\n        if(isChildDoc(((Map<String, Object>) fieldValue).get(op))) {\n          return Collections.emptySet();\n        }\n      }\n      candidateFields.add(fieldName);\n    }\n\n    if (candidateFields.isEmpty()) {\n      return Collections.emptySet();\n    }\n\n    // second pass over the candidates for in-place updates\n    // this time more expensive checks involving schema/config settings\n    for (String fieldName: candidateFields) {\n      SchemaField schemaField = schema.getField(fieldName);\n\n      if (!isSupportedFieldForInPlaceUpdate(schemaField)) {\n        return Collections.emptySet();\n      } \n\n      // if this field has copy target which is not supported for in place, then empty\n      for (CopyField copyField: schema.getCopyFieldsList(fieldName)) {\n        if (!isSupportedFieldForInPlaceUpdate(copyField.getDestination()))\n          return Collections.emptySet();\n      }\n    }\n    \n    // third pass: requiring checks against the actual IndexWriter due to internal DV update limitations\n    SolrCore core = cmd.getReq().getCore();\n    RefCounted<IndexWriter> holder = core.getSolrCoreState().getIndexWriter(core);\n    Set<String> segmentSortingFields = null;\n    try {\n      IndexWriter iw = holder.get();\n      segmentSortingFields = iw.getConfig().getIndexSortFields();\n    } finally {\n      holder.decref();\n    }\n    for (String fieldName: candidateFields) {\n      if (segmentSortingFields.contains(fieldName) ) {\n        return Collections.emptySet(); // if this is used for segment sorting, DV updates can't work\n      }\n    }\n    \n    return candidateFields;\n  }\n\n","sourceOld":"  /**\n   * Given an add update command, compute a list of fields that can be updated in-place. If there is even a single\n   * field in the update that cannot be updated in-place, the entire update cannot be executed in-place (and empty set\n   * will be returned in that case).\n   * \n   * @return Return a set of fields that can be in-place updated.\n   */\n  public static Set<String> computeInPlaceUpdatableFields(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    IndexSchema schema = cmd.getReq().getSchema();\n    \n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    final Set<String> candidateFields = new HashSet<>();\n\n    // if _version_ field is not supported for in-place update, bail out early\n    SchemaField versionField = schema.getFieldOrNull(CommonParams.VERSION_FIELD);\n    if (versionField == null || !isSupportedFieldForInPlaceUpdate(versionField)) {\n      return Collections.emptySet();\n    }\n    \n    String routeFieldOrNull = getRouteField(cmd);\n    // first pass, check the things that are virtually free,\n    // and bail out early if anything is obviously not a valid in-place update\n    for (String fieldName : sdoc.getFieldNames()) {\n      if (fieldName.equals(uniqueKeyFieldName)\n          || fieldName.equals(CommonParams.VERSION_FIELD)\n          || fieldName.equals(routeFieldOrNull)) {\n        continue;\n      }\n      Object fieldValue = sdoc.getField(fieldName).getValue();\n      if (! (fieldValue instanceof Map) ) {\n        // not an in-place update if there are fields that are not maps\n        return Collections.emptySet();\n      }\n      // else it's a atomic update map...\n      Map<String, Object> fieldValueMap = (Map<String, Object>)fieldValue;\n      for (String op : fieldValueMap.keySet()) {\n        Object obj = fieldValueMap.get(op);\n        if (!op.equals(\"set\") && !op.equals(\"inc\")) {\n          // not a supported in-place update op\n          return Collections.emptySet();\n        } else if (op.equals(\"set\") && (obj == null || (obj instanceof Collection && ((Collection) obj).isEmpty()))) {\n          // when operation is set and value is either null or empty list\n          // treat the update as atomic instead of inplace\n          return Collections.emptySet();\n        }\n        // fail fast if child doc\n        if(isChildDoc(((Map<String, Object>) fieldValue).get(op))) {\n          return Collections.emptySet();\n        }\n      }\n      candidateFields.add(fieldName);\n    }\n\n    if (candidateFields.isEmpty()) {\n      return Collections.emptySet();\n    }\n\n    // second pass over the candidates for in-place updates\n    // this time more expensive checks involving schema/config settings\n    for (String fieldName: candidateFields) {\n      SchemaField schemaField = schema.getField(fieldName);\n\n      if (!isSupportedFieldForInPlaceUpdate(schemaField)) {\n        return Collections.emptySet();\n      } \n\n      // if this field has copy target which is not supported for in place, then empty\n      for (CopyField copyField: schema.getCopyFieldsList(fieldName)) {\n        if (!isSupportedFieldForInPlaceUpdate(copyField.getDestination()))\n          return Collections.emptySet();\n      }\n    }\n    \n    // third pass: requiring checks against the actual IndexWriter due to internal DV update limitations\n    SolrCore core = cmd.getReq().getCore();\n    RefCounted<IndexWriter> holder = core.getSolrCoreState().getIndexWriter(core);\n    Set<String> fieldNamesFromIndexWriter = null;\n    Set<String> segmentSortingFields = null;\n    try {\n      IndexWriter iw = holder.get();\n      fieldNamesFromIndexWriter = iw.getFieldNames(); // This shouldn't be needed once LUCENE-7659 is resolved\n      segmentSortingFields = iw.getConfig().getIndexSortFields();\n    } finally {\n      holder.decref();\n    }\n    for (String fieldName: candidateFields) {\n      if (! fieldNamesFromIndexWriter.contains(fieldName) ) {\n        return Collections.emptySet(); // if this field doesn't exist, DV update can't work\n      }\n      if (segmentSortingFields.contains(fieldName) ) {\n        return Collections.emptySet(); // if this is used for segment sorting, DV updates can't work\n      }\n    }\n    \n    return candidateFields;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f97fc3d287be2a8d7f513f0de3249b50dda47299","date":1568378558,"type":3,"author":"Koen De Groote","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#computeInPlaceUpdatableFields(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#computeInPlaceUpdatableFields(AddUpdateCommand).mjava","sourceNew":"  /**\n   * Given an add update command, compute a list of fields that can be updated in-place. If there is even a single\n   * field in the update that cannot be updated in-place, the entire update cannot be executed in-place (and empty set\n   * will be returned in that case).\n   * \n   * @return Return a set of fields that can be in-place updated.\n   */\n  public static Set<String> computeInPlaceUpdatableFields(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    IndexSchema schema = cmd.getReq().getSchema();\n    \n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    final Set<String> candidateFields = new HashSet<>();\n\n    // if _version_ field is not supported for in-place update, bail out early\n    SchemaField versionField = schema.getFieldOrNull(CommonParams.VERSION_FIELD);\n    if (versionField == null || !isSupportedFieldForInPlaceUpdate(versionField)) {\n      return Collections.emptySet();\n    }\n    \n    String routeFieldOrNull = getRouteField(cmd);\n    // first pass, check the things that are virtually free,\n    // and bail out early if anything is obviously not a valid in-place update\n    for (String fieldName : sdoc.getFieldNames()) {\n      if (fieldName.equals(uniqueKeyFieldName)\n          || fieldName.equals(CommonParams.VERSION_FIELD)\n          || fieldName.equals(routeFieldOrNull)) {\n        continue;\n      }\n      Object fieldValue = sdoc.getField(fieldName).getValue();\n      if (! (fieldValue instanceof Map) ) {\n        // not an in-place update if there are fields that are not maps\n        return Collections.emptySet();\n      }\n      // else it's a atomic update map...\n      Map<String, Object> fieldValueMap = (Map<String, Object>)fieldValue;\n      for (Entry<String, Object> entry : fieldValueMap.entrySet()) {\n        String op = entry.getKey();\n        Object obj = entry.getValue();\n        if (!op.equals(\"set\") && !op.equals(\"inc\")) {\n          // not a supported in-place update op\n          return Collections.emptySet();\n        } else if (op.equals(\"set\") && (obj == null || (obj instanceof Collection && ((Collection) obj).isEmpty()))) {\n          // when operation is set and value is either null or empty list\n          // treat the update as atomic instead of inplace\n          return Collections.emptySet();\n        }\n        // fail fast if child doc\n        if(isChildDoc(((Map<String, Object>) fieldValue).get(op))) {\n          return Collections.emptySet();\n        }\n      }\n      candidateFields.add(fieldName);\n    }\n\n    if (candidateFields.isEmpty()) {\n      return Collections.emptySet();\n    }\n\n    // second pass over the candidates for in-place updates\n    // this time more expensive checks involving schema/config settings\n    for (String fieldName: candidateFields) {\n      SchemaField schemaField = schema.getField(fieldName);\n\n      if (!isSupportedFieldForInPlaceUpdate(schemaField)) {\n        return Collections.emptySet();\n      } \n\n      // if this field has copy target which is not supported for in place, then empty\n      for (CopyField copyField: schema.getCopyFieldsList(fieldName)) {\n        if (!isSupportedFieldForInPlaceUpdate(copyField.getDestination()))\n          return Collections.emptySet();\n      }\n    }\n    \n    // third pass: requiring checks against the actual IndexWriter due to internal DV update limitations\n    SolrCore core = cmd.getReq().getCore();\n    RefCounted<IndexWriter> holder = core.getSolrCoreState().getIndexWriter(core);\n    Set<String> segmentSortingFields = null;\n    try {\n      IndexWriter iw = holder.get();\n      segmentSortingFields = iw.getConfig().getIndexSortFields();\n    } finally {\n      holder.decref();\n    }\n    for (String fieldName: candidateFields) {\n      if (segmentSortingFields.contains(fieldName) ) {\n        return Collections.emptySet(); // if this is used for segment sorting, DV updates can't work\n      }\n    }\n    \n    return candidateFields;\n  }\n\n","sourceOld":"  /**\n   * Given an add update command, compute a list of fields that can be updated in-place. If there is even a single\n   * field in the update that cannot be updated in-place, the entire update cannot be executed in-place (and empty set\n   * will be returned in that case).\n   * \n   * @return Return a set of fields that can be in-place updated.\n   */\n  public static Set<String> computeInPlaceUpdatableFields(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    IndexSchema schema = cmd.getReq().getSchema();\n    \n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    final Set<String> candidateFields = new HashSet<>();\n\n    // if _version_ field is not supported for in-place update, bail out early\n    SchemaField versionField = schema.getFieldOrNull(CommonParams.VERSION_FIELD);\n    if (versionField == null || !isSupportedFieldForInPlaceUpdate(versionField)) {\n      return Collections.emptySet();\n    }\n    \n    String routeFieldOrNull = getRouteField(cmd);\n    // first pass, check the things that are virtually free,\n    // and bail out early if anything is obviously not a valid in-place update\n    for (String fieldName : sdoc.getFieldNames()) {\n      if (fieldName.equals(uniqueKeyFieldName)\n          || fieldName.equals(CommonParams.VERSION_FIELD)\n          || fieldName.equals(routeFieldOrNull)) {\n        continue;\n      }\n      Object fieldValue = sdoc.getField(fieldName).getValue();\n      if (! (fieldValue instanceof Map) ) {\n        // not an in-place update if there are fields that are not maps\n        return Collections.emptySet();\n      }\n      // else it's a atomic update map...\n      Map<String, Object> fieldValueMap = (Map<String, Object>)fieldValue;\n      for (String op : fieldValueMap.keySet()) {\n        Object obj = fieldValueMap.get(op);\n        if (!op.equals(\"set\") && !op.equals(\"inc\")) {\n          // not a supported in-place update op\n          return Collections.emptySet();\n        } else if (op.equals(\"set\") && (obj == null || (obj instanceof Collection && ((Collection) obj).isEmpty()))) {\n          // when operation is set and value is either null or empty list\n          // treat the update as atomic instead of inplace\n          return Collections.emptySet();\n        }\n        // fail fast if child doc\n        if(isChildDoc(((Map<String, Object>) fieldValue).get(op))) {\n          return Collections.emptySet();\n        }\n      }\n      candidateFields.add(fieldName);\n    }\n\n    if (candidateFields.isEmpty()) {\n      return Collections.emptySet();\n    }\n\n    // second pass over the candidates for in-place updates\n    // this time more expensive checks involving schema/config settings\n    for (String fieldName: candidateFields) {\n      SchemaField schemaField = schema.getField(fieldName);\n\n      if (!isSupportedFieldForInPlaceUpdate(schemaField)) {\n        return Collections.emptySet();\n      } \n\n      // if this field has copy target which is not supported for in place, then empty\n      for (CopyField copyField: schema.getCopyFieldsList(fieldName)) {\n        if (!isSupportedFieldForInPlaceUpdate(copyField.getDestination()))\n          return Collections.emptySet();\n      }\n    }\n    \n    // third pass: requiring checks against the actual IndexWriter due to internal DV update limitations\n    SolrCore core = cmd.getReq().getCore();\n    RefCounted<IndexWriter> holder = core.getSolrCoreState().getIndexWriter(core);\n    Set<String> segmentSortingFields = null;\n    try {\n      IndexWriter iw = holder.get();\n      segmentSortingFields = iw.getConfig().getIndexSortFields();\n    } finally {\n      holder.decref();\n    }\n    for (String fieldName: candidateFields) {\n      if (segmentSortingFields.contains(fieldName) ) {\n        return Collections.emptySet(); // if this is used for segment sorting, DV updates can't work\n      }\n    }\n    \n    return candidateFields;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"689f9afcb5195815904e30fd753e3db8f5fcbf29","date":1582804294,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#computeInPlaceUpdatableFields(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#computeInPlaceUpdatableFields(AddUpdateCommand).mjava","sourceNew":"  /**\n   * Given an add update command, compute a list of fields that can be updated in-place. If there is even a single\n   * field in the update that cannot be updated in-place, the entire update cannot be executed in-place (and empty set\n   * will be returned in that case).\n   * \n   * @return Return a set of fields that can be in-place updated.\n   */\n  public static Set<String> computeInPlaceUpdatableFields(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    IndexSchema schema = cmd.getReq().getSchema();\n    \n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    final Set<String> candidateFields = new HashSet<>();\n\n    // if _version_ field is not supported for in-place update, bail out early\n    SchemaField versionField = schema.getFieldOrNull(CommonParams.VERSION_FIELD);\n    if (versionField == null || !isSupportedFieldForInPlaceUpdate(versionField)) {\n      return Collections.emptySet();\n    }\n    \n    String routeFieldOrNull = getRouteField(cmd);\n    // first pass, check the things that are virtually free,\n    // and bail out early if anything is obviously not a valid in-place update\n    for (String fieldName : sdoc.getFieldNames()) {\n      Object fieldValue = sdoc.getField(fieldName).getValue();\n      if (fieldName.equals(uniqueKeyFieldName)\n          || fieldName.equals(CommonParams.VERSION_FIELD)\n          || fieldName.equals(routeFieldOrNull)) {\n        if (fieldValue instanceof Map ) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Updating unique key, version or route field is not allowed: \" + sdoc.getField(fieldName));\n        } else {\n          continue;\n        }\n      }\n      if (! (fieldValue instanceof Map) ) {\n        // not an in-place update if there are fields that are not maps\n        return Collections.emptySet();\n      }\n      // else it's a atomic update map...\n      Map<String, Object> fieldValueMap = (Map<String, Object>)fieldValue;\n      for (Entry<String, Object> entry : fieldValueMap.entrySet()) {\n        String op = entry.getKey();\n        Object obj = entry.getValue();\n        if (!op.equals(\"set\") && !op.equals(\"inc\")) {\n          // not a supported in-place update op\n          return Collections.emptySet();\n        } else if (op.equals(\"set\") && (obj == null || (obj instanceof Collection && ((Collection) obj).isEmpty()))) {\n          // when operation is set and value is either null or empty list\n          // treat the update as atomic instead of inplace\n          return Collections.emptySet();\n        }\n        // fail fast if child doc\n        if(isChildDoc(((Map<String, Object>) fieldValue).get(op))) {\n          return Collections.emptySet();\n        }\n      }\n      candidateFields.add(fieldName);\n    }\n\n    if (candidateFields.isEmpty()) {\n      return Collections.emptySet();\n    }\n\n    // second pass over the candidates for in-place updates\n    // this time more expensive checks involving schema/config settings\n    for (String fieldName: candidateFields) {\n      SchemaField schemaField = schema.getField(fieldName);\n\n      if (!isSupportedFieldForInPlaceUpdate(schemaField)) {\n        return Collections.emptySet();\n      } \n\n      // if this field has copy target which is not supported for in place, then empty\n      for (CopyField copyField: schema.getCopyFieldsList(fieldName)) {\n        if (!isSupportedFieldForInPlaceUpdate(copyField.getDestination()))\n          return Collections.emptySet();\n      }\n    }\n    \n    // third pass: requiring checks against the actual IndexWriter due to internal DV update limitations\n    SolrCore core = cmd.getReq().getCore();\n    RefCounted<IndexWriter> holder = core.getSolrCoreState().getIndexWriter(core);\n    Set<String> segmentSortingFields = null;\n    try {\n      IndexWriter iw = holder.get();\n      segmentSortingFields = iw.getConfig().getIndexSortFields();\n    } finally {\n      holder.decref();\n    }\n    for (String fieldName: candidateFields) {\n      if (segmentSortingFields.contains(fieldName) ) {\n        return Collections.emptySet(); // if this is used for segment sorting, DV updates can't work\n      }\n    }\n    \n    return candidateFields;\n  }\n\n","sourceOld":"  /**\n   * Given an add update command, compute a list of fields that can be updated in-place. If there is even a single\n   * field in the update that cannot be updated in-place, the entire update cannot be executed in-place (and empty set\n   * will be returned in that case).\n   * \n   * @return Return a set of fields that can be in-place updated.\n   */\n  public static Set<String> computeInPlaceUpdatableFields(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    IndexSchema schema = cmd.getReq().getSchema();\n    \n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    final Set<String> candidateFields = new HashSet<>();\n\n    // if _version_ field is not supported for in-place update, bail out early\n    SchemaField versionField = schema.getFieldOrNull(CommonParams.VERSION_FIELD);\n    if (versionField == null || !isSupportedFieldForInPlaceUpdate(versionField)) {\n      return Collections.emptySet();\n    }\n    \n    String routeFieldOrNull = getRouteField(cmd);\n    // first pass, check the things that are virtually free,\n    // and bail out early if anything is obviously not a valid in-place update\n    for (String fieldName : sdoc.getFieldNames()) {\n      if (fieldName.equals(uniqueKeyFieldName)\n          || fieldName.equals(CommonParams.VERSION_FIELD)\n          || fieldName.equals(routeFieldOrNull)) {\n        continue;\n      }\n      Object fieldValue = sdoc.getField(fieldName).getValue();\n      if (! (fieldValue instanceof Map) ) {\n        // not an in-place update if there are fields that are not maps\n        return Collections.emptySet();\n      }\n      // else it's a atomic update map...\n      Map<String, Object> fieldValueMap = (Map<String, Object>)fieldValue;\n      for (Entry<String, Object> entry : fieldValueMap.entrySet()) {\n        String op = entry.getKey();\n        Object obj = entry.getValue();\n        if (!op.equals(\"set\") && !op.equals(\"inc\")) {\n          // not a supported in-place update op\n          return Collections.emptySet();\n        } else if (op.equals(\"set\") && (obj == null || (obj instanceof Collection && ((Collection) obj).isEmpty()))) {\n          // when operation is set and value is either null or empty list\n          // treat the update as atomic instead of inplace\n          return Collections.emptySet();\n        }\n        // fail fast if child doc\n        if(isChildDoc(((Map<String, Object>) fieldValue).get(op))) {\n          return Collections.emptySet();\n        }\n      }\n      candidateFields.add(fieldName);\n    }\n\n    if (candidateFields.isEmpty()) {\n      return Collections.emptySet();\n    }\n\n    // second pass over the candidates for in-place updates\n    // this time more expensive checks involving schema/config settings\n    for (String fieldName: candidateFields) {\n      SchemaField schemaField = schema.getField(fieldName);\n\n      if (!isSupportedFieldForInPlaceUpdate(schemaField)) {\n        return Collections.emptySet();\n      } \n\n      // if this field has copy target which is not supported for in place, then empty\n      for (CopyField copyField: schema.getCopyFieldsList(fieldName)) {\n        if (!isSupportedFieldForInPlaceUpdate(copyField.getDestination()))\n          return Collections.emptySet();\n      }\n    }\n    \n    // third pass: requiring checks against the actual IndexWriter due to internal DV update limitations\n    SolrCore core = cmd.getReq().getCore();\n    RefCounted<IndexWriter> holder = core.getSolrCoreState().getIndexWriter(core);\n    Set<String> segmentSortingFields = null;\n    try {\n      IndexWriter iw = holder.get();\n      segmentSortingFields = iw.getConfig().getIndexSortFields();\n    } finally {\n      holder.decref();\n    }\n    for (String fieldName: candidateFields) {\n      if (segmentSortingFields.contains(fieldName) ) {\n        return Collections.emptySet(); // if this is used for segment sorting, DV updates can't work\n      }\n    }\n    \n    return candidateFields;\n  }\n\n","bugFix":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"018a36ff4088cb91ab12cbe44f696d81d1fadd77","date":1591657414,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#computeInPlaceUpdatableFields(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/AtomicUpdateDocumentMerger#computeInPlaceUpdatableFields(AddUpdateCommand).mjava","sourceNew":"  /**\n   * Given an add update command, compute a list of fields that can be updated in-place. If there is even a single\n   * field in the update that cannot be updated in-place, the entire update cannot be executed in-place (and empty set\n   * will be returned in that case).\n   * \n   * @return Return a set of fields that can be in-place updated.\n   */\n  @SuppressWarnings({\"unchecked\"})\n  public static Set<String> computeInPlaceUpdatableFields(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    IndexSchema schema = cmd.getReq().getSchema();\n    \n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    final Set<String> candidateFields = new HashSet<>();\n\n    // if _version_ field is not supported for in-place update, bail out early\n    SchemaField versionField = schema.getFieldOrNull(CommonParams.VERSION_FIELD);\n    if (versionField == null || !isSupportedFieldForInPlaceUpdate(versionField)) {\n      return Collections.emptySet();\n    }\n    \n    String routeFieldOrNull = getRouteField(cmd);\n    // first pass, check the things that are virtually free,\n    // and bail out early if anything is obviously not a valid in-place update\n    for (String fieldName : sdoc.getFieldNames()) {\n      Object fieldValue = sdoc.getField(fieldName).getValue();\n      if (fieldName.equals(uniqueKeyFieldName)\n          || fieldName.equals(CommonParams.VERSION_FIELD)\n          || fieldName.equals(routeFieldOrNull)) {\n        if (fieldValue instanceof Map ) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Updating unique key, version or route field is not allowed: \" + sdoc.getField(fieldName));\n        } else {\n          continue;\n        }\n      }\n      if (! (fieldValue instanceof Map) ) {\n        // not an in-place update if there are fields that are not maps\n        return Collections.emptySet();\n      }\n      // else it's a atomic update map...\n      Map<String, Object> fieldValueMap = (Map<String, Object>)fieldValue;\n      for (Entry<String, Object> entry : fieldValueMap.entrySet()) {\n        String op = entry.getKey();\n        Object obj = entry.getValue();\n        if (!op.equals(\"set\") && !op.equals(\"inc\")) {\n          // not a supported in-place update op\n          return Collections.emptySet();\n        } else if (op.equals(\"set\") && (obj == null || (obj instanceof Collection && ((Collection) obj).isEmpty()))) {\n          // when operation is set and value is either null or empty list\n          // treat the update as atomic instead of inplace\n          return Collections.emptySet();\n        }\n        // fail fast if child doc\n        if(isChildDoc(((Map<String, Object>) fieldValue).get(op))) {\n          return Collections.emptySet();\n        }\n      }\n      candidateFields.add(fieldName);\n    }\n\n    if (candidateFields.isEmpty()) {\n      return Collections.emptySet();\n    }\n\n    // second pass over the candidates for in-place updates\n    // this time more expensive checks involving schema/config settings\n    for (String fieldName: candidateFields) {\n      SchemaField schemaField = schema.getField(fieldName);\n\n      if (!isSupportedFieldForInPlaceUpdate(schemaField)) {\n        return Collections.emptySet();\n      } \n\n      // if this field has copy target which is not supported for in place, then empty\n      for (CopyField copyField: schema.getCopyFieldsList(fieldName)) {\n        if (!isSupportedFieldForInPlaceUpdate(copyField.getDestination()))\n          return Collections.emptySet();\n      }\n    }\n    \n    // third pass: requiring checks against the actual IndexWriter due to internal DV update limitations\n    SolrCore core = cmd.getReq().getCore();\n    RefCounted<IndexWriter> holder = core.getSolrCoreState().getIndexWriter(core);\n    Set<String> segmentSortingFields = null;\n    try {\n      IndexWriter iw = holder.get();\n      segmentSortingFields = iw.getConfig().getIndexSortFields();\n    } finally {\n      holder.decref();\n    }\n    for (String fieldName: candidateFields) {\n      if (segmentSortingFields.contains(fieldName) ) {\n        return Collections.emptySet(); // if this is used for segment sorting, DV updates can't work\n      }\n    }\n    \n    return candidateFields;\n  }\n\n","sourceOld":"  /**\n   * Given an add update command, compute a list of fields that can be updated in-place. If there is even a single\n   * field in the update that cannot be updated in-place, the entire update cannot be executed in-place (and empty set\n   * will be returned in that case).\n   * \n   * @return Return a set of fields that can be in-place updated.\n   */\n  public static Set<String> computeInPlaceUpdatableFields(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    IndexSchema schema = cmd.getReq().getSchema();\n    \n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n\n    final Set<String> candidateFields = new HashSet<>();\n\n    // if _version_ field is not supported for in-place update, bail out early\n    SchemaField versionField = schema.getFieldOrNull(CommonParams.VERSION_FIELD);\n    if (versionField == null || !isSupportedFieldForInPlaceUpdate(versionField)) {\n      return Collections.emptySet();\n    }\n    \n    String routeFieldOrNull = getRouteField(cmd);\n    // first pass, check the things that are virtually free,\n    // and bail out early if anything is obviously not a valid in-place update\n    for (String fieldName : sdoc.getFieldNames()) {\n      Object fieldValue = sdoc.getField(fieldName).getValue();\n      if (fieldName.equals(uniqueKeyFieldName)\n          || fieldName.equals(CommonParams.VERSION_FIELD)\n          || fieldName.equals(routeFieldOrNull)) {\n        if (fieldValue instanceof Map ) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Updating unique key, version or route field is not allowed: \" + sdoc.getField(fieldName));\n        } else {\n          continue;\n        }\n      }\n      if (! (fieldValue instanceof Map) ) {\n        // not an in-place update if there are fields that are not maps\n        return Collections.emptySet();\n      }\n      // else it's a atomic update map...\n      Map<String, Object> fieldValueMap = (Map<String, Object>)fieldValue;\n      for (Entry<String, Object> entry : fieldValueMap.entrySet()) {\n        String op = entry.getKey();\n        Object obj = entry.getValue();\n        if (!op.equals(\"set\") && !op.equals(\"inc\")) {\n          // not a supported in-place update op\n          return Collections.emptySet();\n        } else if (op.equals(\"set\") && (obj == null || (obj instanceof Collection && ((Collection) obj).isEmpty()))) {\n          // when operation is set and value is either null or empty list\n          // treat the update as atomic instead of inplace\n          return Collections.emptySet();\n        }\n        // fail fast if child doc\n        if(isChildDoc(((Map<String, Object>) fieldValue).get(op))) {\n          return Collections.emptySet();\n        }\n      }\n      candidateFields.add(fieldName);\n    }\n\n    if (candidateFields.isEmpty()) {\n      return Collections.emptySet();\n    }\n\n    // second pass over the candidates for in-place updates\n    // this time more expensive checks involving schema/config settings\n    for (String fieldName: candidateFields) {\n      SchemaField schemaField = schema.getField(fieldName);\n\n      if (!isSupportedFieldForInPlaceUpdate(schemaField)) {\n        return Collections.emptySet();\n      } \n\n      // if this field has copy target which is not supported for in place, then empty\n      for (CopyField copyField: schema.getCopyFieldsList(fieldName)) {\n        if (!isSupportedFieldForInPlaceUpdate(copyField.getDestination()))\n          return Collections.emptySet();\n      }\n    }\n    \n    // third pass: requiring checks against the actual IndexWriter due to internal DV update limitations\n    SolrCore core = cmd.getReq().getCore();\n    RefCounted<IndexWriter> holder = core.getSolrCoreState().getIndexWriter(core);\n    Set<String> segmentSortingFields = null;\n    try {\n      IndexWriter iw = holder.get();\n      segmentSortingFields = iw.getConfig().getIndexSortFields();\n    } finally {\n      holder.decref();\n    }\n    for (String fieldName: candidateFields) {\n      if (segmentSortingFields.contains(fieldName) ) {\n        return Collections.emptySet(); // if this is used for segment sorting, DV updates can't work\n      }\n    }\n    \n    return candidateFields;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"598b5d23aa7c9732bf473c21a9cd309c44599394":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","415bbbe7da8065dd3c477bdc3c703c6425622998"],"018a36ff4088cb91ab12cbe44f696d81d1fadd77":["689f9afcb5195815904e30fd753e3db8f5fcbf29"],"6d2dadc1f5ca8703d8659f4964961f9967935d75":["c2795aeb0b4c10d1588f672d3d5ac7a394fc8461"],"07749612bed4eb54dd05255c1434c301133310c1":["6d2dadc1f5ca8703d8659f4964961f9967935d75"],"689f9afcb5195815904e30fd753e3db8f5fcbf29":["f97fc3d287be2a8d7f513f0de3249b50dda47299"],"e5fa6615014cd2288fe930f8c8bb726f9504961d":["c2795aeb0b4c10d1588f672d3d5ac7a394fc8461"],"48924d191f1724fe63df8b6401965b79a2787c71":["de77148275e541f915efc6e934c276a0a7ec45ea"],"c2795aeb0b4c10d1588f672d3d5ac7a394fc8461":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9c14208216474e190dcec6327766fd749b8aa965":["48924d191f1724fe63df8b6401965b79a2787c71"],"f97fc3d287be2a8d7f513f0de3249b50dda47299":["9c14208216474e190dcec6327766fd749b8aa965"],"de77148275e541f915efc6e934c276a0a7ec45ea":["07749612bed4eb54dd05255c1434c301133310c1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["018a36ff4088cb91ab12cbe44f696d81d1fadd77"]},"commit2Childs":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["598b5d23aa7c9732bf473c21a9cd309c44599394","c2795aeb0b4c10d1588f672d3d5ac7a394fc8461"],"598b5d23aa7c9732bf473c21a9cd309c44599394":[],"018a36ff4088cb91ab12cbe44f696d81d1fadd77":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6d2dadc1f5ca8703d8659f4964961f9967935d75":["07749612bed4eb54dd05255c1434c301133310c1"],"07749612bed4eb54dd05255c1434c301133310c1":["de77148275e541f915efc6e934c276a0a7ec45ea"],"689f9afcb5195815904e30fd753e3db8f5fcbf29":["018a36ff4088cb91ab12cbe44f696d81d1fadd77"],"e5fa6615014cd2288fe930f8c8bb726f9504961d":[],"48924d191f1724fe63df8b6401965b79a2787c71":["9c14208216474e190dcec6327766fd749b8aa965"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["415bbbe7da8065dd3c477bdc3c703c6425622998","598b5d23aa7c9732bf473c21a9cd309c44599394"],"c2795aeb0b4c10d1588f672d3d5ac7a394fc8461":["6d2dadc1f5ca8703d8659f4964961f9967935d75","e5fa6615014cd2288fe930f8c8bb726f9504961d"],"9c14208216474e190dcec6327766fd749b8aa965":["f97fc3d287be2a8d7f513f0de3249b50dda47299"],"f97fc3d287be2a8d7f513f0de3249b50dda47299":["689f9afcb5195815904e30fd753e3db8f5fcbf29"],"de77148275e541f915efc6e934c276a0a7ec45ea":["48924d191f1724fe63df8b6401965b79a2787c71"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["598b5d23aa7c9732bf473c21a9cd309c44599394","e5fa6615014cd2288fe930f8c8bb726f9504961d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}