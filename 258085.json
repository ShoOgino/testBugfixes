{"path":"lucene/core/src/java/org/apache/lucene/search/WANDScorer#updateMaxScores(int).mjava","commits":[{"id":"523cc6563c99a55527ef7993efc5413c6648852d","date":1518704038,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/WANDScorer#updateMaxScores(int).mjava","pathOld":"/dev/null","sourceNew":"  private void updateMaxScores(int target) throws IOException {\n    if (head.size() == 0) {\n      // If the head is empty we use the greatest score contributor as a lead\n      // like for conjunctions.\n      upTo = tail[0].scorer.advanceShallow(target);\n    } else {\n      // If we still have entries in 'head', we treat them all as leads and\n      // take the minimum of their next block boundaries as a next boundary.\n      // We don't take entries in 'tail' into account on purpose: 'tail' is\n      // supposed to contain the least score contributors, and taking them\n      // into account might not move the boundary fast enough, so we'll waste\n      // CPU re-computing the next boundary all the time.\n      int newUpTo = DocIdSetIterator.NO_MORE_DOCS;\n      for (DisiWrapper w : head) {\n        if (w.doc <= newUpTo) {\n          newUpTo = Math.min(w.scorer.advanceShallow(w.doc), newUpTo);\n          w.maxScore = scaleMaxScore(w.scorer.getMaxScore(newUpTo), scalingFactor);\n        }\n      }\n      upTo = newUpTo;\n    }\n\n    tailMaxScore = 0;\n    for (int i = 0; i < tailSize; ++i) {\n      DisiWrapper w = tail[i];\n      w.scorer.advanceShallow(target);\n      w.maxScore = scaleMaxScore(w.scorer.getMaxScore(upTo), scalingFactor);\n      upHeapMaxScore(tail, i); // the heap might need to be reordered\n      tailMaxScore += w.maxScore;\n    }\n\n    // We need to make sure that entries in 'tail' alone cannot match\n    // a competitive hit.\n    while (tailSize > 0 && tailMaxScore >= minCompetitiveScore) {\n      DisiWrapper w = popTail();\n      w.doc = w.iterator.advance(target);\n      head.add(w);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"523cc6563c99a55527ef7993efc5413c6648852d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["523cc6563c99a55527ef7993efc5413c6648852d"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["523cc6563c99a55527ef7993efc5413c6648852d"],"523cc6563c99a55527ef7993efc5413c6648852d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}