{"path":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeStrategy#createIndexableFields(Shape).mjava","commits":[{"id":"42ea82a615127d578d4d21a6743834c45fa10468","date":1342101990,"type":1,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeStrategy#createIndexableFields(Shape).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeStrategy#createField(Shape).mjava","sourceNew":"  @Override\n  public IndexableField[] createIndexableFields(Shape shape) {\n    int detailLevel = grid.getMaxLevelForPrecision(shape,distErrPct);\n    List<Node> cells = grid.getNodes(shape, detailLevel, true);//true=intermediates cells\n    //If shape isn't a point, add a full-resolution center-point so that\n    // PrefixFieldCacheProvider has the center-points.\n    // TODO index each center of a multi-point? Yes/no?\n    if (!(shape instanceof Point)) {\n      Point ctr = shape.getCenter();\n      //TODO should be smarter; don't index 2 tokens for this in CellTokenizer. Harmless though.\n      cells.add(grid.getNodes(ctr,grid.getMaxLevels(),false).get(0));\n    }\n\n    //TODO is CellTokenStream supposed to be re-used somehow? see Uwe's comments:\n    //  http://code.google.com/p/lucene-spatial-playground/issues/detail?id=4\n\n    Field field = new Field(getFieldName(), new CellTokenStream(cells.iterator()), FIELD_TYPE);\n    return new IndexableField[]{field};\n  }\n\n","sourceOld":"  @Override\n  public IndexableField createField(Shape shape) {\n    int detailLevel = grid.getMaxLevelForPrecision(shape,distErrPct);\n    List<Node> cells = grid.getNodes(shape, detailLevel, true);//true=intermediates cells\n    //If shape isn't a point, add a full-resolution center-point so that\n    // PrefixFieldCacheProvider has the center-points.\n    // TODO index each center of a multi-point? Yes/no?\n    if (!(shape instanceof Point)) {\n      Point ctr = shape.getCenter();\n      //TODO should be smarter; don't index 2 tokens for this in CellTokenizer. Harmless though.\n      cells.add(grid.getNodes(ctr,grid.getMaxLevels(),false).get(0));\n    }\n\n    //TODO is CellTokenStream supposed to be re-used somehow? see Uwe's comments:\n    //  http://code.google.com/p/lucene-spatial-playground/issues/detail?id=4\n\n    return new Field(getFieldName(),new CellTokenStream(cells.iterator()), FIELD_TYPE);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeStrategy#createIndexableFields(Shape).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public IndexableField[] createIndexableFields(Shape shape) {\n    int detailLevel = grid.getMaxLevelForPrecision(shape,distErrPct);\n    List<Node> cells = grid.getNodes(shape, detailLevel, true);//true=intermediates cells\n    //If shape isn't a point, add a full-resolution center-point so that\n    // PrefixFieldCacheProvider has the center-points.\n    // TODO index each center of a multi-point? Yes/no?\n    if (!(shape instanceof Point)) {\n      Point ctr = shape.getCenter();\n      //TODO should be smarter; don't index 2 tokens for this in CellTokenizer. Harmless though.\n      cells.add(grid.getNodes(ctr,grid.getMaxLevels(),false).get(0));\n    }\n\n    //TODO is CellTokenStream supposed to be re-used somehow? see Uwe's comments:\n    //  http://code.google.com/p/lucene-spatial-playground/issues/detail?id=4\n\n    Field field = new Field(getFieldName(), new CellTokenStream(cells.iterator()), FIELD_TYPE);\n    return new IndexableField[]{field};\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeStrategy#createIndexableFields(Shape).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public IndexableField[] createIndexableFields(Shape shape) {\n    int detailLevel = grid.getMaxLevelForPrecision(shape,distErrPct);\n    List<Node> cells = grid.getNodes(shape, detailLevel, true);//true=intermediates cells\n    //If shape isn't a point, add a full-resolution center-point so that\n    // PrefixFieldCacheProvider has the center-points.\n    // TODO index each center of a multi-point? Yes/no?\n    if (!(shape instanceof Point)) {\n      Point ctr = shape.getCenter();\n      //TODO should be smarter; don't index 2 tokens for this in CellTokenizer. Harmless though.\n      cells.add(grid.getNodes(ctr,grid.getMaxLevels(),false).get(0));\n    }\n\n    //TODO is CellTokenStream supposed to be re-used somehow? see Uwe's comments:\n    //  http://code.google.com/p/lucene-spatial-playground/issues/detail?id=4\n\n    Field field = new Field(getFieldName(), new CellTokenStream(cells.iterator()), FIELD_TYPE);\n    return new IndexableField[]{field};\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"409324b31a1419d7c05a38211168cf317e39be77","date":1344866765,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeStrategy#createIndexableFields(Shape).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeStrategy#createIndexableFields(Shape).mjava","sourceNew":"  @Override\n  public Field[] createIndexableFields(Shape shape) {\n    int detailLevel = grid.getMaxLevelForPrecision(shape,distErrPct);\n    List<Node> cells = grid.getNodes(shape, detailLevel, true);//true=intermediates cells\n    //If shape isn't a point, add a full-resolution center-point so that\n    // PrefixFieldCacheProvider has the center-points.\n    // TODO index each center of a multi-point? Yes/no?\n    if (!(shape instanceof Point)) {\n      Point ctr = shape.getCenter();\n      //TODO should be smarter; don't index 2 tokens for this in CellTokenizer. Harmless though.\n      cells.add(grid.getNodes(ctr,grid.getMaxLevels(),false).get(0));\n    }\n\n    //TODO is CellTokenStream supposed to be re-used somehow? see Uwe's comments:\n    //  http://code.google.com/p/lucene-spatial-playground/issues/detail?id=4\n\n    Field field = new Field(getFieldName(), new CellTokenStream(cells.iterator()), FIELD_TYPE);\n    return new Field[]{field};\n  }\n\n","sourceOld":"  @Override\n  public IndexableField[] createIndexableFields(Shape shape) {\n    int detailLevel = grid.getMaxLevelForPrecision(shape,distErrPct);\n    List<Node> cells = grid.getNodes(shape, detailLevel, true);//true=intermediates cells\n    //If shape isn't a point, add a full-resolution center-point so that\n    // PrefixFieldCacheProvider has the center-points.\n    // TODO index each center of a multi-point? Yes/no?\n    if (!(shape instanceof Point)) {\n      Point ctr = shape.getCenter();\n      //TODO should be smarter; don't index 2 tokens for this in CellTokenizer. Harmless though.\n      cells.add(grid.getNodes(ctr,grid.getMaxLevels(),false).get(0));\n    }\n\n    //TODO is CellTokenStream supposed to be re-used somehow? see Uwe's comments:\n    //  http://code.google.com/p/lucene-spatial-playground/issues/detail?id=4\n\n    Field field = new Field(getFieldName(), new CellTokenStream(cells.iterator()), FIELD_TYPE);\n    return new IndexableField[]{field};\n  }\n\n","bugFix":null,"bugIntro":["6e2410e27320f6aaba450cbf500d7822baf642f8"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1d028314cced5858683a1bb4741423d0f934257b","date":1346596535,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeStrategy#createIndexableFields(Shape).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeStrategy#createIndexableFields(Shape).mjava","sourceNew":"  @Override\n  public Field[] createIndexableFields(Shape shape) {\n    int detailLevel = grid.getMaxLevelForPrecision(shape,distErrPct);\n    List<Node> cells = grid.getNodes(shape, detailLevel, true);//true=intermediates cells\n    //If shape isn't a point, add a full-resolution center-point so that\n    // PrefixFieldCacheProvider has the center-points.\n    // TODO index each center of a multi-point? Yes/no?\n    if (!(shape instanceof Point)) {\n      Point ctr = shape.getCenter();\n      //TODO should be smarter; don't index 2 tokens for this in CellTokenizer. Harmless though.\n      cells.add(grid.getNodes(ctr,grid.getMaxLevels(),false).get(0));\n    }\n\n    //TODO is CellTokenStream supposed to be re-used somehow? see Uwe's comments:\n    //  http://code.google.com/p/lucene-spatial-playground/issues/detail?id=4\n\n    Field field = new Field(getFieldName(), new CellTokenStream(cells.iterator()), FIELD_TYPE);\n    return new Field[]{field};\n  }\n\n","sourceOld":"  @Override\n  public IndexableField[] createIndexableFields(Shape shape) {\n    int detailLevel = grid.getMaxLevelForPrecision(shape,distErrPct);\n    List<Node> cells = grid.getNodes(shape, detailLevel, true);//true=intermediates cells\n    //If shape isn't a point, add a full-resolution center-point so that\n    // PrefixFieldCacheProvider has the center-points.\n    // TODO index each center of a multi-point? Yes/no?\n    if (!(shape instanceof Point)) {\n      Point ctr = shape.getCenter();\n      //TODO should be smarter; don't index 2 tokens for this in CellTokenizer. Harmless though.\n      cells.add(grid.getNodes(ctr,grid.getMaxLevels(),false).get(0));\n    }\n\n    //TODO is CellTokenStream supposed to be re-used somehow? see Uwe's comments:\n    //  http://code.google.com/p/lucene-spatial-playground/issues/detail?id=4\n\n    Field field = new Field(getFieldName(), new CellTokenStream(cells.iterator()), FIELD_TYPE);\n    return new IndexableField[]{field};\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6e2410e27320f6aaba450cbf500d7822baf642f8","date":1347075066,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeStrategy#createIndexableFields(Shape).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeStrategy#createIndexableFields(Shape).mjava","sourceNew":"  @Override\n  public Field[] createIndexableFields(Shape shape) {\n    double distErr = SpatialArgs.calcDistanceFromErrPct(shape, distErrPct, ctx);\n    return createIndexableFields(shape, distErr);\n  }\n\n","sourceOld":"  @Override\n  public Field[] createIndexableFields(Shape shape) {\n    int detailLevel = grid.getMaxLevelForPrecision(shape,distErrPct);\n    List<Node> cells = grid.getNodes(shape, detailLevel, true);//true=intermediates cells\n    //If shape isn't a point, add a full-resolution center-point so that\n    // PrefixFieldCacheProvider has the center-points.\n    // TODO index each center of a multi-point? Yes/no?\n    if (!(shape instanceof Point)) {\n      Point ctr = shape.getCenter();\n      //TODO should be smarter; don't index 2 tokens for this in CellTokenizer. Harmless though.\n      cells.add(grid.getNodes(ctr,grid.getMaxLevels(),false).get(0));\n    }\n\n    //TODO is CellTokenStream supposed to be re-used somehow? see Uwe's comments:\n    //  http://code.google.com/p/lucene-spatial-playground/issues/detail?id=4\n\n    Field field = new Field(getFieldName(), new CellTokenStream(cells.iterator()), FIELD_TYPE);\n    return new Field[]{field};\n  }\n\n","bugFix":["399d569d88e65d963440cdd3a3e2d5f7cdd1bd42","409324b31a1419d7c05a38211168cf317e39be77","42ea82a615127d578d4d21a6743834c45fa10468"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"112d77ac8d3e10a362516ad834c9a11d35c94234","date":1456784319,"type":5,"author":"nknize","isMerge":false,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/PrefixTreeStrategy#createIndexableFields(Shape).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeStrategy#createIndexableFields(Shape).mjava","sourceNew":"  @Override\n  public Field[] createIndexableFields(Shape shape) {\n    double distErr = SpatialArgs.calcDistanceFromErrPct(shape, distErrPct, ctx);\n    return createIndexableFields(shape, distErr);\n  }\n\n","sourceOld":"  @Override\n  public Field[] createIndexableFields(Shape shape) {\n    double distErr = SpatialArgs.calcDistanceFromErrPct(shape, distErrPct, ctx);\n    return createIndexableFields(shape, distErr);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":5,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/PrefixTreeStrategy#createIndexableFields(Shape).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeStrategy#createIndexableFields(Shape).mjava","sourceNew":"  @Override\n  public Field[] createIndexableFields(Shape shape) {\n    double distErr = SpatialArgs.calcDistanceFromErrPct(shape, distErrPct, ctx);\n    return createIndexableFields(shape, distErr);\n  }\n\n","sourceOld":"  @Override\n  public Field[] createIndexableFields(Shape shape) {\n    double distErr = SpatialArgs.calcDistanceFromErrPct(shape, distErrPct, ctx);\n    return createIndexableFields(shape, distErr);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"409324b31a1419d7c05a38211168cf317e39be77":["aba371508186796cc6151d8223a5b4e16d02e26e"],"6e2410e27320f6aaba450cbf500d7822baf642f8":["1d028314cced5858683a1bb4741423d0f934257b"],"af2638813028b254a88b418ebeafb541afb49653":["6e2410e27320f6aaba450cbf500d7822baf642f8","112d77ac8d3e10a362516ad834c9a11d35c94234"],"1d028314cced5858683a1bb4741423d0f934257b":["42ea82a615127d578d4d21a6743834c45fa10468","409324b31a1419d7c05a38211168cf317e39be77"],"aba371508186796cc6151d8223a5b4e16d02e26e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","42ea82a615127d578d4d21a6743834c45fa10468"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","42ea82a615127d578d4d21a6743834c45fa10468"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"112d77ac8d3e10a362516ad834c9a11d35c94234":["6e2410e27320f6aaba450cbf500d7822baf642f8"],"42ea82a615127d578d4d21a6743834c45fa10468":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["af2638813028b254a88b418ebeafb541afb49653"]},"commit2Childs":{"409324b31a1419d7c05a38211168cf317e39be77":["1d028314cced5858683a1bb4741423d0f934257b"],"6e2410e27320f6aaba450cbf500d7822baf642f8":["af2638813028b254a88b418ebeafb541afb49653","112d77ac8d3e10a362516ad834c9a11d35c94234"],"af2638813028b254a88b418ebeafb541afb49653":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1d028314cced5858683a1bb4741423d0f934257b":["6e2410e27320f6aaba450cbf500d7822baf642f8"],"aba371508186796cc6151d8223a5b4e16d02e26e":["409324b31a1419d7c05a38211168cf317e39be77"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424","42ea82a615127d578d4d21a6743834c45fa10468"],"112d77ac8d3e10a362516ad834c9a11d35c94234":["af2638813028b254a88b418ebeafb541afb49653"],"42ea82a615127d578d4d21a6743834c45fa10468":["1d028314cced5858683a1bb4741423d0f934257b","aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}