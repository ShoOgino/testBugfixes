{"path":"solr/core/src/java/org/apache/solr/update/PeerSyncWithLeader#sync(List[Long]).mjava","commits":[{"id":"ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7","date":1529486762,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSyncWithLeader#sync(List[Long]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Sync with leader\n   * @param startingVersions : recent versions on startup\n   * @return result of PeerSync with leader\n   */\n  public PeerSync.PeerSyncResult sync(List<Long> startingVersions){\n    if (ulog == null) {\n      syncErrors.inc();\n      return PeerSync.PeerSyncResult.failure();\n    }\n\n    if (startingVersions.isEmpty()) {\n      log.warn(\"no frame of reference to tell if we've missed updates\");\n      syncErrors.inc();\n      return PeerSync.PeerSyncResult.failure();\n    }\n\n    MDCLoggingContext.setCore(core);\n    Timer.Context timerContext = null;\n    try {\n      log.info(msg() + \"START leader=\" + leaderUrl + \" nUpdates=\" + nUpdates);\n\n      if (debug) {\n        log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n      }\n      // check if we already in sync to begin with\n      if(doFingerprint && alreadyInSync()) {\n        syncSkipped.inc();\n        return PeerSync.PeerSyncResult.success();\n      }\n\n      // measure only when actual sync is performed\n      timerContext = syncTime.time();\n\n      List<Long> ourUpdates;\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n        bufferedUpdates = recentUpdates.getBufferUpdates();\n      }\n\n      ourUpdates.sort(absComparator);\n      startingVersions.sort(absComparator);\n\n      long ourLowThreshold = percentile(startingVersions, 0.8f);\n      long ourHighThreshold = percentile(startingVersions, 0.2f);\n\n      // now make sure that the starting updates overlap our updates\n      // there shouldn't be reorders, so any overlap will do.\n      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n\n      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n        log.warn(msg()\n            + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n        syncErrors.inc();\n        return PeerSync.PeerSyncResult.failure();\n      }\n\n      // let's merge the lists\n      for (Long ver : startingVersions) {\n        if (Math.abs(ver) < smallestNewUpdate) {\n          ourUpdates.add(ver);\n        }\n      }\n\n      boolean success = doSync(ourUpdates, ourLowThreshold, ourHighThreshold);\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      if (!success) {\n        syncErrors.inc();\n      }\n      return success ?  PeerSync.PeerSyncResult.success() : PeerSync.PeerSyncResult.failure();\n    } finally {\n      if (timerContext != null) {\n        timerContext.close();\n      }\n      try {\n        clientToLeader.close();\n      } catch (IOException e) {\n        log.warn(\"{} unable to close client to leader\", msg(), e);\n      }\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":0,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSyncWithLeader#sync(List[Long]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Sync with leader\n   * @param startingVersions : recent versions on startup\n   * @return result of PeerSync with leader\n   */\n  public PeerSync.PeerSyncResult sync(List<Long> startingVersions){\n    if (ulog == null) {\n      syncErrors.inc();\n      return PeerSync.PeerSyncResult.failure();\n    }\n\n    if (startingVersions.isEmpty()) {\n      log.warn(\"no frame of reference to tell if we've missed updates\");\n      syncErrors.inc();\n      return PeerSync.PeerSyncResult.failure();\n    }\n\n    MDCLoggingContext.setCore(core);\n    Timer.Context timerContext = null;\n    try {\n      log.info(msg() + \"START leader=\" + leaderUrl + \" nUpdates=\" + nUpdates);\n\n      if (debug) {\n        log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n      }\n      // check if we already in sync to begin with\n      if(doFingerprint && alreadyInSync()) {\n        syncSkipped.inc();\n        return PeerSync.PeerSyncResult.success();\n      }\n\n      // measure only when actual sync is performed\n      timerContext = syncTime.time();\n\n      List<Long> ourUpdates;\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n        bufferedUpdates = recentUpdates.getBufferUpdates();\n      }\n\n      ourUpdates.sort(absComparator);\n      startingVersions.sort(absComparator);\n\n      long ourLowThreshold = percentile(startingVersions, 0.8f);\n      long ourHighThreshold = percentile(startingVersions, 0.2f);\n\n      // now make sure that the starting updates overlap our updates\n      // there shouldn't be reorders, so any overlap will do.\n      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n\n      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n        log.warn(msg()\n            + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n        syncErrors.inc();\n        return PeerSync.PeerSyncResult.failure();\n      }\n\n      // let's merge the lists\n      for (Long ver : startingVersions) {\n        if (Math.abs(ver) < smallestNewUpdate) {\n          ourUpdates.add(ver);\n        }\n      }\n\n      boolean success = doSync(ourUpdates, ourLowThreshold, ourHighThreshold);\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      if (!success) {\n        syncErrors.inc();\n      }\n      return success ?  PeerSync.PeerSyncResult.success() : PeerSync.PeerSyncResult.failure();\n    } finally {\n      if (timerContext != null) {\n        timerContext.close();\n      }\n      try {\n        clientToLeader.close();\n      } catch (IOException e) {\n        log.warn(\"{} unable to close client to leader\", msg(), e);\n      }\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":0,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSyncWithLeader#sync(List[Long]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Sync with leader\n   * @param startingVersions : recent versions on startup\n   * @return result of PeerSync with leader\n   */\n  public PeerSync.PeerSyncResult sync(List<Long> startingVersions){\n    if (ulog == null) {\n      syncErrors.inc();\n      return PeerSync.PeerSyncResult.failure();\n    }\n\n    if (startingVersions.isEmpty()) {\n      log.warn(\"no frame of reference to tell if we've missed updates\");\n      syncErrors.inc();\n      return PeerSync.PeerSyncResult.failure();\n    }\n\n    MDCLoggingContext.setCore(core);\n    Timer.Context timerContext = null;\n    try {\n      log.info(msg() + \"START leader=\" + leaderUrl + \" nUpdates=\" + nUpdates);\n\n      if (debug) {\n        log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n      }\n      // check if we already in sync to begin with\n      if(doFingerprint && alreadyInSync()) {\n        syncSkipped.inc();\n        return PeerSync.PeerSyncResult.success();\n      }\n\n      // measure only when actual sync is performed\n      timerContext = syncTime.time();\n\n      List<Long> ourUpdates;\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n        bufferedUpdates = recentUpdates.getBufferUpdates();\n      }\n\n      ourUpdates.sort(absComparator);\n      startingVersions.sort(absComparator);\n\n      long ourLowThreshold = percentile(startingVersions, 0.8f);\n      long ourHighThreshold = percentile(startingVersions, 0.2f);\n\n      // now make sure that the starting updates overlap our updates\n      // there shouldn't be reorders, so any overlap will do.\n      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n\n      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n        log.warn(msg()\n            + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n        syncErrors.inc();\n        return PeerSync.PeerSyncResult.failure();\n      }\n\n      // let's merge the lists\n      for (Long ver : startingVersions) {\n        if (Math.abs(ver) < smallestNewUpdate) {\n          ourUpdates.add(ver);\n        }\n      }\n\n      boolean success = doSync(ourUpdates, ourLowThreshold, ourHighThreshold);\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      if (!success) {\n        syncErrors.inc();\n      }\n      return success ?  PeerSync.PeerSyncResult.success() : PeerSync.PeerSyncResult.failure();\n    } finally {\n      if (timerContext != null) {\n        timerContext.close();\n      }\n      try {\n        clientToLeader.close();\n      } catch (IOException e) {\n        log.warn(\"{} unable to close client to leader\", msg(), e);\n      }\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ed5005b977107bba28c700351216f1595e7abe4f","date":1585964712,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSyncWithLeader#sync(List[Long]).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSyncWithLeader#sync(List[Long]).mjava","sourceNew":"  /**\n   * Sync with leader\n   * @param startingVersions : recent versions on startup\n   * @return result of PeerSync with leader\n   */\n  public PeerSync.PeerSyncResult sync(List<Long> startingVersions){\n    if (ulog == null) {\n      syncErrors.inc();\n      return PeerSync.PeerSyncResult.failure();\n    }\n\n    if (startingVersions.isEmpty()) {\n      log.warn(\"no frame of reference to tell if we've missed updates\");\n      syncErrors.inc();\n      return PeerSync.PeerSyncResult.failure();\n    }\n\n    Timer.Context timerContext = null;\n    try {\n      log.info(msg() + \"START leader=\" + leaderUrl + \" nUpdates=\" + nUpdates);\n\n      if (debug) {\n        log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n      }\n      // check if we already in sync to begin with\n      if(doFingerprint && alreadyInSync()) {\n        syncSkipped.inc();\n        return PeerSync.PeerSyncResult.success();\n      }\n\n      // measure only when actual sync is performed\n      timerContext = syncTime.time();\n\n      List<Long> ourUpdates;\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n        bufferedUpdates = recentUpdates.getBufferUpdates();\n      }\n\n      ourUpdates.sort(absComparator);\n      startingVersions.sort(absComparator);\n\n      long ourLowThreshold = percentile(startingVersions, 0.8f);\n      long ourHighThreshold = percentile(startingVersions, 0.2f);\n\n      // now make sure that the starting updates overlap our updates\n      // there shouldn't be reorders, so any overlap will do.\n      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n\n      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n        log.warn(msg()\n            + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n        syncErrors.inc();\n        return PeerSync.PeerSyncResult.failure();\n      }\n\n      // let's merge the lists\n      for (Long ver : startingVersions) {\n        if (Math.abs(ver) < smallestNewUpdate) {\n          ourUpdates.add(ver);\n        }\n      }\n\n      boolean success = doSync(ourUpdates, ourLowThreshold, ourHighThreshold);\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      if (!success) {\n        syncErrors.inc();\n      }\n      return success ?  PeerSync.PeerSyncResult.success() : PeerSync.PeerSyncResult.failure();\n    } finally {\n      if (timerContext != null) {\n        timerContext.close();\n      }\n      try {\n        clientToLeader.close();\n      } catch (IOException e) {\n        log.warn(\"{} unable to close client to leader\", msg(), e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Sync with leader\n   * @param startingVersions : recent versions on startup\n   * @return result of PeerSync with leader\n   */\n  public PeerSync.PeerSyncResult sync(List<Long> startingVersions){\n    if (ulog == null) {\n      syncErrors.inc();\n      return PeerSync.PeerSyncResult.failure();\n    }\n\n    if (startingVersions.isEmpty()) {\n      log.warn(\"no frame of reference to tell if we've missed updates\");\n      syncErrors.inc();\n      return PeerSync.PeerSyncResult.failure();\n    }\n\n    MDCLoggingContext.setCore(core);\n    Timer.Context timerContext = null;\n    try {\n      log.info(msg() + \"START leader=\" + leaderUrl + \" nUpdates=\" + nUpdates);\n\n      if (debug) {\n        log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n      }\n      // check if we already in sync to begin with\n      if(doFingerprint && alreadyInSync()) {\n        syncSkipped.inc();\n        return PeerSync.PeerSyncResult.success();\n      }\n\n      // measure only when actual sync is performed\n      timerContext = syncTime.time();\n\n      List<Long> ourUpdates;\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n        bufferedUpdates = recentUpdates.getBufferUpdates();\n      }\n\n      ourUpdates.sort(absComparator);\n      startingVersions.sort(absComparator);\n\n      long ourLowThreshold = percentile(startingVersions, 0.8f);\n      long ourHighThreshold = percentile(startingVersions, 0.2f);\n\n      // now make sure that the starting updates overlap our updates\n      // there shouldn't be reorders, so any overlap will do.\n      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n\n      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n        log.warn(msg()\n            + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n        syncErrors.inc();\n        return PeerSync.PeerSyncResult.failure();\n      }\n\n      // let's merge the lists\n      for (Long ver : startingVersions) {\n        if (Math.abs(ver) < smallestNewUpdate) {\n          ourUpdates.add(ver);\n        }\n      }\n\n      boolean success = doSync(ourUpdates, ourLowThreshold, ourHighThreshold);\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      if (!success) {\n        syncErrors.inc();\n      }\n      return success ?  PeerSync.PeerSyncResult.success() : PeerSync.PeerSyncResult.failure();\n    } finally {\n      if (timerContext != null) {\n        timerContext.close();\n      }\n      try {\n        clientToLeader.close();\n      } catch (IOException e) {\n        log.warn(\"{} unable to close client to leader\", msg(), e);\n      }\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"740d649f013f07efbeb73ca854f106c60166e7c0","date":1587431295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSyncWithLeader#sync(List[Long]).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSyncWithLeader#sync(List[Long]).mjava","sourceNew":"  /**\n   * Sync with leader\n   * @param startingVersions : recent versions on startup\n   * @return result of PeerSync with leader\n   */\n  public PeerSync.PeerSyncResult sync(List<Long> startingVersions){\n    if (ulog == null) {\n      syncErrors.inc();\n      return PeerSync.PeerSyncResult.failure();\n    }\n\n    if (startingVersions.isEmpty()) {\n      log.warn(\"no frame of reference to tell if we've missed updates\");\n      syncErrors.inc();\n      return PeerSync.PeerSyncResult.failure();\n    }\n\n    Timer.Context timerContext = null;\n    try {\n      if (log.isInfoEnabled()) {\n        log.info(\"{} START leader={} nUpdates={}\", msg(), leaderUrl, nUpdates);\n      }\n\n      if (debug) {\n        log.debug(\"{} startingVersions={} {}\", msg(), startingVersions.size(), startingVersions);\n      }\n      // check if we already in sync to begin with\n      if(doFingerprint && alreadyInSync()) {\n        syncSkipped.inc();\n        return PeerSync.PeerSyncResult.success();\n      }\n\n      // measure only when actual sync is performed\n      timerContext = syncTime.time();\n\n      List<Long> ourUpdates;\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n        bufferedUpdates = recentUpdates.getBufferUpdates();\n      }\n\n      ourUpdates.sort(absComparator);\n      startingVersions.sort(absComparator);\n\n      long ourLowThreshold = percentile(startingVersions, 0.8f);\n      long ourHighThreshold = percentile(startingVersions, 0.2f);\n\n      // now make sure that the starting updates overlap our updates\n      // there shouldn't be reorders, so any overlap will do.\n      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n\n      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n        if (log.isWarnEnabled()) {\n          log.warn(\"{} too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\", msg());\n        }\n        syncErrors.inc();\n        return PeerSync.PeerSyncResult.failure();\n      }\n\n      // let's merge the lists\n      for (Long ver : startingVersions) {\n        if (Math.abs(ver) < smallestNewUpdate) {\n          ourUpdates.add(ver);\n        }\n      }\n\n      boolean success = doSync(ourUpdates, ourLowThreshold, ourHighThreshold);\n\n      if (log.isInfoEnabled()) {\n        log.info(\"{} DONE. sync {}\", msg(), (success ? \"succeeded\" : \"failed\"));\n      }\n      if (!success) {\n        syncErrors.inc();\n      }\n      return success ?  PeerSync.PeerSyncResult.success() : PeerSync.PeerSyncResult.failure();\n    } finally {\n      if (timerContext != null) {\n        timerContext.close();\n      }\n      try {\n        clientToLeader.close();\n      } catch (IOException e) {\n        if (log.isWarnEnabled()) {\n          log.warn(\"{} unable to close client to leader\", msg(), e);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Sync with leader\n   * @param startingVersions : recent versions on startup\n   * @return result of PeerSync with leader\n   */\n  public PeerSync.PeerSyncResult sync(List<Long> startingVersions){\n    if (ulog == null) {\n      syncErrors.inc();\n      return PeerSync.PeerSyncResult.failure();\n    }\n\n    if (startingVersions.isEmpty()) {\n      log.warn(\"no frame of reference to tell if we've missed updates\");\n      syncErrors.inc();\n      return PeerSync.PeerSyncResult.failure();\n    }\n\n    Timer.Context timerContext = null;\n    try {\n      log.info(msg() + \"START leader=\" + leaderUrl + \" nUpdates=\" + nUpdates);\n\n      if (debug) {\n        log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n      }\n      // check if we already in sync to begin with\n      if(doFingerprint && alreadyInSync()) {\n        syncSkipped.inc();\n        return PeerSync.PeerSyncResult.success();\n      }\n\n      // measure only when actual sync is performed\n      timerContext = syncTime.time();\n\n      List<Long> ourUpdates;\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n        bufferedUpdates = recentUpdates.getBufferUpdates();\n      }\n\n      ourUpdates.sort(absComparator);\n      startingVersions.sort(absComparator);\n\n      long ourLowThreshold = percentile(startingVersions, 0.8f);\n      long ourHighThreshold = percentile(startingVersions, 0.2f);\n\n      // now make sure that the starting updates overlap our updates\n      // there shouldn't be reorders, so any overlap will do.\n      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n\n      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n        log.warn(msg()\n            + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n        syncErrors.inc();\n        return PeerSync.PeerSyncResult.failure();\n      }\n\n      // let's merge the lists\n      for (Long ver : startingVersions) {\n        if (Math.abs(ver) < smallestNewUpdate) {\n          ourUpdates.add(ver);\n        }\n      }\n\n      boolean success = doSync(ourUpdates, ourLowThreshold, ourHighThreshold);\n\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      if (!success) {\n        syncErrors.inc();\n      }\n      return success ?  PeerSync.PeerSyncResult.success() : PeerSync.PeerSyncResult.failure();\n    } finally {\n      if (timerContext != null) {\n        timerContext.close();\n      }\n      try {\n        clientToLeader.close();\n      } catch (IOException e) {\n        log.warn(\"{} unable to close client to leader\", msg(), e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/PeerSyncWithLeader#sync(List[Long]).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/PeerSyncWithLeader#sync(List[Long]).mjava","sourceNew":"  /**\n   * Sync with leader\n   * @param startingVersions : recent versions on startup\n   * @return result of PeerSync with leader\n   */\n  public PeerSync.PeerSyncResult sync(List<Long> startingVersions){\n    if (ulog == null) {\n      syncErrors.inc();\n      return PeerSync.PeerSyncResult.failure();\n    }\n\n    if (startingVersions.isEmpty()) {\n      log.warn(\"no frame of reference to tell if we've missed updates\");\n      syncErrors.inc();\n      return PeerSync.PeerSyncResult.failure();\n    }\n\n    Timer.Context timerContext = null;\n    try {\n      if (log.isInfoEnabled()) {\n        log.info(\"{} START leader={} nUpdates={}\", msg(), leaderUrl, nUpdates);\n      }\n\n      if (debug) {\n        log.debug(\"{} startingVersions={} {}\", msg(), startingVersions.size(), startingVersions);\n      }\n      // check if we already in sync to begin with\n      if(doFingerprint && alreadyInSync()) {\n        syncSkipped.inc();\n        return PeerSync.PeerSyncResult.success();\n      }\n\n      // measure only when actual sync is performed\n      timerContext = syncTime.time();\n\n      List<Long> ourUpdates;\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n        bufferedUpdates = recentUpdates.getBufferUpdates();\n      }\n\n      ourUpdates.sort(absComparator);\n      startingVersions.sort(absComparator);\n\n      long ourLowThreshold = percentile(startingVersions, 0.8f);\n      long ourHighThreshold = percentile(startingVersions, 0.2f);\n\n      // now make sure that the starting updates overlap our updates\n      // there shouldn't be reorders, so any overlap will do.\n      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n\n      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n        log.warn(\"{} too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\", msg());\n        syncErrors.inc();\n        return PeerSync.PeerSyncResult.failure();\n      }\n\n      // let's merge the lists\n      for (Long ver : startingVersions) {\n        if (Math.abs(ver) < smallestNewUpdate) {\n          ourUpdates.add(ver);\n        }\n      }\n\n      boolean success = doSync(ourUpdates, ourLowThreshold, ourHighThreshold);\n\n      if (log.isInfoEnabled()) {\n        log.info(\"{} DONE. sync {}\", msg(), (success ? \"succeeded\" : \"failed\"));\n      }\n      if (!success) {\n        syncErrors.inc();\n      }\n      return success ?  PeerSync.PeerSyncResult.success() : PeerSync.PeerSyncResult.failure();\n    } finally {\n      if (timerContext != null) {\n        timerContext.close();\n      }\n      try {\n        clientToLeader.close();\n      } catch (IOException e) {\n        log.warn(\"{} unable to close client to leader\", msg(), e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Sync with leader\n   * @param startingVersions : recent versions on startup\n   * @return result of PeerSync with leader\n   */\n  public PeerSync.PeerSyncResult sync(List<Long> startingVersions){\n    if (ulog == null) {\n      syncErrors.inc();\n      return PeerSync.PeerSyncResult.failure();\n    }\n\n    if (startingVersions.isEmpty()) {\n      log.warn(\"no frame of reference to tell if we've missed updates\");\n      syncErrors.inc();\n      return PeerSync.PeerSyncResult.failure();\n    }\n\n    Timer.Context timerContext = null;\n    try {\n      if (log.isInfoEnabled()) {\n        log.info(\"{} START leader={} nUpdates={}\", msg(), leaderUrl, nUpdates);\n      }\n\n      if (debug) {\n        log.debug(\"{} startingVersions={} {}\", msg(), startingVersions.size(), startingVersions);\n      }\n      // check if we already in sync to begin with\n      if(doFingerprint && alreadyInSync()) {\n        syncSkipped.inc();\n        return PeerSync.PeerSyncResult.success();\n      }\n\n      // measure only when actual sync is performed\n      timerContext = syncTime.time();\n\n      List<Long> ourUpdates;\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n        bufferedUpdates = recentUpdates.getBufferUpdates();\n      }\n\n      ourUpdates.sort(absComparator);\n      startingVersions.sort(absComparator);\n\n      long ourLowThreshold = percentile(startingVersions, 0.8f);\n      long ourHighThreshold = percentile(startingVersions, 0.2f);\n\n      // now make sure that the starting updates overlap our updates\n      // there shouldn't be reorders, so any overlap will do.\n      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n\n      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n        if (log.isWarnEnabled()) {\n          log.warn(\"{} too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\", msg());\n        }\n        syncErrors.inc();\n        return PeerSync.PeerSyncResult.failure();\n      }\n\n      // let's merge the lists\n      for (Long ver : startingVersions) {\n        if (Math.abs(ver) < smallestNewUpdate) {\n          ourUpdates.add(ver);\n        }\n      }\n\n      boolean success = doSync(ourUpdates, ourLowThreshold, ourHighThreshold);\n\n      if (log.isInfoEnabled()) {\n        log.info(\"{} DONE. sync {}\", msg(), (success ? \"succeeded\" : \"failed\"));\n      }\n      if (!success) {\n        syncErrors.inc();\n      }\n      return success ?  PeerSync.PeerSyncResult.success() : PeerSync.PeerSyncResult.failure();\n    } finally {\n      if (timerContext != null) {\n        timerContext.close();\n      }\n      try {\n        clientToLeader.close();\n      } catch (IOException e) {\n        if (log.isWarnEnabled()) {\n          log.warn(\"{} unable to close client to leader\", msg(), e);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7"],"740d649f013f07efbeb73ca854f106c60166e7c0":["ed5005b977107bba28c700351216f1595e7abe4f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ed5005b977107bba28c700351216f1595e7abe4f":["ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7"],"575e66bd4b2349209027f6801184da7fc3cba13f":["740d649f013f07efbeb73ca854f106c60166e7c0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["575e66bd4b2349209027f6801184da7fc3cba13f"],"ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7"]},"commit2Childs":{"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"740d649f013f07efbeb73ca854f106c60166e7c0":["575e66bd4b2349209027f6801184da7fc3cba13f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"ed5005b977107bba28c700351216f1595e7abe4f":["740d649f013f07efbeb73ca854f106c60166e7c0"],"575e66bd4b2349209027f6801184da7fc3cba13f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","ed5005b977107bba28c700351216f1595e7abe4f","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}