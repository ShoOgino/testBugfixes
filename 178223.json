{"path":"solr/core/src/test/org/apache/solr/handler/TestCoreBackup#testDemoWhyBackupCodeShouldNeverUseIndexCommitFromSearcher().mjava","commits":[{"id":"19f02bb04467ed179738a398a7da80bbbe161c16","date":1573660732,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestCoreBackup#testDemoWhyBackupCodeShouldNeverUseIndexCommitFromSearcher().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * A simple sanity check that asserts the current weird behavior of DirectoryReader.openIfChanged()\n   * and demos how 'softCommit' can cause the IndexReader in use by SolrIndexSearcher to missrepresent what \n   * commit is \"current\".  So Backup code should only ever \"trust\" the IndexCommit info available from the \n   * IndexDeletionPolicyWrapper\n   * \n   * @see <a href=\"https://issues.apache.org/jira/browse/LUCENE-9040\">LUCENE-9040</a>\n   * @see <a href=\"https://issues.apache.org/jira/browse/SOLR-13909\">SOLR-13909</a>\n   */\n  public void testDemoWhyBackupCodeShouldNeverUseIndexCommitFromSearcher() throws Exception {\n\n    final long EXPECTED_GEN_OF_EMPTY_INDEX = 1L;\n    \n    // sanity check this is an empty index...\n    assertQ(req(\"q\", \"*:*\"), \"//result[@numFound='0']\");\n    \n    // sanity check what the searcher/reader of this empty index report about current commit\n    final IndexCommit empty = h.getCore().withSearcher(s -> {\n        // sanity check we are empty...\n        assertEquals(0L, (long) s.getIndexReader().numDocs());\n        \n        // sanity check this is the initial commit..\n        final IndexCommit commit = s.getIndexReader().getIndexCommit();\n        assertEquals(EXPECTED_GEN_OF_EMPTY_INDEX, (long) commit.getGeneration());\n        return commit;\n      });\n\n    // now let's add & soft commit 1 doc...\n    assertU(adoc(\"id\", \"42\"));\n    assertU(commit(\"softCommit\", \"true\", \"openSearcher\", \"true\"));\n\n    // verify it's \"searchable\" ...\n    assertQ(req(\"q\", \"id:42\"), \"//result[@numFound='1']\");\n\n    // sanity check what the searcher/reader of this empty index report about current commit\n    IndexCommit oneDoc = h.getCore().withSearcher(s -> {\n        // sanity check this really is the searcher/reader that has the new doc...\n        assertEquals(1L, (long) s.getIndexReader().numDocs());\n        \n        final IndexCommit commit = s.getIndexReader().getIndexCommit();\n        // WTF: how/why does this reader still have the same commit generation as before ? ? ? ? ?\n        assertEquals(\"WTF: This Reader (claims) the same generation as our previous pre-softCommif (empty) reader\",\n                     EXPECTED_GEN_OF_EMPTY_INDEX, (long) commit.getGeneration());\n        return commit;\n      });\n\n    assertEquals(\"WTF: Our two IndexCommits, which we know have different docs, claim to be equals\",\n                 empty, oneDoc);\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e98520789adb1d5ad05afb4956eca0944a929688","date":1592430701,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestCoreBackup#testDemoWhyBackupCodeShouldNeverUseIndexCommitFromSearcher().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestCoreBackup#testDemoWhyBackupCodeShouldNeverUseIndexCommitFromSearcher().mjava","sourceNew":"  /**\n   * A simple sanity check that asserts the current weird behavior of DirectoryReader.openIfChanged()\n   * and demos how 'softCommit' can cause the IndexReader in use by SolrIndexSearcher to missrepresent what \n   * commit is \"current\".  So Backup code should only ever \"trust\" the IndexCommit info available from the \n   * IndexDeletionPolicyWrapper\n   * \n   * @see <a href=\"https://issues.apache.org/jira/browse/LUCENE-9040\">LUCENE-9040</a>\n   * @see <a href=\"https://issues.apache.org/jira/browse/SOLR-13909\">SOLR-13909</a>\n   */\n  public void testDemoWhyBackupCodeShouldNeverUseIndexCommitFromSearcher() throws Exception {\n\n    final long EXPECTED_GEN_OF_EMPTY_INDEX = 1L;\n    \n    // sanity check this is an empty index...\n    assertQ(req(\"q\", \"*:*\"), \"//result[@numFound='0']\");\n    \n    // sanity check what the searcher/reader of this empty index report about current commit\n    final IndexCommit empty = h.getCore().withSearcher(s -> {\n        // sanity check we are empty...\n        assertEquals(0L, (long) s.getIndexReader().numDocs());\n        \n        // sanity check this is the initial commit..\n        final IndexCommit commit = s.getIndexReader().getIndexCommit();\n        assertEquals(EXPECTED_GEN_OF_EMPTY_INDEX, commit.getGeneration());\n        return commit;\n      });\n\n    // now let's add & soft commit 1 doc...\n    assertU(adoc(\"id\", \"42\"));\n    assertU(commit(\"softCommit\", \"true\", \"openSearcher\", \"true\"));\n\n    // verify it's \"searchable\" ...\n    assertQ(req(\"q\", \"id:42\"), \"//result[@numFound='1']\");\n\n    // sanity check what the searcher/reader of this empty index report about current commit\n    IndexCommit oneDoc = h.getCore().withSearcher(s -> {\n        // sanity check this really is the searcher/reader that has the new doc...\n        assertEquals(1L, (long) s.getIndexReader().numDocs());\n        \n        final IndexCommit commit = s.getIndexReader().getIndexCommit();\n        // WTF: how/why does this reader still have the same commit generation as before ? ? ? ? ?\n        assertEquals(\"WTF: This Reader (claims) the same generation as our previous pre-softCommif (empty) reader\",\n                     EXPECTED_GEN_OF_EMPTY_INDEX, commit.getGeneration());\n        return commit;\n      });\n\n    assertEquals(\"WTF: Our two IndexCommits, which we know have different docs, claim to be equals\",\n                 empty, oneDoc);\n    \n  }\n\n","sourceOld":"  /**\n   * A simple sanity check that asserts the current weird behavior of DirectoryReader.openIfChanged()\n   * and demos how 'softCommit' can cause the IndexReader in use by SolrIndexSearcher to missrepresent what \n   * commit is \"current\".  So Backup code should only ever \"trust\" the IndexCommit info available from the \n   * IndexDeletionPolicyWrapper\n   * \n   * @see <a href=\"https://issues.apache.org/jira/browse/LUCENE-9040\">LUCENE-9040</a>\n   * @see <a href=\"https://issues.apache.org/jira/browse/SOLR-13909\">SOLR-13909</a>\n   */\n  public void testDemoWhyBackupCodeShouldNeverUseIndexCommitFromSearcher() throws Exception {\n\n    final long EXPECTED_GEN_OF_EMPTY_INDEX = 1L;\n    \n    // sanity check this is an empty index...\n    assertQ(req(\"q\", \"*:*\"), \"//result[@numFound='0']\");\n    \n    // sanity check what the searcher/reader of this empty index report about current commit\n    final IndexCommit empty = h.getCore().withSearcher(s -> {\n        // sanity check we are empty...\n        assertEquals(0L, (long) s.getIndexReader().numDocs());\n        \n        // sanity check this is the initial commit..\n        final IndexCommit commit = s.getIndexReader().getIndexCommit();\n        assertEquals(EXPECTED_GEN_OF_EMPTY_INDEX, (long) commit.getGeneration());\n        return commit;\n      });\n\n    // now let's add & soft commit 1 doc...\n    assertU(adoc(\"id\", \"42\"));\n    assertU(commit(\"softCommit\", \"true\", \"openSearcher\", \"true\"));\n\n    // verify it's \"searchable\" ...\n    assertQ(req(\"q\", \"id:42\"), \"//result[@numFound='1']\");\n\n    // sanity check what the searcher/reader of this empty index report about current commit\n    IndexCommit oneDoc = h.getCore().withSearcher(s -> {\n        // sanity check this really is the searcher/reader that has the new doc...\n        assertEquals(1L, (long) s.getIndexReader().numDocs());\n        \n        final IndexCommit commit = s.getIndexReader().getIndexCommit();\n        // WTF: how/why does this reader still have the same commit generation as before ? ? ? ? ?\n        assertEquals(\"WTF: This Reader (claims) the same generation as our previous pre-softCommif (empty) reader\",\n                     EXPECTED_GEN_OF_EMPTY_INDEX, (long) commit.getGeneration());\n        return commit;\n      });\n\n    assertEquals(\"WTF: Our two IndexCommits, which we know have different docs, claim to be equals\",\n                 empty, oneDoc);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"19f02bb04467ed179738a398a7da80bbbe161c16":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e98520789adb1d5ad05afb4956eca0944a929688"],"e98520789adb1d5ad05afb4956eca0944a929688":["19f02bb04467ed179738a398a7da80bbbe161c16"]},"commit2Childs":{"19f02bb04467ed179738a398a7da80bbbe161c16":["e98520789adb1d5ad05afb4956eca0944a929688"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["19f02bb04467ed179738a398a7da80bbbe161c16"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"e98520789adb1d5ad05afb4956eca0944a929688":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}