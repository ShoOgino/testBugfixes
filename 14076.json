{"path":"solr/solr-ref-guide/tools/BuildNavDataFiles#main(String[]).mjava","commits":[{"id":"580584a6c5fc0f03777842090bc2d2dfb64337e5","date":1574200470,"type":1,"author":"Cassandra Targett","isMerge":false,"pathNew":"solr/solr-ref-guide/tools/BuildNavDataFiles#main(String[]).mjava","pathOld":"solr/solr-ref-guide/tools/BuildNavAndPDFBody#main(String[]).mjava","sourceNew":"  public static void main(String[] args) throws Exception {\n    if (args.length != 2) {\n      throw new RuntimeException(\"Wrong # of args: \" + args.length);\n    }\n\n    final File adocDir = new File(args[0]);\n    final String mainPageShortname = args[1];\n    if (! adocDir.exists()) {\n      throw new RuntimeException(\"asciidoc directory does not exist: \" + adocDir.toString());\n    }\n\n    // build up a quick mapping of every known page\n    System.out.println(\"Building up tree of all known pages\");\n    final Map<String,Page> allPages = new LinkedHashMap<String,Page>();\n    Asciidoctor doctor = null;\n    try {\n      doctor = Factory.create();\n      final File[] adocFiles = adocDir.listFiles(ADOC_FILE_NAMES);\n      for (File file : adocFiles) {\n        Page page = new Page(file, doctor.readDocumentHeader(file));\n        if (allPages.containsKey(page.shortname)) {\n          throw new RuntimeException(\"multiple pages with same shortname: \" + page.file.toString() + \" and \" + allPages.get(page.shortname));\n        }\n        allPages.put(page.shortname, page);\n      }\n    } finally {\n      if (null != doctor) {\n        doctor.shutdown();\n        doctor = null;\n      }\n    }\n\n    // build up a hierarchical structure rooted at our mainPage\n    final Page mainPage = allPages.get(mainPageShortname);\n    if (null == mainPage) {\n      throw new RuntimeException(\"no main-page found with shortname: \" + mainPageShortname);\n    }\n    // NOTE: mainPage claims to be its own parent to prevent anyone decendent from introducing a loop\n    mainPage.buildPageTreeRecursive(mainPage, allPages);\n\n    { // validate that there are no orphan pages\n      int orphans = 0;\n      for (Page p : allPages.values()) {\n        if (null == p.getParent()) {\n          orphans++;\n          System.err.println(\"ERROR: Orphan page: \" + p.file);\n        }\n      }\n      if (0 != orphans) {\n        throw new RuntimeException(\"Found \" + orphans + \" orphan pages (which are not in the 'page-children' attribute of any other pages)\");\n      }\n    }\n\n    // Loop over all files \"in order\" to build up next/prev maps for use in building the scrollnav\n    final Map<String,Page> nextPage = new HashMap<String,Page>();\n    final Map<String,Page> prevPage = new HashMap<String,Page>();\n    System.out.println(\"Looping over pages to build nav data\");\n\n    { // the previous page seen during our walk\n      AtomicReference<Page> previous = new AtomicReference<Page>();\n      \n      mainPage.depthFirstWalk(new Page.RecursiveAction() {\n        public boolean act(Page page) {\n          if (null != previous.get()) {\n            // add previous as our 'prev' page, and ourselves as the 'next' of previous\n            prevPage.put(page.shortname, previous.get());\n            nextPage.put(previous.get().shortname, page);\n          }\n          previous.set(page);\n          return true;\n        }\n      });\n    }\n    \n    // Build up the scrollnav file for jekyll's footer\n    File scrollnavFile = new File(new File(adocDir, \"_data\"), \"scrollnav.json\");\n    if (scrollnavFile.exists()) {\n      throw new RuntimeException(scrollnavFile.toString() + \" already exists\");\n    }\n    System.out.println(\"Creating \" + scrollnavFile.toString());\n    try (Writer w = new OutputStreamWriter(new FileOutputStream(scrollnavFile), \"UTF-8\")) {\n      JSONObject scrollnav = new JSONObject();\n      for (Page p : allPages.values()) {\n        JSONObject current = new JSONObject();\n        Page prev = prevPage.get(p.shortname);\n        Page next = nextPage.get(p.shortname);\n        if (null != prev) {\n          current.put(\"prev\",\n                      new JSONObject()\n                      .put(\"url\", prev.permalink)\n                      .put(\"title\", prev.title));\n        }\n        if (null != next) {\n          current.put(\"next\",\n                      new JSONObject()\n                      .put(\"url\", next.permalink)\n                      .put(\"title\", next.title));\n        }\n        scrollnav.put(p.shortname, current);\n      }\n      // HACK: jekyll doesn't like escaped forward slashes in it's JSON?\n      w.write(scrollnav.toString(2).replaceAll(\"\\\\\\\\/\",\"/\"));\n    }\n    \n    // Build up the sidebar file for jekyll\n    File sidebarFile = new File(new File(adocDir, \"_data\"), \"sidebar.json\");\n    if (sidebarFile.exists()) {\n      throw new RuntimeException(sidebarFile.toString() + \" already exists\");\n    }\n    System.out.println(\"Creating \" + sidebarFile.toString());\n    try (Writer w = new OutputStreamWriter(new FileOutputStream(sidebarFile), \"UTF-8\")) {\n      // A stack for tracking what we're working on as we recurse\n      final Stack<JSONObject> stack = new Stack<JSONObject>();\n      \n      mainPage.depthFirstWalk(new Page.RecursiveAction() {\n        public boolean act(Page page) {\n          final int depth = stack.size();\n          if (4 < depth) {\n            System.err.println(\"ERROR: depth==\" + depth + \" for \" + page.permalink);\n            System.err.println(\"sidebar.html template can not support pages this deep\");\n            System.exit(-1);\n          }\n          try {\n            final JSONObject current = new JSONObject()\n              .put(\"title\",page.title)\n              .put(\"url\", page.permalink)\n              .put(\"depth\", depth)\n              .put(\"kids\", new JSONArray());\n            \n            if (0 < depth) {\n              JSONObject parent = stack.peek();\n              ((JSONArray)parent.get(\"kids\")).put(current);\n            }\n            \n            stack.push(current);\n          } catch (JSONException e) {\n            throw new RuntimeException(e);\n          }\n          return true;\n        }\n        public void postKids(Page page) {\n          final JSONObject current = stack.pop();\n          if (0 == stack.size()) {\n            assert page == mainPage;\n            try {\n              // HACK: jekyll doesn't like escaped forward slashes in it's JSON?\n              w.write(current.toString(2).replaceAll(\"\\\\\\\\/\",\"/\"));\n            } catch (IOException | JSONException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      });\n    }\n    \n  }\n\n","sourceOld":"  public static void main(String[] args) throws Exception {\n    if (args.length != 2) {\n      throw new RuntimeException(\"Wrong # of args: \" + args.length);\n    }\n\n    final File adocDir = new File(args[0]);\n    final String mainPageShortname = args[1];\n    if (! adocDir.exists()) {\n      throw new RuntimeException(\"asciidoc directory does not exist: \" + adocDir.toString());\n    }\n\n    // build up a quick mapping of every known page\n    System.out.println(\"Building up tree of all known pages\");\n    final Map<String,Page> allPages = new LinkedHashMap<String,Page>();\n    Asciidoctor doctor = null;\n    try {\n      doctor = Factory.create();\n      final File[] adocFiles = adocDir.listFiles(ADOC_FILE_NAMES);\n      for (File file : adocFiles) {\n        Page page = new Page(file, doctor.readDocumentHeader(file));\n        if (allPages.containsKey(page.shortname)) {\n          throw new RuntimeException(\"multiple pages with same shortname: \" + page.file.toString() + \" and \" + allPages.get(page.shortname));\n        }\n        allPages.put(page.shortname, page);\n      }\n    } finally {\n      if (null != doctor) {\n        doctor.shutdown();\n        doctor = null;\n      }\n    }\n\n    // build up a hierarchical structure rooted at our mainPage\n    final Page mainPage = allPages.get(mainPageShortname);\n    if (null == mainPage) {\n      throw new RuntimeException(\"no main-page found with shortname: \" + mainPageShortname);\n    }\n    // NOTE: mainPage claims to be its own parent to prevent anyone decendent from introducing a loop\n    mainPage.buildPageTreeRecursive(mainPage, allPages);\n\n    { // validate that there are no orphan pages\n      int orphans = 0;\n      for (Page p : allPages.values()) {\n        if (null == p.getParent()) {\n          orphans++;\n          System.err.println(\"ERROR: Orphan page: \" + p.file);\n        }\n      }\n      if (0 != orphans) {\n        throw new RuntimeException(\"Found \" + orphans + \" orphan pages (which are not in the 'page-children' attribute of any other pages)\");\n      }\n    }\n\n\n    // Build up the PDF file,\n    // while doing this also build up some next/prev maps for use in building the scrollnav\n    File pdfFile = new File(new File(adocDir, \"_data\"), \"pdf-main-body.adoc\");\n    if (pdfFile.exists()) {\n      throw new RuntimeException(pdfFile.toString() + \" already exists\");\n    }\n    final Map<String,Page> nextPage = new HashMap<String,Page>();\n    final Map<String,Page> prevPage = new HashMap<String,Page>();\n    System.out.println(\"Creating \" + pdfFile.toString());\n    try (Writer w = new OutputStreamWriter(new FileOutputStream(pdfFile), \"UTF-8\")) {\n      // Note: not worrying about headers or anything like that ...\n      // expecting this file to just be included by the main PDF file.\n\n      // track how deep we are so we can adjust headers accordingly\n      // start with a \"negative\" depth to treat all \"top level\" pages as same depth as main-page using Math.max\n      // (see below)\n      final AtomicInteger depth = new AtomicInteger(-1);\n\n      // the previous page seen in our walk\n      AtomicReference<Page> previous = new AtomicReference<Page>();\n      \n      mainPage.depthFirstWalk(new Page.RecursiveAction() {\n        public boolean act(Page page) {\n          try {\n            if (null != previous.get()) {\n              // add previous as our 'prev' page, and ourselves as the 'next' of previous\n              prevPage.put(page.shortname, previous.get());\n              nextPage.put(previous.get().shortname, page);\n            }\n            previous.set(page);\n\n            // use an explicit anchor, since the auto-generated ID from the \"title\" might not match\n            // the shortname/filename\n            w.append(\"[[\").append(page.shortname).append(\"]]\\n\");\n            // HACK: where this file actually lives will determine what we need here...\n            w.write(\"include::../\");\n            w.write(page.file.getName());\n            w.write(\"[leveloffset=+\"+Math.max(0, depth.intValue())+\"]\\n\\n\");\n            depth.incrementAndGet();\n            return true;\n          } catch (IOException ioe) {\n            throw new RuntimeException(\"IOE recursively acting on \" + page.shortname, ioe);\n          }\n        }\n        public void postKids(Page page) {\n          depth.decrementAndGet();\n        }\n      });\n    }\n    \n    // Build up the scrollnav file for jekyll's footer\n    File scrollnavFile = new File(new File(adocDir, \"_data\"), \"scrollnav.json\");\n    if (scrollnavFile.exists()) {\n      throw new RuntimeException(scrollnavFile.toString() + \" already exists\");\n    }\n    System.out.println(\"Creating \" + scrollnavFile.toString());\n    try (Writer w = new OutputStreamWriter(new FileOutputStream(scrollnavFile), \"UTF-8\")) {\n      JSONObject scrollnav = new JSONObject();\n      for (Page p : allPages.values()) {\n        JSONObject current = new JSONObject();\n        Page prev = prevPage.get(p.shortname);\n        Page next = nextPage.get(p.shortname);\n        if (null != prev) {\n          current.put(\"prev\",\n                      new JSONObject()\n                      .put(\"url\", prev.permalink)\n                      .put(\"title\", prev.title));\n        }\n        if (null != next) {\n          current.put(\"next\",\n                      new JSONObject()\n                      .put(\"url\", next.permalink)\n                      .put(\"title\", next.title));\n        }\n        scrollnav.put(p.shortname, current);\n      }\n      // HACK: jekyll doesn't like escaped forward slashes in it's JSON?\n      w.write(scrollnav.toString(2).replaceAll(\"\\\\\\\\/\",\"/\"));\n    }\n    \n    // Build up the sidebar file for jekyll\n    File sidebarFile = new File(new File(adocDir, \"_data\"), \"sidebar.json\");\n    if (sidebarFile.exists()) {\n      throw new RuntimeException(sidebarFile.toString() + \" already exists\");\n    }\n    System.out.println(\"Creating \" + sidebarFile.toString());\n    try (Writer w = new OutputStreamWriter(new FileOutputStream(sidebarFile), \"UTF-8\")) {\n      // A stack for tracking what we're working on as we recurse\n      final Stack<JSONObject> stack = new Stack<JSONObject>();\n      \n      mainPage.depthFirstWalk(new Page.RecursiveAction() {\n        public boolean act(Page page) {\n          final int depth = stack.size();\n          if (4 < depth) {\n            System.err.println(\"ERROR: depth==\" + depth + \" for \" + page.permalink);\n            System.err.println(\"sidebar.html template can not support pages this deep\");\n            System.exit(-1);\n          }\n          try {\n            final JSONObject current = new JSONObject()\n              .put(\"title\",page.title)\n              .put(\"url\", page.permalink)\n              .put(\"depth\", depth)\n              .put(\"kids\", new JSONArray());\n            \n            if (0 < depth) {\n              JSONObject parent = stack.peek();\n              ((JSONArray)parent.get(\"kids\")).put(current);\n            }\n            \n            stack.push(current);\n          } catch (JSONException e) {\n            throw new RuntimeException(e);\n          }\n          return true;\n        }\n        public void postKids(Page page) {\n          final JSONObject current = stack.pop();\n          if (0 == stack.size()) {\n            assert page == mainPage;\n            try {\n              // HACK: jekyll doesn't like escaped forward slashes in it's JSON?\n              w.write(current.toString(2).replaceAll(\"\\\\\\\\/\",\"/\"));\n            } catch (IOException | JSONException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      });\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"580584a6c5fc0f03777842090bc2d2dfb64337e5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["580584a6c5fc0f03777842090bc2d2dfb64337e5"]},"commit2Childs":{"580584a6c5fc0f03777842090bc2d2dfb64337e5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["580584a6c5fc0f03777842090bc2d2dfb64337e5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}