{"path":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#update(boolean,boolean,boolean,IndexOptions,int,int).mjava","commits":[{"id":"ca792c26af46bd6c4a08d81117c60440cf6a7e3d","date":1445938295,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#update(boolean,boolean,boolean,IndexOptions,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#update(boolean,boolean,boolean,IndexOptions).mjava","sourceNew":"  // should only be called by FieldInfos#addOrUpdate\n  void update(boolean storeTermVector, boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n              int dimensionCount, int dimensionNumBytes) {\n    if (indexOptions == null) {\n      throw new NullPointerException(\"IndexOptions cannot be null (field: \\\"\" + name + \"\\\")\");\n    }\n    //System.out.println(\"FI.update field=\" + name + \" indexed=\" + indexed + \" omitNorms=\" + omitNorms + \" this.omitNorms=\" + this.omitNorms);\n    if (this.indexOptions != indexOptions) {\n      if (this.indexOptions == IndexOptions.NONE) {\n        this.indexOptions = indexOptions;\n      } else if (indexOptions != IndexOptions.NONE) {\n        // downgrade\n        this.indexOptions = this.indexOptions.compareTo(indexOptions) < 0 ? this.indexOptions : indexOptions;\n      }\n    }\n\n    if (this.dimensionCount == 0 && dimensionCount != 0) {\n      this.dimensionCount = dimensionCount;\n      this.dimensionNumBytes = dimensionNumBytes;\n    }\n\n    if (this.indexOptions != IndexOptions.NONE) { // if updated field data is not for indexing, leave the updates out\n      this.storeTermVector |= storeTermVector;                // once vector, always vector\n      this.storePayloads |= storePayloads;\n\n      // Awkward: only drop norms if incoming update is indexed:\n      if (indexOptions != IndexOptions.NONE && this.omitNorms != omitNorms) {\n        this.omitNorms = true;                // if one require omitNorms at least once, it remains off for life\n      }\n    }\n    if (this.indexOptions == IndexOptions.NONE || this.indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0) {\n      // cannot store payloads if we don't store positions:\n      this.storePayloads = false;\n    }\n    assert checkConsistency();\n  }\n\n","sourceOld":"  // should only be called by FieldInfos#addOrUpdate\n  void update(boolean storeTermVector, boolean omitNorms, boolean storePayloads, IndexOptions indexOptions) {\n    if (indexOptions == null) {\n      throw new NullPointerException(\"IndexOptions cannot be null (field: \\\"\" + name + \"\\\")\");\n    }\n    //System.out.println(\"FI.update field=\" + name + \" indexed=\" + indexed + \" omitNorms=\" + omitNorms + \" this.omitNorms=\" + this.omitNorms);\n    if (this.indexOptions != indexOptions) {\n      if (this.indexOptions == IndexOptions.NONE) {\n        this.indexOptions = indexOptions;\n      } else if (indexOptions != IndexOptions.NONE) {\n        // downgrade\n        this.indexOptions = this.indexOptions.compareTo(indexOptions) < 0 ? this.indexOptions : indexOptions;\n      }\n    }\n\n    if (this.indexOptions != IndexOptions.NONE) { // if updated field data is not for indexing, leave the updates out\n      this.storeTermVector |= storeTermVector;                // once vector, always vector\n      this.storePayloads |= storePayloads;\n\n      // Awkward: only drop norms if incoming update is indexed:\n      if (indexOptions != IndexOptions.NONE && this.omitNorms != omitNorms) {\n        this.omitNorms = true;                // if one require omitNorms at least once, it remains off for life\n      }\n    }\n    if (this.indexOptions == IndexOptions.NONE || this.indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0) {\n      // cannot store payloads if we don't store positions:\n      this.storePayloads = false;\n    }\n    assert checkConsistency();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cab7a79353f33d1a94cd307bf33aa5148601ebe6","date":1453391888,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#update(boolean,boolean,boolean,IndexOptions,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#update(boolean,boolean,boolean,IndexOptions,int,int).mjava","sourceNew":"  // should only be called by FieldInfos#addOrUpdate\n  void update(boolean storeTermVector, boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n              int dimensionCount, int dimensionNumBytes) {\n    if (indexOptions == null) {\n      throw new NullPointerException(\"IndexOptions cannot be null (field: \\\"\" + name + \"\\\")\");\n    }\n    //System.out.println(\"FI.update field=\" + name + \" indexed=\" + indexed + \" omitNorms=\" + omitNorms + \" this.omitNorms=\" + this.omitNorms);\n    if (this.indexOptions != indexOptions) {\n      if (this.indexOptions == IndexOptions.NONE) {\n        this.indexOptions = indexOptions;\n      } else if (indexOptions != IndexOptions.NONE) {\n        // downgrade\n        this.indexOptions = this.indexOptions.compareTo(indexOptions) < 0 ? this.indexOptions : indexOptions;\n      }\n    }\n\n    if (this.pointDimensionCount == 0 && dimensionCount != 0) {\n      this.pointDimensionCount = dimensionCount;\n      this.pointNumBytes = dimensionNumBytes;\n    }\n\n    if (this.indexOptions != IndexOptions.NONE) { // if updated field data is not for indexing, leave the updates out\n      this.storeTermVector |= storeTermVector;                // once vector, always vector\n      this.storePayloads |= storePayloads;\n\n      // Awkward: only drop norms if incoming update is indexed:\n      if (indexOptions != IndexOptions.NONE && this.omitNorms != omitNorms) {\n        this.omitNorms = true;                // if one require omitNorms at least once, it remains off for life\n      }\n    }\n    if (this.indexOptions == IndexOptions.NONE || this.indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0) {\n      // cannot store payloads if we don't store positions:\n      this.storePayloads = false;\n    }\n    assert checkConsistency();\n  }\n\n","sourceOld":"  // should only be called by FieldInfos#addOrUpdate\n  void update(boolean storeTermVector, boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n              int dimensionCount, int dimensionNumBytes) {\n    if (indexOptions == null) {\n      throw new NullPointerException(\"IndexOptions cannot be null (field: \\\"\" + name + \"\\\")\");\n    }\n    //System.out.println(\"FI.update field=\" + name + \" indexed=\" + indexed + \" omitNorms=\" + omitNorms + \" this.omitNorms=\" + this.omitNorms);\n    if (this.indexOptions != indexOptions) {\n      if (this.indexOptions == IndexOptions.NONE) {\n        this.indexOptions = indexOptions;\n      } else if (indexOptions != IndexOptions.NONE) {\n        // downgrade\n        this.indexOptions = this.indexOptions.compareTo(indexOptions) < 0 ? this.indexOptions : indexOptions;\n      }\n    }\n\n    if (this.dimensionCount == 0 && dimensionCount != 0) {\n      this.dimensionCount = dimensionCount;\n      this.dimensionNumBytes = dimensionNumBytes;\n    }\n\n    if (this.indexOptions != IndexOptions.NONE) { // if updated field data is not for indexing, leave the updates out\n      this.storeTermVector |= storeTermVector;                // once vector, always vector\n      this.storePayloads |= storePayloads;\n\n      // Awkward: only drop norms if incoming update is indexed:\n      if (indexOptions != IndexOptions.NONE && this.omitNorms != omitNorms) {\n        this.omitNorms = true;                // if one require omitNorms at least once, it remains off for life\n      }\n    }\n    if (this.indexOptions == IndexOptions.NONE || this.indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0) {\n      // cannot store payloads if we don't store positions:\n      this.storePayloads = false;\n    }\n    assert checkConsistency();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad0d09e969f4763b0df4230f8e3f74357872a4e4","date":1459188769,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#update(boolean,boolean,boolean,IndexOptions,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#update(boolean,boolean,boolean,IndexOptions,int,int).mjava","sourceNew":"  // should only be called by FieldInfos#addOrUpdate\n  void update(boolean storeTermVector, boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n              int dimensionCount, int dimensionNumBytes) {\n    if (indexOptions == null) {\n      throw new NullPointerException(\"IndexOptions must not be null (field: \\\"\" + name + \"\\\")\");\n    }\n    //System.out.println(\"FI.update field=\" + name + \" indexed=\" + indexed + \" omitNorms=\" + omitNorms + \" this.omitNorms=\" + this.omitNorms);\n    if (this.indexOptions != indexOptions) {\n      if (this.indexOptions == IndexOptions.NONE) {\n        this.indexOptions = indexOptions;\n      } else if (indexOptions != IndexOptions.NONE) {\n        // downgrade\n        this.indexOptions = this.indexOptions.compareTo(indexOptions) < 0 ? this.indexOptions : indexOptions;\n      }\n    }\n\n    if (this.pointDimensionCount == 0 && dimensionCount != 0) {\n      this.pointDimensionCount = dimensionCount;\n      this.pointNumBytes = dimensionNumBytes;\n    }\n\n    if (this.indexOptions != IndexOptions.NONE) { // if updated field data is not for indexing, leave the updates out\n      this.storeTermVector |= storeTermVector;                // once vector, always vector\n      this.storePayloads |= storePayloads;\n\n      // Awkward: only drop norms if incoming update is indexed:\n      if (indexOptions != IndexOptions.NONE && this.omitNorms != omitNorms) {\n        this.omitNorms = true;                // if one require omitNorms at least once, it remains off for life\n      }\n    }\n    if (this.indexOptions == IndexOptions.NONE || this.indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0) {\n      // cannot store payloads if we don't store positions:\n      this.storePayloads = false;\n    }\n    assert checkConsistency();\n  }\n\n","sourceOld":"  // should only be called by FieldInfos#addOrUpdate\n  void update(boolean storeTermVector, boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n              int dimensionCount, int dimensionNumBytes) {\n    if (indexOptions == null) {\n      throw new NullPointerException(\"IndexOptions cannot be null (field: \\\"\" + name + \"\\\")\");\n    }\n    //System.out.println(\"FI.update field=\" + name + \" indexed=\" + indexed + \" omitNorms=\" + omitNorms + \" this.omitNorms=\" + this.omitNorms);\n    if (this.indexOptions != indexOptions) {\n      if (this.indexOptions == IndexOptions.NONE) {\n        this.indexOptions = indexOptions;\n      } else if (indexOptions != IndexOptions.NONE) {\n        // downgrade\n        this.indexOptions = this.indexOptions.compareTo(indexOptions) < 0 ? this.indexOptions : indexOptions;\n      }\n    }\n\n    if (this.pointDimensionCount == 0 && dimensionCount != 0) {\n      this.pointDimensionCount = dimensionCount;\n      this.pointNumBytes = dimensionNumBytes;\n    }\n\n    if (this.indexOptions != IndexOptions.NONE) { // if updated field data is not for indexing, leave the updates out\n      this.storeTermVector |= storeTermVector;                // once vector, always vector\n      this.storePayloads |= storePayloads;\n\n      // Awkward: only drop norms if incoming update is indexed:\n      if (indexOptions != IndexOptions.NONE && this.omitNorms != omitNorms) {\n        this.omitNorms = true;                // if one require omitNorms at least once, it remains off for life\n      }\n    }\n    if (this.indexOptions == IndexOptions.NONE || this.indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0) {\n      // cannot store payloads if we don't store positions:\n      this.storePayloads = false;\n    }\n    assert checkConsistency();\n  }\n\n","bugFix":["d1edd0fe3b3915bf01160dfd544ab0c18cb77e45"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"523b9a0ab605d725bf2b9a7a2e1040f1c6599dd6","date":1476277226,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#update(boolean,boolean,boolean,IndexOptions,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#update(boolean,boolean,boolean,IndexOptions,int,int).mjava","sourceNew":"  // should only be called by FieldInfos#addOrUpdate\n  void update(boolean storeTermVector, boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n              int dimensionCount, int dimensionNumBytes) {\n    if (indexOptions == null) {\n      throw new NullPointerException(\"IndexOptions must not be null (field: \\\"\" + name + \"\\\")\");\n    }\n    //System.out.println(\"FI.update field=\" + name + \" indexed=\" + indexed + \" omitNorms=\" + omitNorms + \" this.omitNorms=\" + this.omitNorms);\n    if (this.indexOptions != indexOptions) {\n      if (this.indexOptions == IndexOptions.NONE) {\n        this.indexOptions = indexOptions;\n      } else if (indexOptions != IndexOptions.NONE) {\n        // downgrade\n        this.indexOptions = this.indexOptions.compareTo(indexOptions) < 0 ? this.indexOptions : indexOptions;\n      }\n    }\n\n    if (this.pointDimensionCount == 0 && dimensionCount != 0) {\n      this.pointDimensionCount = dimensionCount;\n      this.pointNumBytes = dimensionNumBytes;\n    } else if (this.pointDimensionCount != dimensionCount || this.pointNumBytes != dimensionNumBytes) {\n      throw new IllegalArgumentException(\"cannot change field \\\"\" + name + \"\\\" from points dimensionCount=\" + this.pointDimensionCount + \", numBytes=\" + this.pointNumBytes + \" to inconsistent dimensionCount=\" + dimensionCount + \", numBytes=\" + dimensionNumBytes);\n    }\n\n    if (this.indexOptions != IndexOptions.NONE) { // if updated field data is not for indexing, leave the updates out\n      this.storeTermVector |= storeTermVector;                // once vector, always vector\n      this.storePayloads |= storePayloads;\n\n      // Awkward: only drop norms if incoming update is indexed:\n      if (indexOptions != IndexOptions.NONE && this.omitNorms != omitNorms) {\n        this.omitNorms = true;                // if one require omitNorms at least once, it remains off for life\n      }\n    }\n    if (this.indexOptions == IndexOptions.NONE || this.indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0) {\n      // cannot store payloads if we don't store positions:\n      this.storePayloads = false;\n    }\n    assert checkConsistency();\n  }\n\n","sourceOld":"  // should only be called by FieldInfos#addOrUpdate\n  void update(boolean storeTermVector, boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n              int dimensionCount, int dimensionNumBytes) {\n    if (indexOptions == null) {\n      throw new NullPointerException(\"IndexOptions must not be null (field: \\\"\" + name + \"\\\")\");\n    }\n    //System.out.println(\"FI.update field=\" + name + \" indexed=\" + indexed + \" omitNorms=\" + omitNorms + \" this.omitNorms=\" + this.omitNorms);\n    if (this.indexOptions != indexOptions) {\n      if (this.indexOptions == IndexOptions.NONE) {\n        this.indexOptions = indexOptions;\n      } else if (indexOptions != IndexOptions.NONE) {\n        // downgrade\n        this.indexOptions = this.indexOptions.compareTo(indexOptions) < 0 ? this.indexOptions : indexOptions;\n      }\n    }\n\n    if (this.pointDimensionCount == 0 && dimensionCount != 0) {\n      this.pointDimensionCount = dimensionCount;\n      this.pointNumBytes = dimensionNumBytes;\n    }\n\n    if (this.indexOptions != IndexOptions.NONE) { // if updated field data is not for indexing, leave the updates out\n      this.storeTermVector |= storeTermVector;                // once vector, always vector\n      this.storePayloads |= storePayloads;\n\n      // Awkward: only drop norms if incoming update is indexed:\n      if (indexOptions != IndexOptions.NONE && this.omitNorms != omitNorms) {\n        this.omitNorms = true;                // if one require omitNorms at least once, it remains off for life\n      }\n    }\n    if (this.indexOptions == IndexOptions.NONE || this.indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0) {\n      // cannot store payloads if we don't store positions:\n      this.storePayloads = false;\n    }\n    assert checkConsistency();\n  }\n\n","bugFix":null,"bugIntro":["ad39e231f187e2ba1c42b3ab420b188f9a561ea2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad39e231f187e2ba1c42b3ab420b188f9a561ea2","date":1476368438,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#update(boolean,boolean,boolean,IndexOptions,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#update(boolean,boolean,boolean,IndexOptions,int,int).mjava","sourceNew":"  // should only be called by FieldInfos#addOrUpdate\n  void update(boolean storeTermVector, boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n              int dimensionCount, int dimensionNumBytes) {\n    if (indexOptions == null) {\n      throw new NullPointerException(\"IndexOptions must not be null (field: \\\"\" + name + \"\\\")\");\n    }\n    //System.out.println(\"FI.update field=\" + name + \" indexed=\" + indexed + \" omitNorms=\" + omitNorms + \" this.omitNorms=\" + this.omitNorms);\n    if (this.indexOptions != indexOptions) {\n      if (this.indexOptions == IndexOptions.NONE) {\n        this.indexOptions = indexOptions;\n      } else if (indexOptions != IndexOptions.NONE) {\n        // downgrade\n        this.indexOptions = this.indexOptions.compareTo(indexOptions) < 0 ? this.indexOptions : indexOptions;\n      }\n    }\n\n    if (this.pointDimensionCount == 0 && dimensionCount != 0) {\n      this.pointDimensionCount = dimensionCount;\n      this.pointNumBytes = dimensionNumBytes;\n    } else if (dimensionCount != 0 && (this.pointDimensionCount != dimensionCount || this.pointNumBytes != dimensionNumBytes)) {\n      throw new IllegalArgumentException(\"cannot change field \\\"\" + name + \"\\\" from points dimensionCount=\" + this.pointDimensionCount + \", numBytes=\" + this.pointNumBytes + \" to inconsistent dimensionCount=\" + dimensionCount + \", numBytes=\" + dimensionNumBytes);\n    }\n\n    if (this.indexOptions != IndexOptions.NONE) { // if updated field data is not for indexing, leave the updates out\n      this.storeTermVector |= storeTermVector;                // once vector, always vector\n      this.storePayloads |= storePayloads;\n\n      // Awkward: only drop norms if incoming update is indexed:\n      if (indexOptions != IndexOptions.NONE && this.omitNorms != omitNorms) {\n        this.omitNorms = true;                // if one require omitNorms at least once, it remains off for life\n      }\n    }\n    if (this.indexOptions == IndexOptions.NONE || this.indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0) {\n      // cannot store payloads if we don't store positions:\n      this.storePayloads = false;\n    }\n    assert checkConsistency();\n  }\n\n","sourceOld":"  // should only be called by FieldInfos#addOrUpdate\n  void update(boolean storeTermVector, boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n              int dimensionCount, int dimensionNumBytes) {\n    if (indexOptions == null) {\n      throw new NullPointerException(\"IndexOptions must not be null (field: \\\"\" + name + \"\\\")\");\n    }\n    //System.out.println(\"FI.update field=\" + name + \" indexed=\" + indexed + \" omitNorms=\" + omitNorms + \" this.omitNorms=\" + this.omitNorms);\n    if (this.indexOptions != indexOptions) {\n      if (this.indexOptions == IndexOptions.NONE) {\n        this.indexOptions = indexOptions;\n      } else if (indexOptions != IndexOptions.NONE) {\n        // downgrade\n        this.indexOptions = this.indexOptions.compareTo(indexOptions) < 0 ? this.indexOptions : indexOptions;\n      }\n    }\n\n    if (this.pointDimensionCount == 0 && dimensionCount != 0) {\n      this.pointDimensionCount = dimensionCount;\n      this.pointNumBytes = dimensionNumBytes;\n    } else if (this.pointDimensionCount != dimensionCount || this.pointNumBytes != dimensionNumBytes) {\n      throw new IllegalArgumentException(\"cannot change field \\\"\" + name + \"\\\" from points dimensionCount=\" + this.pointDimensionCount + \", numBytes=\" + this.pointNumBytes + \" to inconsistent dimensionCount=\" + dimensionCount + \", numBytes=\" + dimensionNumBytes);\n    }\n\n    if (this.indexOptions != IndexOptions.NONE) { // if updated field data is not for indexing, leave the updates out\n      this.storeTermVector |= storeTermVector;                // once vector, always vector\n      this.storePayloads |= storePayloads;\n\n      // Awkward: only drop norms if incoming update is indexed:\n      if (indexOptions != IndexOptions.NONE && this.omitNorms != omitNorms) {\n        this.omitNorms = true;                // if one require omitNorms at least once, it remains off for life\n      }\n    }\n    if (this.indexOptions == IndexOptions.NONE || this.indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0) {\n      // cannot store payloads if we don't store positions:\n      this.storePayloads = false;\n    }\n    assert checkConsistency();\n  }\n\n","bugFix":["523b9a0ab605d725bf2b9a7a2e1040f1c6599dd6"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#update(boolean,boolean,boolean,IndexOptions,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#update(boolean,boolean,boolean,IndexOptions,int,int).mjava","sourceNew":"  // should only be called by FieldInfos#addOrUpdate\n  void update(boolean storeTermVector, boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n              int dimensionCount, int dimensionNumBytes) {\n    if (indexOptions == null) {\n      throw new NullPointerException(\"IndexOptions must not be null (field: \\\"\" + name + \"\\\")\");\n    }\n    //System.out.println(\"FI.update field=\" + name + \" indexed=\" + indexed + \" omitNorms=\" + omitNorms + \" this.omitNorms=\" + this.omitNorms);\n    if (this.indexOptions != indexOptions) {\n      if (this.indexOptions == IndexOptions.NONE) {\n        this.indexOptions = indexOptions;\n      } else if (indexOptions != IndexOptions.NONE) {\n        // downgrade\n        this.indexOptions = this.indexOptions.compareTo(indexOptions) < 0 ? this.indexOptions : indexOptions;\n      }\n    }\n\n    if (this.pointDimensionCount == 0 && dimensionCount != 0) {\n      this.pointDimensionCount = dimensionCount;\n      this.pointNumBytes = dimensionNumBytes;\n    } else if (dimensionCount != 0 && (this.pointDimensionCount != dimensionCount || this.pointNumBytes != dimensionNumBytes)) {\n      throw new IllegalArgumentException(\"cannot change field \\\"\" + name + \"\\\" from points dimensionCount=\" + this.pointDimensionCount + \", numBytes=\" + this.pointNumBytes + \" to inconsistent dimensionCount=\" + dimensionCount + \", numBytes=\" + dimensionNumBytes);\n    }\n\n    if (this.indexOptions != IndexOptions.NONE) { // if updated field data is not for indexing, leave the updates out\n      this.storeTermVector |= storeTermVector;                // once vector, always vector\n      this.storePayloads |= storePayloads;\n\n      // Awkward: only drop norms if incoming update is indexed:\n      if (indexOptions != IndexOptions.NONE && this.omitNorms != omitNorms) {\n        this.omitNorms = true;                // if one require omitNorms at least once, it remains off for life\n      }\n    }\n    if (this.indexOptions == IndexOptions.NONE || this.indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0) {\n      // cannot store payloads if we don't store positions:\n      this.storePayloads = false;\n    }\n    assert checkConsistency();\n  }\n\n","sourceOld":"  // should only be called by FieldInfos#addOrUpdate\n  void update(boolean storeTermVector, boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n              int dimensionCount, int dimensionNumBytes) {\n    if (indexOptions == null) {\n      throw new NullPointerException(\"IndexOptions must not be null (field: \\\"\" + name + \"\\\")\");\n    }\n    //System.out.println(\"FI.update field=\" + name + \" indexed=\" + indexed + \" omitNorms=\" + omitNorms + \" this.omitNorms=\" + this.omitNorms);\n    if (this.indexOptions != indexOptions) {\n      if (this.indexOptions == IndexOptions.NONE) {\n        this.indexOptions = indexOptions;\n      } else if (indexOptions != IndexOptions.NONE) {\n        // downgrade\n        this.indexOptions = this.indexOptions.compareTo(indexOptions) < 0 ? this.indexOptions : indexOptions;\n      }\n    }\n\n    if (this.pointDimensionCount == 0 && dimensionCount != 0) {\n      this.pointDimensionCount = dimensionCount;\n      this.pointNumBytes = dimensionNumBytes;\n    }\n\n    if (this.indexOptions != IndexOptions.NONE) { // if updated field data is not for indexing, leave the updates out\n      this.storeTermVector |= storeTermVector;                // once vector, always vector\n      this.storePayloads |= storePayloads;\n\n      // Awkward: only drop norms if incoming update is indexed:\n      if (indexOptions != IndexOptions.NONE && this.omitNorms != omitNorms) {\n        this.omitNorms = true;                // if one require omitNorms at least once, it remains off for life\n      }\n    }\n    if (this.indexOptions == IndexOptions.NONE || this.indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0) {\n      // cannot store payloads if we don't store positions:\n      this.storePayloads = false;\n    }\n    assert checkConsistency();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"165c905a42bedc7c7d1acb37b177498306b7e866","date":1518704038,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#update(boolean,boolean,boolean,IndexOptions,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#update(boolean,boolean,boolean,IndexOptions,int,int).mjava","sourceNew":"  // should only be called by FieldInfos#addOrUpdate\n  void update(boolean storeTermVector, boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n              int dimensionCount, int dimensionNumBytes) {\n    if (indexOptions == null) {\n      throw new NullPointerException(\"IndexOptions must not be null (field: \\\"\" + name + \"\\\")\");\n    }\n    //System.out.println(\"FI.update field=\" + name + \" indexed=\" + indexed + \" omitNorms=\" + omitNorms + \" this.omitNorms=\" + this.omitNorms);\n    if (this.indexOptions != indexOptions) {\n      if (this.indexOptions == IndexOptions.NONE) {\n        this.indexOptions = indexOptions;\n      } else if (indexOptions != IndexOptions.NONE) {\n        throw new IllegalArgumentException(\"cannot change field \\\"\" + name + \"\\\" from index options=\" + this.indexOptions + \" to inconsistent index options=\" + indexOptions);\n      }\n    }\n\n    if (this.pointDimensionCount == 0 && dimensionCount != 0) {\n      this.pointDimensionCount = dimensionCount;\n      this.pointNumBytes = dimensionNumBytes;\n    } else if (dimensionCount != 0 && (this.pointDimensionCount != dimensionCount || this.pointNumBytes != dimensionNumBytes)) {\n      throw new IllegalArgumentException(\"cannot change field \\\"\" + name + \"\\\" from points dimensionCount=\" + this.pointDimensionCount + \", numBytes=\" + this.pointNumBytes + \" to inconsistent dimensionCount=\" + dimensionCount + \", numBytes=\" + dimensionNumBytes);\n    }\n\n    if (this.indexOptions != IndexOptions.NONE) { // if updated field data is not for indexing, leave the updates out\n      this.storeTermVector |= storeTermVector;                // once vector, always vector\n      this.storePayloads |= storePayloads;\n\n      // Awkward: only drop norms if incoming update is indexed:\n      if (indexOptions != IndexOptions.NONE && this.omitNorms != omitNorms) {\n        this.omitNorms = true;                // if one require omitNorms at least once, it remains off for life\n      }\n    }\n    if (this.indexOptions == IndexOptions.NONE || this.indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0) {\n      // cannot store payloads if we don't store positions:\n      this.storePayloads = false;\n    }\n    assert checkConsistency();\n  }\n\n","sourceOld":"  // should only be called by FieldInfos#addOrUpdate\n  void update(boolean storeTermVector, boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n              int dimensionCount, int dimensionNumBytes) {\n    if (indexOptions == null) {\n      throw new NullPointerException(\"IndexOptions must not be null (field: \\\"\" + name + \"\\\")\");\n    }\n    //System.out.println(\"FI.update field=\" + name + \" indexed=\" + indexed + \" omitNorms=\" + omitNorms + \" this.omitNorms=\" + this.omitNorms);\n    if (this.indexOptions != indexOptions) {\n      if (this.indexOptions == IndexOptions.NONE) {\n        this.indexOptions = indexOptions;\n      } else if (indexOptions != IndexOptions.NONE) {\n        // downgrade\n        this.indexOptions = this.indexOptions.compareTo(indexOptions) < 0 ? this.indexOptions : indexOptions;\n      }\n    }\n\n    if (this.pointDimensionCount == 0 && dimensionCount != 0) {\n      this.pointDimensionCount = dimensionCount;\n      this.pointNumBytes = dimensionNumBytes;\n    } else if (dimensionCount != 0 && (this.pointDimensionCount != dimensionCount || this.pointNumBytes != dimensionNumBytes)) {\n      throw new IllegalArgumentException(\"cannot change field \\\"\" + name + \"\\\" from points dimensionCount=\" + this.pointDimensionCount + \", numBytes=\" + this.pointNumBytes + \" to inconsistent dimensionCount=\" + dimensionCount + \", numBytes=\" + dimensionNumBytes);\n    }\n\n    if (this.indexOptions != IndexOptions.NONE) { // if updated field data is not for indexing, leave the updates out\n      this.storeTermVector |= storeTermVector;                // once vector, always vector\n      this.storePayloads |= storePayloads;\n\n      // Awkward: only drop norms if incoming update is indexed:\n      if (indexOptions != IndexOptions.NONE && this.omitNorms != omitNorms) {\n        this.omitNorms = true;                // if one require omitNorms at least once, it remains off for life\n      }\n    }\n    if (this.indexOptions == IndexOptions.NONE || this.indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0) {\n      // cannot store payloads if we don't store positions:\n      this.storePayloads = false;\n    }\n    assert checkConsistency();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6652c943595e92c187ee904c382863013eae28f","date":1539042663,"type":5,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#update(boolean,boolean,boolean,IndexOptions,int,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfo#update(boolean,boolean,boolean,IndexOptions,int,int).mjava","sourceNew":"  // should only be called by FieldInfos#addOrUpdate\n  void update(boolean storeTermVector, boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n              int dataDimensionCount, int indexDimensionCount, int dimensionNumBytes) {\n    if (indexOptions == null) {\n      throw new NullPointerException(\"IndexOptions must not be null (field: \\\"\" + name + \"\\\")\");\n    }\n    //System.out.println(\"FI.update field=\" + name + \" indexed=\" + indexed + \" omitNorms=\" + omitNorms + \" this.omitNorms=\" + this.omitNorms);\n    if (this.indexOptions != indexOptions) {\n      if (this.indexOptions == IndexOptions.NONE) {\n        this.indexOptions = indexOptions;\n      } else if (indexOptions != IndexOptions.NONE) {\n        throw new IllegalArgumentException(\"cannot change field \\\"\" + name + \"\\\" from index options=\" + this.indexOptions + \" to inconsistent index options=\" + indexOptions);\n      }\n    }\n\n    if (this.pointDataDimensionCount == 0 && dataDimensionCount != 0) {\n      this.pointDataDimensionCount = dataDimensionCount;\n      this.pointIndexDimensionCount = indexDimensionCount;\n      this.pointNumBytes = dimensionNumBytes;\n    } else if (dataDimensionCount != 0 && (this.pointDataDimensionCount != dataDimensionCount || this.pointIndexDimensionCount != indexDimensionCount || this.pointNumBytes != dimensionNumBytes)) {\n      throw new IllegalArgumentException(\"cannot change field \\\"\" + name + \"\\\" from points dataDimensionCount=\" + this.pointDataDimensionCount + \", indexDimensionCount=\" + this.pointIndexDimensionCount + \", numBytes=\" + this.pointNumBytes + \" to inconsistent dataDimensionCount=\" + dataDimensionCount +\", indexDimensionCount=\" + indexDimensionCount + \", numBytes=\" + dimensionNumBytes);\n    }\n\n    if (this.indexOptions != IndexOptions.NONE) { // if updated field data is not for indexing, leave the updates out\n      this.storeTermVector |= storeTermVector;                // once vector, always vector\n      this.storePayloads |= storePayloads;\n\n      // Awkward: only drop norms if incoming update is indexed:\n      if (indexOptions != IndexOptions.NONE && this.omitNorms != omitNorms) {\n        this.omitNorms = true;                // if one require omitNorms at least once, it remains off for life\n      }\n    }\n    if (this.indexOptions == IndexOptions.NONE || this.indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0) {\n      // cannot store payloads if we don't store positions:\n      this.storePayloads = false;\n    }\n    assert checkConsistency();\n  }\n\n","sourceOld":"  // should only be called by FieldInfos#addOrUpdate\n  void update(boolean storeTermVector, boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n              int dimensionCount, int dimensionNumBytes) {\n    if (indexOptions == null) {\n      throw new NullPointerException(\"IndexOptions must not be null (field: \\\"\" + name + \"\\\")\");\n    }\n    //System.out.println(\"FI.update field=\" + name + \" indexed=\" + indexed + \" omitNorms=\" + omitNorms + \" this.omitNorms=\" + this.omitNorms);\n    if (this.indexOptions != indexOptions) {\n      if (this.indexOptions == IndexOptions.NONE) {\n        this.indexOptions = indexOptions;\n      } else if (indexOptions != IndexOptions.NONE) {\n        throw new IllegalArgumentException(\"cannot change field \\\"\" + name + \"\\\" from index options=\" + this.indexOptions + \" to inconsistent index options=\" + indexOptions);\n      }\n    }\n\n    if (this.pointDimensionCount == 0 && dimensionCount != 0) {\n      this.pointDimensionCount = dimensionCount;\n      this.pointNumBytes = dimensionNumBytes;\n    } else if (dimensionCount != 0 && (this.pointDimensionCount != dimensionCount || this.pointNumBytes != dimensionNumBytes)) {\n      throw new IllegalArgumentException(\"cannot change field \\\"\" + name + \"\\\" from points dimensionCount=\" + this.pointDimensionCount + \", numBytes=\" + this.pointNumBytes + \" to inconsistent dimensionCount=\" + dimensionCount + \", numBytes=\" + dimensionNumBytes);\n    }\n\n    if (this.indexOptions != IndexOptions.NONE) { // if updated field data is not for indexing, leave the updates out\n      this.storeTermVector |= storeTermVector;                // once vector, always vector\n      this.storePayloads |= storePayloads;\n\n      // Awkward: only drop norms if incoming update is indexed:\n      if (indexOptions != IndexOptions.NONE && this.omitNorms != omitNorms) {\n        this.omitNorms = true;                // if one require omitNorms at least once, it remains off for life\n      }\n    }\n    if (this.indexOptions == IndexOptions.NONE || this.indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0) {\n      // cannot store payloads if we don't store positions:\n      this.storePayloads = false;\n    }\n    assert checkConsistency();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"165c905a42bedc7c7d1acb37b177498306b7e866":["ad39e231f187e2ba1c42b3ab420b188f9a561ea2"],"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["ca792c26af46bd6c4a08d81117c60440cf6a7e3d"],"f6652c943595e92c187ee904c382863013eae28f":["165c905a42bedc7c7d1acb37b177498306b7e866"],"ca792c26af46bd6c4a08d81117c60440cf6a7e3d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"523b9a0ab605d725bf2b9a7a2e1040f1c6599dd6":["ad0d09e969f4763b0df4230f8e3f74357872a4e4"],"ad0d09e969f4763b0df4230f8e3f74357872a4e4":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"ad39e231f187e2ba1c42b3ab420b188f9a561ea2":["523b9a0ab605d725bf2b9a7a2e1040f1c6599dd6"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["ad0d09e969f4763b0df4230f8e3f74357872a4e4","ad39e231f187e2ba1c42b3ab420b188f9a561ea2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f6652c943595e92c187ee904c382863013eae28f"]},"commit2Childs":{"165c905a42bedc7c7d1acb37b177498306b7e866":["f6652c943595e92c187ee904c382863013eae28f"],"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["ad0d09e969f4763b0df4230f8e3f74357872a4e4"],"f6652c943595e92c187ee904c382863013eae28f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ca792c26af46bd6c4a08d81117c60440cf6a7e3d":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ca792c26af46bd6c4a08d81117c60440cf6a7e3d"],"523b9a0ab605d725bf2b9a7a2e1040f1c6599dd6":["ad39e231f187e2ba1c42b3ab420b188f9a561ea2"],"ad0d09e969f4763b0df4230f8e3f74357872a4e4":["523b9a0ab605d725bf2b9a7a2e1040f1c6599dd6","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"ad39e231f187e2ba1c42b3ab420b188f9a561ea2":["165c905a42bedc7c7d1acb37b177498306b7e866","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}