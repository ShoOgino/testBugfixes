{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/HashRollupStream#read().mjava","commits":[{"id":"1ecdfb266e7c129f6740243b70a053b96b0a1346","date":1551363608,"type":0,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/HashRollupStream#read().mjava","pathOld":"/dev/null","sourceNew":"  public Tuple read() throws IOException {\n    //On the first call to read build the tupleIterator.\n    if(tupleIterator == null) {\n      Map<HashKey, Metric[]> metricMap = new HashMap();\n      while (true) {\n        Tuple tuple = tupleStream.read();\n        if (tuple.EOF) {\n          List tuples = new ArrayList();\n          for(Map.Entry<HashKey, Metric[]> entry : metricMap.entrySet()) {\n            Map<String, Object> map = new HashMap<String, Object>();\n            Metric[] finishedMetrics = entry.getValue();\n            for (Metric metric : finishedMetrics) {\n              map.put(metric.getIdentifier(), metric.getValue());\n            }\n\n            HashKey hashKey = entry.getKey();\n            for (int i = 0; i < buckets.length; i++) {\n              map.put(buckets[i].toString(), hashKey.getParts()[i]);\n            }\n\n            Tuple t = new Tuple(map);\n            tuples.add(t);\n          }\n          tuples.add(tuple);\n          this.tupleIterator = tuples.iterator();\n          break;\n        }\n\n        Object[] bucketValues = new Object[buckets.length];\n        for (int i = 0; i < buckets.length; i++) {\n          bucketValues[i] = buckets[i].getBucketValue(tuple);\n        }\n\n        HashKey hashKey = new HashKey(bucketValues);\n        Metric[] currentMetrics = metricMap.get(hashKey);\n\n        if (currentMetrics != null) {\n          for (Metric bucketMetric : currentMetrics) {\n            bucketMetric.update(tuple);\n          }\n        } else {\n          currentMetrics = new Metric[metrics.length];\n          for (int i = 0; i < metrics.length; i++) {\n            Metric bucketMetric = metrics[i].newInstance();\n            bucketMetric.update(tuple);\n            currentMetrics[i] = bucketMetric;\n          }\n          metricMap.put(hashKey, currentMetrics);\n        }\n      }\n    }\n\n    return tupleIterator.next();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"804a8d5358fe7b7563b85ee7838714d720b89272","date":1591624987,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/HashRollupStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/HashRollupStream#read().mjava","sourceNew":"  public Tuple read() throws IOException {\n    //On the first call to read build the tupleIterator.\n    if(tupleIterator == null) {\n      Map<HashKey, Metric[]> metricMap = new HashMap();\n      while (true) {\n        Tuple tuple = tupleStream.read();\n        if (tuple.EOF) {\n          List tuples = new ArrayList();\n          for(Map.Entry<HashKey, Metric[]> entry : metricMap.entrySet()) {\n            Tuple t = new Tuple();\n            Metric[] finishedMetrics = entry.getValue();\n            for (Metric metric : finishedMetrics) {\n              t.put(metric.getIdentifier(), metric.getValue());\n            }\n\n            HashKey hashKey = entry.getKey();\n            for (int i = 0; i < buckets.length; i++) {\n              t.put(buckets[i].toString(), hashKey.getParts()[i]);\n            }\n            tuples.add(t);\n          }\n          tuples.add(tuple);\n          this.tupleIterator = tuples.iterator();\n          break;\n        }\n\n        Object[] bucketValues = new Object[buckets.length];\n        for (int i = 0; i < buckets.length; i++) {\n          bucketValues[i] = buckets[i].getBucketValue(tuple);\n        }\n\n        HashKey hashKey = new HashKey(bucketValues);\n        Metric[] currentMetrics = metricMap.get(hashKey);\n\n        if (currentMetrics != null) {\n          for (Metric bucketMetric : currentMetrics) {\n            bucketMetric.update(tuple);\n          }\n        } else {\n          currentMetrics = new Metric[metrics.length];\n          for (int i = 0; i < metrics.length; i++) {\n            Metric bucketMetric = metrics[i].newInstance();\n            bucketMetric.update(tuple);\n            currentMetrics[i] = bucketMetric;\n          }\n          metricMap.put(hashKey, currentMetrics);\n        }\n      }\n    }\n\n    return tupleIterator.next();\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n    //On the first call to read build the tupleIterator.\n    if(tupleIterator == null) {\n      Map<HashKey, Metric[]> metricMap = new HashMap();\n      while (true) {\n        Tuple tuple = tupleStream.read();\n        if (tuple.EOF) {\n          List tuples = new ArrayList();\n          for(Map.Entry<HashKey, Metric[]> entry : metricMap.entrySet()) {\n            Map<String, Object> map = new HashMap<String, Object>();\n            Metric[] finishedMetrics = entry.getValue();\n            for (Metric metric : finishedMetrics) {\n              map.put(metric.getIdentifier(), metric.getValue());\n            }\n\n            HashKey hashKey = entry.getKey();\n            for (int i = 0; i < buckets.length; i++) {\n              map.put(buckets[i].toString(), hashKey.getParts()[i]);\n            }\n\n            Tuple t = new Tuple(map);\n            tuples.add(t);\n          }\n          tuples.add(tuple);\n          this.tupleIterator = tuples.iterator();\n          break;\n        }\n\n        Object[] bucketValues = new Object[buckets.length];\n        for (int i = 0; i < buckets.length; i++) {\n          bucketValues[i] = buckets[i].getBucketValue(tuple);\n        }\n\n        HashKey hashKey = new HashKey(bucketValues);\n        Metric[] currentMetrics = metricMap.get(hashKey);\n\n        if (currentMetrics != null) {\n          for (Metric bucketMetric : currentMetrics) {\n            bucketMetric.update(tuple);\n          }\n        } else {\n          currentMetrics = new Metric[metrics.length];\n          for (int i = 0; i < metrics.length; i++) {\n            Metric bucketMetric = metrics[i].newInstance();\n            bucketMetric.update(tuple);\n            currentMetrics[i] = bucketMetric;\n          }\n          metricMap.put(hashKey, currentMetrics);\n        }\n      }\n    }\n\n    return tupleIterator.next();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2b7d28aa15134f77b3a8f4c2724bdc7cb402ab75","date":1591744896,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/HashRollupStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/HashRollupStream#read().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  public Tuple read() throws IOException {\n    //On the first call to read build the tupleIterator.\n    if(tupleIterator == null) {\n      Map<HashKey, Metric[]> metricMap = new HashMap<>();\n      while (true) {\n        Tuple tuple = tupleStream.read();\n        if (tuple.EOF) {\n          @SuppressWarnings({\"rawtypes\"})\n          List tuples = new ArrayList();\n          for(Map.Entry<HashKey, Metric[]> entry : metricMap.entrySet()) {\n            Tuple t = new Tuple();\n            Metric[] finishedMetrics = entry.getValue();\n            for (Metric metric : finishedMetrics) {\n              t.put(metric.getIdentifier(), metric.getValue());\n            }\n\n            HashKey hashKey = entry.getKey();\n            for (int i = 0; i < buckets.length; i++) {\n              t.put(buckets[i].toString(), hashKey.getParts()[i]);\n            }\n            tuples.add(t);\n          }\n          tuples.add(tuple);\n          this.tupleIterator = tuples.iterator();\n          break;\n        }\n\n        Object[] bucketValues = new Object[buckets.length];\n        for (int i = 0; i < buckets.length; i++) {\n          bucketValues[i] = buckets[i].getBucketValue(tuple);\n        }\n\n        HashKey hashKey = new HashKey(bucketValues);\n        Metric[] currentMetrics = metricMap.get(hashKey);\n\n        if (currentMetrics != null) {\n          for (Metric bucketMetric : currentMetrics) {\n            bucketMetric.update(tuple);\n          }\n        } else {\n          currentMetrics = new Metric[metrics.length];\n          for (int i = 0; i < metrics.length; i++) {\n            Metric bucketMetric = metrics[i].newInstance();\n            bucketMetric.update(tuple);\n            currentMetrics[i] = bucketMetric;\n          }\n          metricMap.put(hashKey, currentMetrics);\n        }\n      }\n    }\n\n    return tupleIterator.next();\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n    //On the first call to read build the tupleIterator.\n    if(tupleIterator == null) {\n      Map<HashKey, Metric[]> metricMap = new HashMap();\n      while (true) {\n        Tuple tuple = tupleStream.read();\n        if (tuple.EOF) {\n          List tuples = new ArrayList();\n          for(Map.Entry<HashKey, Metric[]> entry : metricMap.entrySet()) {\n            Tuple t = new Tuple();\n            Metric[] finishedMetrics = entry.getValue();\n            for (Metric metric : finishedMetrics) {\n              t.put(metric.getIdentifier(), metric.getValue());\n            }\n\n            HashKey hashKey = entry.getKey();\n            for (int i = 0; i < buckets.length; i++) {\n              t.put(buckets[i].toString(), hashKey.getParts()[i]);\n            }\n            tuples.add(t);\n          }\n          tuples.add(tuple);\n          this.tupleIterator = tuples.iterator();\n          break;\n        }\n\n        Object[] bucketValues = new Object[buckets.length];\n        for (int i = 0; i < buckets.length; i++) {\n          bucketValues[i] = buckets[i].getBucketValue(tuple);\n        }\n\n        HashKey hashKey = new HashKey(bucketValues);\n        Metric[] currentMetrics = metricMap.get(hashKey);\n\n        if (currentMetrics != null) {\n          for (Metric bucketMetric : currentMetrics) {\n            bucketMetric.update(tuple);\n          }\n        } else {\n          currentMetrics = new Metric[metrics.length];\n          for (int i = 0; i < metrics.length; i++) {\n            Metric bucketMetric = metrics[i].newInstance();\n            bucketMetric.update(tuple);\n            currentMetrics[i] = bucketMetric;\n          }\n          metricMap.put(hashKey, currentMetrics);\n        }\n      }\n    }\n\n    return tupleIterator.next();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1ecdfb266e7c129f6740243b70a053b96b0a1346":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2b7d28aa15134f77b3a8f4c2724bdc7cb402ab75":["804a8d5358fe7b7563b85ee7838714d720b89272"],"804a8d5358fe7b7563b85ee7838714d720b89272":["1ecdfb266e7c129f6740243b70a053b96b0a1346"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2b7d28aa15134f77b3a8f4c2724bdc7cb402ab75"]},"commit2Childs":{"1ecdfb266e7c129f6740243b70a053b96b0a1346":["804a8d5358fe7b7563b85ee7838714d720b89272"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1ecdfb266e7c129f6740243b70a053b96b0a1346"],"2b7d28aa15134f77b3a8f4c2724bdc7cb402ab75":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"804a8d5358fe7b7563b85ee7838714d720b89272":["2b7d28aa15134f77b3a8f4c2724bdc7cb402ab75"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}