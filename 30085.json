{"path":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#SimCloudManager(TimeSource,SimDistribStateManager).mjava","commits":[{"id":"edf5b262a72d10530eb2f01dc8f19060355b213e","date":1557765866,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#SimCloudManager(TimeSource,SimDistribStateManager).mjava","pathOld":"/dev/null","sourceNew":"  SimCloudManager(TimeSource timeSource, SimDistribStateManager distribStateManager) throws Exception {\n    this.loader = new SolrResourceLoader();\n    if (distribStateManager == null) {\n      this.stateManager =  new SimDistribStateManager(SimDistribStateManager.createNewRootNode());\n      // init common paths\n      stateManager.makePath(ZkStateReader.CLUSTER_STATE);\n      stateManager.makePath(ZkStateReader.CLUSTER_PROPS);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH);\n      stateManager.makePath(ZkStateReader.LIVE_NODES_ZKNODE);\n      stateManager.makePath(ZkStateReader.ROLES);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_EVENTS_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_LOST_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      stateManager.makePath(Overseer.OVERSEER_ELECT);\n    } else {\n      this.stateManager = distribStateManager;\n    }\n\n    // register common metrics\n    metricTag = Integer.toHexString(hashCode());\n    String registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm);\n    metricManager.registerAll(registryName, new AltBufferPoolMetricSet(), true, \"buffers\");\n    metricManager.registerAll(registryName, new ClassLoadingGaugeSet(), true, \"classes\");\n    metricManager.registerAll(registryName, new OperatingSystemMetricSet(), true, \"os\");\n    metricManager.registerAll(registryName, new GarbageCollectorMetricSet(), true, \"gc\");\n    metricManager.registerAll(registryName, new MemoryUsageGaugeSet(), true, \"memory\");\n    metricManager.registerAll(registryName, new ThreadStatesGaugeSet(), true, \"threads\"); // todo should we use CachedThreadStatesGaugeSet instead?\n    MetricsMap sysprops = new MetricsMap((detailed, map) -> {\n      System.getProperties().forEach((k, v) -> {\n        map.put(String.valueOf(k), v);\n      });\n    });\n    metricManager.registerGauge(null, registryName, sysprops, metricTag, true, \"properties\", \"system\");\n\n    registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.node);\n    metricManager.registerGauge(null, registryName, () -> new File(\"/\").getUsableSpace(),\n        metricTag, true, \"usableSpace\", SolrInfoBean.Category.CONTAINER.toString(), \"fs\", \"coreRoot\");\n\n    solrClient = new MockSearchableSolrClient() {\n      @Override\n      public NamedList<Object> request(SolrRequest request, String collection) throws SolrServerException, IOException {\n        if (collection != null) {\n          if (request instanceof AbstractUpdateRequest) {\n            ((AbstractUpdateRequest)request).setParam(\"collection\", collection);\n          } else if (request instanceof QueryRequest) {\n            if (request.getPath() != null && (\n                request.getPath().startsWith(\"/admin/autoscaling\") ||\n                request.getPath().startsWith(\"/cluster/autoscaling\") ||\n            request.getPath().startsWith(\"/admin/metrics/history\") ||\n                request.getPath().startsWith(\"/cluster/metrics/history\")\n            )) {\n              // forward it\n              ModifiableSolrParams params = new ModifiableSolrParams(request.getParams());\n              params.set(\"collection\", collection);\n              request = new QueryRequest(params);\n            } else {\n              // search request\n              if (collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n                return super.request(request, collection);\n              } else {\n                // forward it\n                ModifiableSolrParams params = new ModifiableSolrParams(request.getParams());\n                params.set(\"collection\", collection);\n                request = new QueryRequest(params);\n              }\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"when collection != null only UpdateRequest and QueryRequest are supported: request=\" + request + \", collection=\" + collection);\n          }\n        }\n        try {\n          SolrResponse rsp = SimCloudManager.this.request(request);\n          return rsp.getResponse();\n        } catch (UnsupportedOperationException e) {\n          throw new SolrServerException(e);\n        }\n      }\n    };\n\n\n    this.timeSource = timeSource != null ? timeSource : TimeSource.NANO_TIME;\n    this.clusterStateProvider = new SimClusterStateProvider(liveNodesSet, this);\n    this.nodeStateProvider = new SimNodeStateProvider(liveNodesSet, this.stateManager, this.clusterStateProvider, null);\n    this.queueFactory = new GenericDistributedQueueFactory(stateManager);\n    this.simCloudManagerPool = ExecutorUtil.newMDCAwareFixedThreadPool(200, new DefaultSolrThreadFactory(\"simCloudManagerPool\"));\n\n    this.autoScalingHandler = new AutoScalingHandler(this, loader);\n\n\n    triggerThreadGroup = new ThreadGroup(\"Simulated Overseer autoscaling triggers\");\n    OverseerTriggerThread trigger = new OverseerTriggerThread(loader, this,\n        new CloudConfig.CloudConfigBuilder(\"nonexistent\", 0, \"sim\").build());\n    triggerThread = new Overseer.OverseerThread(triggerThreadGroup, trigger, \"Simulated OverseerAutoScalingTriggerThread\");\n    triggerThread.start();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["f94e3cd399f3275b48f601d95bc80d6d9b7fc4ca","1d5f160125c0bc785bf95466c3633984b77845d0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1d5f160125c0bc785bf95466c3633984b77845d0","date":1585162097,"type":3,"author":"Mike","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#SimCloudManager(TimeSource,SimDistribStateManager).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#SimCloudManager(TimeSource,SimDistribStateManager).mjava","sourceNew":"  SimCloudManager(TimeSource timeSource, SimDistribStateManager distribStateManager) throws Exception {\n    this.loader = new SolrResourceLoader();\n    if (distribStateManager == null) {\n      this.stateManager =  new SimDistribStateManager(SimDistribStateManager.createNewRootNode());\n      // init common paths\n      stateManager.makePath(ZkStateReader.CLUSTER_STATE);\n      stateManager.makePath(ZkStateReader.CLUSTER_PROPS);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH);\n      stateManager.makePath(ZkStateReader.LIVE_NODES_ZKNODE);\n      stateManager.makePath(ZkStateReader.ROLES);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_EVENTS_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_LOST_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      stateManager.makePath(Overseer.OVERSEER_ELECT);\n    } else {\n      this.stateManager = distribStateManager;\n    }\n\n    // register common metrics\n    metricTag = Integer.toHexString(hashCode());\n    String registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm);\n    metricManager.registerAll(registryName, new AltBufferPoolMetricSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"buffers\");\n    metricManager.registerAll(registryName, new ClassLoadingGaugeSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"classes\");\n    metricManager.registerAll(registryName, new OperatingSystemMetricSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"os\");\n    metricManager.registerAll(registryName, new GarbageCollectorMetricSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"gc\");\n    metricManager.registerAll(registryName, new MemoryUsageGaugeSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"memory\");\n    metricManager.registerAll(registryName, new ThreadStatesGaugeSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"threads\"); // todo should we use CachedThreadStatesGaugeSet instead?\n    MetricsMap sysprops = new MetricsMap((detailed, map) -> {\n      System.getProperties().forEach((k, v) -> {\n        map.put(String.valueOf(k), v);\n      });\n    });\n    metricManager.registerGauge(null, registryName, sysprops, metricTag, true, \"properties\", \"system\");\n\n    registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.node);\n    metricManager.registerGauge(null, registryName, () -> new File(\"/\").getUsableSpace(),\n        metricTag, true, \"usableSpace\", SolrInfoBean.Category.CONTAINER.toString(), \"fs\", \"coreRoot\");\n\n    solrClient = new MockSearchableSolrClient() {\n      @Override\n      public NamedList<Object> request(SolrRequest request, String collection) throws SolrServerException, IOException {\n        if (collection != null) {\n          if (request instanceof AbstractUpdateRequest) {\n            ((AbstractUpdateRequest)request).setParam(\"collection\", collection);\n          } else if (request instanceof QueryRequest) {\n            if (request.getPath() != null && (\n                request.getPath().startsWith(\"/admin/autoscaling\") ||\n                request.getPath().startsWith(\"/cluster/autoscaling\") ||\n            request.getPath().startsWith(\"/admin/metrics/history\") ||\n                request.getPath().startsWith(\"/cluster/metrics/history\")\n            )) {\n              // forward it\n              ModifiableSolrParams params = new ModifiableSolrParams(request.getParams());\n              params.set(\"collection\", collection);\n              request = new QueryRequest(params);\n            } else {\n              // search request\n              if (collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n                return super.request(request, collection);\n              } else {\n                // forward it\n                ModifiableSolrParams params = new ModifiableSolrParams(request.getParams());\n                params.set(\"collection\", collection);\n                request = new QueryRequest(params);\n              }\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"when collection != null only UpdateRequest and QueryRequest are supported: request=\" + request + \", collection=\" + collection);\n          }\n        }\n        try {\n          SolrResponse rsp = SimCloudManager.this.request(request);\n          return rsp.getResponse();\n        } catch (UnsupportedOperationException e) {\n          throw new SolrServerException(e);\n        }\n      }\n    };\n\n\n    this.timeSource = timeSource != null ? timeSource : TimeSource.NANO_TIME;\n    this.clusterStateProvider = new SimClusterStateProvider(liveNodesSet, this);\n    this.nodeStateProvider = new SimNodeStateProvider(liveNodesSet, this.stateManager, this.clusterStateProvider, null);\n    this.queueFactory = new GenericDistributedQueueFactory(stateManager);\n    this.simCloudManagerPool = ExecutorUtil.newMDCAwareFixedThreadPool(200, new DefaultSolrThreadFactory(\"simCloudManagerPool\"));\n\n    this.autoScalingHandler = new AutoScalingHandler(this, loader);\n\n\n    triggerThreadGroup = new ThreadGroup(\"Simulated Overseer autoscaling triggers\");\n    OverseerTriggerThread trigger = new OverseerTriggerThread(loader, this,\n        new CloudConfig.CloudConfigBuilder(\"nonexistent\", 0, \"sim\").build());\n    triggerThread = new Overseer.OverseerThread(triggerThreadGroup, trigger, \"Simulated OverseerAutoScalingTriggerThread\");\n    triggerThread.start();\n  }\n\n","sourceOld":"  SimCloudManager(TimeSource timeSource, SimDistribStateManager distribStateManager) throws Exception {\n    this.loader = new SolrResourceLoader();\n    if (distribStateManager == null) {\n      this.stateManager =  new SimDistribStateManager(SimDistribStateManager.createNewRootNode());\n      // init common paths\n      stateManager.makePath(ZkStateReader.CLUSTER_STATE);\n      stateManager.makePath(ZkStateReader.CLUSTER_PROPS);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH);\n      stateManager.makePath(ZkStateReader.LIVE_NODES_ZKNODE);\n      stateManager.makePath(ZkStateReader.ROLES);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_EVENTS_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_LOST_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      stateManager.makePath(Overseer.OVERSEER_ELECT);\n    } else {\n      this.stateManager = distribStateManager;\n    }\n\n    // register common metrics\n    metricTag = Integer.toHexString(hashCode());\n    String registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm);\n    metricManager.registerAll(registryName, new AltBufferPoolMetricSet(), true, \"buffers\");\n    metricManager.registerAll(registryName, new ClassLoadingGaugeSet(), true, \"classes\");\n    metricManager.registerAll(registryName, new OperatingSystemMetricSet(), true, \"os\");\n    metricManager.registerAll(registryName, new GarbageCollectorMetricSet(), true, \"gc\");\n    metricManager.registerAll(registryName, new MemoryUsageGaugeSet(), true, \"memory\");\n    metricManager.registerAll(registryName, new ThreadStatesGaugeSet(), true, \"threads\"); // todo should we use CachedThreadStatesGaugeSet instead?\n    MetricsMap sysprops = new MetricsMap((detailed, map) -> {\n      System.getProperties().forEach((k, v) -> {\n        map.put(String.valueOf(k), v);\n      });\n    });\n    metricManager.registerGauge(null, registryName, sysprops, metricTag, true, \"properties\", \"system\");\n\n    registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.node);\n    metricManager.registerGauge(null, registryName, () -> new File(\"/\").getUsableSpace(),\n        metricTag, true, \"usableSpace\", SolrInfoBean.Category.CONTAINER.toString(), \"fs\", \"coreRoot\");\n\n    solrClient = new MockSearchableSolrClient() {\n      @Override\n      public NamedList<Object> request(SolrRequest request, String collection) throws SolrServerException, IOException {\n        if (collection != null) {\n          if (request instanceof AbstractUpdateRequest) {\n            ((AbstractUpdateRequest)request).setParam(\"collection\", collection);\n          } else if (request instanceof QueryRequest) {\n            if (request.getPath() != null && (\n                request.getPath().startsWith(\"/admin/autoscaling\") ||\n                request.getPath().startsWith(\"/cluster/autoscaling\") ||\n            request.getPath().startsWith(\"/admin/metrics/history\") ||\n                request.getPath().startsWith(\"/cluster/metrics/history\")\n            )) {\n              // forward it\n              ModifiableSolrParams params = new ModifiableSolrParams(request.getParams());\n              params.set(\"collection\", collection);\n              request = new QueryRequest(params);\n            } else {\n              // search request\n              if (collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n                return super.request(request, collection);\n              } else {\n                // forward it\n                ModifiableSolrParams params = new ModifiableSolrParams(request.getParams());\n                params.set(\"collection\", collection);\n                request = new QueryRequest(params);\n              }\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"when collection != null only UpdateRequest and QueryRequest are supported: request=\" + request + \", collection=\" + collection);\n          }\n        }\n        try {\n          SolrResponse rsp = SimCloudManager.this.request(request);\n          return rsp.getResponse();\n        } catch (UnsupportedOperationException e) {\n          throw new SolrServerException(e);\n        }\n      }\n    };\n\n\n    this.timeSource = timeSource != null ? timeSource : TimeSource.NANO_TIME;\n    this.clusterStateProvider = new SimClusterStateProvider(liveNodesSet, this);\n    this.nodeStateProvider = new SimNodeStateProvider(liveNodesSet, this.stateManager, this.clusterStateProvider, null);\n    this.queueFactory = new GenericDistributedQueueFactory(stateManager);\n    this.simCloudManagerPool = ExecutorUtil.newMDCAwareFixedThreadPool(200, new DefaultSolrThreadFactory(\"simCloudManagerPool\"));\n\n    this.autoScalingHandler = new AutoScalingHandler(this, loader);\n\n\n    triggerThreadGroup = new ThreadGroup(\"Simulated Overseer autoscaling triggers\");\n    OverseerTriggerThread trigger = new OverseerTriggerThread(loader, this,\n        new CloudConfig.CloudConfigBuilder(\"nonexistent\", 0, \"sim\").build());\n    triggerThread = new Overseer.OverseerThread(triggerThreadGroup, trigger, \"Simulated OverseerAutoScalingTriggerThread\");\n    triggerThread.start();\n  }\n\n","bugFix":["edf5b262a72d10530eb2f01dc8f19060355b213e"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f94e3cd399f3275b48f601d95bc80d6d9b7fc4ca","date":1586138114,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#SimCloudManager(TimeSource,SimDistribStateManager).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#SimCloudManager(TimeSource,SimDistribStateManager).mjava","sourceNew":"  SimCloudManager(TimeSource timeSource, SimDistribStateManager distribStateManager) throws Exception {\n    this.loader = new SolrResourceLoader();\n    if (distribStateManager == null) {\n      this.stateManager =  new SimDistribStateManager(SimDistribStateManager.createNewRootNode());\n      // init common paths\n      stateManager.makePath(ZkStateReader.CLUSTER_STATE);\n      stateManager.makePath(ZkStateReader.CLUSTER_PROPS);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH);\n      stateManager.makePath(ZkStateReader.LIVE_NODES_ZKNODE);\n      stateManager.makePath(ZkStateReader.ROLES);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_EVENTS_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_LOST_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      stateManager.makePath(Overseer.OVERSEER_ELECT);\n    } else {\n      this.stateManager = distribStateManager;\n    }\n\n    // register common metrics\n    metricTag = Integer.toHexString(hashCode());\n    String registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm);\n    metricManager.registerAll(registryName, new AltBufferPoolMetricSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"buffers\");\n    metricManager.registerAll(registryName, new ClassLoadingGaugeSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"classes\");\n    metricManager.registerAll(registryName, new OperatingSystemMetricSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"os\");\n    metricManager.registerAll(registryName, new GarbageCollectorMetricSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"gc\");\n    metricManager.registerAll(registryName, new MemoryUsageGaugeSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"memory\");\n    metricManager.registerAll(registryName, new ThreadStatesGaugeSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"threads\"); // todo should we use CachedThreadStatesGaugeSet instead?\n    MetricsMap sysprops = new MetricsMap((detailed, map) -> {\n      System.getProperties().forEach((k, v) -> {\n        map.put(String.valueOf(k), v);\n      });\n    });\n    metricManager.registerGauge(null, registryName, sysprops, metricTag, true, \"properties\", \"system\");\n\n    registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.node);\n    metricManager.registerGauge(null, registryName, () -> new File(\"/\").getUsableSpace(),\n        metricTag, true, \"usableSpace\", SolrInfoBean.Category.CONTAINER.toString(), \"fs\", \"coreRoot\");\n\n    solrClient = new MockSearchableSolrClient() {\n      @Override\n      public NamedList<Object> request(SolrRequest request, String collection) throws SolrServerException, IOException {\n        if (collection != null) {\n          if (request instanceof AbstractUpdateRequest) {\n            ((AbstractUpdateRequest)request).setParam(\"collection\", collection);\n          } else if (request instanceof QueryRequest) {\n            if (request.getPath() != null && (\n                request.getPath().startsWith(\"/admin/autoscaling\") ||\n                request.getPath().startsWith(\"/cluster/autoscaling\") ||\n            request.getPath().startsWith(\"/admin/metrics/history\") ||\n                request.getPath().startsWith(\"/cluster/metrics/history\")\n            )) {\n              // forward it\n              ModifiableSolrParams params = new ModifiableSolrParams(request.getParams());\n              params.set(\"collection\", collection);\n              request = new QueryRequest(params);\n            } else {\n              // search request\n              if (collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n                return super.request(request, collection);\n              } else {\n                // forward it\n                ModifiableSolrParams params = new ModifiableSolrParams(request.getParams());\n                params.set(\"collection\", collection);\n                request = new QueryRequest(params);\n              }\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"when collection != null only UpdateRequest and QueryRequest are supported: request=\" + request + \", collection=\" + collection);\n          }\n        }\n        try {\n          SolrResponse rsp = SimCloudManager.this.request(request);\n          return rsp.getResponse();\n        } catch (UnsupportedOperationException e) {\n          throw new SolrServerException(e);\n        }\n      }\n    };\n\n\n    this.timeSource = timeSource != null ? timeSource : TimeSource.NANO_TIME;\n    this.clusterStateProvider = new SimClusterStateProvider(liveNodesSet, this);\n    this.nodeStateProvider = new SimNodeStateProvider(liveNodesSet, this.stateManager, this.clusterStateProvider, null);\n    this.queueFactory = new GenericDistributedQueueFactory(stateManager);\n    this.simCloudManagerPool = ExecutorUtil.newMDCAwareFixedThreadPool(200, new DefaultSolrThreadFactory(\"simCloudManagerPool\"));\n\n    this.autoScalingHandler = new AutoScalingHandler(this, loader);\n\n\n    triggerThreadGroup = new ThreadGroup(\"Simulated Overseer autoscaling triggers\");\n    OverseerTriggerThread trigger = new OverseerTriggerThread(loader, this);\n    triggerThread = new Overseer.OverseerThread(triggerThreadGroup, trigger, \"Simulated OverseerAutoScalingTriggerThread\");\n    triggerThread.start();\n  }\n\n","sourceOld":"  SimCloudManager(TimeSource timeSource, SimDistribStateManager distribStateManager) throws Exception {\n    this.loader = new SolrResourceLoader();\n    if (distribStateManager == null) {\n      this.stateManager =  new SimDistribStateManager(SimDistribStateManager.createNewRootNode());\n      // init common paths\n      stateManager.makePath(ZkStateReader.CLUSTER_STATE);\n      stateManager.makePath(ZkStateReader.CLUSTER_PROPS);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH);\n      stateManager.makePath(ZkStateReader.LIVE_NODES_ZKNODE);\n      stateManager.makePath(ZkStateReader.ROLES);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_EVENTS_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_LOST_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      stateManager.makePath(Overseer.OVERSEER_ELECT);\n    } else {\n      this.stateManager = distribStateManager;\n    }\n\n    // register common metrics\n    metricTag = Integer.toHexString(hashCode());\n    String registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm);\n    metricManager.registerAll(registryName, new AltBufferPoolMetricSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"buffers\");\n    metricManager.registerAll(registryName, new ClassLoadingGaugeSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"classes\");\n    metricManager.registerAll(registryName, new OperatingSystemMetricSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"os\");\n    metricManager.registerAll(registryName, new GarbageCollectorMetricSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"gc\");\n    metricManager.registerAll(registryName, new MemoryUsageGaugeSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"memory\");\n    metricManager.registerAll(registryName, new ThreadStatesGaugeSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"threads\"); // todo should we use CachedThreadStatesGaugeSet instead?\n    MetricsMap sysprops = new MetricsMap((detailed, map) -> {\n      System.getProperties().forEach((k, v) -> {\n        map.put(String.valueOf(k), v);\n      });\n    });\n    metricManager.registerGauge(null, registryName, sysprops, metricTag, true, \"properties\", \"system\");\n\n    registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.node);\n    metricManager.registerGauge(null, registryName, () -> new File(\"/\").getUsableSpace(),\n        metricTag, true, \"usableSpace\", SolrInfoBean.Category.CONTAINER.toString(), \"fs\", \"coreRoot\");\n\n    solrClient = new MockSearchableSolrClient() {\n      @Override\n      public NamedList<Object> request(SolrRequest request, String collection) throws SolrServerException, IOException {\n        if (collection != null) {\n          if (request instanceof AbstractUpdateRequest) {\n            ((AbstractUpdateRequest)request).setParam(\"collection\", collection);\n          } else if (request instanceof QueryRequest) {\n            if (request.getPath() != null && (\n                request.getPath().startsWith(\"/admin/autoscaling\") ||\n                request.getPath().startsWith(\"/cluster/autoscaling\") ||\n            request.getPath().startsWith(\"/admin/metrics/history\") ||\n                request.getPath().startsWith(\"/cluster/metrics/history\")\n            )) {\n              // forward it\n              ModifiableSolrParams params = new ModifiableSolrParams(request.getParams());\n              params.set(\"collection\", collection);\n              request = new QueryRequest(params);\n            } else {\n              // search request\n              if (collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n                return super.request(request, collection);\n              } else {\n                // forward it\n                ModifiableSolrParams params = new ModifiableSolrParams(request.getParams());\n                params.set(\"collection\", collection);\n                request = new QueryRequest(params);\n              }\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"when collection != null only UpdateRequest and QueryRequest are supported: request=\" + request + \", collection=\" + collection);\n          }\n        }\n        try {\n          SolrResponse rsp = SimCloudManager.this.request(request);\n          return rsp.getResponse();\n        } catch (UnsupportedOperationException e) {\n          throw new SolrServerException(e);\n        }\n      }\n    };\n\n\n    this.timeSource = timeSource != null ? timeSource : TimeSource.NANO_TIME;\n    this.clusterStateProvider = new SimClusterStateProvider(liveNodesSet, this);\n    this.nodeStateProvider = new SimNodeStateProvider(liveNodesSet, this.stateManager, this.clusterStateProvider, null);\n    this.queueFactory = new GenericDistributedQueueFactory(stateManager);\n    this.simCloudManagerPool = ExecutorUtil.newMDCAwareFixedThreadPool(200, new DefaultSolrThreadFactory(\"simCloudManagerPool\"));\n\n    this.autoScalingHandler = new AutoScalingHandler(this, loader);\n\n\n    triggerThreadGroup = new ThreadGroup(\"Simulated Overseer autoscaling triggers\");\n    OverseerTriggerThread trigger = new OverseerTriggerThread(loader, this,\n        new CloudConfig.CloudConfigBuilder(\"nonexistent\", 0, \"sim\").build());\n    triggerThread = new Overseer.OverseerThread(triggerThreadGroup, trigger, \"Simulated OverseerAutoScalingTriggerThread\");\n    triggerThread.start();\n  }\n\n","bugFix":["edf5b262a72d10530eb2f01dc8f19060355b213e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb03700c9690d16b15fb4f56f6ec36b128fd894e","date":1586745995,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#SimCloudManager(TimeSource,SimDistribStateManager).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#SimCloudManager(TimeSource,SimDistribStateManager).mjava","sourceNew":"  SimCloudManager(TimeSource timeSource, SimDistribStateManager distribStateManager) throws Exception {\n    this.loader = new SolrResourceLoader();\n    if (distribStateManager == null) {\n      this.stateManager =  new SimDistribStateManager(SimDistribStateManager.createNewRootNode());\n      // init common paths\n      stateManager.makePath(ZkStateReader.CLUSTER_STATE);\n      stateManager.makePath(ZkStateReader.CLUSTER_PROPS);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH);\n      stateManager.makePath(ZkStateReader.LIVE_NODES_ZKNODE);\n      stateManager.makePath(ZkStateReader.ROLES);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_EVENTS_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_LOST_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      stateManager.makePath(Overseer.OVERSEER_ELECT);\n    } else {\n      this.stateManager = distribStateManager;\n    }\n\n    // register common metrics\n    metricTag = Integer.toHexString(hashCode());\n    String registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm);\n    metricManager.registerAll(registryName, new AltBufferPoolMetricSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"buffers\");\n    metricManager.registerAll(registryName, new ClassLoadingGaugeSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"classes\");\n    metricManager.registerAll(registryName, new OperatingSystemMetricSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"os\");\n    metricManager.registerAll(registryName, new GarbageCollectorMetricSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"gc\");\n    metricManager.registerAll(registryName, new MemoryUsageGaugeSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"memory\");\n    metricManager.registerAll(registryName, new ThreadStatesGaugeSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"threads\"); // todo should we use CachedThreadStatesGaugeSet instead?\n    MetricsMap sysprops = new MetricsMap((detailed, map) -> {\n      System.getProperties().forEach((k, v) -> {\n        map.put(String.valueOf(k), v);\n      });\n    });\n    metricManager.registerGauge(null, registryName, sysprops, metricTag, true, \"properties\", \"system\");\n\n    registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.node);\n    metricManager.registerGauge(null, registryName, () -> new File(\"/\").getUsableSpace(),\n        metricTag, true, \"usableSpace\", SolrInfoBean.Category.CONTAINER.toString(), \"fs\", \"coreRoot\");\n\n    solrClient = new MockSearchableSolrClient() {\n      @Override\n      public NamedList<Object> request(SolrRequest request, String collection) throws SolrServerException, IOException {\n        if (collection != null) {\n          if (request instanceof AbstractUpdateRequest) {\n            ((AbstractUpdateRequest)request).setParam(\"collection\", collection);\n          } else if (request instanceof QueryRequest) {\n            if (request.getPath() != null && (\n                request.getPath().startsWith(\"/admin/autoscaling\") ||\n                request.getPath().startsWith(\"/cluster/autoscaling\") ||\n            request.getPath().startsWith(\"/admin/metrics/history\") ||\n                request.getPath().startsWith(\"/cluster/metrics/history\")\n            )) {\n              // forward it\n              ModifiableSolrParams params = new ModifiableSolrParams(request.getParams());\n              params.set(\"collection\", collection);\n              request = new QueryRequest(params);\n            } else {\n              // search request\n              if (collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n                return super.request(request, collection);\n              } else {\n                // forward it\n                ModifiableSolrParams params = new ModifiableSolrParams(request.getParams());\n                params.set(\"collection\", collection);\n                request = new QueryRequest(params);\n              }\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"when collection != null only UpdateRequest and QueryRequest are supported: request=\" + request + \", collection=\" + collection);\n          }\n        }\n        try {\n          SolrResponse rsp = SimCloudManager.this.request(request);\n          return rsp.getResponse();\n        } catch (UnsupportedOperationException e) {\n          throw new SolrServerException(e);\n        }\n      }\n    };\n\n\n    this.timeSource = timeSource != null ? timeSource : TimeSource.NANO_TIME;\n    this.clusterStateProvider = new SimClusterStateProvider(liveNodesSet, this);\n    this.nodeStateProvider = new SimNodeStateProvider(liveNodesSet, this.stateManager, this.clusterStateProvider, null);\n    this.queueFactory = new GenericDistributedQueueFactory(stateManager);\n    this.simCloudManagerPool = ExecutorUtil.newMDCAwareFixedThreadPool(200, new SolrNamedThreadFactory(\"simCloudManagerPool\"));\n\n    this.autoScalingHandler = new AutoScalingHandler(this, loader);\n\n\n    triggerThreadGroup = new ThreadGroup(\"Simulated Overseer autoscaling triggers\");\n    OverseerTriggerThread trigger = new OverseerTriggerThread(loader, this);\n    triggerThread = new Overseer.OverseerThread(triggerThreadGroup, trigger, \"Simulated OverseerAutoScalingTriggerThread\");\n    triggerThread.start();\n  }\n\n","sourceOld":"  SimCloudManager(TimeSource timeSource, SimDistribStateManager distribStateManager) throws Exception {\n    this.loader = new SolrResourceLoader();\n    if (distribStateManager == null) {\n      this.stateManager =  new SimDistribStateManager(SimDistribStateManager.createNewRootNode());\n      // init common paths\n      stateManager.makePath(ZkStateReader.CLUSTER_STATE);\n      stateManager.makePath(ZkStateReader.CLUSTER_PROPS);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH);\n      stateManager.makePath(ZkStateReader.LIVE_NODES_ZKNODE);\n      stateManager.makePath(ZkStateReader.ROLES);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_EVENTS_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_LOST_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      stateManager.makePath(Overseer.OVERSEER_ELECT);\n    } else {\n      this.stateManager = distribStateManager;\n    }\n\n    // register common metrics\n    metricTag = Integer.toHexString(hashCode());\n    String registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm);\n    metricManager.registerAll(registryName, new AltBufferPoolMetricSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"buffers\");\n    metricManager.registerAll(registryName, new ClassLoadingGaugeSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"classes\");\n    metricManager.registerAll(registryName, new OperatingSystemMetricSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"os\");\n    metricManager.registerAll(registryName, new GarbageCollectorMetricSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"gc\");\n    metricManager.registerAll(registryName, new MemoryUsageGaugeSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"memory\");\n    metricManager.registerAll(registryName, new ThreadStatesGaugeSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"threads\"); // todo should we use CachedThreadStatesGaugeSet instead?\n    MetricsMap sysprops = new MetricsMap((detailed, map) -> {\n      System.getProperties().forEach((k, v) -> {\n        map.put(String.valueOf(k), v);\n      });\n    });\n    metricManager.registerGauge(null, registryName, sysprops, metricTag, true, \"properties\", \"system\");\n\n    registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.node);\n    metricManager.registerGauge(null, registryName, () -> new File(\"/\").getUsableSpace(),\n        metricTag, true, \"usableSpace\", SolrInfoBean.Category.CONTAINER.toString(), \"fs\", \"coreRoot\");\n\n    solrClient = new MockSearchableSolrClient() {\n      @Override\n      public NamedList<Object> request(SolrRequest request, String collection) throws SolrServerException, IOException {\n        if (collection != null) {\n          if (request instanceof AbstractUpdateRequest) {\n            ((AbstractUpdateRequest)request).setParam(\"collection\", collection);\n          } else if (request instanceof QueryRequest) {\n            if (request.getPath() != null && (\n                request.getPath().startsWith(\"/admin/autoscaling\") ||\n                request.getPath().startsWith(\"/cluster/autoscaling\") ||\n            request.getPath().startsWith(\"/admin/metrics/history\") ||\n                request.getPath().startsWith(\"/cluster/metrics/history\")\n            )) {\n              // forward it\n              ModifiableSolrParams params = new ModifiableSolrParams(request.getParams());\n              params.set(\"collection\", collection);\n              request = new QueryRequest(params);\n            } else {\n              // search request\n              if (collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n                return super.request(request, collection);\n              } else {\n                // forward it\n                ModifiableSolrParams params = new ModifiableSolrParams(request.getParams());\n                params.set(\"collection\", collection);\n                request = new QueryRequest(params);\n              }\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"when collection != null only UpdateRequest and QueryRequest are supported: request=\" + request + \", collection=\" + collection);\n          }\n        }\n        try {\n          SolrResponse rsp = SimCloudManager.this.request(request);\n          return rsp.getResponse();\n        } catch (UnsupportedOperationException e) {\n          throw new SolrServerException(e);\n        }\n      }\n    };\n\n\n    this.timeSource = timeSource != null ? timeSource : TimeSource.NANO_TIME;\n    this.clusterStateProvider = new SimClusterStateProvider(liveNodesSet, this);\n    this.nodeStateProvider = new SimNodeStateProvider(liveNodesSet, this.stateManager, this.clusterStateProvider, null);\n    this.queueFactory = new GenericDistributedQueueFactory(stateManager);\n    this.simCloudManagerPool = ExecutorUtil.newMDCAwareFixedThreadPool(200, new DefaultSolrThreadFactory(\"simCloudManagerPool\"));\n\n    this.autoScalingHandler = new AutoScalingHandler(this, loader);\n\n\n    triggerThreadGroup = new ThreadGroup(\"Simulated Overseer autoscaling triggers\");\n    OverseerTriggerThread trigger = new OverseerTriggerThread(loader, this);\n    triggerThread = new Overseer.OverseerThread(triggerThreadGroup, trigger, \"Simulated OverseerAutoScalingTriggerThread\");\n    triggerThread.start();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eb7a329be123e1f46f9d78d74f6d23f33ec81b0a","date":1589907167,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#SimCloudManager(TimeSource,SimDistribStateManager).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#SimCloudManager(TimeSource,SimDistribStateManager).mjava","sourceNew":"  SimCloudManager(TimeSource timeSource, SimDistribStateManager distribStateManager) throws Exception {\n    this.loader = new SolrResourceLoader();\n    if (distribStateManager == null) {\n      this.stateManager =  new SimDistribStateManager(SimDistribStateManager.createNewRootNode());\n      // init common paths\n      stateManager.makePath(ZkStateReader.CLUSTER_PROPS);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH);\n      stateManager.makePath(ZkStateReader.LIVE_NODES_ZKNODE);\n      stateManager.makePath(ZkStateReader.ROLES);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_EVENTS_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_LOST_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      stateManager.makePath(Overseer.OVERSEER_ELECT);\n    } else {\n      this.stateManager = distribStateManager;\n    }\n\n    // register common metrics\n    metricTag = Integer.toHexString(hashCode());\n    String registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm);\n    metricManager.registerAll(registryName, new AltBufferPoolMetricSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"buffers\");\n    metricManager.registerAll(registryName, new ClassLoadingGaugeSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"classes\");\n    metricManager.registerAll(registryName, new OperatingSystemMetricSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"os\");\n    metricManager.registerAll(registryName, new GarbageCollectorMetricSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"gc\");\n    metricManager.registerAll(registryName, new MemoryUsageGaugeSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"memory\");\n    metricManager.registerAll(registryName, new ThreadStatesGaugeSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"threads\"); // todo should we use CachedThreadStatesGaugeSet instead?\n    MetricsMap sysprops = new MetricsMap((detailed, map) -> {\n      System.getProperties().forEach((k, v) -> {\n        map.put(String.valueOf(k), v);\n      });\n    });\n    metricManager.registerGauge(null, registryName, sysprops, metricTag, true, \"properties\", \"system\");\n\n    registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.node);\n    metricManager.registerGauge(null, registryName, () -> new File(\"/\").getUsableSpace(),\n        metricTag, true, \"usableSpace\", SolrInfoBean.Category.CONTAINER.toString(), \"fs\", \"coreRoot\");\n\n    solrClient = new MockSearchableSolrClient() {\n      @Override\n      public NamedList<Object> request(SolrRequest request, String collection) throws SolrServerException, IOException {\n        if (collection != null) {\n          if (request instanceof AbstractUpdateRequest) {\n            ((AbstractUpdateRequest)request).setParam(\"collection\", collection);\n          } else if (request instanceof QueryRequest) {\n            if (request.getPath() != null && (\n                request.getPath().startsWith(\"/admin/autoscaling\") ||\n                request.getPath().startsWith(\"/cluster/autoscaling\") ||\n            request.getPath().startsWith(\"/admin/metrics/history\") ||\n                request.getPath().startsWith(\"/cluster/metrics/history\")\n            )) {\n              // forward it\n              ModifiableSolrParams params = new ModifiableSolrParams(request.getParams());\n              params.set(\"collection\", collection);\n              request = new QueryRequest(params);\n            } else {\n              // search request\n              if (collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n                return super.request(request, collection);\n              } else {\n                // forward it\n                ModifiableSolrParams params = new ModifiableSolrParams(request.getParams());\n                params.set(\"collection\", collection);\n                request = new QueryRequest(params);\n              }\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"when collection != null only UpdateRequest and QueryRequest are supported: request=\" + request + \", collection=\" + collection);\n          }\n        }\n        try {\n          SolrResponse rsp = SimCloudManager.this.request(request);\n          return rsp.getResponse();\n        } catch (UnsupportedOperationException e) {\n          throw new SolrServerException(e);\n        }\n      }\n    };\n\n\n    this.timeSource = timeSource != null ? timeSource : TimeSource.NANO_TIME;\n    this.clusterStateProvider = new SimClusterStateProvider(liveNodesSet, this);\n    this.nodeStateProvider = new SimNodeStateProvider(liveNodesSet, this.stateManager, this.clusterStateProvider, null);\n    this.queueFactory = new GenericDistributedQueueFactory(stateManager);\n    this.simCloudManagerPool = ExecutorUtil.newMDCAwareFixedThreadPool(200, new SolrNamedThreadFactory(\"simCloudManagerPool\"));\n\n    this.autoScalingHandler = new AutoScalingHandler(this, loader);\n\n\n    triggerThreadGroup = new ThreadGroup(\"Simulated Overseer autoscaling triggers\");\n    OverseerTriggerThread trigger = new OverseerTriggerThread(loader, this);\n    triggerThread = new Overseer.OverseerThread(triggerThreadGroup, trigger, \"Simulated OverseerAutoScalingTriggerThread\");\n    triggerThread.start();\n  }\n\n","sourceOld":"  SimCloudManager(TimeSource timeSource, SimDistribStateManager distribStateManager) throws Exception {\n    this.loader = new SolrResourceLoader();\n    if (distribStateManager == null) {\n      this.stateManager =  new SimDistribStateManager(SimDistribStateManager.createNewRootNode());\n      // init common paths\n      stateManager.makePath(ZkStateReader.CLUSTER_STATE);\n      stateManager.makePath(ZkStateReader.CLUSTER_PROPS);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH);\n      stateManager.makePath(ZkStateReader.LIVE_NODES_ZKNODE);\n      stateManager.makePath(ZkStateReader.ROLES);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_EVENTS_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_LOST_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      stateManager.makePath(Overseer.OVERSEER_ELECT);\n    } else {\n      this.stateManager = distribStateManager;\n    }\n\n    // register common metrics\n    metricTag = Integer.toHexString(hashCode());\n    String registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm);\n    metricManager.registerAll(registryName, new AltBufferPoolMetricSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"buffers\");\n    metricManager.registerAll(registryName, new ClassLoadingGaugeSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"classes\");\n    metricManager.registerAll(registryName, new OperatingSystemMetricSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"os\");\n    metricManager.registerAll(registryName, new GarbageCollectorMetricSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"gc\");\n    metricManager.registerAll(registryName, new MemoryUsageGaugeSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"memory\");\n    metricManager.registerAll(registryName, new ThreadStatesGaugeSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"threads\"); // todo should we use CachedThreadStatesGaugeSet instead?\n    MetricsMap sysprops = new MetricsMap((detailed, map) -> {\n      System.getProperties().forEach((k, v) -> {\n        map.put(String.valueOf(k), v);\n      });\n    });\n    metricManager.registerGauge(null, registryName, sysprops, metricTag, true, \"properties\", \"system\");\n\n    registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.node);\n    metricManager.registerGauge(null, registryName, () -> new File(\"/\").getUsableSpace(),\n        metricTag, true, \"usableSpace\", SolrInfoBean.Category.CONTAINER.toString(), \"fs\", \"coreRoot\");\n\n    solrClient = new MockSearchableSolrClient() {\n      @Override\n      public NamedList<Object> request(SolrRequest request, String collection) throws SolrServerException, IOException {\n        if (collection != null) {\n          if (request instanceof AbstractUpdateRequest) {\n            ((AbstractUpdateRequest)request).setParam(\"collection\", collection);\n          } else if (request instanceof QueryRequest) {\n            if (request.getPath() != null && (\n                request.getPath().startsWith(\"/admin/autoscaling\") ||\n                request.getPath().startsWith(\"/cluster/autoscaling\") ||\n            request.getPath().startsWith(\"/admin/metrics/history\") ||\n                request.getPath().startsWith(\"/cluster/metrics/history\")\n            )) {\n              // forward it\n              ModifiableSolrParams params = new ModifiableSolrParams(request.getParams());\n              params.set(\"collection\", collection);\n              request = new QueryRequest(params);\n            } else {\n              // search request\n              if (collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n                return super.request(request, collection);\n              } else {\n                // forward it\n                ModifiableSolrParams params = new ModifiableSolrParams(request.getParams());\n                params.set(\"collection\", collection);\n                request = new QueryRequest(params);\n              }\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"when collection != null only UpdateRequest and QueryRequest are supported: request=\" + request + \", collection=\" + collection);\n          }\n        }\n        try {\n          SolrResponse rsp = SimCloudManager.this.request(request);\n          return rsp.getResponse();\n        } catch (UnsupportedOperationException e) {\n          throw new SolrServerException(e);\n        }\n      }\n    };\n\n\n    this.timeSource = timeSource != null ? timeSource : TimeSource.NANO_TIME;\n    this.clusterStateProvider = new SimClusterStateProvider(liveNodesSet, this);\n    this.nodeStateProvider = new SimNodeStateProvider(liveNodesSet, this.stateManager, this.clusterStateProvider, null);\n    this.queueFactory = new GenericDistributedQueueFactory(stateManager);\n    this.simCloudManagerPool = ExecutorUtil.newMDCAwareFixedThreadPool(200, new SolrNamedThreadFactory(\"simCloudManagerPool\"));\n\n    this.autoScalingHandler = new AutoScalingHandler(this, loader);\n\n\n    triggerThreadGroup = new ThreadGroup(\"Simulated Overseer autoscaling triggers\");\n    OverseerTriggerThread trigger = new OverseerTriggerThread(loader, this);\n    triggerThread = new Overseer.OverseerThread(triggerThreadGroup, trigger, \"Simulated OverseerAutoScalingTriggerThread\");\n    triggerThread.start();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"daa0f21a44e235a2299ea1fa913898b182dd7cce","date":1590952026,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#SimCloudManager(TimeSource,SimDistribStateManager).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#SimCloudManager(TimeSource,SimDistribStateManager).mjava","sourceNew":"  SimCloudManager(TimeSource timeSource, SimDistribStateManager distribStateManager) throws Exception {\n    this.loader = new SolrResourceLoader();\n    if (distribStateManager == null) {\n      this.stateManager =  new SimDistribStateManager(SimDistribStateManager.createNewRootNode());\n      // init common paths\n      stateManager.makePath(ZkStateReader.CLUSTER_PROPS);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH);\n      stateManager.makePath(ZkStateReader.LIVE_NODES_ZKNODE);\n      stateManager.makePath(ZkStateReader.ROLES);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_EVENTS_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_LOST_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      stateManager.makePath(Overseer.OVERSEER_ELECT);\n    } else {\n      this.stateManager = distribStateManager;\n    }\n\n    // register common metrics\n    metricTag = Integer.toHexString(hashCode());\n    String registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm);\n    metricManager.registerAll(registryName, new AltBufferPoolMetricSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"buffers\");\n    metricManager.registerAll(registryName, new ClassLoadingGaugeSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"classes\");\n    metricManager.registerAll(registryName, new OperatingSystemMetricSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"os\");\n    metricManager.registerAll(registryName, new GarbageCollectorMetricSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"gc\");\n    metricManager.registerAll(registryName, new MemoryUsageGaugeSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"memory\");\n    metricManager.registerAll(registryName, new ThreadStatesGaugeSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"threads\"); // todo should we use CachedThreadStatesGaugeSet instead?\n    MetricsMap sysprops = new MetricsMap((detailed, map) -> {\n      System.getProperties().forEach((k, v) -> {\n        map.put(String.valueOf(k), v);\n      });\n    });\n    metricManager.registerGauge(null, registryName, sysprops, metricTag, true, \"properties\", \"system\");\n\n    registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.node);\n    metricManager.registerGauge(null, registryName, () -> new File(\"/\").getUsableSpace(),\n        metricTag, true, \"usableSpace\", SolrInfoBean.Category.CONTAINER.toString(), \"fs\", \"coreRoot\");\n\n    solrClient = new MockSearchableSolrClient() {\n      @Override\n      @SuppressWarnings({\"rawtypes\"})\n      public NamedList<Object> request(SolrRequest request, String collection) throws SolrServerException, IOException {\n        if (collection != null) {\n          if (request instanceof AbstractUpdateRequest) {\n            ((AbstractUpdateRequest)request).setParam(\"collection\", collection);\n          } else if (request instanceof QueryRequest) {\n            if (request.getPath() != null && (\n                request.getPath().startsWith(\"/admin/autoscaling\") ||\n                request.getPath().startsWith(\"/cluster/autoscaling\") ||\n            request.getPath().startsWith(\"/admin/metrics/history\") ||\n                request.getPath().startsWith(\"/cluster/metrics/history\")\n            )) {\n              // forward it\n              ModifiableSolrParams params = new ModifiableSolrParams(request.getParams());\n              params.set(\"collection\", collection);\n              request = new QueryRequest(params);\n            } else {\n              // search request\n              if (collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n                return super.request(request, collection);\n              } else {\n                // forward it\n                ModifiableSolrParams params = new ModifiableSolrParams(request.getParams());\n                params.set(\"collection\", collection);\n                request = new QueryRequest(params);\n              }\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"when collection != null only UpdateRequest and QueryRequest are supported: request=\" + request + \", collection=\" + collection);\n          }\n        }\n        try {\n          SolrResponse rsp = SimCloudManager.this.request(request);\n          return rsp.getResponse();\n        } catch (UnsupportedOperationException e) {\n          throw new SolrServerException(e);\n        }\n      }\n    };\n\n\n    this.timeSource = timeSource != null ? timeSource : TimeSource.NANO_TIME;\n    this.clusterStateProvider = new SimClusterStateProvider(liveNodesSet, this);\n    this.nodeStateProvider = new SimNodeStateProvider(liveNodesSet, this.stateManager, this.clusterStateProvider, null);\n    this.queueFactory = new GenericDistributedQueueFactory(stateManager);\n    this.simCloudManagerPool = ExecutorUtil.newMDCAwareFixedThreadPool(200, new SolrNamedThreadFactory(\"simCloudManagerPool\"));\n\n    this.autoScalingHandler = new AutoScalingHandler(this, loader);\n\n\n    triggerThreadGroup = new ThreadGroup(\"Simulated Overseer autoscaling triggers\");\n    OverseerTriggerThread trigger = new OverseerTriggerThread(loader, this);\n    triggerThread = new Overseer.OverseerThread(triggerThreadGroup, trigger, \"Simulated OverseerAutoScalingTriggerThread\");\n    triggerThread.start();\n  }\n\n","sourceOld":"  SimCloudManager(TimeSource timeSource, SimDistribStateManager distribStateManager) throws Exception {\n    this.loader = new SolrResourceLoader();\n    if (distribStateManager == null) {\n      this.stateManager =  new SimDistribStateManager(SimDistribStateManager.createNewRootNode());\n      // init common paths\n      stateManager.makePath(ZkStateReader.CLUSTER_PROPS);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH);\n      stateManager.makePath(ZkStateReader.LIVE_NODES_ZKNODE);\n      stateManager.makePath(ZkStateReader.ROLES);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_EVENTS_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_LOST_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      stateManager.makePath(Overseer.OVERSEER_ELECT);\n    } else {\n      this.stateManager = distribStateManager;\n    }\n\n    // register common metrics\n    metricTag = Integer.toHexString(hashCode());\n    String registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm);\n    metricManager.registerAll(registryName, new AltBufferPoolMetricSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"buffers\");\n    metricManager.registerAll(registryName, new ClassLoadingGaugeSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"classes\");\n    metricManager.registerAll(registryName, new OperatingSystemMetricSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"os\");\n    metricManager.registerAll(registryName, new GarbageCollectorMetricSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"gc\");\n    metricManager.registerAll(registryName, new MemoryUsageGaugeSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"memory\");\n    metricManager.registerAll(registryName, new ThreadStatesGaugeSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"threads\"); // todo should we use CachedThreadStatesGaugeSet instead?\n    MetricsMap sysprops = new MetricsMap((detailed, map) -> {\n      System.getProperties().forEach((k, v) -> {\n        map.put(String.valueOf(k), v);\n      });\n    });\n    metricManager.registerGauge(null, registryName, sysprops, metricTag, true, \"properties\", \"system\");\n\n    registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.node);\n    metricManager.registerGauge(null, registryName, () -> new File(\"/\").getUsableSpace(),\n        metricTag, true, \"usableSpace\", SolrInfoBean.Category.CONTAINER.toString(), \"fs\", \"coreRoot\");\n\n    solrClient = new MockSearchableSolrClient() {\n      @Override\n      public NamedList<Object> request(SolrRequest request, String collection) throws SolrServerException, IOException {\n        if (collection != null) {\n          if (request instanceof AbstractUpdateRequest) {\n            ((AbstractUpdateRequest)request).setParam(\"collection\", collection);\n          } else if (request instanceof QueryRequest) {\n            if (request.getPath() != null && (\n                request.getPath().startsWith(\"/admin/autoscaling\") ||\n                request.getPath().startsWith(\"/cluster/autoscaling\") ||\n            request.getPath().startsWith(\"/admin/metrics/history\") ||\n                request.getPath().startsWith(\"/cluster/metrics/history\")\n            )) {\n              // forward it\n              ModifiableSolrParams params = new ModifiableSolrParams(request.getParams());\n              params.set(\"collection\", collection);\n              request = new QueryRequest(params);\n            } else {\n              // search request\n              if (collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n                return super.request(request, collection);\n              } else {\n                // forward it\n                ModifiableSolrParams params = new ModifiableSolrParams(request.getParams());\n                params.set(\"collection\", collection);\n                request = new QueryRequest(params);\n              }\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"when collection != null only UpdateRequest and QueryRequest are supported: request=\" + request + \", collection=\" + collection);\n          }\n        }\n        try {\n          SolrResponse rsp = SimCloudManager.this.request(request);\n          return rsp.getResponse();\n        } catch (UnsupportedOperationException e) {\n          throw new SolrServerException(e);\n        }\n      }\n    };\n\n\n    this.timeSource = timeSource != null ? timeSource : TimeSource.NANO_TIME;\n    this.clusterStateProvider = new SimClusterStateProvider(liveNodesSet, this);\n    this.nodeStateProvider = new SimNodeStateProvider(liveNodesSet, this.stateManager, this.clusterStateProvider, null);\n    this.queueFactory = new GenericDistributedQueueFactory(stateManager);\n    this.simCloudManagerPool = ExecutorUtil.newMDCAwareFixedThreadPool(200, new SolrNamedThreadFactory(\"simCloudManagerPool\"));\n\n    this.autoScalingHandler = new AutoScalingHandler(this, loader);\n\n\n    triggerThreadGroup = new ThreadGroup(\"Simulated Overseer autoscaling triggers\");\n    OverseerTriggerThread trigger = new OverseerTriggerThread(loader, this);\n    triggerThread = new Overseer.OverseerThread(triggerThreadGroup, trigger, \"Simulated OverseerAutoScalingTriggerThread\");\n    triggerThread.start();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#SimCloudManager(TimeSource,SimDistribStateManager).mjava","sourceNew":null,"sourceOld":"  SimCloudManager(TimeSource timeSource, SimDistribStateManager distribStateManager) throws Exception {\n    this.loader = new SolrResourceLoader();\n    if (distribStateManager == null) {\n      this.stateManager =  new SimDistribStateManager(SimDistribStateManager.createNewRootNode());\n      // init common paths\n      stateManager.makePath(ZkStateReader.CLUSTER_PROPS);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH);\n      stateManager.makePath(ZkStateReader.LIVE_NODES_ZKNODE);\n      stateManager.makePath(ZkStateReader.ROLES);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_EVENTS_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_LOST_PATH);\n      stateManager.makePath(ZkStateReader.SOLR_AUTOSCALING_NODE_ADDED_PATH);\n      stateManager.makePath(Overseer.OVERSEER_ELECT);\n    } else {\n      this.stateManager = distribStateManager;\n    }\n\n    // register common metrics\n    metricTag = Integer.toHexString(hashCode());\n    String registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm);\n    metricManager.registerAll(registryName, new AltBufferPoolMetricSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"buffers\");\n    metricManager.registerAll(registryName, new ClassLoadingGaugeSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"classes\");\n    metricManager.registerAll(registryName, new OperatingSystemMetricSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"os\");\n    metricManager.registerAll(registryName, new GarbageCollectorMetricSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"gc\");\n    metricManager.registerAll(registryName, new MemoryUsageGaugeSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"memory\");\n    metricManager.registerAll(registryName, new ThreadStatesGaugeSet(), SolrMetricManager.ResolutionStrategy.REPLACE, \"threads\"); // todo should we use CachedThreadStatesGaugeSet instead?\n    MetricsMap sysprops = new MetricsMap((detailed, map) -> {\n      System.getProperties().forEach((k, v) -> {\n        map.put(String.valueOf(k), v);\n      });\n    });\n    metricManager.registerGauge(null, registryName, sysprops, metricTag, true, \"properties\", \"system\");\n\n    registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.node);\n    metricManager.registerGauge(null, registryName, () -> new File(\"/\").getUsableSpace(),\n        metricTag, true, \"usableSpace\", SolrInfoBean.Category.CONTAINER.toString(), \"fs\", \"coreRoot\");\n\n    solrClient = new MockSearchableSolrClient() {\n      @Override\n      @SuppressWarnings({\"rawtypes\"})\n      public NamedList<Object> request(SolrRequest request, String collection) throws SolrServerException, IOException {\n        if (collection != null) {\n          if (request instanceof AbstractUpdateRequest) {\n            ((AbstractUpdateRequest)request).setParam(\"collection\", collection);\n          } else if (request instanceof QueryRequest) {\n            if (request.getPath() != null && (\n                request.getPath().startsWith(\"/admin/autoscaling\") ||\n                request.getPath().startsWith(\"/cluster/autoscaling\") ||\n            request.getPath().startsWith(\"/admin/metrics/history\") ||\n                request.getPath().startsWith(\"/cluster/metrics/history\")\n            )) {\n              // forward it\n              ModifiableSolrParams params = new ModifiableSolrParams(request.getParams());\n              params.set(\"collection\", collection);\n              request = new QueryRequest(params);\n            } else {\n              // search request\n              if (collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n                return super.request(request, collection);\n              } else {\n                // forward it\n                ModifiableSolrParams params = new ModifiableSolrParams(request.getParams());\n                params.set(\"collection\", collection);\n                request = new QueryRequest(params);\n              }\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"when collection != null only UpdateRequest and QueryRequest are supported: request=\" + request + \", collection=\" + collection);\n          }\n        }\n        try {\n          SolrResponse rsp = SimCloudManager.this.request(request);\n          return rsp.getResponse();\n        } catch (UnsupportedOperationException e) {\n          throw new SolrServerException(e);\n        }\n      }\n    };\n\n\n    this.timeSource = timeSource != null ? timeSource : TimeSource.NANO_TIME;\n    this.clusterStateProvider = new SimClusterStateProvider(liveNodesSet, this);\n    this.nodeStateProvider = new SimNodeStateProvider(liveNodesSet, this.stateManager, this.clusterStateProvider, null);\n    this.queueFactory = new GenericDistributedQueueFactory(stateManager);\n    this.simCloudManagerPool = ExecutorUtil.newMDCAwareFixedThreadPool(200, new SolrNamedThreadFactory(\"simCloudManagerPool\"));\n\n    this.autoScalingHandler = new AutoScalingHandler(this, loader);\n\n\n    triggerThreadGroup = new ThreadGroup(\"Simulated Overseer autoscaling triggers\");\n    OverseerTriggerThread trigger = new OverseerTriggerThread(loader, this);\n    triggerThread = new Overseer.OverseerThread(triggerThreadGroup, trigger, \"Simulated OverseerAutoScalingTriggerThread\");\n    triggerThread.start();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f94e3cd399f3275b48f601d95bc80d6d9b7fc4ca":["1d5f160125c0bc785bf95466c3633984b77845d0"],"1d5f160125c0bc785bf95466c3633984b77845d0":["edf5b262a72d10530eb2f01dc8f19060355b213e"],"3f504512a03d978990cbff30db0522b354e846db":["daa0f21a44e235a2299ea1fa913898b182dd7cce"],"daa0f21a44e235a2299ea1fa913898b182dd7cce":["eb7a329be123e1f46f9d78d74f6d23f33ec81b0a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["f94e3cd399f3275b48f601d95bc80d6d9b7fc4ca"],"eb7a329be123e1f46f9d78d74f6d23f33ec81b0a":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"],"edf5b262a72d10530eb2f01dc8f19060355b213e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"]},"commit2Childs":{"f94e3cd399f3275b48f601d95bc80d6d9b7fc4ca":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"],"1d5f160125c0bc785bf95466c3633984b77845d0":["f94e3cd399f3275b48f601d95bc80d6d9b7fc4ca"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"daa0f21a44e235a2299ea1fa913898b182dd7cce":["3f504512a03d978990cbff30db0522b354e846db"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["edf5b262a72d10530eb2f01dc8f19060355b213e"],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["eb7a329be123e1f46f9d78d74f6d23f33ec81b0a"],"edf5b262a72d10530eb2f01dc8f19060355b213e":["1d5f160125c0bc785bf95466c3633984b77845d0"],"eb7a329be123e1f46f9d78d74f6d23f33ec81b0a":["daa0f21a44e235a2299ea1fa913898b182dd7cce"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}