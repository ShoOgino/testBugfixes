{"path":"src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","commits":[{"id":"4230c91a8f260cc364b5a46269bd21d6122b4fbd","date":1182024063,"type":0,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function shoould go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  {    \n    Document out = new Document();\n    \n    // Load fields from SolrDocument to Document\n    for( String name : doc.getFieldNames() ) {\n      SchemaField sfield = schema.getField(name);\n      Float b = doc.getBoost( name );\n      float boost = (b==null) ? 1.0f : b.floatValue();\n      \n      // Make sure it has the correct number\n      Collection<Object> vals = doc.getFieldValues( name );\n      if( vals.size() > 1 && !sfield.multiValued() ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +vals.toString() );\n      }\n      \n      // load each field value\n      for( Object v : vals ) {\n        String val = null;\n        if( v instanceof Date && sfield.getType() instanceof DateField ) {\n          DateField df = (DateField)sfield.getType();\n          val = df.toInternal( (Date)v )+'Z';\n        }\n        else if (v != null) {\n          val = v.toString();\n        }\n        out.add( sfield.createField( val, boost ) );\n      }\n    }\n    \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          out.add( field.createField( field.getDefaultValue(), 1.0f ) );\n        } \n        else {\n          String id = schema.printableUniqueKey( out );\n          String msg = \"Document [\"+id+\"] missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n  \n    // set the full document boost\n    if( doc.getBoost( null ) != null ) {\n      out.setBoost( doc.getBoost( null ) );\n    }  \n    return out;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["1e210ae1e604402eb4eeff2a52e56d189cd4f2f1","1e210ae1e604402eb4eeff2a52e56d189cd4f2f1","1e210ae1e604402eb4eeff2a52e56d189cd4f2f1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a76eb9a31b3f158d4803594a76191193a920c2dd","date":1182104048,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function shoould go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  {    \n    Document out = new Document();\n    \n    // Load fields from SolrDocument to Document\n    for( String name : doc.getFieldNames() ) {\n      SchemaField sfield = schema.getField(name);\n      Float b = doc.getBoost( name );\n      float boost = (b==null) ? 1.0f : b.floatValue();\n      \n      // Make sure it has the correct number\n      Collection<Object> vals = doc.getFieldValues( name );\n      if( vals.size() > 1 && !sfield.multiValued() ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +vals.toString() );\n      }\n      \n      // load each field value\n      for( Object v : vals ) {\n        String val = null;\n        if( v instanceof Date && sfield.getType() instanceof DateField ) {\n          DateField df = (DateField)sfield.getType();\n          val = df.toInternal( (Date)v )+'Z';\n        }\n        else if (v != null) {\n          val = v.toString();\n        }\n        out.add( sfield.createField( val, boost ) );\n        \n        // In lucene, the boost for a given field is the product of the \n        // document boost and *all* boosts on values of that field. \n        // For multi-valued fields, we only want to set the boost on the\n        // first field.\n        boost = 1.0f; \n      }\n    }\n    \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          out.add( field.createField( field.getDefaultValue(), 1.0f ) );\n        } \n        else {\n          String id = schema.printableUniqueKey( out );\n          String msg = \"Document [\"+id+\"] missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n  \n    // set the full document boost\n    if( doc.getBoost( null ) != null ) {\n      out.setBoost( doc.getBoost( null ) );\n    }  \n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function shoould go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  {    \n    Document out = new Document();\n    \n    // Load fields from SolrDocument to Document\n    for( String name : doc.getFieldNames() ) {\n      SchemaField sfield = schema.getField(name);\n      Float b = doc.getBoost( name );\n      float boost = (b==null) ? 1.0f : b.floatValue();\n      \n      // Make sure it has the correct number\n      Collection<Object> vals = doc.getFieldValues( name );\n      if( vals.size() > 1 && !sfield.multiValued() ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +vals.toString() );\n      }\n      \n      // load each field value\n      for( Object v : vals ) {\n        String val = null;\n        if( v instanceof Date && sfield.getType() instanceof DateField ) {\n          DateField df = (DateField)sfield.getType();\n          val = df.toInternal( (Date)v )+'Z';\n        }\n        else if (v != null) {\n          val = v.toString();\n        }\n        out.add( sfield.createField( val, boost ) );\n      }\n    }\n    \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          out.add( field.createField( field.getDefaultValue(), 1.0f ) );\n        } \n        else {\n          String id = schema.printableUniqueKey( out );\n          String msg = \"Document [\"+id+\"] missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n  \n    // set the full document boost\n    if( doc.getBoost( null ) != null ) {\n      out.setBoost( doc.getBoost( null ) );\n    }  \n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ee4f075a5b1a77c2fb5eb752bdedabf6497aaf9b","date":1182321983,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function shoould go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    \n    // Load fields from SolrDocument to Document\n    for( String name : doc.getFieldNames() ) {\n      SchemaField sfield = schema.getFieldOrNull(name);\n      Float b = doc.getBoost( name );\n      float boost = (b==null) ? 1.0f : b.floatValue();\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      Collection<Object> vals = doc.getFieldValues( name );\n      if( vals.size() > 1 && !sfield.multiValued() ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +vals.toString() );\n      }\n      \n      SchemaField[] destArr = schema.getCopyFields(name);\n      \n      // load each field value\n      for( Object v : vals ) {\n        String val = null;\n        \n        // HACK -- date conversion\n        if( sfield != null && v instanceof Date && sfield.getType() instanceof DateField ) {\n          DateField df = (DateField)sfield.getType();\n          val = df.toInternal( (Date)v )+'Z';\n        }\n        else if (v != null) {\n          val = v.toString();\n        }\n        \n        if( sfield != null ) {\n          used = true;\n          Field f = sfield.createField( val, boost );\n          if( f != null ) { // null fields are not added\n            out.add( f );\n          }\n        }\n        \n        // Add the copy fields\n        for( SchemaField sf : destArr ) {\n          \n          // check if the copy field is a multivalued or not\n          if( !sf.multiValued() && out.get( sf.getName() ) != null ) {\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n                \"ERROR: multiple values encountered for non multiValued copy field \" + \n                  sf.getName() + \": \" +val ); \n          }\n          \n          used = true;\n          Field f = sf.createField( val, boost );\n          if( f != null ) { // null fields are not added\n            out.add( f );\n          }\n        }\n        \n        // In lucene, the boost for a given field is the product of the \n        // document boost and *all* boosts on values of that field. \n        // For multi-valued fields, we only want to set the boost on the\n        // first field.\n        boost = 1.0f; \n      }\n      \n      // make sure the field was used somehow...\n      if( !used ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"ERROR:unknown field '\" + name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          out.add( field.createField( field.getDefaultValue(), 1.0f ) );\n        } \n        else {\n          String id = schema.printableUniqueKey( out );\n          String msg = \"Document [\"+id+\"] missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n  \n    // set the full document boost\n    if( doc.getBoost( null ) != null ) {\n      out.setBoost( doc.getBoost( null ) );\n    }  \n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function shoould go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  {    \n    Document out = new Document();\n    \n    // Load fields from SolrDocument to Document\n    for( String name : doc.getFieldNames() ) {\n      SchemaField sfield = schema.getField(name);\n      Float b = doc.getBoost( name );\n      float boost = (b==null) ? 1.0f : b.floatValue();\n      \n      // Make sure it has the correct number\n      Collection<Object> vals = doc.getFieldValues( name );\n      if( vals.size() > 1 && !sfield.multiValued() ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +vals.toString() );\n      }\n      \n      // load each field value\n      for( Object v : vals ) {\n        String val = null;\n        if( v instanceof Date && sfield.getType() instanceof DateField ) {\n          DateField df = (DateField)sfield.getType();\n          val = df.toInternal( (Date)v )+'Z';\n        }\n        else if (v != null) {\n          val = v.toString();\n        }\n        out.add( sfield.createField( val, boost ) );\n        \n        // In lucene, the boost for a given field is the product of the \n        // document boost and *all* boosts on values of that field. \n        // For multi-valued fields, we only want to set the boost on the\n        // first field.\n        boost = 1.0f; \n      }\n    }\n    \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          out.add( field.createField( field.getDefaultValue(), 1.0f ) );\n        } \n        else {\n          String id = schema.printableUniqueKey( out );\n          String msg = \"Document [\"+id+\"] missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n  \n    // set the full document boost\n    if( doc.getBoost( null ) != null ) {\n      out.setBoost( doc.getBoost( null ) );\n    }  \n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0cd1b5cc13e2ad6adfe55db8cf8a0d81077563f4","date":1182923522,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function shoould go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    \n    // Load fields from SolrDocument to Document\n    for( String name : doc.getFieldNames() ) {\n      SchemaField sfield = schema.getFieldOrNull(name);\n      Float b = doc.getBoost( name );\n      float boost = (b==null) ? 1.0f : b.floatValue();\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      Collection<Object> vals = doc.getFieldValues( name );\n      if(vals.size() > 1 && sfield!=null && !sfield.multiValued() ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +vals.toString() );\n      }\n      \n      SchemaField[] destArr = schema.getCopyFields(name);\n      \n      // load each field value\n      for( Object v : vals ) {\n        String val = null;\n        \n        // HACK -- date conversion\n        if( sfield != null && v instanceof Date && sfield.getType() instanceof DateField ) {\n          DateField df = (DateField)sfield.getType();\n          val = df.toInternal( (Date)v )+'Z';\n        }\n        else if (v != null) {\n          val = v.toString();\n        }\n        \n        if( sfield != null ) {\n          used = true;\n          Field f = sfield.createField( val, boost );\n          if( f != null ) { // null fields are not added\n            out.add( f );\n          }\n        }\n        \n        // Add the copy fields\n        for( SchemaField sf : destArr ) {\n          \n          // check if the copy field is a multivalued or not\n          if( !sf.multiValued() && out.get( sf.getName() ) != null ) {\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n                \"ERROR: multiple values encountered for non multiValued copy field \" + \n                  sf.getName() + \": \" +val ); \n          }\n          \n          used = true;\n          Field f = sf.createField( val, boost );\n          if( f != null ) { // null fields are not added\n            out.add( f );\n          }\n        }\n        \n        // In lucene, the boost for a given field is the product of the \n        // document boost and *all* boosts on values of that field. \n        // For multi-valued fields, we only want to set the boost on the\n        // first field.\n        boost = 1.0f; \n      }\n      \n      // make sure the field was used somehow...\n      if( !used ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"ERROR:unknown field '\" + name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          out.add( field.createField( field.getDefaultValue(), 1.0f ) );\n        } \n        else {\n          String id = schema.printableUniqueKey( out );\n          String msg = \"Document [\"+id+\"] missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n  \n    // set the full document boost\n    if( doc.getBoost( null ) != null ) {\n      out.setBoost( doc.getBoost( null ) );\n    }  \n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function shoould go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    \n    // Load fields from SolrDocument to Document\n    for( String name : doc.getFieldNames() ) {\n      SchemaField sfield = schema.getFieldOrNull(name);\n      Float b = doc.getBoost( name );\n      float boost = (b==null) ? 1.0f : b.floatValue();\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      Collection<Object> vals = doc.getFieldValues( name );\n      if( vals.size() > 1 && !sfield.multiValued() ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +vals.toString() );\n      }\n      \n      SchemaField[] destArr = schema.getCopyFields(name);\n      \n      // load each field value\n      for( Object v : vals ) {\n        String val = null;\n        \n        // HACK -- date conversion\n        if( sfield != null && v instanceof Date && sfield.getType() instanceof DateField ) {\n          DateField df = (DateField)sfield.getType();\n          val = df.toInternal( (Date)v )+'Z';\n        }\n        else if (v != null) {\n          val = v.toString();\n        }\n        \n        if( sfield != null ) {\n          used = true;\n          Field f = sfield.createField( val, boost );\n          if( f != null ) { // null fields are not added\n            out.add( f );\n          }\n        }\n        \n        // Add the copy fields\n        for( SchemaField sf : destArr ) {\n          \n          // check if the copy field is a multivalued or not\n          if( !sf.multiValued() && out.get( sf.getName() ) != null ) {\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n                \"ERROR: multiple values encountered for non multiValued copy field \" + \n                  sf.getName() + \": \" +val ); \n          }\n          \n          used = true;\n          Field f = sf.createField( val, boost );\n          if( f != null ) { // null fields are not added\n            out.add( f );\n          }\n        }\n        \n        // In lucene, the boost for a given field is the product of the \n        // document boost and *all* boosts on values of that field. \n        // For multi-valued fields, we only want to set the boost on the\n        // first field.\n        boost = 1.0f; \n      }\n      \n      // make sure the field was used somehow...\n      if( !used ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"ERROR:unknown field '\" + name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          out.add( field.createField( field.getDefaultValue(), 1.0f ) );\n        } \n        else {\n          String id = schema.printableUniqueKey( out );\n          String msg = \"Document [\"+id+\"] missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n  \n    // set the full document boost\n    if( doc.getBoost( null ) != null ) {\n      out.setBoost( doc.getBoost( null ) );\n    }  \n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ebb24ab555aab7c4dd5d2264c06a4f19fb217913","date":1183353562,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function shoould go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    out.setBoost( doc.getDocumentBoost() );\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      SchemaField[] destArr = schema.getCopyFields(name);\n      \n      // load each field value\n      for( Object v : field ) {\n        String val = null;\n        \n        // TODO!!! HACK -- date conversion\n        if( sfield != null && v instanceof Date && sfield.getType() instanceof DateField ) {\n          DateField df = (DateField)sfield.getType();\n          val = df.toInternal( (Date)v )+'Z';\n        }\n        else if (v != null) {\n          val = v.toString();\n        }\n        \n        if( sfield != null ) {\n          used = true;\n          Field f = sfield.createField( val, boost );\n          if( f != null ) { // null fields are not added\n            out.add( f );\n          }\n        }\n        \n        // Add the copy fields\n        for( SchemaField sf : destArr ) {\n          // check if the copy field is a multivalued or not\n          if( !sf.multiValued() && out.get( sf.getName() ) != null ) {\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n                \"ERROR: multiple values encountered for non multiValued copy field \" + \n                  sf.getName() + \": \" +val ); \n          }\n          \n          used = true;\n          Field f = sf.createField( val, boost );\n          if( f != null ) { // null fields are not added\n            out.add( f );\n          }\n        }\n        \n        // In lucene, the boost for a given field is the product of the \n        // document boost and *all* boosts on values of that field. \n        // For multi-valued fields, we only want to set the boost on the\n        // first field.\n        boost = 1.0f; \n      }\n      \n      // make sure the field was used somehow...\n      if( !used ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"ERROR:unknown field '\" + name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          out.add( field.createField( field.getDefaultValue(), 1.0f ) );\n        } \n        else {\n          String id = schema.printableUniqueKey( out );\n          String msg = \"Document [\"+id+\"] missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function shoould go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    \n    // Load fields from SolrDocument to Document\n    for( String name : doc.getFieldNames() ) {\n      SchemaField sfield = schema.getFieldOrNull(name);\n      Float b = doc.getBoost( name );\n      float boost = (b==null) ? 1.0f : b.floatValue();\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      Collection<Object> vals = doc.getFieldValues( name );\n      if(vals.size() > 1 && sfield!=null && !sfield.multiValued() ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +vals.toString() );\n      }\n      \n      SchemaField[] destArr = schema.getCopyFields(name);\n      \n      // load each field value\n      for( Object v : vals ) {\n        String val = null;\n        \n        // HACK -- date conversion\n        if( sfield != null && v instanceof Date && sfield.getType() instanceof DateField ) {\n          DateField df = (DateField)sfield.getType();\n          val = df.toInternal( (Date)v )+'Z';\n        }\n        else if (v != null) {\n          val = v.toString();\n        }\n        \n        if( sfield != null ) {\n          used = true;\n          Field f = sfield.createField( val, boost );\n          if( f != null ) { // null fields are not added\n            out.add( f );\n          }\n        }\n        \n        // Add the copy fields\n        for( SchemaField sf : destArr ) {\n          \n          // check if the copy field is a multivalued or not\n          if( !sf.multiValued() && out.get( sf.getName() ) != null ) {\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n                \"ERROR: multiple values encountered for non multiValued copy field \" + \n                  sf.getName() + \": \" +val ); \n          }\n          \n          used = true;\n          Field f = sf.createField( val, boost );\n          if( f != null ) { // null fields are not added\n            out.add( f );\n          }\n        }\n        \n        // In lucene, the boost for a given field is the product of the \n        // document boost and *all* boosts on values of that field. \n        // For multi-valued fields, we only want to set the boost on the\n        // first field.\n        boost = 1.0f; \n      }\n      \n      // make sure the field was used somehow...\n      if( !used ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"ERROR:unknown field '\" + name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          out.add( field.createField( field.getDefaultValue(), 1.0f ) );\n        } \n        else {\n          String id = schema.printableUniqueKey( out );\n          String msg = \"Document [\"+id+\"] missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n  \n    // set the full document boost\n    if( doc.getBoost( null ) != null ) {\n      out.setBoost( doc.getBoost( null ) );\n    }  \n    return out;\n  }\n\n","bugFix":null,"bugIntro":["d4148af0b1a0b6991d37fc16a075d88fc63068f9","d4148af0b1a0b6991d37fc16a075d88fc63068f9","d4148af0b1a0b6991d37fc16a075d88fc63068f9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"91f6a1cbf34f0ff73228cad8b1390ba53d9dadc4","date":1186604616,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function shoould go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    out.setBoost( doc.getDocumentBoost() );\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      SchemaField[] destArr = schema.getCopyFields(name);\n      \n      // load each field value\n      boolean hasField = false;\n      for( Object v : field ) {\n        if( v == null ) {\n          continue;\n        }\n        String val = null;\n        hasField = true;\n        \n        // TODO!!! HACK -- date conversion\n        if( sfield != null && v instanceof Date && sfield.getType() instanceof DateField ) {\n          DateField df = (DateField)sfield.getType();\n          val = df.toInternal( (Date)v )+'Z';\n        }\n        else if (v != null) {\n          val = v.toString();\n        }\n        \n        if( sfield != null ) {\n          used = true;\n          Field f = sfield.createField( val, boost );\n          if( f != null ) { // null fields are not added\n            out.add( f );\n          }\n        }\n        \n        // Add the copy fields\n        for( SchemaField sf : destArr ) {\n          // check if the copy field is a multivalued or not\n          if( !sf.multiValued() && out.get( sf.getName() ) != null ) {\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n                \"ERROR: multiple values encountered for non multiValued copy field \" + \n                  sf.getName() + \": \" +val ); \n          }\n          \n          used = true;\n          Field f = sf.createField( val, boost );\n          if( f != null ) { // null fields are not added\n            out.add( f );\n          }\n        }\n        \n        // In lucene, the boost for a given field is the product of the \n        // document boost and *all* boosts on values of that field. \n        // For multi-valued fields, we only want to set the boost on the\n        // first field.\n        boost = 1.0f; \n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"ERROR:unknown field '\" + name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          out.add( field.createField( field.getDefaultValue(), 1.0f ) );\n        } \n        else {\n          String id = schema.printableUniqueKey( out );\n          String msg = \"Document [\"+id+\"] missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function shoould go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    out.setBoost( doc.getDocumentBoost() );\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      SchemaField[] destArr = schema.getCopyFields(name);\n      \n      // load each field value\n      for( Object v : field ) {\n        String val = null;\n        \n        // TODO!!! HACK -- date conversion\n        if( sfield != null && v instanceof Date && sfield.getType() instanceof DateField ) {\n          DateField df = (DateField)sfield.getType();\n          val = df.toInternal( (Date)v )+'Z';\n        }\n        else if (v != null) {\n          val = v.toString();\n        }\n        \n        if( sfield != null ) {\n          used = true;\n          Field f = sfield.createField( val, boost );\n          if( f != null ) { // null fields are not added\n            out.add( f );\n          }\n        }\n        \n        // Add the copy fields\n        for( SchemaField sf : destArr ) {\n          // check if the copy field is a multivalued or not\n          if( !sf.multiValued() && out.get( sf.getName() ) != null ) {\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n                \"ERROR: multiple values encountered for non multiValued copy field \" + \n                  sf.getName() + \": \" +val ); \n          }\n          \n          used = true;\n          Field f = sf.createField( val, boost );\n          if( f != null ) { // null fields are not added\n            out.add( f );\n          }\n        }\n        \n        // In lucene, the boost for a given field is the product of the \n        // document boost and *all* boosts on values of that field. \n        // For multi-valued fields, we only want to set the boost on the\n        // first field.\n        boost = 1.0f; \n      }\n      \n      // make sure the field was used somehow...\n      if( !used ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"ERROR:unknown field '\" + name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          out.add( field.createField( field.getDefaultValue(), 1.0f ) );\n        } \n        else {\n          String id = schema.printableUniqueKey( out );\n          String msg = \"Document [\"+id+\"] missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b4e01dcd4807436dd0fd45e23b3dee970905983f","date":1191972173,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function shoould go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    out.setBoost( doc.getDocumentBoost() );\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        String id = \"\";\n        SchemaField sf = schema.getUniqueKeyField();\n        if( sf != null ) {\n          id = \"[\"+doc.getFieldValue( sf.getName() )+\"] \";\n        }\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+id+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      SchemaField[] destArr = schema.getCopyFields(name);\n      \n      // load each field value\n      boolean hasField = false;\n      for( Object v : field ) {\n        if( v == null ) {\n          continue;\n        }\n        String val = null;\n        hasField = true;\n        \n        // TODO!!! HACK -- date conversion\n        if( sfield != null && v instanceof Date && sfield.getType() instanceof DateField ) {\n          DateField df = (DateField)sfield.getType();\n          val = df.toInternal( (Date)v )+'Z';\n        }\n        else if (v != null) {\n          val = v.toString();\n        }\n        \n        if( sfield != null ) {\n          used = true;\n          Field f = sfield.createField( val, boost );\n          if( f != null ) { // null fields are not added\n            out.add( f );\n          }\n        }\n        \n        // Add the copy fields\n        for( SchemaField sf : destArr ) {\n          // check if the copy field is a multivalued or not\n          if( !sf.multiValued() && out.get( sf.getName() ) != null ) {\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n                \"ERROR: multiple values encountered for non multiValued copy field \" + \n                  sf.getName() + \": \" +val ); \n          }\n          \n          used = true;\n          Field f = sf.createField( val, boost );\n          if( f != null ) { // null fields are not added\n            out.add( f );\n          }\n        }\n        \n        // In lucene, the boost for a given field is the product of the \n        // document boost and *all* boosts on values of that field. \n        // For multi-valued fields, we only want to set the boost on the\n        // first field.\n        boost = 1.0f; \n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"ERROR:unknown field '\" + name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          out.add( field.createField( field.getDefaultValue(), 1.0f ) );\n        } \n        else {\n          String id = schema.printableUniqueKey( out );\n          String msg = \"Document [\"+id+\"] missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function shoould go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    out.setBoost( doc.getDocumentBoost() );\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      SchemaField[] destArr = schema.getCopyFields(name);\n      \n      // load each field value\n      boolean hasField = false;\n      for( Object v : field ) {\n        if( v == null ) {\n          continue;\n        }\n        String val = null;\n        hasField = true;\n        \n        // TODO!!! HACK -- date conversion\n        if( sfield != null && v instanceof Date && sfield.getType() instanceof DateField ) {\n          DateField df = (DateField)sfield.getType();\n          val = df.toInternal( (Date)v )+'Z';\n        }\n        else if (v != null) {\n          val = v.toString();\n        }\n        \n        if( sfield != null ) {\n          used = true;\n          Field f = sfield.createField( val, boost );\n          if( f != null ) { // null fields are not added\n            out.add( f );\n          }\n        }\n        \n        // Add the copy fields\n        for( SchemaField sf : destArr ) {\n          // check if the copy field is a multivalued or not\n          if( !sf.multiValued() && out.get( sf.getName() ) != null ) {\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n                \"ERROR: multiple values encountered for non multiValued copy field \" + \n                  sf.getName() + \": \" +val ); \n          }\n          \n          used = true;\n          Field f = sf.createField( val, boost );\n          if( f != null ) { // null fields are not added\n            out.add( f );\n          }\n        }\n        \n        // In lucene, the boost for a given field is the product of the \n        // document boost and *all* boosts on values of that field. \n        // For multi-valued fields, we only want to set the boost on the\n        // first field.\n        boost = 1.0f; \n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"ERROR:unknown field '\" + name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          out.add( field.createField( field.getDefaultValue(), 1.0f ) );\n        } \n        else {\n          String id = schema.printableUniqueKey( out );\n          String msg = \"Document [\"+id+\"] missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55883d09343e80968c5e44b9c14da13238544a0a","date":1228020380,"type":3,"author":"Koji Sekiguchi","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function shoould go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    out.setBoost( doc.getDocumentBoost() );\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        String id = \"\";\n        SchemaField sf = schema.getUniqueKeyField();\n        if( sf != null ) {\n          id = \"[\"+doc.getFieldValue( sf.getName() )+\"] \";\n        }\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+id+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      final List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      \n      // load each field value\n      boolean hasField = false;\n      for( Object v : field ) {\n        if( v == null ) {\n          continue;\n        }\n        String val = null;\n        hasField = true;\n        \n        // TODO!!! HACK -- date conversion\n        if( sfield != null && v instanceof Date && sfield.getType() instanceof DateField ) {\n          DateField df = (DateField)sfield.getType();\n          val = df.toInternal( (Date)v )+'Z';\n        }\n        else if (v != null) {\n          val = v.toString();\n        }\n        \n        if( sfield != null ) {\n          used = true;\n          Field f = sfield.createField( val, boost );\n          if( f != null ) { // null fields are not added\n            out.add( f );\n          }\n        }\n        \n        // Check if we should copy this field to any other fields.\n        // This could happen whether it is explicit or not.\n        for( CopyField cf : copyFields ) {\n          SchemaField sf = cf.getDestination();\n          // check if the copy field is a multivalued or not\n          if( !sf.multiValued() && out.get( sf.getName() ) != null ) {\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n                \"ERROR: multiple values encountered for non multiValued copy field \" + \n                  sf.getName() + \": \" +val ); \n          }\n          \n          used = true;\n          Field f = sf.createField( cf.getLimitedValue( val ), boost );\n          if( f != null ) { // null fields are not added\n            out.add( f );\n          }\n        }\n        \n        // In lucene, the boost for a given field is the product of the \n        // document boost and *all* boosts on values of that field. \n        // For multi-valued fields, we only want to set the boost on the\n        // first field.\n        boost = 1.0f; \n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"ERROR:unknown field '\" + name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          out.add( field.createField( field.getDefaultValue(), 1.0f ) );\n        } \n        else {\n          String id = schema.printableUniqueKey( out );\n          String msg = \"Document [\"+id+\"] missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function shoould go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    out.setBoost( doc.getDocumentBoost() );\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        String id = \"\";\n        SchemaField sf = schema.getUniqueKeyField();\n        if( sf != null ) {\n          id = \"[\"+doc.getFieldValue( sf.getName() )+\"] \";\n        }\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+id+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      SchemaField[] destArr = schema.getCopyFields(name);\n      \n      // load each field value\n      boolean hasField = false;\n      for( Object v : field ) {\n        if( v == null ) {\n          continue;\n        }\n        String val = null;\n        hasField = true;\n        \n        // TODO!!! HACK -- date conversion\n        if( sfield != null && v instanceof Date && sfield.getType() instanceof DateField ) {\n          DateField df = (DateField)sfield.getType();\n          val = df.toInternal( (Date)v )+'Z';\n        }\n        else if (v != null) {\n          val = v.toString();\n        }\n        \n        if( sfield != null ) {\n          used = true;\n          Field f = sfield.createField( val, boost );\n          if( f != null ) { // null fields are not added\n            out.add( f );\n          }\n        }\n        \n        // Add the copy fields\n        for( SchemaField sf : destArr ) {\n          // check if the copy field is a multivalued or not\n          if( !sf.multiValued() && out.get( sf.getName() ) != null ) {\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n                \"ERROR: multiple values encountered for non multiValued copy field \" + \n                  sf.getName() + \": \" +val ); \n          }\n          \n          used = true;\n          Field f = sf.createField( val, boost );\n          if( f != null ) { // null fields are not added\n            out.add( f );\n          }\n        }\n        \n        // In lucene, the boost for a given field is the product of the \n        // document boost and *all* boosts on values of that field. \n        // For multi-valued fields, we only want to set the boost on the\n        // first field.\n        boost = 1.0f; \n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"ERROR:unknown field '\" + name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          out.add( field.createField( field.getDefaultValue(), 1.0f ) );\n        } \n        else {\n          String id = schema.printableUniqueKey( out );\n          String msg = \"Document [\"+id+\"] missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b10b80126cc7d42b263ed791eba82e494c2901bc","date":1228857738,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    out.setBoost( doc.getDocumentBoost() );\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        String id = \"\";\n        SchemaField sf = schema.getUniqueKeyField();\n        if( sf != null ) {\n          id = \"[\"+doc.getFieldValue( sf.getName() )+\"] \";\n        }\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+id+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      final List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      \n      // load each field value\n      boolean hasField = false;\n      for( Object v : field ) {\n        if( v == null ) {\n          continue;\n        }\n        String val = null;\n        hasField = true;\n        \n        // TODO!!! HACK -- date conversion\n        if( sfield != null && v instanceof Date && sfield.getType() instanceof DateField ) {\n          DateField df = (DateField)sfield.getType();\n          val = df.toInternal( (Date)v )+'Z';\n        }\n        else if (v != null) {\n          val = v.toString();\n        }\n        \n        if( sfield != null ) {\n          used = true;\n          Field f = sfield.createField( val, boost );\n          if( f != null ) { // null fields are not added\n            out.add( f );\n          }\n        }\n        \n        // Check if we should copy this field to any other fields.\n        // This could happen whether it is explicit or not.\n        for( CopyField cf : copyFields ) {\n          SchemaField sf = cf.getDestination();\n          // check if the copy field is a multivalued or not\n          if( !sf.multiValued() && out.get( sf.getName() ) != null ) {\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n                \"ERROR: multiple values encountered for non multiValued copy field \" + \n                  sf.getName() + \": \" +val ); \n          }\n          \n          used = true;\n          Field f = sf.createField( cf.getLimitedValue( val ), boost );\n          if( f != null ) { // null fields are not added\n            out.add( f );\n          }\n        }\n        \n        // In lucene, the boost for a given field is the product of the \n        // document boost and *all* boosts on values of that field. \n        // For multi-valued fields, we only want to set the boost on the\n        // first field.\n        boost = 1.0f; \n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"ERROR:unknown field '\" + name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          out.add( field.createField( field.getDefaultValue(), 1.0f ) );\n        } \n        else {\n          String id = schema.printableUniqueKey( out );\n          String msg = \"Document [\"+id+\"] missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function shoould go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    out.setBoost( doc.getDocumentBoost() );\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        String id = \"\";\n        SchemaField sf = schema.getUniqueKeyField();\n        if( sf != null ) {\n          id = \"[\"+doc.getFieldValue( sf.getName() )+\"] \";\n        }\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+id+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      final List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      \n      // load each field value\n      boolean hasField = false;\n      for( Object v : field ) {\n        if( v == null ) {\n          continue;\n        }\n        String val = null;\n        hasField = true;\n        \n        // TODO!!! HACK -- date conversion\n        if( sfield != null && v instanceof Date && sfield.getType() instanceof DateField ) {\n          DateField df = (DateField)sfield.getType();\n          val = df.toInternal( (Date)v )+'Z';\n        }\n        else if (v != null) {\n          val = v.toString();\n        }\n        \n        if( sfield != null ) {\n          used = true;\n          Field f = sfield.createField( val, boost );\n          if( f != null ) { // null fields are not added\n            out.add( f );\n          }\n        }\n        \n        // Check if we should copy this field to any other fields.\n        // This could happen whether it is explicit or not.\n        for( CopyField cf : copyFields ) {\n          SchemaField sf = cf.getDestination();\n          // check if the copy field is a multivalued or not\n          if( !sf.multiValued() && out.get( sf.getName() ) != null ) {\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n                \"ERROR: multiple values encountered for non multiValued copy field \" + \n                  sf.getName() + \": \" +val ); \n          }\n          \n          used = true;\n          Field f = sf.createField( cf.getLimitedValue( val ), boost );\n          if( f != null ) { // null fields are not added\n            out.add( f );\n          }\n        }\n        \n        // In lucene, the boost for a given field is the product of the \n        // document boost and *all* boosts on values of that field. \n        // For multi-valued fields, we only want to set the boost on the\n        // first field.\n        boost = 1.0f; \n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"ERROR:unknown field '\" + name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          out.add( field.createField( field.getDefaultValue(), 1.0f ) );\n        } \n        else {\n          String id = schema.printableUniqueKey( out );\n          String msg = \"Document [\"+id+\"] missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8281d815c10235e2dab9ded85615ebe920dd3c22","date":1243323879,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    out.setBoost( doc.getDocumentBoost() );\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        String id = \"\";\n        SchemaField sf = schema.getUniqueKeyField();\n        if( sf != null ) {\n          id = \"[\"+doc.getFieldValue( sf.getName() )+\"] \";\n        }\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+id+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n\n      // load each field value\n      boolean hasField = false;\n      for( Object v : field ) {\n        if( v == null ) {\n          continue;\n        }\n        String val = null;\n        hasField = true;\n        boolean isBinaryField = false;\n        if (sfield != null && sfield.getType() instanceof BinaryField) {\n          isBinaryField = true;\n          BinaryField binaryField = (BinaryField) sfield.getType();\n          Field f = binaryField.createField(sfield,v,boost);\n          if(f != null) out.add(f);\n          used = true;\n        } else {\n          // TODO!!! HACK -- date conversion\n          if (sfield != null && v instanceof Date && sfield.getType() instanceof DateField) {\n            DateField df = (DateField) sfield.getType();\n            val = df.toInternal((Date) v) + 'Z';\n          } else if (v != null) {\n            val = v.toString();\n          }\n\n          if (sfield != null) {\n            used = true;\n            Field f = sfield.createField(val, boost);\n            if (f != null) { // null fields are not added\n              out.add(f);\n            }\n          }\n        }\n\n        // Check if we should copy this field to any other fields.\n        // This could happen whether it is explicit or not.\n        List<CopyField> copyFields = schema.getCopyFieldsList(name);\n        for (CopyField cf : copyFields) {\n          SchemaField destinationField = cf.getDestination();\n          // check if the copy field is a multivalued or not\n          if (!destinationField.multiValued() && out.get(destinationField.getName()) != null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"ERROR: multiple values encountered for non multiValued copy field \" +\n                            destinationField.getName() + \": \" + val);\n          }\n\n          used = true;\n          Field f = null;\n          if (isBinaryField) {\n            if (destinationField.getType() instanceof BinaryField) {\n              BinaryField binaryField = (BinaryField) destinationField.getType();\n              binaryField.createField(destinationField, v, boost);\n            }\n          } else {\n            f = destinationField.createField(cf.getLimitedValue(val), boost);\n          }\n          if (f != null) { // null fields are not added\n            out.add(f);\n          }\n        }\n        \n        // In lucene, the boost for a given field is the product of the \n        // document boost and *all* boosts on values of that field. \n        // For multi-valued fields, we only want to set the boost on the\n        // first field.\n        boost = 1.0f; \n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"ERROR:unknown field '\" +\n                name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          out.add( field.createField( field.getDefaultValue(), 1.0f ) );\n        } \n        else {\n          String id = schema.printableUniqueKey( out );\n          String msg = \"Document [\"+id+\"] missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    out.setBoost( doc.getDocumentBoost() );\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        String id = \"\";\n        SchemaField sf = schema.getUniqueKeyField();\n        if( sf != null ) {\n          id = \"[\"+doc.getFieldValue( sf.getName() )+\"] \";\n        }\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+id+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n      final List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      \n      // load each field value\n      boolean hasField = false;\n      for( Object v : field ) {\n        if( v == null ) {\n          continue;\n        }\n        String val = null;\n        hasField = true;\n        \n        // TODO!!! HACK -- date conversion\n        if( sfield != null && v instanceof Date && sfield.getType() instanceof DateField ) {\n          DateField df = (DateField)sfield.getType();\n          val = df.toInternal( (Date)v )+'Z';\n        }\n        else if (v != null) {\n          val = v.toString();\n        }\n        \n        if( sfield != null ) {\n          used = true;\n          Field f = sfield.createField( val, boost );\n          if( f != null ) { // null fields are not added\n            out.add( f );\n          }\n        }\n        \n        // Check if we should copy this field to any other fields.\n        // This could happen whether it is explicit or not.\n        for( CopyField cf : copyFields ) {\n          SchemaField sf = cf.getDestination();\n          // check if the copy field is a multivalued or not\n          if( !sf.multiValued() && out.get( sf.getName() ) != null ) {\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n                \"ERROR: multiple values encountered for non multiValued copy field \" + \n                  sf.getName() + \": \" +val ); \n          }\n          \n          used = true;\n          Field f = sf.createField( cf.getLimitedValue( val ), boost );\n          if( f != null ) { // null fields are not added\n            out.add( f );\n          }\n        }\n        \n        // In lucene, the boost for a given field is the product of the \n        // document boost and *all* boosts on values of that field. \n        // For multi-valued fields, we only want to set the boost on the\n        // first field.\n        boost = 1.0f; \n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"ERROR:unknown field '\" + name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          out.add( field.createField( field.getDefaultValue(), 1.0f ) );\n        } \n        else {\n          String id = schema.printableUniqueKey( out );\n          String msg = \"Document [\"+id+\"] missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":null,"bugIntro":["ad8cb9616ba022b889bbe0c8e1f2b7f302748404"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad8cb9616ba022b889bbe0c8e1f2b7f302748404","date":1258755057,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    out.setBoost( doc.getDocumentBoost() );\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        String id = \"\";\n        SchemaField sf = schema.getUniqueKeyField();\n        if( sf != null ) {\n          id = \"[\"+doc.getFieldValue( sf.getName() )+\"] \";\n        }\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+id+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n\n      // load each field value\n      boolean hasField = false;\n      for( Object v : field ) {\n        if( v == null ) {\n          continue;\n        }\n        String val = null;\n        hasField = true;\n        boolean isBinaryField = false;\n        if (sfield != null && sfield.getType() instanceof BinaryField) {\n          isBinaryField = true;\n          BinaryField binaryField = (BinaryField) sfield.getType();\n          Field f = binaryField.createField(sfield,v,boost);\n          if(f != null) out.add(f);\n          used = true;\n        } else {\n          // TODO!!! HACK -- date conversion\n          if (sfield != null && v instanceof Date && sfield.getType() instanceof DateField) {\n            DateField df = (DateField) sfield.getType();\n            val = df.toInternal((Date) v) + 'Z';\n          } else if (v != null) {\n            val = v.toString();\n          }\n\n          if (sfield != null) {\n            used = true;\n            Field f = sfield.createField(val, boost);\n            if (f != null) { // null fields are not added\n              out.add(f);\n            }\n          }\n        }\n\n        // Check if we should copy this field to any other fields.\n        // This could happen whether it is explicit or not.\n        List<CopyField> copyFields = schema.getCopyFieldsList(name);\n        for (CopyField cf : copyFields) {\n          SchemaField destinationField = cf.getDestination();\n          // check if the copy field is a multivalued or not\n          if (!destinationField.multiValued() && out.get(destinationField.getName()) != null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"ERROR: multiple values encountered for non multiValued copy field \" +\n                            destinationField.getName() + \": \" + val);\n          }\n\n          used = true;\n          Field f = null;\n          if (isBinaryField) {\n            if (destinationField.getType() instanceof BinaryField) {\n              BinaryField binaryField = (BinaryField) destinationField.getType();\n              f = binaryField.createField(destinationField, v, boost);\n            }\n          } else {\n            f = destinationField.createField(cf.getLimitedValue(val), boost);\n          }\n          if (f != null) { // null fields are not added\n            out.add(f);\n          }\n        }\n        \n        // In lucene, the boost for a given field is the product of the \n        // document boost and *all* boosts on values of that field. \n        // For multi-valued fields, we only want to set the boost on the\n        // first field.\n        boost = 1.0f; \n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"ERROR:unknown field '\" +\n                name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          out.add( field.createField( field.getDefaultValue(), 1.0f ) );\n        } \n        else {\n          String id = schema.printableUniqueKey( out );\n          String msg = \"Document [\"+id+\"] missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    out.setBoost( doc.getDocumentBoost() );\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        String id = \"\";\n        SchemaField sf = schema.getUniqueKeyField();\n        if( sf != null ) {\n          id = \"[\"+doc.getFieldValue( sf.getName() )+\"] \";\n        }\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+id+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n\n      // load each field value\n      boolean hasField = false;\n      for( Object v : field ) {\n        if( v == null ) {\n          continue;\n        }\n        String val = null;\n        hasField = true;\n        boolean isBinaryField = false;\n        if (sfield != null && sfield.getType() instanceof BinaryField) {\n          isBinaryField = true;\n          BinaryField binaryField = (BinaryField) sfield.getType();\n          Field f = binaryField.createField(sfield,v,boost);\n          if(f != null) out.add(f);\n          used = true;\n        } else {\n          // TODO!!! HACK -- date conversion\n          if (sfield != null && v instanceof Date && sfield.getType() instanceof DateField) {\n            DateField df = (DateField) sfield.getType();\n            val = df.toInternal((Date) v) + 'Z';\n          } else if (v != null) {\n            val = v.toString();\n          }\n\n          if (sfield != null) {\n            used = true;\n            Field f = sfield.createField(val, boost);\n            if (f != null) { // null fields are not added\n              out.add(f);\n            }\n          }\n        }\n\n        // Check if we should copy this field to any other fields.\n        // This could happen whether it is explicit or not.\n        List<CopyField> copyFields = schema.getCopyFieldsList(name);\n        for (CopyField cf : copyFields) {\n          SchemaField destinationField = cf.getDestination();\n          // check if the copy field is a multivalued or not\n          if (!destinationField.multiValued() && out.get(destinationField.getName()) != null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"ERROR: multiple values encountered for non multiValued copy field \" +\n                            destinationField.getName() + \": \" + val);\n          }\n\n          used = true;\n          Field f = null;\n          if (isBinaryField) {\n            if (destinationField.getType() instanceof BinaryField) {\n              BinaryField binaryField = (BinaryField) destinationField.getType();\n              binaryField.createField(destinationField, v, boost);\n            }\n          } else {\n            f = destinationField.createField(cf.getLimitedValue(val), boost);\n          }\n          if (f != null) { // null fields are not added\n            out.add(f);\n          }\n        }\n        \n        // In lucene, the boost for a given field is the product of the \n        // document boost and *all* boosts on values of that field. \n        // For multi-valued fields, we only want to set the boost on the\n        // first field.\n        boost = 1.0f; \n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"ERROR:unknown field '\" +\n                name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          out.add( field.createField( field.getDefaultValue(), 1.0f ) );\n        } \n        else {\n          String id = schema.printableUniqueKey( out );\n          String msg = \"Document [\"+id+\"] missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":["8281d815c10235e2dab9ded85615ebe920dd3c22"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"abec2fd822be07fc74ef5ba3609b9c5625a87d6d","date":1261659802,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    out.setBoost( doc.getDocumentBoost() );\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        String id = \"\";\n        SchemaField sf = schema.getUniqueKeyField();\n        if( sf != null ) {\n          id = \"[\"+doc.getFieldValue( sf.getName() )+\"] \";\n        }\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+id+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n\n      // load each field value\n      boolean hasField = false;\n      for( Object v : field ) {\n        if( v == null ) {\n          continue;\n        }\n        String val = null;\n        hasField = true;\n        boolean isBinaryField = false;\n        if (sfield != null && sfield.getType() instanceof BinaryField) {\n          isBinaryField = true;\n          BinaryField binaryField = (BinaryField) sfield.getType();\n          Field f = binaryField.createField(sfield,v,boost);\n          if(f != null){\n            out.add(f);\n          }\n          used = true;\n        } else {\n          // TODO!!! HACK -- date conversion\n          if (sfield != null && v instanceof Date && sfield.getType() instanceof DateField) {\n            DateField df = (DateField) sfield.getType();\n            val = df.toInternal((Date) v) + 'Z';\n          } else if (v != null) {\n            val = v.toString();\n          }\n\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, val, boost);\n          }\n        }\n\n        // Check if we should copy this field to any other fields.\n        // This could happen whether it is explicit or not.\n        List<CopyField> copyFields = schema.getCopyFieldsList(name);\n        for (CopyField cf : copyFields) {\n          SchemaField destinationField = cf.getDestination();\n          // check if the copy field is a multivalued or not\n          if (!destinationField.multiValued() && out.get(destinationField.getName()) != null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"ERROR: multiple values encountered for non multiValued copy field \" +\n                            destinationField.getName() + \": \" + val);\n          }\n\n          used = true;\n          //Don't worry about poly fields here\n          Fieldable [] fields = null;\n          if (isBinaryField) {\n            if (destinationField.getType() instanceof BinaryField) {\n              BinaryField binaryField = (BinaryField) destinationField.getType();\n              //TODO: safe to assume that binary fields only create one?\n              fields = new Field[]{binaryField.createField(destinationField, v, boost)};\n            }\n          } else {\n            fields = destinationField.createFields(cf.getLimitedValue(val), boost);\n          }\n          if (fields != null) { // null fields are not added\n            for (Fieldable f : fields) {\n              out.add(f);\n            }\n          }\n        }\n        \n        // In lucene, the boost for a given field is the product of the \n        // document boost and *all* boosts on values of that field. \n        // For multi-valued fields, we only want to set the boost on the\n        // first field.\n        boost = 1.0f; \n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"ERROR:unknown field '\" +\n                name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String id = schema.printableUniqueKey( out );\n          String msg = \"Document [\"+id+\"] missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    out.setBoost( doc.getDocumentBoost() );\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        String id = \"\";\n        SchemaField sf = schema.getUniqueKeyField();\n        if( sf != null ) {\n          id = \"[\"+doc.getFieldValue( sf.getName() )+\"] \";\n        }\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+id+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n\n      // load each field value\n      boolean hasField = false;\n      for( Object v : field ) {\n        if( v == null ) {\n          continue;\n        }\n        String val = null;\n        hasField = true;\n        boolean isBinaryField = false;\n        if (sfield != null && sfield.getType() instanceof BinaryField) {\n          isBinaryField = true;\n          BinaryField binaryField = (BinaryField) sfield.getType();\n          Field f = binaryField.createField(sfield,v,boost);\n          if(f != null) out.add(f);\n          used = true;\n        } else {\n          // TODO!!! HACK -- date conversion\n          if (sfield != null && v instanceof Date && sfield.getType() instanceof DateField) {\n            DateField df = (DateField) sfield.getType();\n            val = df.toInternal((Date) v) + 'Z';\n          } else if (v != null) {\n            val = v.toString();\n          }\n\n          if (sfield != null) {\n            used = true;\n            Field f = sfield.createField(val, boost);\n            if (f != null) { // null fields are not added\n              out.add(f);\n            }\n          }\n        }\n\n        // Check if we should copy this field to any other fields.\n        // This could happen whether it is explicit or not.\n        List<CopyField> copyFields = schema.getCopyFieldsList(name);\n        for (CopyField cf : copyFields) {\n          SchemaField destinationField = cf.getDestination();\n          // check if the copy field is a multivalued or not\n          if (!destinationField.multiValued() && out.get(destinationField.getName()) != null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"ERROR: multiple values encountered for non multiValued copy field \" +\n                            destinationField.getName() + \": \" + val);\n          }\n\n          used = true;\n          Field f = null;\n          if (isBinaryField) {\n            if (destinationField.getType() instanceof BinaryField) {\n              BinaryField binaryField = (BinaryField) destinationField.getType();\n              f = binaryField.createField(destinationField, v, boost);\n            }\n          } else {\n            f = destinationField.createField(cf.getLimitedValue(val), boost);\n          }\n          if (f != null) { // null fields are not added\n            out.add(f);\n          }\n        }\n        \n        // In lucene, the boost for a given field is the product of the \n        // document boost and *all* boosts on values of that field. \n        // For multi-valued fields, we only want to set the boost on the\n        // first field.\n        boost = 1.0f; \n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"ERROR:unknown field '\" +\n                name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          out.add( field.createField( field.getDefaultValue(), 1.0f ) );\n        } \n        else {\n          String id = schema.printableUniqueKey( out );\n          String msg = \"Document [\"+id+\"] missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e0befc1c5860d4d36852c59fb5303d8d44a9f51e","date":1266450758,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    out.setBoost( doc.getDocumentBoost() );\n\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    if (null != uniqueKeyField) {\n      Collection<Object> keys = doc.getFieldValues(uniqueKeyField.getName());\n      if (null == keys || keys.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                                \"Document missing value for uniqueKeyField: \" +\n                                uniqueKeyField.getName());\n      }\n    }\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        String id = ( uniqueKeyField == null )\n          ? \"\"\n          : (\"[\"+doc.getFieldValue( uniqueKeyField.getName() )+\"] \");\n\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+id+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n\n      // load each field value\n      boolean hasField = false;\n      for( Object v : field ) {\n        if( v == null ) {\n          continue;\n        }\n        String val = null;\n        hasField = true;\n        boolean isBinaryField = false;\n        if (sfield != null && sfield.getType() instanceof BinaryField) {\n          isBinaryField = true;\n          BinaryField binaryField = (BinaryField) sfield.getType();\n          Field f = binaryField.createField(sfield,v,boost);\n          if(f != null){\n            out.add(f);\n          }\n          used = true;\n        } else {\n          // TODO!!! HACK -- date conversion\n          if (sfield != null && v instanceof Date && sfield.getType() instanceof DateField) {\n            DateField df = (DateField) sfield.getType();\n            val = df.toInternal((Date) v) + 'Z';\n          } else if (v != null) {\n            val = v.toString();\n          }\n\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, val, boost);\n          }\n        }\n\n        // Check if we should copy this field to any other fields.\n        // This could happen whether it is explicit or not.\n        List<CopyField> copyFields = schema.getCopyFieldsList(name);\n        for (CopyField cf : copyFields) {\n          SchemaField destinationField = cf.getDestination();\n          // check if the copy field is a multivalued or not\n          if (!destinationField.multiValued() && out.get(destinationField.getName()) != null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"ERROR: multiple values encountered for non multiValued copy field \" +\n                            destinationField.getName() + \": \" + val);\n          }\n\n          used = true;\n          //Don't worry about poly fields here\n          Fieldable [] fields = null;\n          if (isBinaryField) {\n            if (destinationField.getType() instanceof BinaryField) {\n              BinaryField binaryField = (BinaryField) destinationField.getType();\n              //TODO: safe to assume that binary fields only create one?\n              fields = new Field[]{binaryField.createField(destinationField, v, boost)};\n            }\n          } else {\n            fields = destinationField.createFields(cf.getLimitedValue(val), boost);\n          }\n          if (fields != null) { // null fields are not added\n            for (Fieldable f : fields) {\n              out.add(f);\n            }\n          }\n        }\n        \n        // In lucene, the boost for a given field is the product of the \n        // document boost and *all* boosts on values of that field. \n        // For multi-valued fields, we only want to set the boost on the\n        // first field.\n        boost = 1.0f; \n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"ERROR:unknown field '\" +\n                name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String id = schema.printableUniqueKey( out );\n          String msg = \"Document [\"+id+\"] missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    out.setBoost( doc.getDocumentBoost() );\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        String id = \"\";\n        SchemaField sf = schema.getUniqueKeyField();\n        if( sf != null ) {\n          id = \"[\"+doc.getFieldValue( sf.getName() )+\"] \";\n        }\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+id+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n\n      // load each field value\n      boolean hasField = false;\n      for( Object v : field ) {\n        if( v == null ) {\n          continue;\n        }\n        String val = null;\n        hasField = true;\n        boolean isBinaryField = false;\n        if (sfield != null && sfield.getType() instanceof BinaryField) {\n          isBinaryField = true;\n          BinaryField binaryField = (BinaryField) sfield.getType();\n          Field f = binaryField.createField(sfield,v,boost);\n          if(f != null){\n            out.add(f);\n          }\n          used = true;\n        } else {\n          // TODO!!! HACK -- date conversion\n          if (sfield != null && v instanceof Date && sfield.getType() instanceof DateField) {\n            DateField df = (DateField) sfield.getType();\n            val = df.toInternal((Date) v) + 'Z';\n          } else if (v != null) {\n            val = v.toString();\n          }\n\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, val, boost);\n          }\n        }\n\n        // Check if we should copy this field to any other fields.\n        // This could happen whether it is explicit or not.\n        List<CopyField> copyFields = schema.getCopyFieldsList(name);\n        for (CopyField cf : copyFields) {\n          SchemaField destinationField = cf.getDestination();\n          // check if the copy field is a multivalued or not\n          if (!destinationField.multiValued() && out.get(destinationField.getName()) != null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"ERROR: multiple values encountered for non multiValued copy field \" +\n                            destinationField.getName() + \": \" + val);\n          }\n\n          used = true;\n          //Don't worry about poly fields here\n          Fieldable [] fields = null;\n          if (isBinaryField) {\n            if (destinationField.getType() instanceof BinaryField) {\n              BinaryField binaryField = (BinaryField) destinationField.getType();\n              //TODO: safe to assume that binary fields only create one?\n              fields = new Field[]{binaryField.createField(destinationField, v, boost)};\n            }\n          } else {\n            fields = destinationField.createFields(cf.getLimitedValue(val), boost);\n          }\n          if (fields != null) { // null fields are not added\n            for (Fieldable f : fields) {\n              out.add(f);\n            }\n          }\n        }\n        \n        // In lucene, the boost for a given field is the product of the \n        // document boost and *all* boosts on values of that field. \n        // For multi-valued fields, we only want to set the boost on the\n        // first field.\n        boost = 1.0f; \n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"ERROR:unknown field '\" +\n                name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String id = schema.printableUniqueKey( out );\n          String msg = \"Document [\"+id+\"] missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2e76c4e73a9601d1f951cef3209ed07c6d7d7d79","date":1266451369,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    out.setBoost( doc.getDocumentBoost() );\n\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    if (null != uniqueKeyField) {\n      Collection<Object> keys = doc.getFieldValues(uniqueKeyField.getName());\n      if (null == keys || keys.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                                \"Document missing a value for uniqueKey field: \" +\n                                uniqueKeyField.getName());\n      }\n      if (1 < keys.size()) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Document contains multiple values for uniqueKey field: \" +\n           uniqueKeyField.getName());\n      }\n    }\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        String id = ( uniqueKeyField == null )\n          ? \"\"\n          : (\"[\"+doc.getFieldValue( uniqueKeyField.getName() )+\"] \");\n\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+id+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n\n      // load each field value\n      boolean hasField = false;\n      for( Object v : field ) {\n        if( v == null ) {\n          continue;\n        }\n        String val = null;\n        hasField = true;\n        boolean isBinaryField = false;\n        if (sfield != null && sfield.getType() instanceof BinaryField) {\n          isBinaryField = true;\n          BinaryField binaryField = (BinaryField) sfield.getType();\n          Field f = binaryField.createField(sfield,v,boost);\n          if(f != null){\n            out.add(f);\n          }\n          used = true;\n        } else {\n          // TODO!!! HACK -- date conversion\n          if (sfield != null && v instanceof Date && sfield.getType() instanceof DateField) {\n            DateField df = (DateField) sfield.getType();\n            val = df.toInternal((Date) v) + 'Z';\n          } else if (v != null) {\n            val = v.toString();\n          }\n\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, val, boost);\n          }\n        }\n\n        // Check if we should copy this field to any other fields.\n        // This could happen whether it is explicit or not.\n        List<CopyField> copyFields = schema.getCopyFieldsList(name);\n        for (CopyField cf : copyFields) {\n          SchemaField destinationField = cf.getDestination();\n          // check if the copy field is a multivalued or not\n          if (!destinationField.multiValued() && out.get(destinationField.getName()) != null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"ERROR: multiple values encountered for non multiValued copy field \" +\n                            destinationField.getName() + \": \" + val);\n          }\n\n          used = true;\n          //Don't worry about poly fields here\n          Fieldable [] fields = null;\n          if (isBinaryField) {\n            if (destinationField.getType() instanceof BinaryField) {\n              BinaryField binaryField = (BinaryField) destinationField.getType();\n              //TODO: safe to assume that binary fields only create one?\n              fields = new Field[]{binaryField.createField(destinationField, v, boost)};\n            }\n          } else {\n            fields = destinationField.createFields(cf.getLimitedValue(val), boost);\n          }\n          if (fields != null) { // null fields are not added\n            for (Fieldable f : fields) {\n              out.add(f);\n            }\n          }\n        }\n        \n        // In lucene, the boost for a given field is the product of the \n        // document boost and *all* boosts on values of that field. \n        // For multi-valued fields, we only want to set the boost on the\n        // first field.\n        boost = 1.0f; \n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"ERROR:unknown field '\" +\n                name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String id = schema.printableUniqueKey( out );\n          String msg = \"Document [\"+id+\"] missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    out.setBoost( doc.getDocumentBoost() );\n\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    if (null != uniqueKeyField) {\n      Collection<Object> keys = doc.getFieldValues(uniqueKeyField.getName());\n      if (null == keys || keys.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                                \"Document missing value for uniqueKeyField: \" +\n                                uniqueKeyField.getName());\n      }\n    }\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        String id = ( uniqueKeyField == null )\n          ? \"\"\n          : (\"[\"+doc.getFieldValue( uniqueKeyField.getName() )+\"] \");\n\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+id+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n\n      // load each field value\n      boolean hasField = false;\n      for( Object v : field ) {\n        if( v == null ) {\n          continue;\n        }\n        String val = null;\n        hasField = true;\n        boolean isBinaryField = false;\n        if (sfield != null && sfield.getType() instanceof BinaryField) {\n          isBinaryField = true;\n          BinaryField binaryField = (BinaryField) sfield.getType();\n          Field f = binaryField.createField(sfield,v,boost);\n          if(f != null){\n            out.add(f);\n          }\n          used = true;\n        } else {\n          // TODO!!! HACK -- date conversion\n          if (sfield != null && v instanceof Date && sfield.getType() instanceof DateField) {\n            DateField df = (DateField) sfield.getType();\n            val = df.toInternal((Date) v) + 'Z';\n          } else if (v != null) {\n            val = v.toString();\n          }\n\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, val, boost);\n          }\n        }\n\n        // Check if we should copy this field to any other fields.\n        // This could happen whether it is explicit or not.\n        List<CopyField> copyFields = schema.getCopyFieldsList(name);\n        for (CopyField cf : copyFields) {\n          SchemaField destinationField = cf.getDestination();\n          // check if the copy field is a multivalued or not\n          if (!destinationField.multiValued() && out.get(destinationField.getName()) != null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"ERROR: multiple values encountered for non multiValued copy field \" +\n                            destinationField.getName() + \": \" + val);\n          }\n\n          used = true;\n          //Don't worry about poly fields here\n          Fieldable [] fields = null;\n          if (isBinaryField) {\n            if (destinationField.getType() instanceof BinaryField) {\n              BinaryField binaryField = (BinaryField) destinationField.getType();\n              //TODO: safe to assume that binary fields only create one?\n              fields = new Field[]{binaryField.createField(destinationField, v, boost)};\n            }\n          } else {\n            fields = destinationField.createFields(cf.getLimitedValue(val), boost);\n          }\n          if (fields != null) { // null fields are not added\n            for (Fieldable f : fields) {\n              out.add(f);\n            }\n          }\n        }\n        \n        // In lucene, the boost for a given field is the product of the \n        // document boost and *all* boosts on values of that field. \n        // For multi-valued fields, we only want to set the boost on the\n        // first field.\n        boost = 1.0f; \n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"ERROR:unknown field '\" +\n                name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String id = schema.printableUniqueKey( out );\n          String msg = \"Document [\"+id+\"] missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ba3f1c0856832d1e8fa89cd51b61a32fe42aa45","date":1266528548,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    out.setBoost( doc.getDocumentBoost() );\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        String id = \"\";\n        SchemaField sf = schema.getUniqueKeyField();\n        if( sf != null ) {\n          id = \"[\"+doc.getFieldValue( sf.getName() )+\"] \";\n        }\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+id+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n\n      // load each field value\n      boolean hasField = false;\n      for( Object v : field ) {\n        if( v == null ) {\n          continue;\n        }\n        String val = null;\n        hasField = true;\n        boolean isBinaryField = false;\n        if (sfield != null && sfield.getType() instanceof BinaryField) {\n          isBinaryField = true;\n          BinaryField binaryField = (BinaryField) sfield.getType();\n          Field f = binaryField.createField(sfield,v,boost);\n          if(f != null){\n            out.add(f);\n          }\n          used = true;\n        } else {\n          // TODO!!! HACK -- date conversion\n          if (sfield != null && v instanceof Date && sfield.getType() instanceof DateField) {\n            DateField df = (DateField) sfield.getType();\n            val = df.toInternal((Date) v) + 'Z';\n          } else if (v != null) {\n            val = v.toString();\n          }\n\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, val, boost);\n          }\n        }\n\n        // Check if we should copy this field to any other fields.\n        // This could happen whether it is explicit or not.\n        List<CopyField> copyFields = schema.getCopyFieldsList(name);\n        for (CopyField cf : copyFields) {\n          SchemaField destinationField = cf.getDestination();\n          // check if the copy field is a multivalued or not\n          if (!destinationField.multiValued() && out.get(destinationField.getName()) != null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"ERROR: multiple values encountered for non multiValued copy field \" +\n                            destinationField.getName() + \": \" + val);\n          }\n\n          used = true;\n          //Don't worry about poly fields here\n          Fieldable [] fields = null;\n          if (isBinaryField) {\n            if (destinationField.getType() instanceof BinaryField) {\n              BinaryField binaryField = (BinaryField) destinationField.getType();\n              //TODO: safe to assume that binary fields only create one?\n              fields = new Field[]{binaryField.createField(destinationField, v, boost)};\n            }\n          } else {\n            fields = destinationField.createFields(cf.getLimitedValue(val), boost);\n          }\n          if (fields != null) { // null fields are not added\n            for (Fieldable f : fields) {\n              out.add(f);\n            }\n          }\n        }\n        \n        // In lucene, the boost for a given field is the product of the \n        // document boost and *all* boosts on values of that field. \n        // For multi-valued fields, we only want to set the boost on the\n        // first field.\n        boost = 1.0f; \n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"ERROR:unknown field '\" +\n                name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String id = schema.printableUniqueKey( out );\n          String msg = \"Document [\"+id+\"] missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    out.setBoost( doc.getDocumentBoost() );\n\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    if (null != uniqueKeyField) {\n      Collection<Object> keys = doc.getFieldValues(uniqueKeyField.getName());\n      if (null == keys || keys.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                                \"Document missing a value for uniqueKey field: \" +\n                                uniqueKeyField.getName());\n      }\n      if (1 < keys.size()) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Document contains multiple values for uniqueKey field: \" +\n           uniqueKeyField.getName());\n      }\n    }\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        String id = ( uniqueKeyField == null )\n          ? \"\"\n          : (\"[\"+doc.getFieldValue( uniqueKeyField.getName() )+\"] \");\n\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+id+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n\n      // load each field value\n      boolean hasField = false;\n      for( Object v : field ) {\n        if( v == null ) {\n          continue;\n        }\n        String val = null;\n        hasField = true;\n        boolean isBinaryField = false;\n        if (sfield != null && sfield.getType() instanceof BinaryField) {\n          isBinaryField = true;\n          BinaryField binaryField = (BinaryField) sfield.getType();\n          Field f = binaryField.createField(sfield,v,boost);\n          if(f != null){\n            out.add(f);\n          }\n          used = true;\n        } else {\n          // TODO!!! HACK -- date conversion\n          if (sfield != null && v instanceof Date && sfield.getType() instanceof DateField) {\n            DateField df = (DateField) sfield.getType();\n            val = df.toInternal((Date) v) + 'Z';\n          } else if (v != null) {\n            val = v.toString();\n          }\n\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, val, boost);\n          }\n        }\n\n        // Check if we should copy this field to any other fields.\n        // This could happen whether it is explicit or not.\n        List<CopyField> copyFields = schema.getCopyFieldsList(name);\n        for (CopyField cf : copyFields) {\n          SchemaField destinationField = cf.getDestination();\n          // check if the copy field is a multivalued or not\n          if (!destinationField.multiValued() && out.get(destinationField.getName()) != null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"ERROR: multiple values encountered for non multiValued copy field \" +\n                            destinationField.getName() + \": \" + val);\n          }\n\n          used = true;\n          //Don't worry about poly fields here\n          Fieldable [] fields = null;\n          if (isBinaryField) {\n            if (destinationField.getType() instanceof BinaryField) {\n              BinaryField binaryField = (BinaryField) destinationField.getType();\n              //TODO: safe to assume that binary fields only create one?\n              fields = new Field[]{binaryField.createField(destinationField, v, boost)};\n            }\n          } else {\n            fields = destinationField.createFields(cf.getLimitedValue(val), boost);\n          }\n          if (fields != null) { // null fields are not added\n            for (Fieldable f : fields) {\n              out.add(f);\n            }\n          }\n        }\n        \n        // In lucene, the boost for a given field is the product of the \n        // document boost and *all* boosts on values of that field. \n        // For multi-valued fields, we only want to set the boost on the\n        // first field.\n        boost = 1.0f; \n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"ERROR:unknown field '\" +\n                name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String id = schema.printableUniqueKey( out );\n          String msg = \"Document [\"+id+\"] missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    out.setBoost( doc.getDocumentBoost() );\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        String id = \"\";\n        SchemaField sf = schema.getUniqueKeyField();\n        if( sf != null ) {\n          id = \"[\"+doc.getFieldValue( sf.getName() )+\"] \";\n        }\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+id+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n\n      // load each field value\n      boolean hasField = false;\n      for( Object v : field ) {\n        if( v == null ) {\n          continue;\n        }\n        String val = null;\n        hasField = true;\n        boolean isBinaryField = false;\n        if (sfield != null && sfield.getType() instanceof BinaryField) {\n          isBinaryField = true;\n          BinaryField binaryField = (BinaryField) sfield.getType();\n          Field f = binaryField.createField(sfield,v,boost);\n          if(f != null){\n            out.add(f);\n          }\n          used = true;\n        } else {\n          // TODO!!! HACK -- date conversion\n          if (sfield != null && v instanceof Date && sfield.getType() instanceof DateField) {\n            DateField df = (DateField) sfield.getType();\n            val = df.toInternal((Date) v) + 'Z';\n          } else if (v != null) {\n            val = v.toString();\n          }\n\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, val, boost);\n          }\n        }\n\n        // Check if we should copy this field to any other fields.\n        // This could happen whether it is explicit or not.\n        List<CopyField> copyFields = schema.getCopyFieldsList(name);\n        for (CopyField cf : copyFields) {\n          SchemaField destinationField = cf.getDestination();\n          // check if the copy field is a multivalued or not\n          if (!destinationField.multiValued() && out.get(destinationField.getName()) != null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"ERROR: multiple values encountered for non multiValued copy field \" +\n                            destinationField.getName() + \": \" + val);\n          }\n\n          used = true;\n          //Don't worry about poly fields here\n          Fieldable [] fields = null;\n          if (isBinaryField) {\n            if (destinationField.getType() instanceof BinaryField) {\n              BinaryField binaryField = (BinaryField) destinationField.getType();\n              //TODO: safe to assume that binary fields only create one?\n              fields = new Field[]{binaryField.createField(destinationField, v, boost)};\n            }\n          } else {\n            fields = destinationField.createFields(cf.getLimitedValue(val), boost);\n          }\n          if (fields != null) { // null fields are not added\n            for (Fieldable f : fields) {\n              out.add(f);\n            }\n          }\n        }\n        \n        // In lucene, the boost for a given field is the product of the \n        // document boost and *all* boosts on values of that field. \n        // For multi-valued fields, we only want to set the boost on the\n        // first field.\n        boost = 1.0f; \n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"ERROR:unknown field '\" +\n                name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String id = schema.printableUniqueKey( out );\n          String msg = \"Document [\"+id+\"] missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map<> checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema )\n  { \n    Document out = new Document();\n    out.setBoost( doc.getDocumentBoost() );\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      float boost = field.getBoost();\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        String id = \"\";\n        SchemaField sf = schema.getUniqueKeyField();\n        if( sf != null ) {\n          id = \"[\"+doc.getFieldValue( sf.getName() )+\"] \";\n        }\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+id+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n      \n\n      // load each field value\n      boolean hasField = false;\n      for( Object v : field ) {\n        if( v == null ) {\n          continue;\n        }\n        String val = null;\n        hasField = true;\n        boolean isBinaryField = false;\n        if (sfield != null && sfield.getType() instanceof BinaryField) {\n          isBinaryField = true;\n          BinaryField binaryField = (BinaryField) sfield.getType();\n          Field f = binaryField.createField(sfield,v,boost);\n          if(f != null){\n            out.add(f);\n          }\n          used = true;\n        } else {\n          // TODO!!! HACK -- date conversion\n          if (sfield != null && v instanceof Date && sfield.getType() instanceof DateField) {\n            DateField df = (DateField) sfield.getType();\n            val = df.toInternal((Date) v) + 'Z';\n          } else if (v != null) {\n            val = v.toString();\n          }\n\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, val, boost);\n          }\n        }\n\n        // Check if we should copy this field to any other fields.\n        // This could happen whether it is explicit or not.\n        List<CopyField> copyFields = schema.getCopyFieldsList(name);\n        for (CopyField cf : copyFields) {\n          SchemaField destinationField = cf.getDestination();\n          // check if the copy field is a multivalued or not\n          if (!destinationField.multiValued() && out.get(destinationField.getName()) != null) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                    \"ERROR: multiple values encountered for non multiValued copy field \" +\n                            destinationField.getName() + \": \" + val);\n          }\n\n          used = true;\n          //Don't worry about poly fields here\n          Fieldable [] fields = null;\n          if (isBinaryField) {\n            if (destinationField.getType() instanceof BinaryField) {\n              BinaryField binaryField = (BinaryField) destinationField.getType();\n              //TODO: safe to assume that binary fields only create one?\n              fields = new Field[]{binaryField.createField(destinationField, v, boost)};\n            }\n          } else {\n            fields = destinationField.createFields(cf.getLimitedValue(val), boost);\n          }\n          if (fields != null) { // null fields are not added\n            for (Fieldable f : fields) {\n              out.add(f);\n            }\n          }\n        }\n        \n        // In lucene, the boost for a given field is the product of the \n        // document boost and *all* boosts on values of that field. \n        // For multi-valued fields, we only want to set the boost on the\n        // first field.\n        boost = 1.0f; \n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"ERROR:unknown field '\" +\n                name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n    for (SchemaField field : schema.getRequiredFields()) {\n      if (out.getField(field.getName() ) == null) {\n        if (field.getDefaultValue() != null) {\n          addField(out, field, field.getDefaultValue(), 1.0f);\n        } \n        else {\n          String id = schema.printableUniqueKey( out );\n          String msg = \"Document [\"+id+\"] missing required field: \" + field.getName();\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n        }\n      }\n    }\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"abec2fd822be07fc74ef5ba3609b9c5625a87d6d":["ad8cb9616ba022b889bbe0c8e1f2b7f302748404"],"0ba3f1c0856832d1e8fa89cd51b61a32fe42aa45":["2e76c4e73a9601d1f951cef3209ed07c6d7d7d79"],"ebb24ab555aab7c4dd5d2264c06a4f19fb217913":["0cd1b5cc13e2ad6adfe55db8cf8a0d81077563f4"],"91f6a1cbf34f0ff73228cad8b1390ba53d9dadc4":["ebb24ab555aab7c4dd5d2264c06a4f19fb217913"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"8281d815c10235e2dab9ded85615ebe920dd3c22":["b10b80126cc7d42b263ed791eba82e494c2901bc"],"e0befc1c5860d4d36852c59fb5303d8d44a9f51e":["abec2fd822be07fc74ef5ba3609b9c5625a87d6d"],"0cd1b5cc13e2ad6adfe55db8cf8a0d81077563f4":["ee4f075a5b1a77c2fb5eb752bdedabf6497aaf9b"],"2e76c4e73a9601d1f951cef3209ed07c6d7d7d79":["e0befc1c5860d4d36852c59fb5303d8d44a9f51e"],"55883d09343e80968c5e44b9c14da13238544a0a":["b4e01dcd4807436dd0fd45e23b3dee970905983f"],"ee4f075a5b1a77c2fb5eb752bdedabf6497aaf9b":["a76eb9a31b3f158d4803594a76191193a920c2dd"],"a76eb9a31b3f158d4803594a76191193a920c2dd":["4230c91a8f260cc364b5a46269bd21d6122b4fbd"],"4230c91a8f260cc364b5a46269bd21d6122b4fbd":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b10b80126cc7d42b263ed791eba82e494c2901bc":["55883d09343e80968c5e44b9c14da13238544a0a"],"b4e01dcd4807436dd0fd45e23b3dee970905983f":["91f6a1cbf34f0ff73228cad8b1390ba53d9dadc4"],"ad94625fb8d088209f46650c8097196fec67f00c":["0ba3f1c0856832d1e8fa89cd51b61a32fe42aa45"],"ad8cb9616ba022b889bbe0c8e1f2b7f302748404":["8281d815c10235e2dab9ded85615ebe920dd3c22"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"abec2fd822be07fc74ef5ba3609b9c5625a87d6d":["e0befc1c5860d4d36852c59fb5303d8d44a9f51e"],"0ba3f1c0856832d1e8fa89cd51b61a32fe42aa45":["ad94625fb8d088209f46650c8097196fec67f00c"],"ebb24ab555aab7c4dd5d2264c06a4f19fb217913":["91f6a1cbf34f0ff73228cad8b1390ba53d9dadc4"],"91f6a1cbf34f0ff73228cad8b1390ba53d9dadc4":["b4e01dcd4807436dd0fd45e23b3dee970905983f"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["4230c91a8f260cc364b5a46269bd21d6122b4fbd"],"8281d815c10235e2dab9ded85615ebe920dd3c22":["ad8cb9616ba022b889bbe0c8e1f2b7f302748404"],"0cd1b5cc13e2ad6adfe55db8cf8a0d81077563f4":["ebb24ab555aab7c4dd5d2264c06a4f19fb217913"],"e0befc1c5860d4d36852c59fb5303d8d44a9f51e":["2e76c4e73a9601d1f951cef3209ed07c6d7d7d79"],"2e76c4e73a9601d1f951cef3209ed07c6d7d7d79":["0ba3f1c0856832d1e8fa89cd51b61a32fe42aa45"],"55883d09343e80968c5e44b9c14da13238544a0a":["b10b80126cc7d42b263ed791eba82e494c2901bc"],"ee4f075a5b1a77c2fb5eb752bdedabf6497aaf9b":["0cd1b5cc13e2ad6adfe55db8cf8a0d81077563f4"],"a76eb9a31b3f158d4803594a76191193a920c2dd":["ee4f075a5b1a77c2fb5eb752bdedabf6497aaf9b"],"4230c91a8f260cc364b5a46269bd21d6122b4fbd":["a76eb9a31b3f158d4803594a76191193a920c2dd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b10b80126cc7d42b263ed791eba82e494c2901bc":["8281d815c10235e2dab9ded85615ebe920dd3c22"],"b4e01dcd4807436dd0fd45e23b3dee970905983f":["55883d09343e80968c5e44b9c14da13238544a0a"],"ad8cb9616ba022b889bbe0c8e1f2b7f302748404":["abec2fd822be07fc74ef5ba3609b9c5625a87d6d"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}