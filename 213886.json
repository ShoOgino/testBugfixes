{"path":"lucene/test-framework/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesWriter#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","commits":[{"id":"db5a3aeba34624ea274f34df5691d40ca25f2b67","date":1358965297,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesWriter#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {\n    assert false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1982459c2ac4916bf3c0644b801f0cb3e4ee159f","date":1359034079,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesWriter#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesWriter#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","sourceNew":"  @Override\n  public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {\n    // examine the values to determine best type to use\n    int minLength = Integer.MAX_VALUE;\n    int maxLength = Integer.MIN_VALUE;\n    for (BytesRef b : values) {\n      minLength = Math.min(minLength, b.length);\n      maxLength = Math.max(maxLength, b.length);\n    }\n    \n    if (minLength == maxLength) {\n      // fixed byte[]\n      String fileName = IndexFileNames.segmentFileName(state.segmentInfo.name, Integer.toString(field.number), \"dat\");\n      IndexOutput data = dir.createOutput(fileName, state.context);\n      boolean success = false;\n      try {\n        addFixedStraightBytesField(field, data, values, minLength);\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(data);\n        } else {\n          IOUtils.closeWhileHandlingException(data);\n        }\n      }\n    } else {\n      // not yet\n      assert false;\n    }\n  }\n\n","sourceOld":"  @Override\n  public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {\n    assert false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ef85d40fcb2c5bb7ec40780b12e543600a1ae38","date":1359036780,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesWriter#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesWriter#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","sourceNew":"  @Override\n  public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {\n    // examine the values to determine best type to use\n    // TODO: would be cool to write the deref types in this impersonator too\n    int minLength = Integer.MAX_VALUE;\n    int maxLength = Integer.MIN_VALUE;\n    for (BytesRef b : values) {\n      minLength = Math.min(minLength, b.length);\n      maxLength = Math.max(maxLength, b.length);\n    }\n    \n    if (minLength == maxLength) {\n      // fixed byte[]\n      String fileName = IndexFileNames.segmentFileName(state.segmentInfo.name, Integer.toString(field.number), \"dat\");\n      IndexOutput data = dir.createOutput(fileName, state.context);\n      boolean success = false;\n      try {\n        addFixedStraightBytesField(field, data, values, minLength);\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(data);\n        } else {\n          IOUtils.closeWhileHandlingException(data);\n        }\n      }\n    } else {\n      // variable byte[]\n      boolean success = false;\n      IndexOutput data = null;\n      IndexOutput index = null;\n      String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, Integer.toString(field.number), \"dat\");\n      String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name, Integer.toString(field.number), \"idx\");\n      try {\n        data = dir.createOutput(dataName, state.context);\n        index = dir.createOutput(indexName, state.context);\n        addVarStraightBytesField(field, data, index, values);\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(data, index);\n        } else {\n          IOUtils.closeWhileHandlingException(data, index);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {\n    // examine the values to determine best type to use\n    int minLength = Integer.MAX_VALUE;\n    int maxLength = Integer.MIN_VALUE;\n    for (BytesRef b : values) {\n      minLength = Math.min(minLength, b.length);\n      maxLength = Math.max(maxLength, b.length);\n    }\n    \n    if (minLength == maxLength) {\n      // fixed byte[]\n      String fileName = IndexFileNames.segmentFileName(state.segmentInfo.name, Integer.toString(field.number), \"dat\");\n      IndexOutput data = dir.createOutput(fileName, state.context);\n      boolean success = false;\n      try {\n        addFixedStraightBytesField(field, data, values, minLength);\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(data);\n        } else {\n          IOUtils.closeWhileHandlingException(data);\n        }\n      }\n    } else {\n      // not yet\n      assert false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"769aa5c7a844c7615167d4fc9352373d85eef21e","date":1359050293,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesWriter#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesWriter#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","sourceNew":"  @Override\n  public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {\n    // examine the values to determine best type to use\n    HashSet<BytesRef> uniqueValues = new HashSet<BytesRef>();\n    int minLength = Integer.MAX_VALUE;\n    int maxLength = Integer.MIN_VALUE;\n    for (BytesRef b : values) {\n      minLength = Math.min(minLength, b.length);\n      maxLength = Math.max(maxLength, b.length);\n      if (uniqueValues != null) {\n        if (uniqueValues.add(BytesRef.deepCopyOf(b))) {\n          if (uniqueValues.size() > 256) {\n            uniqueValues = null;\n          }\n        }\n      }\n    }\n    \n    int maxDoc = state.segmentInfo.getDocCount();\n    final boolean fixed = minLength == maxLength;\n    // nocommit\n    final boolean dedup = fixed && (uniqueValues != null && uniqueValues.size() * 2 < maxDoc);\n    \n    if (dedup) {\n      // we will deduplicate and deref values\n      boolean success = false;\n      IndexOutput data = null;\n      IndexOutput index = null;\n      String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, Integer.toString(field.number), \"dat\");\n      String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name, Integer.toString(field.number), \"idx\");\n      try {\n        data = dir.createOutput(dataName, state.context);\n        index = dir.createOutput(indexName, state.context);\n        if (fixed) {\n          addFixedDerefBytesField(field, data, index, values, minLength);\n        } else {\n          assert false; // nocommit\n        }\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(data, index);\n        } else {\n          IOUtils.closeWhileHandlingException(data, index);\n        }\n      }\n    } else {\n      // we dont deduplicate, just write values straight\n      if (fixed) {\n        // fixed byte[]\n        String fileName = IndexFileNames.segmentFileName(state.segmentInfo.name, Integer.toString(field.number), \"dat\");\n        IndexOutput data = dir.createOutput(fileName, state.context);\n        boolean success = false;\n        try {\n          addFixedStraightBytesField(field, data, values, minLength);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data);\n          } else {\n            IOUtils.closeWhileHandlingException(data);\n          }\n        }\n      } else {\n        // variable byte[]\n        boolean success = false;\n        IndexOutput data = null;\n        IndexOutput index = null;\n        String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, Integer.toString(field.number), \"dat\");\n        String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name, Integer.toString(field.number), \"idx\");\n        try {\n          data = dir.createOutput(dataName, state.context);\n          index = dir.createOutput(indexName, state.context);\n          addVarStraightBytesField(field, data, index, values);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data, index);\n          } else {\n            IOUtils.closeWhileHandlingException(data, index);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {\n    // examine the values to determine best type to use\n    // TODO: would be cool to write the deref types in this impersonator too\n    int minLength = Integer.MAX_VALUE;\n    int maxLength = Integer.MIN_VALUE;\n    for (BytesRef b : values) {\n      minLength = Math.min(minLength, b.length);\n      maxLength = Math.max(maxLength, b.length);\n    }\n    \n    if (minLength == maxLength) {\n      // fixed byte[]\n      String fileName = IndexFileNames.segmentFileName(state.segmentInfo.name, Integer.toString(field.number), \"dat\");\n      IndexOutput data = dir.createOutput(fileName, state.context);\n      boolean success = false;\n      try {\n        addFixedStraightBytesField(field, data, values, minLength);\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(data);\n        } else {\n          IOUtils.closeWhileHandlingException(data);\n        }\n      }\n    } else {\n      // variable byte[]\n      boolean success = false;\n      IndexOutput data = null;\n      IndexOutput index = null;\n      String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, Integer.toString(field.number), \"dat\");\n      String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name, Integer.toString(field.number), \"idx\");\n      try {\n        data = dir.createOutput(dataName, state.context);\n        index = dir.createOutput(indexName, state.context);\n        addVarStraightBytesField(field, data, index, values);\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(data, index);\n        } else {\n          IOUtils.closeWhileHandlingException(data, index);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1ba10bcc2b7d89f38b6f4629475638edca1a2994","date":1359052288,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesWriter#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesWriter#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","sourceNew":"  @Override\n  public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {\n    // examine the values to determine best type to use\n    HashSet<BytesRef> uniqueValues = new HashSet<BytesRef>();\n    int minLength = Integer.MAX_VALUE;\n    int maxLength = Integer.MIN_VALUE;\n    for (BytesRef b : values) {\n      minLength = Math.min(minLength, b.length);\n      maxLength = Math.max(maxLength, b.length);\n      if (uniqueValues != null) {\n        if (uniqueValues.add(BytesRef.deepCopyOf(b))) {\n          if (uniqueValues.size() > 256) {\n            uniqueValues = null;\n          }\n        }\n      }\n    }\n    \n    int maxDoc = state.segmentInfo.getDocCount();\n    final boolean fixed = minLength == maxLength;\n    final boolean dedup = uniqueValues != null && uniqueValues.size() * 2 < maxDoc;\n    \n    if (dedup) {\n      // we will deduplicate and deref values\n      boolean success = false;\n      IndexOutput data = null;\n      IndexOutput index = null;\n      String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, Integer.toString(field.number), \"dat\");\n      String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name, Integer.toString(field.number), \"idx\");\n      try {\n        data = dir.createOutput(dataName, state.context);\n        index = dir.createOutput(indexName, state.context);\n        if (fixed) {\n          addFixedDerefBytesField(field, data, index, values, minLength);\n        } else {\n          addVarDerefBytesField(field, data, index, values);\n        }\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(data, index);\n        } else {\n          IOUtils.closeWhileHandlingException(data, index);\n        }\n      }\n    } else {\n      // we dont deduplicate, just write values straight\n      if (fixed) {\n        // fixed byte[]\n        String fileName = IndexFileNames.segmentFileName(state.segmentInfo.name, Integer.toString(field.number), \"dat\");\n        IndexOutput data = dir.createOutput(fileName, state.context);\n        boolean success = false;\n        try {\n          addFixedStraightBytesField(field, data, values, minLength);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data);\n          } else {\n            IOUtils.closeWhileHandlingException(data);\n          }\n        }\n      } else {\n        // variable byte[]\n        boolean success = false;\n        IndexOutput data = null;\n        IndexOutput index = null;\n        String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, Integer.toString(field.number), \"dat\");\n        String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name, Integer.toString(field.number), \"idx\");\n        try {\n          data = dir.createOutput(dataName, state.context);\n          index = dir.createOutput(indexName, state.context);\n          addVarStraightBytesField(field, data, index, values);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data, index);\n          } else {\n            IOUtils.closeWhileHandlingException(data, index);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {\n    // examine the values to determine best type to use\n    HashSet<BytesRef> uniqueValues = new HashSet<BytesRef>();\n    int minLength = Integer.MAX_VALUE;\n    int maxLength = Integer.MIN_VALUE;\n    for (BytesRef b : values) {\n      minLength = Math.min(minLength, b.length);\n      maxLength = Math.max(maxLength, b.length);\n      if (uniqueValues != null) {\n        if (uniqueValues.add(BytesRef.deepCopyOf(b))) {\n          if (uniqueValues.size() > 256) {\n            uniqueValues = null;\n          }\n        }\n      }\n    }\n    \n    int maxDoc = state.segmentInfo.getDocCount();\n    final boolean fixed = minLength == maxLength;\n    // nocommit\n    final boolean dedup = fixed && (uniqueValues != null && uniqueValues.size() * 2 < maxDoc);\n    \n    if (dedup) {\n      // we will deduplicate and deref values\n      boolean success = false;\n      IndexOutput data = null;\n      IndexOutput index = null;\n      String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, Integer.toString(field.number), \"dat\");\n      String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name, Integer.toString(field.number), \"idx\");\n      try {\n        data = dir.createOutput(dataName, state.context);\n        index = dir.createOutput(indexName, state.context);\n        if (fixed) {\n          addFixedDerefBytesField(field, data, index, values, minLength);\n        } else {\n          assert false; // nocommit\n        }\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(data, index);\n        } else {\n          IOUtils.closeWhileHandlingException(data, index);\n        }\n      }\n    } else {\n      // we dont deduplicate, just write values straight\n      if (fixed) {\n        // fixed byte[]\n        String fileName = IndexFileNames.segmentFileName(state.segmentInfo.name, Integer.toString(field.number), \"dat\");\n        IndexOutput data = dir.createOutput(fileName, state.context);\n        boolean success = false;\n        try {\n          addFixedStraightBytesField(field, data, values, minLength);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data);\n          } else {\n            IOUtils.closeWhileHandlingException(data);\n          }\n        }\n      } else {\n        // variable byte[]\n        boolean success = false;\n        IndexOutput data = null;\n        IndexOutput index = null;\n        String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, Integer.toString(field.number), \"dat\");\n        String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name, Integer.toString(field.number), \"idx\");\n        try {\n          data = dir.createOutput(dataName, state.context);\n          index = dir.createOutput(indexName, state.context);\n          addVarStraightBytesField(field, data, index, values);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data, index);\n          } else {\n            IOUtils.closeWhileHandlingException(data, index);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"10e89cbe24422ef92a37fc037a955728de2e12cf","date":1359053475,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesWriter#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesWriter#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","sourceNew":"  @Override\n  public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {\n    // examine the values to determine best type to use\n    HashSet<BytesRef> uniqueValues = new HashSet<BytesRef>();\n    int minLength = Integer.MAX_VALUE;\n    int maxLength = Integer.MIN_VALUE;\n    for (BytesRef b : values) {\n      minLength = Math.min(minLength, b.length);\n      maxLength = Math.max(maxLength, b.length);\n      if (uniqueValues != null) {\n        if (uniqueValues.add(BytesRef.deepCopyOf(b))) {\n          if (uniqueValues.size() > 256) {\n            uniqueValues = null;\n          }\n        }\n      }\n    }\n    \n    int maxDoc = state.segmentInfo.getDocCount();\n    final boolean fixed = minLength == maxLength;\n    final boolean dedup = uniqueValues != null && uniqueValues.size() * 2 < maxDoc;\n    \n    if (dedup) {\n      // we will deduplicate and deref values\n      boolean success = false;\n      IndexOutput data = null;\n      IndexOutput index = null;\n      String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n      String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n      try {\n        data = dir.createOutput(dataName, state.context);\n        index = dir.createOutput(indexName, state.context);\n        if (fixed) {\n          addFixedDerefBytesField(field, data, index, values, minLength);\n        } else {\n          addVarDerefBytesField(field, data, index, values);\n        }\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(data, index);\n        } else {\n          IOUtils.closeWhileHandlingException(data, index);\n        }\n      }\n    } else {\n      // we dont deduplicate, just write values straight\n      if (fixed) {\n        // fixed byte[]\n        String fileName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        IndexOutput data = dir.createOutput(fileName, state.context);\n        boolean success = false;\n        try {\n          addFixedStraightBytesField(field, data, values, minLength);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data);\n          } else {\n            IOUtils.closeWhileHandlingException(data);\n          }\n        }\n      } else {\n        // variable byte[]\n        boolean success = false;\n        IndexOutput data = null;\n        IndexOutput index = null;\n        String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n        try {\n          data = dir.createOutput(dataName, state.context);\n          index = dir.createOutput(indexName, state.context);\n          addVarStraightBytesField(field, data, index, values);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data, index);\n          } else {\n            IOUtils.closeWhileHandlingException(data, index);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {\n    // examine the values to determine best type to use\n    HashSet<BytesRef> uniqueValues = new HashSet<BytesRef>();\n    int minLength = Integer.MAX_VALUE;\n    int maxLength = Integer.MIN_VALUE;\n    for (BytesRef b : values) {\n      minLength = Math.min(minLength, b.length);\n      maxLength = Math.max(maxLength, b.length);\n      if (uniqueValues != null) {\n        if (uniqueValues.add(BytesRef.deepCopyOf(b))) {\n          if (uniqueValues.size() > 256) {\n            uniqueValues = null;\n          }\n        }\n      }\n    }\n    \n    int maxDoc = state.segmentInfo.getDocCount();\n    final boolean fixed = minLength == maxLength;\n    final boolean dedup = uniqueValues != null && uniqueValues.size() * 2 < maxDoc;\n    \n    if (dedup) {\n      // we will deduplicate and deref values\n      boolean success = false;\n      IndexOutput data = null;\n      IndexOutput index = null;\n      String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, Integer.toString(field.number), \"dat\");\n      String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name, Integer.toString(field.number), \"idx\");\n      try {\n        data = dir.createOutput(dataName, state.context);\n        index = dir.createOutput(indexName, state.context);\n        if (fixed) {\n          addFixedDerefBytesField(field, data, index, values, minLength);\n        } else {\n          addVarDerefBytesField(field, data, index, values);\n        }\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(data, index);\n        } else {\n          IOUtils.closeWhileHandlingException(data, index);\n        }\n      }\n    } else {\n      // we dont deduplicate, just write values straight\n      if (fixed) {\n        // fixed byte[]\n        String fileName = IndexFileNames.segmentFileName(state.segmentInfo.name, Integer.toString(field.number), \"dat\");\n        IndexOutput data = dir.createOutput(fileName, state.context);\n        boolean success = false;\n        try {\n          addFixedStraightBytesField(field, data, values, minLength);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data);\n          } else {\n            IOUtils.closeWhileHandlingException(data);\n          }\n        }\n      } else {\n        // variable byte[]\n        boolean success = false;\n        IndexOutput data = null;\n        IndexOutput index = null;\n        String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, Integer.toString(field.number), \"dat\");\n        String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name, Integer.toString(field.number), \"idx\");\n        try {\n          data = dir.createOutput(dataName, state.context);\n          index = dir.createOutput(indexName, state.context);\n          addVarStraightBytesField(field, data, index, values);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data, index);\n          } else {\n            IOUtils.closeWhileHandlingException(data, index);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesWriter#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {\n    // examine the values to determine best type to use\n    HashSet<BytesRef> uniqueValues = new HashSet<BytesRef>();\n    int minLength = Integer.MAX_VALUE;\n    int maxLength = Integer.MIN_VALUE;\n    for (BytesRef b : values) {\n      minLength = Math.min(minLength, b.length);\n      maxLength = Math.max(maxLength, b.length);\n      if (uniqueValues != null) {\n        if (uniqueValues.add(BytesRef.deepCopyOf(b))) {\n          if (uniqueValues.size() > 256) {\n            uniqueValues = null;\n          }\n        }\n      }\n    }\n    \n    int maxDoc = state.segmentInfo.getDocCount();\n    final boolean fixed = minLength == maxLength;\n    final boolean dedup = uniqueValues != null && uniqueValues.size() * 2 < maxDoc;\n    \n    if (dedup) {\n      // we will deduplicate and deref values\n      boolean success = false;\n      IndexOutput data = null;\n      IndexOutput index = null;\n      String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n      String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n      try {\n        data = dir.createOutput(dataName, state.context);\n        index = dir.createOutput(indexName, state.context);\n        if (fixed) {\n          addFixedDerefBytesField(field, data, index, values, minLength);\n        } else {\n          addVarDerefBytesField(field, data, index, values);\n        }\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(data, index);\n        } else {\n          IOUtils.closeWhileHandlingException(data, index);\n        }\n      }\n    } else {\n      // we dont deduplicate, just write values straight\n      if (fixed) {\n        // fixed byte[]\n        String fileName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        IndexOutput data = dir.createOutput(fileName, state.context);\n        boolean success = false;\n        try {\n          addFixedStraightBytesField(field, data, values, minLength);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data);\n          } else {\n            IOUtils.closeWhileHandlingException(data);\n          }\n        }\n      } else {\n        // variable byte[]\n        boolean success = false;\n        IndexOutput data = null;\n        IndexOutput index = null;\n        String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n        try {\n          data = dir.createOutput(dataName, state.context);\n          index = dir.createOutput(indexName, state.context);\n          addVarStraightBytesField(field, data, index, values);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data, index);\n          } else {\n            IOUtils.closeWhileHandlingException(data, index);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9faa42f41b6adb98daf009cf99a4ee239189e469","date":1376648738,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesWriter#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesWriter#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","sourceNew":"  @Override\n  public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {\n    // examine the values to determine best type to use\n    HashSet<BytesRef> uniqueValues = new HashSet<BytesRef>();\n    int minLength = Integer.MAX_VALUE;\n    int maxLength = Integer.MIN_VALUE;\n    for (BytesRef b : values) {\n      if (b == null) {\n        b = new BytesRef(); // 4.0 doesnt distinguish\n      }\n      minLength = Math.min(minLength, b.length);\n      maxLength = Math.max(maxLength, b.length);\n      if (uniqueValues != null) {\n        if (uniqueValues.add(BytesRef.deepCopyOf(b))) {\n          if (uniqueValues.size() > 256) {\n            uniqueValues = null;\n          }\n        }\n      }\n    }\n    \n    int maxDoc = state.segmentInfo.getDocCount();\n    final boolean fixed = minLength == maxLength;\n    final boolean dedup = uniqueValues != null && uniqueValues.size() * 2 < maxDoc;\n    \n    if (dedup) {\n      // we will deduplicate and deref values\n      boolean success = false;\n      IndexOutput data = null;\n      IndexOutput index = null;\n      String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n      String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n      try {\n        data = dir.createOutput(dataName, state.context);\n        index = dir.createOutput(indexName, state.context);\n        if (fixed) {\n          addFixedDerefBytesField(field, data, index, values, minLength);\n        } else {\n          addVarDerefBytesField(field, data, index, values);\n        }\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(data, index);\n        } else {\n          IOUtils.closeWhileHandlingException(data, index);\n        }\n      }\n    } else {\n      // we dont deduplicate, just write values straight\n      if (fixed) {\n        // fixed byte[]\n        String fileName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        IndexOutput data = dir.createOutput(fileName, state.context);\n        boolean success = false;\n        try {\n          addFixedStraightBytesField(field, data, values, minLength);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data);\n          } else {\n            IOUtils.closeWhileHandlingException(data);\n          }\n        }\n      } else {\n        // variable byte[]\n        boolean success = false;\n        IndexOutput data = null;\n        IndexOutput index = null;\n        String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n        try {\n          data = dir.createOutput(dataName, state.context);\n          index = dir.createOutput(indexName, state.context);\n          addVarStraightBytesField(field, data, index, values);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data, index);\n          } else {\n            IOUtils.closeWhileHandlingException(data, index);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {\n    // examine the values to determine best type to use\n    HashSet<BytesRef> uniqueValues = new HashSet<BytesRef>();\n    int minLength = Integer.MAX_VALUE;\n    int maxLength = Integer.MIN_VALUE;\n    for (BytesRef b : values) {\n      minLength = Math.min(minLength, b.length);\n      maxLength = Math.max(maxLength, b.length);\n      if (uniqueValues != null) {\n        if (uniqueValues.add(BytesRef.deepCopyOf(b))) {\n          if (uniqueValues.size() > 256) {\n            uniqueValues = null;\n          }\n        }\n      }\n    }\n    \n    int maxDoc = state.segmentInfo.getDocCount();\n    final boolean fixed = minLength == maxLength;\n    final boolean dedup = uniqueValues != null && uniqueValues.size() * 2 < maxDoc;\n    \n    if (dedup) {\n      // we will deduplicate and deref values\n      boolean success = false;\n      IndexOutput data = null;\n      IndexOutput index = null;\n      String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n      String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n      try {\n        data = dir.createOutput(dataName, state.context);\n        index = dir.createOutput(indexName, state.context);\n        if (fixed) {\n          addFixedDerefBytesField(field, data, index, values, minLength);\n        } else {\n          addVarDerefBytesField(field, data, index, values);\n        }\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(data, index);\n        } else {\n          IOUtils.closeWhileHandlingException(data, index);\n        }\n      }\n    } else {\n      // we dont deduplicate, just write values straight\n      if (fixed) {\n        // fixed byte[]\n        String fileName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        IndexOutput data = dir.createOutput(fileName, state.context);\n        boolean success = false;\n        try {\n          addFixedStraightBytesField(field, data, values, minLength);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data);\n          } else {\n            IOUtils.closeWhileHandlingException(data);\n          }\n        }\n      } else {\n        // variable byte[]\n        boolean success = false;\n        IndexOutput data = null;\n        IndexOutput index = null;\n        String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n        try {\n          data = dir.createOutput(dataName, state.context);\n          index = dir.createOutput(indexName, state.context);\n          addVarStraightBytesField(field, data, index, values);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data, index);\n          } else {\n            IOUtils.closeWhileHandlingException(data, index);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c024a3e8fec0a081cbf9539845db12f0dc84d029","date":1376654698,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesWriter#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesWriter#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","sourceNew":"  @Override\n  public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {\n    // examine the values to determine best type to use\n    HashSet<BytesRef> uniqueValues = new HashSet<BytesRef>();\n    int minLength = Integer.MAX_VALUE;\n    int maxLength = Integer.MIN_VALUE;\n    for (BytesRef b : values) {\n      if (b.length > Lucene40DocValuesFormat.MAX_BINARY_FIELD_LENGTH) {\n        throw new IllegalArgumentException(\"DocValuesField \\\"\" + field.name + \"\\\" is too large, must be <= \" + Lucene40DocValuesFormat.MAX_BINARY_FIELD_LENGTH);\n      }\n      minLength = Math.min(minLength, b.length);\n      maxLength = Math.max(maxLength, b.length);\n      if (uniqueValues != null) {\n        if (uniqueValues.add(BytesRef.deepCopyOf(b))) {\n          if (uniqueValues.size() > 256) {\n            uniqueValues = null;\n          }\n        }\n      }\n    }\n    \n    int maxDoc = state.segmentInfo.getDocCount();\n    final boolean fixed = minLength == maxLength;\n    final boolean dedup = uniqueValues != null && uniqueValues.size() * 2 < maxDoc;\n    \n    if (dedup) {\n      // we will deduplicate and deref values\n      boolean success = false;\n      IndexOutput data = null;\n      IndexOutput index = null;\n      String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n      String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n      try {\n        data = dir.createOutput(dataName, state.context);\n        index = dir.createOutput(indexName, state.context);\n        if (fixed) {\n          addFixedDerefBytesField(field, data, index, values, minLength);\n        } else {\n          addVarDerefBytesField(field, data, index, values);\n        }\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(data, index);\n        } else {\n          IOUtils.closeWhileHandlingException(data, index);\n        }\n      }\n    } else {\n      // we dont deduplicate, just write values straight\n      if (fixed) {\n        // fixed byte[]\n        String fileName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        IndexOutput data = dir.createOutput(fileName, state.context);\n        boolean success = false;\n        try {\n          addFixedStraightBytesField(field, data, values, minLength);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data);\n          } else {\n            IOUtils.closeWhileHandlingException(data);\n          }\n        }\n      } else {\n        // variable byte[]\n        boolean success = false;\n        IndexOutput data = null;\n        IndexOutput index = null;\n        String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n        try {\n          data = dir.createOutput(dataName, state.context);\n          index = dir.createOutput(indexName, state.context);\n          addVarStraightBytesField(field, data, index, values);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data, index);\n          } else {\n            IOUtils.closeWhileHandlingException(data, index);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {\n    // examine the values to determine best type to use\n    HashSet<BytesRef> uniqueValues = new HashSet<BytesRef>();\n    int minLength = Integer.MAX_VALUE;\n    int maxLength = Integer.MIN_VALUE;\n    for (BytesRef b : values) {\n      minLength = Math.min(minLength, b.length);\n      maxLength = Math.max(maxLength, b.length);\n      if (uniqueValues != null) {\n        if (uniqueValues.add(BytesRef.deepCopyOf(b))) {\n          if (uniqueValues.size() > 256) {\n            uniqueValues = null;\n          }\n        }\n      }\n    }\n    \n    int maxDoc = state.segmentInfo.getDocCount();\n    final boolean fixed = minLength == maxLength;\n    final boolean dedup = uniqueValues != null && uniqueValues.size() * 2 < maxDoc;\n    \n    if (dedup) {\n      // we will deduplicate and deref values\n      boolean success = false;\n      IndexOutput data = null;\n      IndexOutput index = null;\n      String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n      String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n      try {\n        data = dir.createOutput(dataName, state.context);\n        index = dir.createOutput(indexName, state.context);\n        if (fixed) {\n          addFixedDerefBytesField(field, data, index, values, minLength);\n        } else {\n          addVarDerefBytesField(field, data, index, values);\n        }\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(data, index);\n        } else {\n          IOUtils.closeWhileHandlingException(data, index);\n        }\n      }\n    } else {\n      // we dont deduplicate, just write values straight\n      if (fixed) {\n        // fixed byte[]\n        String fileName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        IndexOutput data = dir.createOutput(fileName, state.context);\n        boolean success = false;\n        try {\n          addFixedStraightBytesField(field, data, values, minLength);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data);\n          } else {\n            IOUtils.closeWhileHandlingException(data);\n          }\n        }\n      } else {\n        // variable byte[]\n        boolean success = false;\n        IndexOutput data = null;\n        IndexOutput index = null;\n        String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n        try {\n          data = dir.createOutput(dataName, state.context);\n          index = dir.createOutput(indexName, state.context);\n          addVarStraightBytesField(field, data, index, values);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data, index);\n          } else {\n            IOUtils.closeWhileHandlingException(data, index);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2ceca04c06658aeb20e0a319ade784ad9a0576dd","date":1376662287,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesWriter#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesWriter#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","sourceNew":"  @Override\n  public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {\n    // examine the values to determine best type to use\n    HashSet<BytesRef> uniqueValues = new HashSet<BytesRef>();\n    int minLength = Integer.MAX_VALUE;\n    int maxLength = Integer.MIN_VALUE;\n    for (BytesRef b : values) {\n      if (b == null) {\n        b = new BytesRef(); // 4.0 doesnt distinguish\n      }\n      if (b.length > Lucene40DocValuesFormat.MAX_BINARY_FIELD_LENGTH) {\n        throw new IllegalArgumentException(\"DocValuesField \\\"\" + field.name + \"\\\" is too large, must be <= \" + Lucene40DocValuesFormat.MAX_BINARY_FIELD_LENGTH);\n      }\n      minLength = Math.min(minLength, b.length);\n      maxLength = Math.max(maxLength, b.length);\n      if (uniqueValues != null) {\n        if (uniqueValues.add(BytesRef.deepCopyOf(b))) {\n          if (uniqueValues.size() > 256) {\n            uniqueValues = null;\n          }\n        }\n      }\n    }\n    \n    int maxDoc = state.segmentInfo.getDocCount();\n    final boolean fixed = minLength == maxLength;\n    final boolean dedup = uniqueValues != null && uniqueValues.size() * 2 < maxDoc;\n    \n    if (dedup) {\n      // we will deduplicate and deref values\n      boolean success = false;\n      IndexOutput data = null;\n      IndexOutput index = null;\n      String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n      String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n      try {\n        data = dir.createOutput(dataName, state.context);\n        index = dir.createOutput(indexName, state.context);\n        if (fixed) {\n          addFixedDerefBytesField(field, data, index, values, minLength);\n        } else {\n          addVarDerefBytesField(field, data, index, values);\n        }\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(data, index);\n        } else {\n          IOUtils.closeWhileHandlingException(data, index);\n        }\n      }\n    } else {\n      // we dont deduplicate, just write values straight\n      if (fixed) {\n        // fixed byte[]\n        String fileName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        IndexOutput data = dir.createOutput(fileName, state.context);\n        boolean success = false;\n        try {\n          addFixedStraightBytesField(field, data, values, minLength);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data);\n          } else {\n            IOUtils.closeWhileHandlingException(data);\n          }\n        }\n      } else {\n        // variable byte[]\n        boolean success = false;\n        IndexOutput data = null;\n        IndexOutput index = null;\n        String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n        try {\n          data = dir.createOutput(dataName, state.context);\n          index = dir.createOutput(indexName, state.context);\n          addVarStraightBytesField(field, data, index, values);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data, index);\n          } else {\n            IOUtils.closeWhileHandlingException(data, index);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {\n    // examine the values to determine best type to use\n    HashSet<BytesRef> uniqueValues = new HashSet<BytesRef>();\n    int minLength = Integer.MAX_VALUE;\n    int maxLength = Integer.MIN_VALUE;\n    for (BytesRef b : values) {\n      if (b == null) {\n        b = new BytesRef(); // 4.0 doesnt distinguish\n      }\n      minLength = Math.min(minLength, b.length);\n      maxLength = Math.max(maxLength, b.length);\n      if (uniqueValues != null) {\n        if (uniqueValues.add(BytesRef.deepCopyOf(b))) {\n          if (uniqueValues.size() > 256) {\n            uniqueValues = null;\n          }\n        }\n      }\n    }\n    \n    int maxDoc = state.segmentInfo.getDocCount();\n    final boolean fixed = minLength == maxLength;\n    final boolean dedup = uniqueValues != null && uniqueValues.size() * 2 < maxDoc;\n    \n    if (dedup) {\n      // we will deduplicate and deref values\n      boolean success = false;\n      IndexOutput data = null;\n      IndexOutput index = null;\n      String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n      String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n      try {\n        data = dir.createOutput(dataName, state.context);\n        index = dir.createOutput(indexName, state.context);\n        if (fixed) {\n          addFixedDerefBytesField(field, data, index, values, minLength);\n        } else {\n          addVarDerefBytesField(field, data, index, values);\n        }\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(data, index);\n        } else {\n          IOUtils.closeWhileHandlingException(data, index);\n        }\n      }\n    } else {\n      // we dont deduplicate, just write values straight\n      if (fixed) {\n        // fixed byte[]\n        String fileName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        IndexOutput data = dir.createOutput(fileName, state.context);\n        boolean success = false;\n        try {\n          addFixedStraightBytesField(field, data, values, minLength);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data);\n          } else {\n            IOUtils.closeWhileHandlingException(data);\n          }\n        }\n      } else {\n        // variable byte[]\n        boolean success = false;\n        IndexOutput data = null;\n        IndexOutput index = null;\n        String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n        try {\n          data = dir.createOutput(dataName, state.context);\n          index = dir.createOutput(indexName, state.context);\n          addVarStraightBytesField(field, data, index, values);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data, index);\n          } else {\n            IOUtils.closeWhileHandlingException(data, index);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff","date":1377034255,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesWriter#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesWriter#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","sourceNew":"  @Override\n  public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {\n    // examine the values to determine best type to use\n    HashSet<BytesRef> uniqueValues = new HashSet<BytesRef>();\n    int minLength = Integer.MAX_VALUE;\n    int maxLength = Integer.MIN_VALUE;\n    for (BytesRef b : values) {\n      if (b == null) {\n        b = new BytesRef(); // 4.0 doesnt distinguish\n      }\n      if (b.length > Lucene40DocValuesFormat.MAX_BINARY_FIELD_LENGTH) {\n        throw new IllegalArgumentException(\"DocValuesField \\\"\" + field.name + \"\\\" is too large, must be <= \" + Lucene40DocValuesFormat.MAX_BINARY_FIELD_LENGTH);\n      }\n      minLength = Math.min(minLength, b.length);\n      maxLength = Math.max(maxLength, b.length);\n      if (uniqueValues != null) {\n        if (uniqueValues.add(BytesRef.deepCopyOf(b))) {\n          if (uniqueValues.size() > 256) {\n            uniqueValues = null;\n          }\n        }\n      }\n    }\n    \n    int maxDoc = state.segmentInfo.getDocCount();\n    final boolean fixed = minLength == maxLength;\n    final boolean dedup = uniqueValues != null && uniqueValues.size() * 2 < maxDoc;\n    \n    if (dedup) {\n      // we will deduplicate and deref values\n      boolean success = false;\n      IndexOutput data = null;\n      IndexOutput index = null;\n      String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n      String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n      try {\n        data = dir.createOutput(dataName, state.context);\n        index = dir.createOutput(indexName, state.context);\n        if (fixed) {\n          addFixedDerefBytesField(field, data, index, values, minLength);\n        } else {\n          addVarDerefBytesField(field, data, index, values);\n        }\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(data, index);\n        } else {\n          IOUtils.closeWhileHandlingException(data, index);\n        }\n      }\n    } else {\n      // we dont deduplicate, just write values straight\n      if (fixed) {\n        // fixed byte[]\n        String fileName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        IndexOutput data = dir.createOutput(fileName, state.context);\n        boolean success = false;\n        try {\n          addFixedStraightBytesField(field, data, values, minLength);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data);\n          } else {\n            IOUtils.closeWhileHandlingException(data);\n          }\n        }\n      } else {\n        // variable byte[]\n        boolean success = false;\n        IndexOutput data = null;\n        IndexOutput index = null;\n        String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n        try {\n          data = dir.createOutput(dataName, state.context);\n          index = dir.createOutput(indexName, state.context);\n          addVarStraightBytesField(field, data, index, values);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data, index);\n          } else {\n            IOUtils.closeWhileHandlingException(data, index);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {\n    // examine the values to determine best type to use\n    HashSet<BytesRef> uniqueValues = new HashSet<BytesRef>();\n    int minLength = Integer.MAX_VALUE;\n    int maxLength = Integer.MIN_VALUE;\n    for (BytesRef b : values) {\n      if (b.length > Lucene40DocValuesFormat.MAX_BINARY_FIELD_LENGTH) {\n        throw new IllegalArgumentException(\"DocValuesField \\\"\" + field.name + \"\\\" is too large, must be <= \" + Lucene40DocValuesFormat.MAX_BINARY_FIELD_LENGTH);\n      }\n      minLength = Math.min(minLength, b.length);\n      maxLength = Math.max(maxLength, b.length);\n      if (uniqueValues != null) {\n        if (uniqueValues.add(BytesRef.deepCopyOf(b))) {\n          if (uniqueValues.size() > 256) {\n            uniqueValues = null;\n          }\n        }\n      }\n    }\n    \n    int maxDoc = state.segmentInfo.getDocCount();\n    final boolean fixed = minLength == maxLength;\n    final boolean dedup = uniqueValues != null && uniqueValues.size() * 2 < maxDoc;\n    \n    if (dedup) {\n      // we will deduplicate and deref values\n      boolean success = false;\n      IndexOutput data = null;\n      IndexOutput index = null;\n      String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n      String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n      try {\n        data = dir.createOutput(dataName, state.context);\n        index = dir.createOutput(indexName, state.context);\n        if (fixed) {\n          addFixedDerefBytesField(field, data, index, values, minLength);\n        } else {\n          addVarDerefBytesField(field, data, index, values);\n        }\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(data, index);\n        } else {\n          IOUtils.closeWhileHandlingException(data, index);\n        }\n      }\n    } else {\n      // we dont deduplicate, just write values straight\n      if (fixed) {\n        // fixed byte[]\n        String fileName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        IndexOutput data = dir.createOutput(fileName, state.context);\n        boolean success = false;\n        try {\n          addFixedStraightBytesField(field, data, values, minLength);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data);\n          } else {\n            IOUtils.closeWhileHandlingException(data);\n          }\n        }\n      } else {\n        // variable byte[]\n        boolean success = false;\n        IndexOutput data = null;\n        IndexOutput index = null;\n        String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n        try {\n          data = dir.createOutput(dataName, state.context);\n          index = dir.createOutput(indexName, state.context);\n          addVarStraightBytesField(field, data, index, values);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data, index);\n          } else {\n            IOUtils.closeWhileHandlingException(data, index);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesWriter#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesWriter#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","sourceNew":"  @Override\n  public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {\n    // examine the values to determine best type to use\n    HashSet<BytesRef> uniqueValues = new HashSet<BytesRef>();\n    int minLength = Integer.MAX_VALUE;\n    int maxLength = Integer.MIN_VALUE;\n    for (BytesRef b : values) {\n      if (b == null) {\n        b = new BytesRef(); // 4.0 doesnt distinguish\n      }\n      if (b.length > Lucene40DocValuesFormat.MAX_BINARY_FIELD_LENGTH) {\n        throw new IllegalArgumentException(\"DocValuesField \\\"\" + field.name + \"\\\" is too large, must be <= \" + Lucene40DocValuesFormat.MAX_BINARY_FIELD_LENGTH);\n      }\n      minLength = Math.min(minLength, b.length);\n      maxLength = Math.max(maxLength, b.length);\n      if (uniqueValues != null) {\n        if (uniqueValues.add(BytesRef.deepCopyOf(b))) {\n          if (uniqueValues.size() > 256) {\n            uniqueValues = null;\n          }\n        }\n      }\n    }\n    \n    int maxDoc = state.segmentInfo.getDocCount();\n    final boolean fixed = minLength == maxLength;\n    final boolean dedup = uniqueValues != null && uniqueValues.size() * 2 < maxDoc;\n    \n    if (dedup) {\n      // we will deduplicate and deref values\n      boolean success = false;\n      IndexOutput data = null;\n      IndexOutput index = null;\n      String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n      String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n      try {\n        data = dir.createOutput(dataName, state.context);\n        index = dir.createOutput(indexName, state.context);\n        if (fixed) {\n          addFixedDerefBytesField(field, data, index, values, minLength);\n        } else {\n          addVarDerefBytesField(field, data, index, values);\n        }\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(data, index);\n        } else {\n          IOUtils.closeWhileHandlingException(data, index);\n        }\n      }\n    } else {\n      // we dont deduplicate, just write values straight\n      if (fixed) {\n        // fixed byte[]\n        String fileName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        IndexOutput data = dir.createOutput(fileName, state.context);\n        boolean success = false;\n        try {\n          addFixedStraightBytesField(field, data, values, minLength);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data);\n          } else {\n            IOUtils.closeWhileHandlingException(data);\n          }\n        }\n      } else {\n        // variable byte[]\n        boolean success = false;\n        IndexOutput data = null;\n        IndexOutput index = null;\n        String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n        try {\n          data = dir.createOutput(dataName, state.context);\n          index = dir.createOutput(indexName, state.context);\n          addVarStraightBytesField(field, data, index, values);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data, index);\n          } else {\n            IOUtils.closeWhileHandlingException(data, index);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {\n    // examine the values to determine best type to use\n    HashSet<BytesRef> uniqueValues = new HashSet<BytesRef>();\n    int minLength = Integer.MAX_VALUE;\n    int maxLength = Integer.MIN_VALUE;\n    for (BytesRef b : values) {\n      minLength = Math.min(minLength, b.length);\n      maxLength = Math.max(maxLength, b.length);\n      if (uniqueValues != null) {\n        if (uniqueValues.add(BytesRef.deepCopyOf(b))) {\n          if (uniqueValues.size() > 256) {\n            uniqueValues = null;\n          }\n        }\n      }\n    }\n    \n    int maxDoc = state.segmentInfo.getDocCount();\n    final boolean fixed = minLength == maxLength;\n    final boolean dedup = uniqueValues != null && uniqueValues.size() * 2 < maxDoc;\n    \n    if (dedup) {\n      // we will deduplicate and deref values\n      boolean success = false;\n      IndexOutput data = null;\n      IndexOutput index = null;\n      String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n      String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n      try {\n        data = dir.createOutput(dataName, state.context);\n        index = dir.createOutput(indexName, state.context);\n        if (fixed) {\n          addFixedDerefBytesField(field, data, index, values, minLength);\n        } else {\n          addVarDerefBytesField(field, data, index, values);\n        }\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(data, index);\n        } else {\n          IOUtils.closeWhileHandlingException(data, index);\n        }\n      }\n    } else {\n      // we dont deduplicate, just write values straight\n      if (fixed) {\n        // fixed byte[]\n        String fileName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        IndexOutput data = dir.createOutput(fileName, state.context);\n        boolean success = false;\n        try {\n          addFixedStraightBytesField(field, data, values, minLength);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data);\n          } else {\n            IOUtils.closeWhileHandlingException(data);\n          }\n        }\n      } else {\n        // variable byte[]\n        boolean success = false;\n        IndexOutput data = null;\n        IndexOutput index = null;\n        String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n        try {\n          data = dir.createOutput(dataName, state.context);\n          index = dir.createOutput(indexName, state.context);\n          addVarStraightBytesField(field, data, index, values);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data, index);\n          } else {\n            IOUtils.closeWhileHandlingException(data, index);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesWriter#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesWriter#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","sourceNew":"  @Override\n  public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {\n    // examine the values to determine best type to use\n    HashSet<BytesRef> uniqueValues = new HashSet<>();\n    int minLength = Integer.MAX_VALUE;\n    int maxLength = Integer.MIN_VALUE;\n    for (BytesRef b : values) {\n      if (b == null) {\n        b = new BytesRef(); // 4.0 doesnt distinguish\n      }\n      if (b.length > Lucene40DocValuesFormat.MAX_BINARY_FIELD_LENGTH) {\n        throw new IllegalArgumentException(\"DocValuesField \\\"\" + field.name + \"\\\" is too large, must be <= \" + Lucene40DocValuesFormat.MAX_BINARY_FIELD_LENGTH);\n      }\n      minLength = Math.min(minLength, b.length);\n      maxLength = Math.max(maxLength, b.length);\n      if (uniqueValues != null) {\n        if (uniqueValues.add(BytesRef.deepCopyOf(b))) {\n          if (uniqueValues.size() > 256) {\n            uniqueValues = null;\n          }\n        }\n      }\n    }\n    \n    int maxDoc = state.segmentInfo.getDocCount();\n    final boolean fixed = minLength == maxLength;\n    final boolean dedup = uniqueValues != null && uniqueValues.size() * 2 < maxDoc;\n    \n    if (dedup) {\n      // we will deduplicate and deref values\n      boolean success = false;\n      IndexOutput data = null;\n      IndexOutput index = null;\n      String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n      String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n      try {\n        data = dir.createOutput(dataName, state.context);\n        index = dir.createOutput(indexName, state.context);\n        if (fixed) {\n          addFixedDerefBytesField(field, data, index, values, minLength);\n        } else {\n          addVarDerefBytesField(field, data, index, values);\n        }\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(data, index);\n        } else {\n          IOUtils.closeWhileHandlingException(data, index);\n        }\n      }\n    } else {\n      // we dont deduplicate, just write values straight\n      if (fixed) {\n        // fixed byte[]\n        String fileName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        IndexOutput data = dir.createOutput(fileName, state.context);\n        boolean success = false;\n        try {\n          addFixedStraightBytesField(field, data, values, minLength);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data);\n          } else {\n            IOUtils.closeWhileHandlingException(data);\n          }\n        }\n      } else {\n        // variable byte[]\n        boolean success = false;\n        IndexOutput data = null;\n        IndexOutput index = null;\n        String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n        try {\n          data = dir.createOutput(dataName, state.context);\n          index = dir.createOutput(indexName, state.context);\n          addVarStraightBytesField(field, data, index, values);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data, index);\n          } else {\n            IOUtils.closeWhileHandlingException(data, index);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {\n    // examine the values to determine best type to use\n    HashSet<BytesRef> uniqueValues = new HashSet<BytesRef>();\n    int minLength = Integer.MAX_VALUE;\n    int maxLength = Integer.MIN_VALUE;\n    for (BytesRef b : values) {\n      if (b == null) {\n        b = new BytesRef(); // 4.0 doesnt distinguish\n      }\n      if (b.length > Lucene40DocValuesFormat.MAX_BINARY_FIELD_LENGTH) {\n        throw new IllegalArgumentException(\"DocValuesField \\\"\" + field.name + \"\\\" is too large, must be <= \" + Lucene40DocValuesFormat.MAX_BINARY_FIELD_LENGTH);\n      }\n      minLength = Math.min(minLength, b.length);\n      maxLength = Math.max(maxLength, b.length);\n      if (uniqueValues != null) {\n        if (uniqueValues.add(BytesRef.deepCopyOf(b))) {\n          if (uniqueValues.size() > 256) {\n            uniqueValues = null;\n          }\n        }\n      }\n    }\n    \n    int maxDoc = state.segmentInfo.getDocCount();\n    final boolean fixed = minLength == maxLength;\n    final boolean dedup = uniqueValues != null && uniqueValues.size() * 2 < maxDoc;\n    \n    if (dedup) {\n      // we will deduplicate and deref values\n      boolean success = false;\n      IndexOutput data = null;\n      IndexOutput index = null;\n      String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n      String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n      try {\n        data = dir.createOutput(dataName, state.context);\n        index = dir.createOutput(indexName, state.context);\n        if (fixed) {\n          addFixedDerefBytesField(field, data, index, values, minLength);\n        } else {\n          addVarDerefBytesField(field, data, index, values);\n        }\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(data, index);\n        } else {\n          IOUtils.closeWhileHandlingException(data, index);\n        }\n      }\n    } else {\n      // we dont deduplicate, just write values straight\n      if (fixed) {\n        // fixed byte[]\n        String fileName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        IndexOutput data = dir.createOutput(fileName, state.context);\n        boolean success = false;\n        try {\n          addFixedStraightBytesField(field, data, values, minLength);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data);\n          } else {\n            IOUtils.closeWhileHandlingException(data);\n          }\n        }\n      } else {\n        // variable byte[]\n        boolean success = false;\n        IndexOutput data = null;\n        IndexOutput index = null;\n        String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n        try {\n          data = dir.createOutput(dataName, state.context);\n          index = dir.createOutput(indexName, state.context);\n          addVarStraightBytesField(field, data, index, values);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data, index);\n          } else {\n            IOUtils.closeWhileHandlingException(data, index);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cc45c615dbb82bf79d5f9550286098367874fbf","date":1409571423,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene40/Lucene40DocValuesWriter#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesWriter#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","sourceNew":"  @Override\n  public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {\n    // examine the values to determine best type to use\n    HashSet<BytesRef> uniqueValues = new HashSet<>();\n    int minLength = Integer.MAX_VALUE;\n    int maxLength = Integer.MIN_VALUE;\n    for (BytesRef b : values) {\n      if (b == null) {\n        b = new BytesRef(); // 4.0 doesnt distinguish\n      }\n      if (b.length > Lucene40DocValuesFormat.MAX_BINARY_FIELD_LENGTH) {\n        throw new IllegalArgumentException(\"DocValuesField \\\"\" + field.name + \"\\\" is too large, must be <= \" + Lucene40DocValuesFormat.MAX_BINARY_FIELD_LENGTH);\n      }\n      minLength = Math.min(minLength, b.length);\n      maxLength = Math.max(maxLength, b.length);\n      if (uniqueValues != null) {\n        if (uniqueValues.add(BytesRef.deepCopyOf(b))) {\n          if (uniqueValues.size() > 256) {\n            uniqueValues = null;\n          }\n        }\n      }\n    }\n    \n    int maxDoc = state.segmentInfo.getDocCount();\n    final boolean fixed = minLength == maxLength;\n    final boolean dedup = uniqueValues != null && uniqueValues.size() * 2 < maxDoc;\n    \n    if (dedup) {\n      // we will deduplicate and deref values\n      boolean success = false;\n      IndexOutput data = null;\n      IndexOutput index = null;\n      String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n      String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n      try {\n        data = dir.createOutput(dataName, state.context);\n        index = dir.createOutput(indexName, state.context);\n        if (fixed) {\n          addFixedDerefBytesField(field, data, index, values, minLength);\n        } else {\n          addVarDerefBytesField(field, data, index, values);\n        }\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(data, index);\n        } else {\n          IOUtils.closeWhileHandlingException(data, index);\n        }\n      }\n    } else {\n      // we dont deduplicate, just write values straight\n      if (fixed) {\n        // fixed byte[]\n        String fileName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        IndexOutput data = dir.createOutput(fileName, state.context);\n        boolean success = false;\n        try {\n          addFixedStraightBytesField(field, data, values, minLength);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data);\n          } else {\n            IOUtils.closeWhileHandlingException(data);\n          }\n        }\n      } else {\n        // variable byte[]\n        boolean success = false;\n        IndexOutput data = null;\n        IndexOutput index = null;\n        String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n        try {\n          data = dir.createOutput(dataName, state.context);\n          index = dir.createOutput(indexName, state.context);\n          addVarStraightBytesField(field, data, index, values);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data, index);\n          } else {\n            IOUtils.closeWhileHandlingException(data, index);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {\n    // examine the values to determine best type to use\n    HashSet<BytesRef> uniqueValues = new HashSet<>();\n    int minLength = Integer.MAX_VALUE;\n    int maxLength = Integer.MIN_VALUE;\n    for (BytesRef b : values) {\n      if (b == null) {\n        b = new BytesRef(); // 4.0 doesnt distinguish\n      }\n      if (b.length > Lucene40DocValuesFormat.MAX_BINARY_FIELD_LENGTH) {\n        throw new IllegalArgumentException(\"DocValuesField \\\"\" + field.name + \"\\\" is too large, must be <= \" + Lucene40DocValuesFormat.MAX_BINARY_FIELD_LENGTH);\n      }\n      minLength = Math.min(minLength, b.length);\n      maxLength = Math.max(maxLength, b.length);\n      if (uniqueValues != null) {\n        if (uniqueValues.add(BytesRef.deepCopyOf(b))) {\n          if (uniqueValues.size() > 256) {\n            uniqueValues = null;\n          }\n        }\n      }\n    }\n    \n    int maxDoc = state.segmentInfo.getDocCount();\n    final boolean fixed = minLength == maxLength;\n    final boolean dedup = uniqueValues != null && uniqueValues.size() * 2 < maxDoc;\n    \n    if (dedup) {\n      // we will deduplicate and deref values\n      boolean success = false;\n      IndexOutput data = null;\n      IndexOutput index = null;\n      String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n      String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n      try {\n        data = dir.createOutput(dataName, state.context);\n        index = dir.createOutput(indexName, state.context);\n        if (fixed) {\n          addFixedDerefBytesField(field, data, index, values, minLength);\n        } else {\n          addVarDerefBytesField(field, data, index, values);\n        }\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(data, index);\n        } else {\n          IOUtils.closeWhileHandlingException(data, index);\n        }\n      }\n    } else {\n      // we dont deduplicate, just write values straight\n      if (fixed) {\n        // fixed byte[]\n        String fileName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        IndexOutput data = dir.createOutput(fileName, state.context);\n        boolean success = false;\n        try {\n          addFixedStraightBytesField(field, data, values, minLength);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data);\n          } else {\n            IOUtils.closeWhileHandlingException(data);\n          }\n        }\n      } else {\n        // variable byte[]\n        boolean success = false;\n        IndexOutput data = null;\n        IndexOutput index = null;\n        String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n        try {\n          data = dir.createOutput(dataName, state.context);\n          index = dir.createOutput(indexName, state.context);\n          addVarStraightBytesField(field, data, index, values);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data, index);\n          } else {\n            IOUtils.closeWhileHandlingException(data, index);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"402ad3ddc9da7b70da1b167667a60ece6a1381fb","date":1409656478,"type":5,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene40/Lucene40DocValuesWriter#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesWriter#addBinaryField(FieldInfo,Iterable[BytesRef]).mjava","sourceNew":"  @Override\n  public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {\n    if (field.getDocValuesGen() != -1) {\n      throw new UnsupportedOperationException(\"4.0 does not support dv updates\");\n    }\n    // examine the values to determine best type to use\n    HashSet<BytesRef> uniqueValues = new HashSet<>();\n    int minLength = Integer.MAX_VALUE;\n    int maxLength = Integer.MIN_VALUE;\n    for (BytesRef b : values) {\n      if (b == null) {\n        b = new BytesRef(); // 4.0 doesnt distinguish\n      }\n      if (b.length > Lucene40DocValuesFormat.MAX_BINARY_FIELD_LENGTH) {\n        throw new IllegalArgumentException(\"DocValuesField \\\"\" + field.name + \"\\\" is too large, must be <= \" + Lucene40DocValuesFormat.MAX_BINARY_FIELD_LENGTH);\n      }\n      minLength = Math.min(minLength, b.length);\n      maxLength = Math.max(maxLength, b.length);\n      if (uniqueValues != null) {\n        if (uniqueValues.add(BytesRef.deepCopyOf(b))) {\n          if (uniqueValues.size() > 256) {\n            uniqueValues = null;\n          }\n        }\n      }\n    }\n    \n    int maxDoc = state.segmentInfo.getDocCount();\n    final boolean fixed = minLength == maxLength;\n    final boolean dedup = uniqueValues != null && uniqueValues.size() * 2 < maxDoc;\n    \n    if (dedup) {\n      // we will deduplicate and deref values\n      boolean success = false;\n      IndexOutput data = null;\n      IndexOutput index = null;\n      String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n      String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n      try {\n        data = dir.createOutput(dataName, state.context);\n        index = dir.createOutput(indexName, state.context);\n        if (fixed) {\n          addFixedDerefBytesField(field, data, index, values, minLength);\n        } else {\n          addVarDerefBytesField(field, data, index, values);\n        }\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(data, index);\n        } else {\n          IOUtils.closeWhileHandlingException(data, index);\n        }\n      }\n    } else {\n      // we dont deduplicate, just write values straight\n      if (fixed) {\n        // fixed byte[]\n        String fileName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        IndexOutput data = dir.createOutput(fileName, state.context);\n        boolean success = false;\n        try {\n          addFixedStraightBytesField(field, data, values, minLength);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data);\n          } else {\n            IOUtils.closeWhileHandlingException(data);\n          }\n        }\n      } else {\n        // variable byte[]\n        boolean success = false;\n        IndexOutput data = null;\n        IndexOutput index = null;\n        String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n        try {\n          data = dir.createOutput(dataName, state.context);\n          index = dir.createOutput(indexName, state.context);\n          addVarStraightBytesField(field, data, index, values);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data, index);\n          } else {\n            IOUtils.closeWhileHandlingException(data, index);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {\n    // examine the values to determine best type to use\n    HashSet<BytesRef> uniqueValues = new HashSet<>();\n    int minLength = Integer.MAX_VALUE;\n    int maxLength = Integer.MIN_VALUE;\n    for (BytesRef b : values) {\n      if (b == null) {\n        b = new BytesRef(); // 4.0 doesnt distinguish\n      }\n      if (b.length > Lucene40DocValuesFormat.MAX_BINARY_FIELD_LENGTH) {\n        throw new IllegalArgumentException(\"DocValuesField \\\"\" + field.name + \"\\\" is too large, must be <= \" + Lucene40DocValuesFormat.MAX_BINARY_FIELD_LENGTH);\n      }\n      minLength = Math.min(minLength, b.length);\n      maxLength = Math.max(maxLength, b.length);\n      if (uniqueValues != null) {\n        if (uniqueValues.add(BytesRef.deepCopyOf(b))) {\n          if (uniqueValues.size() > 256) {\n            uniqueValues = null;\n          }\n        }\n      }\n    }\n    \n    int maxDoc = state.segmentInfo.getDocCount();\n    final boolean fixed = minLength == maxLength;\n    final boolean dedup = uniqueValues != null && uniqueValues.size() * 2 < maxDoc;\n    \n    if (dedup) {\n      // we will deduplicate and deref values\n      boolean success = false;\n      IndexOutput data = null;\n      IndexOutput index = null;\n      String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n      String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n      try {\n        data = dir.createOutput(dataName, state.context);\n        index = dir.createOutput(indexName, state.context);\n        if (fixed) {\n          addFixedDerefBytesField(field, data, index, values, minLength);\n        } else {\n          addVarDerefBytesField(field, data, index, values);\n        }\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(data, index);\n        } else {\n          IOUtils.closeWhileHandlingException(data, index);\n        }\n      }\n    } else {\n      // we dont deduplicate, just write values straight\n      if (fixed) {\n        // fixed byte[]\n        String fileName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        IndexOutput data = dir.createOutput(fileName, state.context);\n        boolean success = false;\n        try {\n          addFixedStraightBytesField(field, data, values, minLength);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data);\n          } else {\n            IOUtils.closeWhileHandlingException(data);\n          }\n        }\n      } else {\n        // variable byte[]\n        boolean success = false;\n        IndexOutput data = null;\n        IndexOutput index = null;\n        String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"dat\");\n        String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + \"_\" + Integer.toString(field.number), segmentSuffix, \"idx\");\n        try {\n          data = dir.createOutput(dataName, state.context);\n          index = dir.createOutput(indexName, state.context);\n          addVarStraightBytesField(field, data, index, values);\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(data, index);\n          } else {\n            IOUtils.closeWhileHandlingException(data, index);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"db5a3aeba34624ea274f34df5691d40ca25f2b67":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"9faa42f41b6adb98daf009cf99a4ee239189e469":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"769aa5c7a844c7615167d4fc9352373d85eef21e":["0ef85d40fcb2c5bb7ec40780b12e543600a1ae38"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["d4d69c535930b5cce125cff868d40f6373dc27d4","e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"1ba10bcc2b7d89f38b6f4629475638edca1a2994":["769aa5c7a844c7615167d4fc9352373d85eef21e"],"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff":["c024a3e8fec0a081cbf9539845db12f0dc84d029","2ceca04c06658aeb20e0a319ade784ad9a0576dd"],"1982459c2ac4916bf3c0644b801f0cb3e4ee159f":["db5a3aeba34624ea274f34df5691d40ca25f2b67"],"2ceca04c06658aeb20e0a319ade784ad9a0576dd":["9faa42f41b6adb98daf009cf99a4ee239189e469","c024a3e8fec0a081cbf9539845db12f0dc84d029"],"10e89cbe24422ef92a37fc037a955728de2e12cf":["1ba10bcc2b7d89f38b6f4629475638edca1a2994"],"402ad3ddc9da7b70da1b167667a60ece6a1381fb":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","4cc45c615dbb82bf79d5f9550286098367874fbf"],"0ef85d40fcb2c5bb7ec40780b12e543600a1ae38":["1982459c2ac4916bf3c0644b801f0cb3e4ee159f"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","10e89cbe24422ef92a37fc037a955728de2e12cf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4cc45c615dbb82bf79d5f9550286098367874fbf":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"c024a3e8fec0a081cbf9539845db12f0dc84d029":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["402ad3ddc9da7b70da1b167667a60ece6a1381fb"]},"commit2Childs":{"db5a3aeba34624ea274f34df5691d40ca25f2b67":["1982459c2ac4916bf3c0644b801f0cb3e4ee159f"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["402ad3ddc9da7b70da1b167667a60ece6a1381fb","4cc45c615dbb82bf79d5f9550286098367874fbf"],"9faa42f41b6adb98daf009cf99a4ee239189e469":["2ceca04c06658aeb20e0a319ade784ad9a0576dd"],"769aa5c7a844c7615167d4fc9352373d85eef21e":["1ba10bcc2b7d89f38b6f4629475638edca1a2994"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"1ba10bcc2b7d89f38b6f4629475638edca1a2994":["10e89cbe24422ef92a37fc037a955728de2e12cf"],"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","3dffec77fb8f7d0e9ca4869dddd6af94528b4576"],"1982459c2ac4916bf3c0644b801f0cb3e4ee159f":["0ef85d40fcb2c5bb7ec40780b12e543600a1ae38"],"2ceca04c06658aeb20e0a319ade784ad9a0576dd":["e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"10e89cbe24422ef92a37fc037a955728de2e12cf":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"402ad3ddc9da7b70da1b167667a60ece6a1381fb":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0ef85d40fcb2c5bb7ec40780b12e543600a1ae38":["769aa5c7a844c7615167d4fc9352373d85eef21e"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["9faa42f41b6adb98daf009cf99a4ee239189e469","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","c024a3e8fec0a081cbf9539845db12f0dc84d029"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["db5a3aeba34624ea274f34df5691d40ca25f2b67","d4d69c535930b5cce125cff868d40f6373dc27d4"],"4cc45c615dbb82bf79d5f9550286098367874fbf":["402ad3ddc9da7b70da1b167667a60ece6a1381fb"],"c024a3e8fec0a081cbf9539845db12f0dc84d029":["e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff","2ceca04c06658aeb20e0a319ade784ad9a0576dd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}