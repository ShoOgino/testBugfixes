{"path":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#collect(int).mjava","commits":[{"id":"fb02351ae2b114dd41585916d1e35fb2cff98fb0","date":1337171337,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#collect(int).mjava","pathOld":"/dev/null","sourceNew":"    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    @Override\n    public void collect(int doc) throws IOException {\n      totalHits++;\n\n      //System.out.println(\"  collect doc=\" + doc);\n\n      // Check if this hit was already collected on a\n      // previous page:\n      boolean sameValues = true;\n      for(int compIDX=0;compIDX<comparators.length;compIDX++) {\n        final FieldComparator comp = comparators[compIDX];\n\n        final int cmp = reverseMul[compIDX] * comp.compareDocToValue(doc, after.fields[compIDX]);\n        if (cmp < 0) {\n          // Already collected on a previous page\n          //System.out.println(\"    skip: before\");\n          return;\n        } else if (cmp > 0) {\n          // Not yet collected\n          sameValues = false;\n          //System.out.println(\"    keep: after\");\n          break;\n        }\n      }\n\n      // Tie-break by docID:\n      if (sameValues && doc <= afterDoc) {\n        // Already collected on a previous page\n        //System.out.println(\"    skip: tie-break\");\n        return;\n      }\n\n      collectedHits++;\n\n      float score = Float.NaN;\n      if (trackMaxScore) {\n        score = scorer.score();\n        if (score > maxScore) {\n          maxScore = score;\n        }\n      }\n\n      if (queueFull) {\n        // Fastmatch: return if this hit is not competitive\n        for (int i = 0;; i++) {\n          final int c = reverseMul[i] * comparators[i].compareBottom(doc);\n          if (c < 0) {\n            // Definitely not competitive.\n            return;\n          } else if (c > 0) {\n            // Definitely competitive.\n            break;\n          } else if (i == comparators.length - 1) {\n            // This is the equals case.\n            if (doc + docBase > bottom.doc) {\n              // Definitely not competitive\n              return;\n            }\n            break;\n          }\n        }\n\n        // This hit is competitive - replace bottom element in queue & adjustTop\n        for (int i = 0; i < comparators.length; i++) {\n          comparators[i].copy(bottom.slot, doc);\n        }\n\n        // Compute score only if it is competitive.\n        if (trackDocScores && !trackMaxScore) {\n          score = scorer.score();\n        }\n        updateBottom(doc, score);\n\n        for (int i = 0; i < comparators.length; i++) {\n          comparators[i].setBottom(bottom.slot);\n        }\n      } else {\n        // Startup transient: queue hasn't gathered numHits yet\n        final int slot = collectedHits - 1;\n        //System.out.println(\"    slot=\" + slot);\n        // Copy hit into queue\n        for (int i = 0; i < comparators.length; i++) {\n          comparators[i].copy(slot, doc);\n        }\n\n        // Compute score only if it is competitive.\n        if (trackDocScores && !trackMaxScore) {\n          score = scorer.score();\n        }\n        bottom = pq.add(new Entry(slot, docBase + doc, score));\n        queueFull = collectedHits == numHits;\n        if (queueFull) {\n          for (int i = 0; i < comparators.length; i++) {\n            comparators[i].setBottom(bottom.slot);\n          }\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ef0d8a69209261514c5739c770bba706c2308450","date":1337607597,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#collect(int).mjava","pathOld":"/dev/null","sourceNew":"    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    @Override\n    public void collect(int doc) throws IOException {\n      totalHits++;\n\n      //System.out.println(\"  collect doc=\" + doc);\n\n      // Check if this hit was already collected on a\n      // previous page:\n      boolean sameValues = true;\n      for(int compIDX=0;compIDX<comparators.length;compIDX++) {\n        final FieldComparator comp = comparators[compIDX];\n\n        final int cmp = reverseMul[compIDX] * comp.compareDocToValue(doc, after.fields[compIDX]);\n        if (cmp < 0) {\n          // Already collected on a previous page\n          //System.out.println(\"    skip: before\");\n          return;\n        } else if (cmp > 0) {\n          // Not yet collected\n          sameValues = false;\n          //System.out.println(\"    keep: after\");\n          break;\n        }\n      }\n\n      // Tie-break by docID:\n      if (sameValues && doc <= afterDoc) {\n        // Already collected on a previous page\n        //System.out.println(\"    skip: tie-break\");\n        return;\n      }\n\n      collectedHits++;\n\n      float score = Float.NaN;\n      if (trackMaxScore) {\n        score = scorer.score();\n        if (score > maxScore) {\n          maxScore = score;\n        }\n      }\n\n      if (queueFull) {\n        // Fastmatch: return if this hit is not competitive\n        for (int i = 0;; i++) {\n          final int c = reverseMul[i] * comparators[i].compareBottom(doc);\n          if (c < 0) {\n            // Definitely not competitive.\n            return;\n          } else if (c > 0) {\n            // Definitely competitive.\n            break;\n          } else if (i == comparators.length - 1) {\n            // This is the equals case.\n            if (doc + docBase > bottom.doc) {\n              // Definitely not competitive\n              return;\n            }\n            break;\n          }\n        }\n\n        // This hit is competitive - replace bottom element in queue & adjustTop\n        for (int i = 0; i < comparators.length; i++) {\n          comparators[i].copy(bottom.slot, doc);\n        }\n\n        // Compute score only if it is competitive.\n        if (trackDocScores && !trackMaxScore) {\n          score = scorer.score();\n        }\n        updateBottom(doc, score);\n\n        for (int i = 0; i < comparators.length; i++) {\n          comparators[i].setBottom(bottom.slot);\n        }\n      } else {\n        // Startup transient: queue hasn't gathered numHits yet\n        final int slot = collectedHits - 1;\n        //System.out.println(\"    slot=\" + slot);\n        // Copy hit into queue\n        for (int i = 0; i < comparators.length; i++) {\n          comparators[i].copy(slot, doc);\n        }\n\n        // Compute score only if it is competitive.\n        if (trackDocScores && !trackMaxScore) {\n          score = scorer.score();\n        }\n        bottom = pq.add(new Entry(slot, docBase + doc, score));\n        queueFull = collectedHits == numHits;\n        if (queueFull) {\n          for (int i = 0; i < comparators.length; i++) {\n            comparators[i].setBottom(bottom.slot);\n          }\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7615b855702e008d91a95a2578bf05d27372f599","date":1389802891,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#collect(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#collect(int).mjava","sourceNew":"    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    @Override\n    public void collect(int doc) throws IOException {\n      totalHits++;\n\n      float score = Float.NaN;\n      if (trackMaxScore) {\n        score = scorer.score();\n        if (score > maxScore) {\n          maxScore = score;\n        }\n      }\n\n      if (queueFull) {\n        // Fastmatch: return if this hit is no better than\n        // the worst hit currently in the queue:\n        for (int i = 0;; i++) {\n          final int c = reverseMul[i] * comparators[i].compareBottom(doc);\n          if (c < 0) {\n            // Definitely not competitive.\n            return;\n          } else if (c > 0) {\n            // Definitely competitive.\n            break;\n          } else if (i == comparators.length - 1) {\n            // This is the equals case.\n            if (doc + docBase > bottom.doc) {\n              // Definitely not competitive\n              return;\n            }\n            break;\n          }\n        }\n      }\n\n      //System.out.println(\"  collect doc=\" + doc);\n\n      // Check if this hit was already collected on a\n      // previous page:\n      boolean sameValues = true;\n      for(int compIDX=0;compIDX<comparators.length;compIDX++) {\n        final FieldComparator comp = comparators[compIDX];\n\n        final int cmp = reverseMul[compIDX] * comp.compareTop(doc);\n        if (cmp > 0) {\n          // Already collected on a previous page\n          //System.out.println(\"    skip: before\");\n          return;\n        } else if (cmp < 0) {\n          // Not yet collected\n          sameValues = false;\n          //System.out.println(\"    keep: after\");\n          break;\n        }\n      }\n\n      // Tie-break by docID:\n      if (sameValues && doc <= afterDoc) {\n        // Already collected on a previous page\n        //System.out.println(\"    skip: tie-break\");\n        return;\n      }\n\n      if (queueFull) {\n        // This hit is competitive - replace bottom element in queue & adjustTop\n        for (int i = 0; i < comparators.length; i++) {\n          comparators[i].copy(bottom.slot, doc);\n        }\n\n        // Compute score only if it is competitive.\n        if (trackDocScores && !trackMaxScore) {\n          score = scorer.score();\n        }\n        updateBottom(doc, score);\n\n        for (int i = 0; i < comparators.length; i++) {\n          comparators[i].setBottom(bottom.slot);\n        }\n      } else {\n        collectedHits++;\n\n        // Startup transient: queue hasn't gathered numHits yet\n        final int slot = collectedHits - 1;\n        //System.out.println(\"    slot=\" + slot);\n        // Copy hit into queue\n        for (int i = 0; i < comparators.length; i++) {\n          comparators[i].copy(slot, doc);\n        }\n\n        // Compute score only if it is competitive.\n        if (trackDocScores && !trackMaxScore) {\n          score = scorer.score();\n        }\n        bottom = pq.add(new Entry(slot, docBase + doc, score));\n        queueFull = collectedHits == numHits;\n        if (queueFull) {\n          for (int i = 0; i < comparators.length; i++) {\n            comparators[i].setBottom(bottom.slot);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    @Override\n    public void collect(int doc) throws IOException {\n      totalHits++;\n\n      //System.out.println(\"  collect doc=\" + doc);\n\n      // Check if this hit was already collected on a\n      // previous page:\n      boolean sameValues = true;\n      for(int compIDX=0;compIDX<comparators.length;compIDX++) {\n        final FieldComparator comp = comparators[compIDX];\n\n        final int cmp = reverseMul[compIDX] * comp.compareDocToValue(doc, after.fields[compIDX]);\n        if (cmp < 0) {\n          // Already collected on a previous page\n          //System.out.println(\"    skip: before\");\n          return;\n        } else if (cmp > 0) {\n          // Not yet collected\n          sameValues = false;\n          //System.out.println(\"    keep: after\");\n          break;\n        }\n      }\n\n      // Tie-break by docID:\n      if (sameValues && doc <= afterDoc) {\n        // Already collected on a previous page\n        //System.out.println(\"    skip: tie-break\");\n        return;\n      }\n\n      collectedHits++;\n\n      float score = Float.NaN;\n      if (trackMaxScore) {\n        score = scorer.score();\n        if (score > maxScore) {\n          maxScore = score;\n        }\n      }\n\n      if (queueFull) {\n        // Fastmatch: return if this hit is not competitive\n        for (int i = 0;; i++) {\n          final int c = reverseMul[i] * comparators[i].compareBottom(doc);\n          if (c < 0) {\n            // Definitely not competitive.\n            return;\n          } else if (c > 0) {\n            // Definitely competitive.\n            break;\n          } else if (i == comparators.length - 1) {\n            // This is the equals case.\n            if (doc + docBase > bottom.doc) {\n              // Definitely not competitive\n              return;\n            }\n            break;\n          }\n        }\n\n        // This hit is competitive - replace bottom element in queue & adjustTop\n        for (int i = 0; i < comparators.length; i++) {\n          comparators[i].copy(bottom.slot, doc);\n        }\n\n        // Compute score only if it is competitive.\n        if (trackDocScores && !trackMaxScore) {\n          score = scorer.score();\n        }\n        updateBottom(doc, score);\n\n        for (int i = 0; i < comparators.length; i++) {\n          comparators[i].setBottom(bottom.slot);\n        }\n      } else {\n        // Startup transient: queue hasn't gathered numHits yet\n        final int slot = collectedHits - 1;\n        //System.out.println(\"    slot=\" + slot);\n        // Copy hit into queue\n        for (int i = 0; i < comparators.length; i++) {\n          comparators[i].copy(slot, doc);\n        }\n\n        // Compute score only if it is competitive.\n        if (trackDocScores && !trackMaxScore) {\n          score = scorer.score();\n        }\n        bottom = pq.add(new Entry(slot, docBase + doc, score));\n        queueFull = collectedHits == numHits;\n        if (queueFull) {\n          for (int i = 0; i < comparators.length; i++) {\n            comparators[i].setBottom(bottom.slot);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81530aec3dade54d134a5bbf27fb31a590def317","date":1389812586,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#collect(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#collect(int).mjava","sourceNew":"    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    @Override\n    public void collect(int doc) throws IOException {\n      //System.out.println(\"  collect doc=\" + doc);\n\n      totalHits++;\n\n      float score = Float.NaN;\n      if (trackMaxScore) {\n        score = scorer.score();\n        if (score > maxScore) {\n          maxScore = score;\n        }\n      }\n\n      if (queueFull) {\n        // Fastmatch: return if this hit is no better than\n        // the worst hit currently in the queue:\n        for (int i = 0;; i++) {\n          final int c = reverseMul[i] * comparators[i].compareBottom(doc);\n          if (c < 0) {\n            // Definitely not competitive.\n            return;\n          } else if (c > 0) {\n            // Definitely competitive.\n            break;\n          } else if (i == comparators.length - 1) {\n            // This is the equals case.\n            if (doc + docBase > bottom.doc) {\n              // Definitely not competitive\n              return;\n            }\n            break;\n          }\n        }\n      }\n\n      // Check if this hit was already collected on a\n      // previous page:\n      boolean sameValues = true;\n      for(int compIDX=0;compIDX<comparators.length;compIDX++) {\n        final FieldComparator comp = comparators[compIDX];\n\n        final int cmp = reverseMul[compIDX] * comp.compareTop(doc);\n        if (cmp > 0) {\n          // Already collected on a previous page\n          //System.out.println(\"    skip: before\");\n          return;\n        } else if (cmp < 0) {\n          // Not yet collected\n          sameValues = false;\n          //System.out.println(\"    keep: after; reverseMul=\" + reverseMul[compIDX]);\n          break;\n        }\n      }\n\n      // Tie-break by docID:\n      if (sameValues && doc <= afterDoc) {\n        // Already collected on a previous page\n        //System.out.println(\"    skip: tie-break\");\n        return;\n      }\n\n      if (queueFull) {\n        // This hit is competitive - replace bottom element in queue & adjustTop\n        for (int i = 0; i < comparators.length; i++) {\n          comparators[i].copy(bottom.slot, doc);\n        }\n\n        // Compute score only if it is competitive.\n        if (trackDocScores && !trackMaxScore) {\n          score = scorer.score();\n        }\n        updateBottom(doc, score);\n\n        for (int i = 0; i < comparators.length; i++) {\n          comparators[i].setBottom(bottom.slot);\n        }\n      } else {\n        collectedHits++;\n\n        // Startup transient: queue hasn't gathered numHits yet\n        final int slot = collectedHits - 1;\n        //System.out.println(\"    slot=\" + slot);\n        // Copy hit into queue\n        for (int i = 0; i < comparators.length; i++) {\n          comparators[i].copy(slot, doc);\n        }\n\n        // Compute score only if it is competitive.\n        if (trackDocScores && !trackMaxScore) {\n          score = scorer.score();\n        }\n        bottom = pq.add(new Entry(slot, docBase + doc, score));\n        queueFull = collectedHits == numHits;\n        if (queueFull) {\n          for (int i = 0; i < comparators.length; i++) {\n            comparators[i].setBottom(bottom.slot);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    @Override\n    public void collect(int doc) throws IOException {\n      totalHits++;\n\n      float score = Float.NaN;\n      if (trackMaxScore) {\n        score = scorer.score();\n        if (score > maxScore) {\n          maxScore = score;\n        }\n      }\n\n      if (queueFull) {\n        // Fastmatch: return if this hit is no better than\n        // the worst hit currently in the queue:\n        for (int i = 0;; i++) {\n          final int c = reverseMul[i] * comparators[i].compareBottom(doc);\n          if (c < 0) {\n            // Definitely not competitive.\n            return;\n          } else if (c > 0) {\n            // Definitely competitive.\n            break;\n          } else if (i == comparators.length - 1) {\n            // This is the equals case.\n            if (doc + docBase > bottom.doc) {\n              // Definitely not competitive\n              return;\n            }\n            break;\n          }\n        }\n      }\n\n      //System.out.println(\"  collect doc=\" + doc);\n\n      // Check if this hit was already collected on a\n      // previous page:\n      boolean sameValues = true;\n      for(int compIDX=0;compIDX<comparators.length;compIDX++) {\n        final FieldComparator comp = comparators[compIDX];\n\n        final int cmp = reverseMul[compIDX] * comp.compareTop(doc);\n        if (cmp > 0) {\n          // Already collected on a previous page\n          //System.out.println(\"    skip: before\");\n          return;\n        } else if (cmp < 0) {\n          // Not yet collected\n          sameValues = false;\n          //System.out.println(\"    keep: after\");\n          break;\n        }\n      }\n\n      // Tie-break by docID:\n      if (sameValues && doc <= afterDoc) {\n        // Already collected on a previous page\n        //System.out.println(\"    skip: tie-break\");\n        return;\n      }\n\n      if (queueFull) {\n        // This hit is competitive - replace bottom element in queue & adjustTop\n        for (int i = 0; i < comparators.length; i++) {\n          comparators[i].copy(bottom.slot, doc);\n        }\n\n        // Compute score only if it is competitive.\n        if (trackDocScores && !trackMaxScore) {\n          score = scorer.score();\n        }\n        updateBottom(doc, score);\n\n        for (int i = 0; i < comparators.length; i++) {\n          comparators[i].setBottom(bottom.slot);\n        }\n      } else {\n        collectedHits++;\n\n        // Startup transient: queue hasn't gathered numHits yet\n        final int slot = collectedHits - 1;\n        //System.out.println(\"    slot=\" + slot);\n        // Copy hit into queue\n        for (int i = 0; i < comparators.length; i++) {\n          comparators[i].copy(slot, doc);\n        }\n\n        // Compute score only if it is competitive.\n        if (trackDocScores && !trackMaxScore) {\n          score = scorer.score();\n        }\n        bottom = pq.add(new Entry(slot, docBase + doc, score));\n        queueFull = collectedHits == numHits;\n        if (queueFull) {\n          for (int i = 0; i < comparators.length; i++) {\n            comparators[i].setBottom(bottom.slot);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"27ab7b234eab0cbc020836989b96ed430e1065bb","date":1389894025,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#collect(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#collect(int).mjava","sourceNew":"    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    @Override\n    public void collect(int doc) throws IOException {\n      //System.out.println(\"  collect doc=\" + doc);\n\n      totalHits++;\n\n      float score = Float.NaN;\n      if (trackMaxScore) {\n        score = scorer.score();\n        if (score > maxScore) {\n          maxScore = score;\n        }\n      }\n\n      if (queueFull) {\n        // Fastmatch: return if this hit is no better than\n        // the worst hit currently in the queue:\n        for (int i = 0;; i++) {\n          final int c = reverseMul[i] * comparators[i].compareBottom(doc);\n          if (c < 0) {\n            // Definitely not competitive.\n            return;\n          } else if (c > 0) {\n            // Definitely competitive.\n            break;\n          } else if (i == comparators.length - 1) {\n            // This is the equals case.\n            if (doc + docBase > bottom.doc) {\n              // Definitely not competitive\n              return;\n            }\n            break;\n          }\n        }\n      }\n\n      // Check if this hit was already collected on a\n      // previous page:\n      boolean sameValues = true;\n      for(int compIDX=0;compIDX<comparators.length;compIDX++) {\n        final FieldComparator comp = comparators[compIDX];\n\n        final int cmp = reverseMul[compIDX] * comp.compareTop(doc);\n        if (cmp > 0) {\n          // Already collected on a previous page\n          //System.out.println(\"    skip: before\");\n          return;\n        } else if (cmp < 0) {\n          // Not yet collected\n          sameValues = false;\n          //System.out.println(\"    keep: after; reverseMul=\" + reverseMul[compIDX]);\n          break;\n        }\n      }\n\n      // Tie-break by docID:\n      if (sameValues && doc <= afterDoc) {\n        // Already collected on a previous page\n        //System.out.println(\"    skip: tie-break\");\n        return;\n      }\n\n      if (queueFull) {\n        // This hit is competitive - replace bottom element in queue & adjustTop\n        for (int i = 0; i < comparators.length; i++) {\n          comparators[i].copy(bottom.slot, doc);\n        }\n\n        // Compute score only if it is competitive.\n        if (trackDocScores && !trackMaxScore) {\n          score = scorer.score();\n        }\n        updateBottom(doc, score);\n\n        for (int i = 0; i < comparators.length; i++) {\n          comparators[i].setBottom(bottom.slot);\n        }\n      } else {\n        collectedHits++;\n\n        // Startup transient: queue hasn't gathered numHits yet\n        final int slot = collectedHits - 1;\n        //System.out.println(\"    slot=\" + slot);\n        // Copy hit into queue\n        for (int i = 0; i < comparators.length; i++) {\n          comparators[i].copy(slot, doc);\n        }\n\n        // Compute score only if it is competitive.\n        if (trackDocScores && !trackMaxScore) {\n          score = scorer.score();\n        }\n        bottom = pq.add(new Entry(slot, docBase + doc, score));\n        queueFull = collectedHits == numHits;\n        if (queueFull) {\n          for (int i = 0; i < comparators.length; i++) {\n            comparators[i].setBottom(bottom.slot);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    @Override\n    public void collect(int doc) throws IOException {\n      totalHits++;\n\n      //System.out.println(\"  collect doc=\" + doc);\n\n      // Check if this hit was already collected on a\n      // previous page:\n      boolean sameValues = true;\n      for(int compIDX=0;compIDX<comparators.length;compIDX++) {\n        final FieldComparator comp = comparators[compIDX];\n\n        final int cmp = reverseMul[compIDX] * comp.compareDocToValue(doc, after.fields[compIDX]);\n        if (cmp < 0) {\n          // Already collected on a previous page\n          //System.out.println(\"    skip: before\");\n          return;\n        } else if (cmp > 0) {\n          // Not yet collected\n          sameValues = false;\n          //System.out.println(\"    keep: after\");\n          break;\n        }\n      }\n\n      // Tie-break by docID:\n      if (sameValues && doc <= afterDoc) {\n        // Already collected on a previous page\n        //System.out.println(\"    skip: tie-break\");\n        return;\n      }\n\n      collectedHits++;\n\n      float score = Float.NaN;\n      if (trackMaxScore) {\n        score = scorer.score();\n        if (score > maxScore) {\n          maxScore = score;\n        }\n      }\n\n      if (queueFull) {\n        // Fastmatch: return if this hit is not competitive\n        for (int i = 0;; i++) {\n          final int c = reverseMul[i] * comparators[i].compareBottom(doc);\n          if (c < 0) {\n            // Definitely not competitive.\n            return;\n          } else if (c > 0) {\n            // Definitely competitive.\n            break;\n          } else if (i == comparators.length - 1) {\n            // This is the equals case.\n            if (doc + docBase > bottom.doc) {\n              // Definitely not competitive\n              return;\n            }\n            break;\n          }\n        }\n\n        // This hit is competitive - replace bottom element in queue & adjustTop\n        for (int i = 0; i < comparators.length; i++) {\n          comparators[i].copy(bottom.slot, doc);\n        }\n\n        // Compute score only if it is competitive.\n        if (trackDocScores && !trackMaxScore) {\n          score = scorer.score();\n        }\n        updateBottom(doc, score);\n\n        for (int i = 0; i < comparators.length; i++) {\n          comparators[i].setBottom(bottom.slot);\n        }\n      } else {\n        // Startup transient: queue hasn't gathered numHits yet\n        final int slot = collectedHits - 1;\n        //System.out.println(\"    slot=\" + slot);\n        // Copy hit into queue\n        for (int i = 0; i < comparators.length; i++) {\n          comparators[i].copy(slot, doc);\n        }\n\n        // Compute score only if it is competitive.\n        if (trackDocScores && !trackMaxScore) {\n          score = scorer.score();\n        }\n        bottom = pq.add(new Entry(slot, docBase + doc, score));\n        queueFull = collectedHits == numHits;\n        if (queueFull) {\n          for (int i = 0; i < comparators.length; i++) {\n            comparators[i].setBottom(bottom.slot);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"901e951cec2e6af4e503209a6721c8834db23279","date":1420556599,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.PagingFieldCollector#collect(int).mjava","sourceNew":null,"sourceOld":"    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    @Override\n    public void collect(int doc) throws IOException {\n      //System.out.println(\"  collect doc=\" + doc);\n\n      totalHits++;\n\n      float score = Float.NaN;\n      if (trackMaxScore) {\n        score = scorer.score();\n        if (score > maxScore) {\n          maxScore = score;\n        }\n      }\n\n      if (queueFull) {\n        // Fastmatch: return if this hit is no better than\n        // the worst hit currently in the queue:\n        for (int i = 0;; i++) {\n          final int c = reverseMul[i] * comparators[i].compareBottom(doc);\n          if (c < 0) {\n            // Definitely not competitive.\n            return;\n          } else if (c > 0) {\n            // Definitely competitive.\n            break;\n          } else if (i == comparators.length - 1) {\n            // This is the equals case.\n            if (doc + docBase > bottom.doc) {\n              // Definitely not competitive\n              return;\n            }\n            break;\n          }\n        }\n      }\n\n      // Check if this hit was already collected on a\n      // previous page:\n      boolean sameValues = true;\n      for(int compIDX=0;compIDX<comparators.length;compIDX++) {\n        final FieldComparator comp = comparators[compIDX];\n\n        final int cmp = reverseMul[compIDX] * comp.compareTop(doc);\n        if (cmp > 0) {\n          // Already collected on a previous page\n          //System.out.println(\"    skip: before\");\n          return;\n        } else if (cmp < 0) {\n          // Not yet collected\n          sameValues = false;\n          //System.out.println(\"    keep: after; reverseMul=\" + reverseMul[compIDX]);\n          break;\n        }\n      }\n\n      // Tie-break by docID:\n      if (sameValues && doc <= afterDoc) {\n        // Already collected on a previous page\n        //System.out.println(\"    skip: tie-break\");\n        return;\n      }\n\n      if (queueFull) {\n        // This hit is competitive - replace bottom element in queue & adjustTop\n        for (int i = 0; i < comparators.length; i++) {\n          comparators[i].copy(bottom.slot, doc);\n        }\n\n        // Compute score only if it is competitive.\n        if (trackDocScores && !trackMaxScore) {\n          score = scorer.score();\n        }\n        updateBottom(doc, score);\n\n        for (int i = 0; i < comparators.length; i++) {\n          comparators[i].setBottom(bottom.slot);\n        }\n      } else {\n        collectedHits++;\n\n        // Startup transient: queue hasn't gathered numHits yet\n        final int slot = collectedHits - 1;\n        //System.out.println(\"    slot=\" + slot);\n        // Copy hit into queue\n        for (int i = 0; i < comparators.length; i++) {\n          comparators[i].copy(slot, doc);\n        }\n\n        // Compute score only if it is competitive.\n        if (trackDocScores && !trackMaxScore) {\n          score = scorer.score();\n        }\n        bottom = pq.add(new Entry(slot, docBase + doc, score));\n        queueFull = collectedHits == numHits;\n        if (queueFull) {\n          for (int i = 0; i < comparators.length; i++) {\n            comparators[i].setBottom(bottom.slot);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fb02351ae2b114dd41585916d1e35fb2cff98fb0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"81530aec3dade54d134a5bbf27fb31a590def317":["7615b855702e008d91a95a2578bf05d27372f599"],"27ab7b234eab0cbc020836989b96ed430e1065bb":["fb02351ae2b114dd41585916d1e35fb2cff98fb0","81530aec3dade54d134a5bbf27fb31a590def317"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7615b855702e008d91a95a2578bf05d27372f599":["fb02351ae2b114dd41585916d1e35fb2cff98fb0"],"901e951cec2e6af4e503209a6721c8834db23279":["27ab7b234eab0cbc020836989b96ed430e1065bb"],"ef0d8a69209261514c5739c770bba706c2308450":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","fb02351ae2b114dd41585916d1e35fb2cff98fb0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["901e951cec2e6af4e503209a6721c8834db23279"]},"commit2Childs":{"fb02351ae2b114dd41585916d1e35fb2cff98fb0":["27ab7b234eab0cbc020836989b96ed430e1065bb","7615b855702e008d91a95a2578bf05d27372f599","ef0d8a69209261514c5739c770bba706c2308450"],"81530aec3dade54d134a5bbf27fb31a590def317":["27ab7b234eab0cbc020836989b96ed430e1065bb"],"27ab7b234eab0cbc020836989b96ed430e1065bb":["901e951cec2e6af4e503209a6721c8834db23279"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fb02351ae2b114dd41585916d1e35fb2cff98fb0","ef0d8a69209261514c5739c770bba706c2308450"],"7615b855702e008d91a95a2578bf05d27372f599":["81530aec3dade54d134a5bbf27fb31a590def317"],"901e951cec2e6af4e503209a6721c8834db23279":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ef0d8a69209261514c5739c770bba706c2308450":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ef0d8a69209261514c5739c770bba706c2308450","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}