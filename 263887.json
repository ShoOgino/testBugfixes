{"path":"lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/MultiTermHighlighting#binaryToCharRunAutomaton(Automaton,String).mjava","commits":[{"id":"5b9ffb60dc4bdc972b1403ad2ab2f5b4d9ce4cf7","date":1552575873,"type":0,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/MultiTermHighlighting#binaryToCharRunAutomaton(Automaton,String).mjava","pathOld":"/dev/null","sourceNew":"  private static CharacterRunAutomaton binaryToCharRunAutomaton(Automaton binaryAutomaton, String description) {\n    return new CharacterRunAutomaton(Automata.makeEmpty()) { // empty here is bogus just to satisfy API\n      //   TODO can we get access to the aq.compiledAutomaton.runAutomaton ?\n      ByteRunAutomaton byteRunAutomaton =\n          new ByteRunAutomaton(binaryAutomaton, true, Operations.DEFAULT_MAX_DETERMINIZED_STATES);\n\n      @Override\n      public String toString() {\n        return description;\n      }\n\n      @Override\n      public boolean run(char[] chars, int offset, int length) {\n        int state = 0;\n        final int maxIdx = offset + length;\n        for (int i = offset; i < maxIdx; i++) {\n          final int code = chars[i];\n          int b;\n          // UTF16 to UTF8   (inlined logic from UnicodeUtil.UTF16toUTF8 )\n          if (code < 0x80) {\n            state = byteRunAutomaton.step(state, code);\n            if (state == -1) return false;\n          } else if (code < 0x800) {\n            b = (0xC0 | (code >> 6));\n            state = byteRunAutomaton.step(state, b);\n            if (state == -1) return false;\n            b = (0x80 | (code & 0x3F));\n            state = byteRunAutomaton.step(state, b);\n            if (state == -1) return false;\n          } else {\n            // more complex\n            byte[] utf8Bytes = new byte[4 * (maxIdx - i)];\n            int utf8Len = UnicodeUtil.UTF16toUTF8(chars, i, maxIdx - i, utf8Bytes);\n            for (int utfIdx = 0; utfIdx < utf8Len; utfIdx++) {\n              state = byteRunAutomaton.step(state, utf8Bytes[utfIdx] & 0xFF);\n              if (state == -1) return false;\n            }\n            break;\n          }\n        }\n        return byteRunAutomaton.isAccept(state);\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d35c63123a7e255b58f8cf3948eb9a6128100a32","date":1574872099,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/LabelledCharArrayMatcher#wrap(String,ByteRunAutomaton).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/MultiTermHighlighting#binaryToCharRunAutomaton(Automaton,String).mjava","sourceNew":"  /**\n   * Returns a representation of the automaton that matches char[] instead of byte[]\n   */\n  static LabelledCharArrayMatcher wrap(String label, ByteRunAutomaton runAutomaton) {\n      return wrap(label, (chars, offset, length) -> {\n        int state = 0;\n        final int maxIdx = offset + length;\n        for (int i = offset; i < maxIdx; i++) {\n          final int code = chars[i];\n          int b;\n          // UTF16 to UTF8   (inlined logic from UnicodeUtil.UTF16toUTF8 )\n          if (code < 0x80) {\n            state = runAutomaton.step(state, code);\n            if (state == -1) return false;\n          } else if (code < 0x800) {\n            b = (0xC0 | (code >> 6));\n            state = runAutomaton.step(state, b);\n            if (state == -1) return false;\n            b = (0x80 | (code & 0x3F));\n            state = runAutomaton.step(state, b);\n            if (state == -1) return false;\n          } else {\n            // more complex\n            byte[] utf8Bytes = new byte[4 * (maxIdx - i)];\n            int utf8Len = UnicodeUtil.UTF16toUTF8(chars, i, maxIdx - i, utf8Bytes);\n            for (int utfIdx = 0; utfIdx < utf8Len; utfIdx++) {\n              state = runAutomaton.step(state, utf8Bytes[utfIdx] & 0xFF);\n              if (state == -1) return false;\n            }\n            break;\n          }\n        }\n        return runAutomaton.isAccept(state);\n      });\n  }\n\n","sourceOld":"  private static CharacterRunAutomaton binaryToCharRunAutomaton(Automaton binaryAutomaton, String description) {\n    return new CharacterRunAutomaton(Automata.makeEmpty()) { // empty here is bogus just to satisfy API\n      //   TODO can we get access to the aq.compiledAutomaton.runAutomaton ?\n      ByteRunAutomaton byteRunAutomaton =\n          new ByteRunAutomaton(binaryAutomaton, true, Operations.DEFAULT_MAX_DETERMINIZED_STATES);\n\n      @Override\n      public String toString() {\n        return description;\n      }\n\n      @Override\n      public boolean run(char[] chars, int offset, int length) {\n        int state = 0;\n        final int maxIdx = offset + length;\n        for (int i = offset; i < maxIdx; i++) {\n          final int code = chars[i];\n          int b;\n          // UTF16 to UTF8   (inlined logic from UnicodeUtil.UTF16toUTF8 )\n          if (code < 0x80) {\n            state = byteRunAutomaton.step(state, code);\n            if (state == -1) return false;\n          } else if (code < 0x800) {\n            b = (0xC0 | (code >> 6));\n            state = byteRunAutomaton.step(state, b);\n            if (state == -1) return false;\n            b = (0x80 | (code & 0x3F));\n            state = byteRunAutomaton.step(state, b);\n            if (state == -1) return false;\n          } else {\n            // more complex\n            byte[] utf8Bytes = new byte[4 * (maxIdx - i)];\n            int utf8Len = UnicodeUtil.UTF16toUTF8(chars, i, maxIdx - i, utf8Bytes);\n            for (int utfIdx = 0; utfIdx < utf8Len; utfIdx++) {\n              state = byteRunAutomaton.step(state, utf8Bytes[utfIdx] & 0xFF);\n              if (state == -1) return false;\n            }\n            break;\n          }\n        }\n        return byteRunAutomaton.isAccept(state);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d35c63123a7e255b58f8cf3948eb9a6128100a32":["5b9ffb60dc4bdc972b1403ad2ab2f5b4d9ce4cf7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d35c63123a7e255b58f8cf3948eb9a6128100a32"],"5b9ffb60dc4bdc972b1403ad2ab2f5b4d9ce4cf7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5b9ffb60dc4bdc972b1403ad2ab2f5b4d9ce4cf7"],"d35c63123a7e255b58f8cf3948eb9a6128100a32":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5b9ffb60dc4bdc972b1403ad2ab2f5b4d9ce4cf7":["d35c63123a7e255b58f8cf3948eb9a6128100a32"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}