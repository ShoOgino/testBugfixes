{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#generateGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],GeoPoint,boolean).mjava","commits":[{"id":"536a864ce38bf14fb3f072a3129a389e95200e20","date":1461068886,"type":1,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#generateGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],GeoPoint,boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],GeoPoint,boolean).mjava","sourceNew":"  /**\n   * Create a GeoPolygon using the specified points and holes and a test point.\n   *\n   * @param filteredPointList is a filtered list of the GeoPoints to build an arbitrary polygon out of.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Null == none.\n   * @param testPoint is a test point that is either known to be within the polygon area, or not.\n   * @param testPointInside is true if the test point is within the area, false otherwise.\n   * @return a GeoPolygon corresponding to what was specified, or null if what was specified\n   *  cannot be turned into a valid non-degenerate polygon.\n   */\n  static GeoPolygon generateGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> filteredPointList,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint, \n    final boolean testPointInside) {\n    // We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n    // side.  While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n    // find.\n    final SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n    // We don't know if this is the correct siding choice.  We will only know as we build the complex polygon.\n    // So we need to be prepared to try both possibilities.\n    GeoCompositePolygon rval = new GeoCompositePolygon();\n    MutableBoolean seenConcave = new MutableBoolean();\n    if (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n      // The testPoint was within the shape.  Was that intended?\n      if (testPointInside) {\n        // Yes: build it for real\n        rval = new GeoCompositePolygon();\n        seenConcave = new MutableBoolean();\n        buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\n        return rval;\n      }\n      // No: do the complement and return that.\n      rval = new GeoCompositePolygon();\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    } else {\n      // The testPoint was outside the shape.  Was that intended?\n      if (!testPointInside) {\n        // Yes: return what we just built\n        return rval;\n      }\n      // No: return the complement\n      rval = new GeoCompositePolygon();\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a GeoPolygon using the specified points and holes and a test point.\n   *\n   * @param pointList        is a list of the GeoPoints to build an arbitrary polygon out of.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Null == none.\n   * @param testPoint is a test point that is either known to be within the polygon area, or not.\n   * @param testPointInside is true if the test point is within the area, false otherwise.\n   * @return a GeoPolygon corresponding to what was specified.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> pointList,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint, \n    final boolean testPointInside) {\n    // First, exercise a sanity filter on the provided pointList, and remove identical points, linear points, and backtracks\n    final List<GeoPoint> filteredPointList = filterPoints(pointList);\n    // We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n    // side.  While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n    // find.\n    final SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n    // We don't know if this is the correct siding choice.  We will only know as we build the complex polygon.\n    // So we need to be prepared to try both possibilities.\n    GeoCompositePolygon rval = new GeoCompositePolygon();\n    MutableBoolean seenConcave = new MutableBoolean();\n    if (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n      // The testPoint was within the shape.  Was that intended?\n      if (testPointInside) {\n        // Yes: build it for real\n        rval = new GeoCompositePolygon();\n        seenConcave = new MutableBoolean();\n        buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\n        return rval;\n      }\n      // No: do the complement and return that.\n      rval = new GeoCompositePolygon();\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    } else {\n      // The testPoint was outside the shape.  Was that intended?\n      if (!testPointInside) {\n        // Yes: return what we just built\n        return rval;\n      }\n      // No: return the complement\n      rval = new GeoCompositePolygon();\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a92ffe0d2961113e5588e614f8dc22b42bf10a95","date":1503304229,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#generateGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],GeoPoint,boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#generateGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],GeoPoint,boolean).mjava","sourceNew":"  /**\n   * Create a GeoPolygon using the specified points and holes and a test point.\n   *\n   * @param filteredPointList is a filtered list of the GeoPoints to build an arbitrary polygon out of.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Null == none.\n   * @param testPoint is a test point that is either known to be within the polygon area, or not.\n   * @param testPointInside is true if the test point is within the area, false otherwise.\n   * @return a GeoPolygon corresponding to what was specified, or null if what was specified\n   *  cannot be turned into a valid non-degenerate polygon.\n   */\n  static GeoPolygon generateGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> filteredPointList,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint, \n    final boolean testPointInside) {\n    // We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n    // side.  While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n    // find.\n    final SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n    // We don't know if this is the correct siding choice.  We will only know as we build the complex polygon.\n    // So we need to be prepared to try both possibilities.\n    GeoCompositePolygon rval = new GeoCompositePolygon(planetModel);\n    MutableBoolean seenConcave = new MutableBoolean();\n    if (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n      // The testPoint was within the shape.  Was that intended?\n      if (testPointInside) {\n        // Yes: build it for real\n        rval = new GeoCompositePolygon(planetModel);\n        seenConcave = new MutableBoolean();\n        buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\n        return rval;\n      }\n      // No: do the complement and return that.\n      rval = new GeoCompositePolygon(planetModel);\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    } else {\n      // The testPoint was outside the shape.  Was that intended?\n      if (!testPointInside) {\n        // Yes: return what we just built\n        return rval;\n      }\n      // No: return the complement\n      rval = new GeoCompositePolygon(planetModel);\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a GeoPolygon using the specified points and holes and a test point.\n   *\n   * @param filteredPointList is a filtered list of the GeoPoints to build an arbitrary polygon out of.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Null == none.\n   * @param testPoint is a test point that is either known to be within the polygon area, or not.\n   * @param testPointInside is true if the test point is within the area, false otherwise.\n   * @return a GeoPolygon corresponding to what was specified, or null if what was specified\n   *  cannot be turned into a valid non-degenerate polygon.\n   */\n  static GeoPolygon generateGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> filteredPointList,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint, \n    final boolean testPointInside) {\n    // We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n    // side.  While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n    // find.\n    final SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n    // We don't know if this is the correct siding choice.  We will only know as we build the complex polygon.\n    // So we need to be prepared to try both possibilities.\n    GeoCompositePolygon rval = new GeoCompositePolygon();\n    MutableBoolean seenConcave = new MutableBoolean();\n    if (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n      // The testPoint was within the shape.  Was that intended?\n      if (testPointInside) {\n        // Yes: build it for real\n        rval = new GeoCompositePolygon();\n        seenConcave = new MutableBoolean();\n        buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\n        return rval;\n      }\n      // No: do the complement and return that.\n      rval = new GeoCompositePolygon();\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    } else {\n      // The testPoint was outside the shape.  Was that intended?\n      if (!testPointInside) {\n        // Yes: return what we just built\n        return rval;\n      }\n      // No: return the complement\n      rval = new GeoCompositePolygon();\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0dcd28a23753c14d56c7d2c5ba71cf1e03d532b","date":1503230479,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#generateGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],GeoPoint,boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#generateGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],GeoPoint,boolean).mjava","sourceNew":"  /**\n   * Create a GeoPolygon using the specified points and holes and a test point.\n   *\n   * @param filteredPointList is a filtered list of the GeoPoints to build an arbitrary polygon out of.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Null == none.\n   * @param testPoint is a test point that is either known to be within the polygon area, or not.\n   * @param testPointInside is true if the test point is within the area, false otherwise.\n   * @return a GeoPolygon corresponding to what was specified, or null if what was specified\n   *  cannot be turned into a valid non-degenerate polygon.\n   */\n  static GeoPolygon generateGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> filteredPointList,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint, \n    final boolean testPointInside) {\n    // We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n    // side.  While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n    // find.\n    final SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n    // We don't know if this is the correct siding choice.  We will only know as we build the complex polygon.\n    // So we need to be prepared to try both possibilities.\n    GeoCompositePolygon rval = new GeoCompositePolygon(planetModel);\n    MutableBoolean seenConcave = new MutableBoolean();\n    if (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n      // The testPoint was within the shape.  Was that intended?\n      if (testPointInside) {\n        // Yes: build it for real\n        rval = new GeoCompositePolygon(planetModel);\n        seenConcave = new MutableBoolean();\n        buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\n        return rval;\n      }\n      // No: do the complement and return that.\n      rval = new GeoCompositePolygon(planetModel);\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    } else {\n      // The testPoint was outside the shape.  Was that intended?\n      if (!testPointInside) {\n        // Yes: return what we just built\n        return rval;\n      }\n      // No: return the complement\n      rval = new GeoCompositePolygon(planetModel);\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a GeoPolygon using the specified points and holes and a test point.\n   *\n   * @param filteredPointList is a filtered list of the GeoPoints to build an arbitrary polygon out of.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Null == none.\n   * @param testPoint is a test point that is either known to be within the polygon area, or not.\n   * @param testPointInside is true if the test point is within the area, false otherwise.\n   * @return a GeoPolygon corresponding to what was specified, or null if what was specified\n   *  cannot be turned into a valid non-degenerate polygon.\n   */\n  static GeoPolygon generateGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> filteredPointList,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint, \n    final boolean testPointInside) {\n    // We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n    // side.  While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n    // find.\n    final SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n    // We don't know if this is the correct siding choice.  We will only know as we build the complex polygon.\n    // So we need to be prepared to try both possibilities.\n    GeoCompositePolygon rval = new GeoCompositePolygon();\n    MutableBoolean seenConcave = new MutableBoolean();\n    if (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n      // The testPoint was within the shape.  Was that intended?\n      if (testPointInside) {\n        // Yes: build it for real\n        rval = new GeoCompositePolygon();\n        seenConcave = new MutableBoolean();\n        buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\n        return rval;\n      }\n      // No: do the complement and return that.\n      rval = new GeoCompositePolygon();\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    } else {\n      // The testPoint was outside the shape.  Was that intended?\n      if (!testPointInside) {\n        // Yes: return what we just built\n        return rval;\n      }\n      // No: return the complement\n      rval = new GeoCompositePolygon();\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3051d6122751c8f6cc1e9cf24592658b59843ec2","date":1503298024,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#generateGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],GeoPoint,boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#generateGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],GeoPoint,boolean).mjava","sourceNew":"  /**\n   * Create a GeoPolygon using the specified points and holes and a test point.\n   *\n   * @param filteredPointList is a filtered list of the GeoPoints to build an arbitrary polygon out of.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Null == none.\n   * @param testPoint is a test point that is either known to be within the polygon area, or not.\n   * @param testPointInside is true if the test point is within the area, false otherwise.\n   * @return a GeoPolygon corresponding to what was specified, or null if what was specified\n   *  cannot be turned into a valid non-degenerate polygon.\n   */\n  static GeoPolygon generateGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> filteredPointList,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint, \n    final boolean testPointInside) {\n    // We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n    // side.  While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n    // find.\n    final SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n    // We don't know if this is the correct siding choice.  We will only know as we build the complex polygon.\n    // So we need to be prepared to try both possibilities.\n    GeoCompositePolygon rval = new GeoCompositePolygon(planetModel);\n    MutableBoolean seenConcave = new MutableBoolean();\n    if (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n      // The testPoint was within the shape.  Was that intended?\n      if (testPointInside) {\n        // Yes: build it for real\n        rval = new GeoCompositePolygon(planetModel);\n        seenConcave = new MutableBoolean();\n        buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\n        return rval;\n      }\n      // No: do the complement and return that.\n      rval = new GeoCompositePolygon(planetModel);\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    } else {\n      // The testPoint was outside the shape.  Was that intended?\n      if (!testPointInside) {\n        // Yes: return what we just built\n        return rval;\n      }\n      // No: return the complement\n      rval = new GeoCompositePolygon(planetModel);\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a GeoPolygon using the specified points and holes and a test point.\n   *\n   * @param filteredPointList is a filtered list of the GeoPoints to build an arbitrary polygon out of.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Null == none.\n   * @param testPoint is a test point that is either known to be within the polygon area, or not.\n   * @param testPointInside is true if the test point is within the area, false otherwise.\n   * @return a GeoPolygon corresponding to what was specified, or null if what was specified\n   *  cannot be turned into a valid non-degenerate polygon.\n   */\n  static GeoPolygon generateGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> filteredPointList,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint, \n    final boolean testPointInside) {\n    // We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n    // side.  While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n    // find.\n    final SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n    // We don't know if this is the correct siding choice.  We will only know as we build the complex polygon.\n    // So we need to be prepared to try both possibilities.\n    GeoCompositePolygon rval = new GeoCompositePolygon();\n    MutableBoolean seenConcave = new MutableBoolean();\n    if (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n      // The testPoint was within the shape.  Was that intended?\n      if (testPointInside) {\n        // Yes: build it for real\n        rval = new GeoCompositePolygon();\n        seenConcave = new MutableBoolean();\n        buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\n        return rval;\n      }\n      // No: do the complement and return that.\n      rval = new GeoCompositePolygon();\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    } else {\n      // The testPoint was outside the shape.  Was that intended?\n      if (!testPointInside) {\n        // Yes: return what we just built\n        return rval;\n      }\n      // No: return the complement\n      rval = new GeoCompositePolygon();\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a1452bbfea2334e79ba7ac6b6e1508344526145c","date":1521980228,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#generateGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],GeoPoint,boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#generateGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],GeoPoint,boolean).mjava","sourceNew":"  /**\n   * Create a GeoPolygon using the specified points and holes and a test point.\n   *\n   * @param filteredPointList is a filtered list of the GeoPoints to build an arbitrary polygon out of.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Null == none.\n   * @param testPoint is a test point that is either known to be within the polygon area, or not.\n   * @param testPointInside is true if the test point is within the area, false otherwise.\n   * @return a GeoPolygon corresponding to what was specified, or null if what was specified\n   *  cannot be turned into a valid non-degenerate polygon.\n   */\n  static GeoPolygon generateGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> filteredPointList,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint, \n    final boolean testPointInside) throws TileException {\n    // We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n    // side.  While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n    // find.\n    final SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n    // We don't know if this is the correct siding choice.  We will only know as we build the complex polygon.\n    // So we need to be prepared to try both possibilities.\n    GeoCompositePolygon rval = new GeoCompositePolygon(planetModel);\n    MutableBoolean seenConcave = new MutableBoolean();\n    if (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n      // The testPoint was within the shape.  Was that intended?\n      if (testPointInside) {\n        // Yes: build it for real\n        rval = new GeoCompositePolygon(planetModel);\n        seenConcave = new MutableBoolean();\n        buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\n        return rval;\n      }\n      // No: do the complement and return that.\n      rval = new GeoCompositePolygon(planetModel);\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    } else {\n      // The testPoint was outside the shape.  Was that intended?\n      if (!testPointInside) {\n        // Yes: return what we just built\n        return rval;\n      }\n      // No: return the complement\n      rval = new GeoCompositePolygon(planetModel);\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a GeoPolygon using the specified points and holes and a test point.\n   *\n   * @param filteredPointList is a filtered list of the GeoPoints to build an arbitrary polygon out of.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Null == none.\n   * @param testPoint is a test point that is either known to be within the polygon area, or not.\n   * @param testPointInside is true if the test point is within the area, false otherwise.\n   * @return a GeoPolygon corresponding to what was specified, or null if what was specified\n   *  cannot be turned into a valid non-degenerate polygon.\n   */\n  static GeoPolygon generateGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> filteredPointList,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint, \n    final boolean testPointInside) {\n    // We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n    // side.  While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n    // find.\n    final SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n    // We don't know if this is the correct siding choice.  We will only know as we build the complex polygon.\n    // So we need to be prepared to try both possibilities.\n    GeoCompositePolygon rval = new GeoCompositePolygon(planetModel);\n    MutableBoolean seenConcave = new MutableBoolean();\n    if (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n      // The testPoint was within the shape.  Was that intended?\n      if (testPointInside) {\n        // Yes: build it for real\n        rval = new GeoCompositePolygon(planetModel);\n        seenConcave = new MutableBoolean();\n        buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\n        return rval;\n      }\n      // No: do the complement and return that.\n      rval = new GeoCompositePolygon(planetModel);\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    } else {\n      // The testPoint was outside the shape.  Was that intended?\n      if (!testPointInside) {\n        // Yes: return what we just built\n        return rval;\n      }\n      // No: return the complement\n      rval = new GeoCompositePolygon(planetModel);\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d0dcd28a23753c14d56c7d2c5ba71cf1e03d532b":["536a864ce38bf14fb3f072a3129a389e95200e20"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a1452bbfea2334e79ba7ac6b6e1508344526145c":["a92ffe0d2961113e5588e614f8dc22b42bf10a95"],"3051d6122751c8f6cc1e9cf24592658b59843ec2":["536a864ce38bf14fb3f072a3129a389e95200e20","d0dcd28a23753c14d56c7d2c5ba71cf1e03d532b"],"a92ffe0d2961113e5588e614f8dc22b42bf10a95":["536a864ce38bf14fb3f072a3129a389e95200e20","d0dcd28a23753c14d56c7d2c5ba71cf1e03d532b"],"536a864ce38bf14fb3f072a3129a389e95200e20":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a1452bbfea2334e79ba7ac6b6e1508344526145c"]},"commit2Childs":{"d0dcd28a23753c14d56c7d2c5ba71cf1e03d532b":["3051d6122751c8f6cc1e9cf24592658b59843ec2","a92ffe0d2961113e5588e614f8dc22b42bf10a95"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["536a864ce38bf14fb3f072a3129a389e95200e20"],"a1452bbfea2334e79ba7ac6b6e1508344526145c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3051d6122751c8f6cc1e9cf24592658b59843ec2":[],"a92ffe0d2961113e5588e614f8dc22b42bf10a95":["a1452bbfea2334e79ba7ac6b6e1508344526145c"],"536a864ce38bf14fb3f072a3129a389e95200e20":["d0dcd28a23753c14d56c7d2c5ba71cf1e03d532b","3051d6122751c8f6cc1e9cf24592658b59843ec2","a92ffe0d2961113e5588e614f8dc22b42bf10a95"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3051d6122751c8f6cc1e9cf24592658b59843ec2","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}