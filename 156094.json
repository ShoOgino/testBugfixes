{"path":"solr/core/src/java/org/apache/solr/handler/loader/JsonLoader.SingleThreadedJsonLoader#parseExtendedFieldValue(SolrInputField,int).mjava","commits":[{"id":"042e4d934397657ba04c82b46cc5665076bc5c58","date":1336511170,"type":0,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/JsonLoader.SingleThreadedJsonLoader#parseExtendedFieldValue(SolrInputField,int).mjava","pathOld":"/dev/null","sourceNew":"    private void parseExtendedFieldValue(SolrInputField sif, int ev)  throws IOException {\n      assert ev == JSONParser.OBJECT_START;\n  \n      float boost = 1.0f;\n      Object normalFieldValue = null;\n      Map<String, Object> extendedInfo = null;\n  \n      for (;;) {\n        ev = parser.nextEvent();\n        switch (ev) {\n          case JSONParser.STRING:\n            String label = parser.getString();\n            if (\"boost\".equals(label)) {\n              ev = parser.nextEvent();\n              if( ev != JSONParser.NUMBER &&\n                  ev != JSONParser.LONG &&\n                  ev != JSONParser.BIGNUMBER ) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"boost should have number! \"+JSONParser.getEventString(ev) );\n              }\n  \n              boost = (float)parser.getDouble();\n            } else if (\"value\".equals(label)) {\n              normalFieldValue = parseNormalFieldValue(parser.nextEvent());\n            } else {\n              // If we encounter other unknown map keys, then use a map\n              if (extendedInfo == null) {\n                extendedInfo = new HashMap<String, Object>(2);\n              }\n              // for now, the only extended info will be field values\n              // we could either store this as an Object or a SolrInputField\n              Object val = parseNormalFieldValue(parser.nextEvent());\n              extendedInfo.put(label, val);\n            }\n            break;\n  \n          case JSONParser.OBJECT_END:\n            if (extendedInfo != null) {\n              if (normalFieldValue != null) {\n                extendedInfo.put(\"value\",normalFieldValue);\n              }\n              sif.setValue(extendedInfo, boost);\n            } else {\n              sif.setValue(normalFieldValue, boost);\n            }\n            return;\n  \n          default:\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing JSON extended field value. Unexpected \"+JSONParser.getEventString(ev) );\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/JsonLoader.SingleThreadedJsonLoader#parseExtendedFieldValue(SolrInputField,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/JsonLoader.SingleThreadedJsonLoader#parseExtendedFieldValue(SolrInputField,int).mjava","sourceNew":"    private void parseExtendedFieldValue(SolrInputField sif, int ev)  throws IOException {\n      assert ev == JSONParser.OBJECT_START;\n  \n      float boost = 1.0f;\n      Object normalFieldValue = null;\n      Map<String, Object> extendedInfo = null;\n  \n      for (;;) {\n        ev = parser.nextEvent();\n        switch (ev) {\n          case JSONParser.STRING:\n            String label = parser.getString();\n            if (\"boost\".equals(label)) {\n              ev = parser.nextEvent();\n              if( ev != JSONParser.NUMBER &&\n                  ev != JSONParser.LONG &&\n                  ev != JSONParser.BIGNUMBER ) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"boost should have number! \"+JSONParser.getEventString(ev) );\n              }\n  \n              boost = (float)parser.getDouble();\n            } else if (\"value\".equals(label)) {\n              normalFieldValue = parseNormalFieldValue(parser.nextEvent());\n            } else {\n              // If we encounter other unknown map keys, then use a map\n              if (extendedInfo == null) {\n                extendedInfo = new HashMap<>(2);\n              }\n              // for now, the only extended info will be field values\n              // we could either store this as an Object or a SolrInputField\n              Object val = parseNormalFieldValue(parser.nextEvent());\n              extendedInfo.put(label, val);\n            }\n            break;\n  \n          case JSONParser.OBJECT_END:\n            if (extendedInfo != null) {\n              if (normalFieldValue != null) {\n                extendedInfo.put(\"value\",normalFieldValue);\n              }\n              sif.setValue(extendedInfo, boost);\n            } else {\n              sif.setValue(normalFieldValue, boost);\n            }\n            return;\n  \n          default:\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing JSON extended field value. Unexpected \"+JSONParser.getEventString(ev) );\n        }\n      }\n    }\n\n","sourceOld":"    private void parseExtendedFieldValue(SolrInputField sif, int ev)  throws IOException {\n      assert ev == JSONParser.OBJECT_START;\n  \n      float boost = 1.0f;\n      Object normalFieldValue = null;\n      Map<String, Object> extendedInfo = null;\n  \n      for (;;) {\n        ev = parser.nextEvent();\n        switch (ev) {\n          case JSONParser.STRING:\n            String label = parser.getString();\n            if (\"boost\".equals(label)) {\n              ev = parser.nextEvent();\n              if( ev != JSONParser.NUMBER &&\n                  ev != JSONParser.LONG &&\n                  ev != JSONParser.BIGNUMBER ) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"boost should have number! \"+JSONParser.getEventString(ev) );\n              }\n  \n              boost = (float)parser.getDouble();\n            } else if (\"value\".equals(label)) {\n              normalFieldValue = parseNormalFieldValue(parser.nextEvent());\n            } else {\n              // If we encounter other unknown map keys, then use a map\n              if (extendedInfo == null) {\n                extendedInfo = new HashMap<String, Object>(2);\n              }\n              // for now, the only extended info will be field values\n              // we could either store this as an Object or a SolrInputField\n              Object val = parseNormalFieldValue(parser.nextEvent());\n              extendedInfo.put(label, val);\n            }\n            break;\n  \n          case JSONParser.OBJECT_END:\n            if (extendedInfo != null) {\n              if (normalFieldValue != null) {\n                extendedInfo.put(\"value\",normalFieldValue);\n              }\n              sif.setValue(extendedInfo, boost);\n            } else {\n              sif.setValue(normalFieldValue, boost);\n            }\n            return;\n  \n          default:\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing JSON extended field value. Unexpected \"+JSONParser.getEventString(ev) );\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab10d7c14ce9f8db61956611a57a5a377362a633","date":1413903184,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/JsonLoader.SingleThreadedJsonLoader#parseExtendedFieldValue(SolrInputField,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/JsonLoader.SingleThreadedJsonLoader#parseExtendedFieldValue(SolrInputField,int).mjava","sourceNew":"    private void parseExtendedFieldValue(SolrInputField sif, int ev)  throws IOException {\n      assert ev == JSONParser.OBJECT_START;\n\n      float boost = 1.0f;\n      Object normalFieldValue = null;\n      Map<String, Object> extendedInfo = null;\n\n      for (;;) {\n        ev = parser.nextEvent();\n        switch (ev) {\n          case JSONParser.STRING:\n            String label = parser.getString();\n            if (\"boost\".equals(label)) {\n              ev = parser.nextEvent();\n              if( ev != JSONParser.NUMBER &&\n                  ev != JSONParser.LONG &&\n                  ev != JSONParser.BIGNUMBER ) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"boost should have number! \"+JSONParser.getEventString(ev) );\n              }\n\n              boost = (float)parser.getDouble();\n            } else if (\"value\".equals(label)) {\n              normalFieldValue = parseNormalFieldValue(parser.nextEvent());\n            } else {\n              // If we encounter other unknown map keys, then use a map\n              if (extendedInfo == null) {\n                extendedInfo = new HashMap<>(2);\n              }\n              // for now, the only extended info will be field values\n              // we could either store this as an Object or a SolrInputField\n              Object val = parseNormalFieldValue(parser.nextEvent());\n              extendedInfo.put(label, val);\n            }\n            break;\n\n          case JSONParser.OBJECT_END:\n            if (extendedInfo != null) {\n              if (normalFieldValue != null) {\n                extendedInfo.put(\"value\",normalFieldValue);\n              }\n              sif.setValue(extendedInfo, boost);\n            } else {\n              sif.setValue(normalFieldValue, boost);\n            }\n            return;\n\n          default:\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing JSON extended field value. Unexpected \"+JSONParser.getEventString(ev) );\n        }\n      }\n    }\n\n","sourceOld":"    private void parseExtendedFieldValue(SolrInputField sif, int ev)  throws IOException {\n      assert ev == JSONParser.OBJECT_START;\n  \n      float boost = 1.0f;\n      Object normalFieldValue = null;\n      Map<String, Object> extendedInfo = null;\n  \n      for (;;) {\n        ev = parser.nextEvent();\n        switch (ev) {\n          case JSONParser.STRING:\n            String label = parser.getString();\n            if (\"boost\".equals(label)) {\n              ev = parser.nextEvent();\n              if( ev != JSONParser.NUMBER &&\n                  ev != JSONParser.LONG &&\n                  ev != JSONParser.BIGNUMBER ) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"boost should have number! \"+JSONParser.getEventString(ev) );\n              }\n  \n              boost = (float)parser.getDouble();\n            } else if (\"value\".equals(label)) {\n              normalFieldValue = parseNormalFieldValue(parser.nextEvent());\n            } else {\n              // If we encounter other unknown map keys, then use a map\n              if (extendedInfo == null) {\n                extendedInfo = new HashMap<>(2);\n              }\n              // for now, the only extended info will be field values\n              // we could either store this as an Object or a SolrInputField\n              Object val = parseNormalFieldValue(parser.nextEvent());\n              extendedInfo.put(label, val);\n            }\n            break;\n  \n          case JSONParser.OBJECT_END:\n            if (extendedInfo != null) {\n              if (normalFieldValue != null) {\n                extendedInfo.put(\"value\",normalFieldValue);\n              }\n              sif.setValue(extendedInfo, boost);\n            } else {\n              sif.setValue(normalFieldValue, boost);\n            }\n            return;\n  \n          default:\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing JSON extended field value. Unexpected \"+JSONParser.getEventString(ev) );\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a22eafe3f72a4c2945eaad9547e6c78816978f4","date":1413956657,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/JsonLoader.SingleThreadedJsonLoader#parseExtendedFieldValue(SolrInputField,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/JsonLoader.SingleThreadedJsonLoader#parseExtendedFieldValue(SolrInputField,int).mjava","sourceNew":"    private void parseExtendedFieldValue(SolrInputField sif, int ev)  throws IOException {\n      assert ev == JSONParser.OBJECT_START;\n\n      float boost = 1.0f;\n      Object normalFieldValue = null;\n      Map<String, Object> extendedInfo = null;\n\n      for (;;) {\n        ev = parser.nextEvent();\n        switch (ev) {\n          case JSONParser.STRING:\n            String label = parser.getString();\n            if (\"boost\".equals(label)) {\n              ev = parser.nextEvent();\n              if( ev != JSONParser.NUMBER &&\n                  ev != JSONParser.LONG &&\n                  ev != JSONParser.BIGNUMBER ) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"boost should have number! \"+JSONParser.getEventString(ev) );\n              }\n\n              boost = (float)parser.getDouble();\n            } else if (\"value\".equals(label)) {\n              normalFieldValue = parseNormalFieldValue(parser.nextEvent());\n            } else {\n              // If we encounter other unknown map keys, then use a map\n              if (extendedInfo == null) {\n                extendedInfo = new HashMap<>(2);\n              }\n              // for now, the only extended info will be field values\n              // we could either store this as an Object or a SolrInputField\n              Object val = parseNormalFieldValue(parser.nextEvent());\n              extendedInfo.put(label, val);\n            }\n            break;\n\n          case JSONParser.OBJECT_END:\n            if (extendedInfo != null) {\n              if (normalFieldValue != null) {\n                extendedInfo.put(\"value\",normalFieldValue);\n              }\n              sif.setValue(extendedInfo, boost);\n            } else {\n              sif.setValue(normalFieldValue, boost);\n            }\n            return;\n\n          default:\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing JSON extended field value. Unexpected \"+JSONParser.getEventString(ev) );\n        }\n      }\n    }\n\n","sourceOld":"    private void parseExtendedFieldValue(SolrInputField sif, int ev)  throws IOException {\n      assert ev == JSONParser.OBJECT_START;\n  \n      float boost = 1.0f;\n      Object normalFieldValue = null;\n      Map<String, Object> extendedInfo = null;\n  \n      for (;;) {\n        ev = parser.nextEvent();\n        switch (ev) {\n          case JSONParser.STRING:\n            String label = parser.getString();\n            if (\"boost\".equals(label)) {\n              ev = parser.nextEvent();\n              if( ev != JSONParser.NUMBER &&\n                  ev != JSONParser.LONG &&\n                  ev != JSONParser.BIGNUMBER ) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"boost should have number! \"+JSONParser.getEventString(ev) );\n              }\n  \n              boost = (float)parser.getDouble();\n            } else if (\"value\".equals(label)) {\n              normalFieldValue = parseNormalFieldValue(parser.nextEvent());\n            } else {\n              // If we encounter other unknown map keys, then use a map\n              if (extendedInfo == null) {\n                extendedInfo = new HashMap<>(2);\n              }\n              // for now, the only extended info will be field values\n              // we could either store this as an Object or a SolrInputField\n              Object val = parseNormalFieldValue(parser.nextEvent());\n              extendedInfo.put(label, val);\n            }\n            break;\n  \n          case JSONParser.OBJECT_END:\n            if (extendedInfo != null) {\n              if (normalFieldValue != null) {\n                extendedInfo.put(\"value\",normalFieldValue);\n              }\n              sif.setValue(extendedInfo, boost);\n            } else {\n              sif.setValue(normalFieldValue, boost);\n            }\n            return;\n  \n          default:\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing JSON extended field value. Unexpected \"+JSONParser.getEventString(ev) );\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a63f62e9f506b7a15c76fddc8ad5f22112070c2","date":1423521689,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/JsonLoader.SingleThreadedJsonLoader#parseExtendedFieldValue(SolrInputField,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/JsonLoader.SingleThreadedJsonLoader#parseExtendedFieldValue(SolrInputField,int).mjava","sourceNew":"    private void parseExtendedFieldValue(SolrInputField sif, int ev)  throws IOException {\n      assert ev == JSONParser.OBJECT_START;\n\n      float boost = 1.0f;\n      Object normalFieldValue = null;\n      Map<String, Object> extendedInfo = null;\n\n      for (;;) {\n        ev = parser.nextEvent();\n        switch (ev) {\n          case JSONParser.STRING:\n            String label = parser.getString();\n            if (\"boost\".equals(label)) {\n              ev = parser.nextEvent();\n              if( ev != JSONParser.NUMBER &&\n                  ev != JSONParser.LONG &&\n                  ev != JSONParser.BIGNUMBER ) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Boost should have number. \"\n                    + \"Unexpected \"+JSONParser.getEventString(ev)+\" at [\"+parser.getPosition()+\"], field=\"+sif.getName() );\n              }\n\n              boost = (float)parser.getDouble();\n            } else if (\"value\".equals(label)) {\n              normalFieldValue = parseNormalFieldValue(parser.nextEvent(), sif.getName());\n            } else {\n              // If we encounter other unknown map keys, then use a map\n              if (extendedInfo == null) {\n                extendedInfo = new HashMap<>(2);\n              }\n              // for now, the only extended info will be field values\n              // we could either store this as an Object or a SolrInputField\n              Object val = parseNormalFieldValue(parser.nextEvent(), sif.getName());\n              extendedInfo.put(label, val);\n            }\n            break;\n\n          case JSONParser.OBJECT_END:\n            if (extendedInfo != null) {\n              if (normalFieldValue != null) {\n                extendedInfo.put(\"value\",normalFieldValue);\n              }\n              sif.setValue(extendedInfo, boost);\n            } else {\n              sif.setValue(normalFieldValue, boost);\n            }\n            return;\n\n          default:\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing JSON extended field value. \"\n                + \"Unexpected \"+JSONParser.getEventString(ev)+\" at [\"+parser.getPosition()+\"], field=\"+sif.getName() );\n        }\n      }\n    }\n\n","sourceOld":"    private void parseExtendedFieldValue(SolrInputField sif, int ev)  throws IOException {\n      assert ev == JSONParser.OBJECT_START;\n\n      float boost = 1.0f;\n      Object normalFieldValue = null;\n      Map<String, Object> extendedInfo = null;\n\n      for (;;) {\n        ev = parser.nextEvent();\n        switch (ev) {\n          case JSONParser.STRING:\n            String label = parser.getString();\n            if (\"boost\".equals(label)) {\n              ev = parser.nextEvent();\n              if( ev != JSONParser.NUMBER &&\n                  ev != JSONParser.LONG &&\n                  ev != JSONParser.BIGNUMBER ) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"boost should have number! \"+JSONParser.getEventString(ev) );\n              }\n\n              boost = (float)parser.getDouble();\n            } else if (\"value\".equals(label)) {\n              normalFieldValue = parseNormalFieldValue(parser.nextEvent());\n            } else {\n              // If we encounter other unknown map keys, then use a map\n              if (extendedInfo == null) {\n                extendedInfo = new HashMap<>(2);\n              }\n              // for now, the only extended info will be field values\n              // we could either store this as an Object or a SolrInputField\n              Object val = parseNormalFieldValue(parser.nextEvent());\n              extendedInfo.put(label, val);\n            }\n            break;\n\n          case JSONParser.OBJECT_END:\n            if (extendedInfo != null) {\n              if (normalFieldValue != null) {\n                extendedInfo.put(\"value\",normalFieldValue);\n              }\n              sif.setValue(extendedInfo, boost);\n            } else {\n              sif.setValue(normalFieldValue, boost);\n            }\n            return;\n\n          default:\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing JSON extended field value. Unexpected \"+JSONParser.getEventString(ev) );\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6f5f8e831e266692b649e39dad7a64f525aa6d21","date":1427506910,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/JsonLoader.SingleThreadedJsonLoader#parseExtendedFieldValue(SolrInputField,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/JsonLoader.SingleThreadedJsonLoader#parseExtendedFieldValue(SolrInputField,int).mjava","sourceNew":"    private void parseExtendedFieldValue(SolrInputField sif, int ev) throws IOException {\n      assert ev == JSONParser.OBJECT_START;\n\n      float boost = 1.0f;\n      Object normalFieldValue = null;\n      Map<String, Object> extendedInfo = null;\n\n      for (; ; ) {\n        ev = parser.nextEvent();\n        switch (ev) {\n          case JSONParser.STRING:\n            String label = parser.getString();\n            if (\"boost\".equals(label)) {\n              ev = parser.nextEvent();\n              if (ev != JSONParser.NUMBER &&\n                  ev != JSONParser.LONG &&\n                  ev != JSONParser.BIGNUMBER) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Boost should have number. \"\n                    + \"Unexpected \" + JSONParser.getEventString(ev) + \" at [\" + parser.getPosition() + \"], field=\" + sif.getName());\n              }\n\n              boost = (float) parser.getDouble();\n            } else if (\"value\".equals(label)) {\n              normalFieldValue = parseNormalFieldValue(parser.nextEvent(), sif.getName());\n            } else {\n              // If we encounter other unknown map keys, then use a map\n              if (extendedInfo == null) {\n                extendedInfo = new HashMap<>(2);\n              }\n              // for now, the only extended info will be field values\n              // we could either store this as an Object or a SolrInputField\n              Object val = parseNormalFieldValue(parser.nextEvent(), sif.getName());\n              extendedInfo.put(label, val);\n            }\n            break;\n\n          case JSONParser.OBJECT_END:\n            if (extendedInfo != null) {\n              if (normalFieldValue != null) {\n                extendedInfo.put(\"value\", normalFieldValue);\n              }\n              sif.setValue(extendedInfo, boost);\n            } else {\n              sif.setValue(normalFieldValue, boost);\n            }\n            return;\n\n          default:\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing JSON extended field value. \"\n                + \"Unexpected \" + JSONParser.getEventString(ev) + \" at [\" + parser.getPosition() + \"], field=\" + sif.getName());\n        }\n      }\n    }\n\n","sourceOld":"    private void parseExtendedFieldValue(SolrInputField sif, int ev)  throws IOException {\n      assert ev == JSONParser.OBJECT_START;\n\n      float boost = 1.0f;\n      Object normalFieldValue = null;\n      Map<String, Object> extendedInfo = null;\n\n      for (;;) {\n        ev = parser.nextEvent();\n        switch (ev) {\n          case JSONParser.STRING:\n            String label = parser.getString();\n            if (\"boost\".equals(label)) {\n              ev = parser.nextEvent();\n              if( ev != JSONParser.NUMBER &&\n                  ev != JSONParser.LONG &&\n                  ev != JSONParser.BIGNUMBER ) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Boost should have number. \"\n                    + \"Unexpected \"+JSONParser.getEventString(ev)+\" at [\"+parser.getPosition()+\"], field=\"+sif.getName() );\n              }\n\n              boost = (float)parser.getDouble();\n            } else if (\"value\".equals(label)) {\n              normalFieldValue = parseNormalFieldValue(parser.nextEvent(), sif.getName());\n            } else {\n              // If we encounter other unknown map keys, then use a map\n              if (extendedInfo == null) {\n                extendedInfo = new HashMap<>(2);\n              }\n              // for now, the only extended info will be field values\n              // we could either store this as an Object or a SolrInputField\n              Object val = parseNormalFieldValue(parser.nextEvent(), sif.getName());\n              extendedInfo.put(label, val);\n            }\n            break;\n\n          case JSONParser.OBJECT_END:\n            if (extendedInfo != null) {\n              if (normalFieldValue != null) {\n                extendedInfo.put(\"value\",normalFieldValue);\n              }\n              sif.setValue(extendedInfo, boost);\n            } else {\n              sif.setValue(normalFieldValue, boost);\n            }\n            return;\n\n          default:\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing JSON extended field value. \"\n                + \"Unexpected \"+JSONParser.getEventString(ev)+\" at [\"+parser.getPosition()+\"], field=\"+sif.getName() );\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/JsonLoader.SingleThreadedJsonLoader#parseExtendedFieldValue(SolrInputField,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/JsonLoader.SingleThreadedJsonLoader#parseExtendedFieldValue(SolrInputField,int).mjava","sourceNew":"    private void parseExtendedFieldValue(SolrInputField sif, int ev) throws IOException {\n      assert ev == JSONParser.OBJECT_START;\n\n      float boost = 1.0f;\n      Object normalFieldValue = null;\n      Map<String, Object> extendedInfo = null;\n\n      for (; ; ) {\n        ev = parser.nextEvent();\n        switch (ev) {\n          case JSONParser.STRING:\n            String label = parser.getString();\n            if (\"boost\".equals(label)) {\n              ev = parser.nextEvent();\n              if (ev != JSONParser.NUMBER &&\n                  ev != JSONParser.LONG &&\n                  ev != JSONParser.BIGNUMBER) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Boost should have number. \"\n                    + \"Unexpected \" + JSONParser.getEventString(ev) + \" at [\" + parser.getPosition() + \"], field=\" + sif.getName());\n              }\n\n              boost = (float) parser.getDouble();\n            } else if (\"value\".equals(label)) {\n              normalFieldValue = parseNormalFieldValue(parser.nextEvent(), sif.getName());\n            } else {\n              // If we encounter other unknown map keys, then use a map\n              if (extendedInfo == null) {\n                extendedInfo = new HashMap<>(2);\n              }\n              // for now, the only extended info will be field values\n              // we could either store this as an Object or a SolrInputField\n              Object val = parseNormalFieldValue(parser.nextEvent(), sif.getName());\n              extendedInfo.put(label, val);\n            }\n            break;\n\n          case JSONParser.OBJECT_END:\n            if (extendedInfo != null) {\n              if (normalFieldValue != null) {\n                extendedInfo.put(\"value\", normalFieldValue);\n              }\n              sif.setValue(extendedInfo, boost);\n            } else {\n              sif.setValue(normalFieldValue, boost);\n            }\n            return;\n\n          default:\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing JSON extended field value. \"\n                + \"Unexpected \" + JSONParser.getEventString(ev) + \" at [\" + parser.getPosition() + \"], field=\" + sif.getName());\n        }\n      }\n    }\n\n","sourceOld":"    private void parseExtendedFieldValue(SolrInputField sif, int ev)  throws IOException {\n      assert ev == JSONParser.OBJECT_START;\n\n      float boost = 1.0f;\n      Object normalFieldValue = null;\n      Map<String, Object> extendedInfo = null;\n\n      for (;;) {\n        ev = parser.nextEvent();\n        switch (ev) {\n          case JSONParser.STRING:\n            String label = parser.getString();\n            if (\"boost\".equals(label)) {\n              ev = parser.nextEvent();\n              if( ev != JSONParser.NUMBER &&\n                  ev != JSONParser.LONG &&\n                  ev != JSONParser.BIGNUMBER ) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Boost should have number. \"\n                    + \"Unexpected \"+JSONParser.getEventString(ev)+\" at [\"+parser.getPosition()+\"], field=\"+sif.getName() );\n              }\n\n              boost = (float)parser.getDouble();\n            } else if (\"value\".equals(label)) {\n              normalFieldValue = parseNormalFieldValue(parser.nextEvent(), sif.getName());\n            } else {\n              // If we encounter other unknown map keys, then use a map\n              if (extendedInfo == null) {\n                extendedInfo = new HashMap<>(2);\n              }\n              // for now, the only extended info will be field values\n              // we could either store this as an Object or a SolrInputField\n              Object val = parseNormalFieldValue(parser.nextEvent(), sif.getName());\n              extendedInfo.put(label, val);\n            }\n            break;\n\n          case JSONParser.OBJECT_END:\n            if (extendedInfo != null) {\n              if (normalFieldValue != null) {\n                extendedInfo.put(\"value\",normalFieldValue);\n              }\n              sif.setValue(extendedInfo, boost);\n            } else {\n              sif.setValue(normalFieldValue, boost);\n            }\n            return;\n\n          default:\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing JSON extended field value. \"\n                + \"Unexpected \"+JSONParser.getEventString(ev)+\" at [\"+parser.getPosition()+\"], field=\"+sif.getName() );\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"acd9883560fd89e6448b2b447302fe543040cd4f","date":1488478696,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/loader/JsonLoader.SingleThreadedJsonLoader#parseExtendedFieldValue(SolrInputField,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/JsonLoader.SingleThreadedJsonLoader#parseExtendedFieldValue(SolrInputField,int).mjava","sourceNew":"    private void parseExtendedFieldValue(SolrInputField sif, int ev) throws IOException {\n      assert ev == JSONParser.OBJECT_START;\n\n      Object normalFieldValue = null;\n      Map<String, Object> extendedInfo = null;\n\n      for (; ; ) {\n        ev = parser.nextEvent();\n        switch (ev) {\n          case JSONParser.STRING:\n            String label = parser.getString();\n            if (\"boost\".equals(label)) {\n              ev = parser.nextEvent();\n              if (ev != JSONParser.NUMBER &&\n                  ev != JSONParser.LONG &&\n                  ev != JSONParser.BIGNUMBER) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Boost should have number. \"\n                    + \"Unexpected \" + JSONParser.getEventString(ev) + \" at [\" + parser.getPosition() + \"], field=\" + sif.getName());\n              }\n\n              String message = \"Ignoring field boost: \" + parser.getDouble() + \" as index-time boosts are not supported anymore\";\n              if (WARNED_ABOUT_INDEX_TIME_BOOSTS.compareAndSet(false, true)) {\n                log.warn(message);\n              } else {\n                log.debug(message);\n              }\n            } else if (\"value\".equals(label)) {\n              normalFieldValue = parseNormalFieldValue(parser.nextEvent(), sif.getName());\n            } else {\n              // If we encounter other unknown map keys, then use a map\n              if (extendedInfo == null) {\n                extendedInfo = new HashMap<>(2);\n              }\n              // for now, the only extended info will be field values\n              // we could either store this as an Object or a SolrInputField\n              Object val = parseNormalFieldValue(parser.nextEvent(), sif.getName());\n              extendedInfo.put(label, val);\n            }\n            break;\n\n          case JSONParser.OBJECT_END:\n            if (extendedInfo != null) {\n              if (normalFieldValue != null) {\n                extendedInfo.put(\"value\", normalFieldValue);\n              }\n              sif.setValue(extendedInfo);\n            } else {\n              sif.setValue(normalFieldValue);\n            }\n            return;\n\n          default:\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing JSON extended field value. \"\n                + \"Unexpected \" + JSONParser.getEventString(ev) + \" at [\" + parser.getPosition() + \"], field=\" + sif.getName());\n        }\n      }\n    }\n\n","sourceOld":"    private void parseExtendedFieldValue(SolrInputField sif, int ev) throws IOException {\n      assert ev == JSONParser.OBJECT_START;\n\n      float boost = 1.0f;\n      Object normalFieldValue = null;\n      Map<String, Object> extendedInfo = null;\n\n      for (; ; ) {\n        ev = parser.nextEvent();\n        switch (ev) {\n          case JSONParser.STRING:\n            String label = parser.getString();\n            if (\"boost\".equals(label)) {\n              ev = parser.nextEvent();\n              if (ev != JSONParser.NUMBER &&\n                  ev != JSONParser.LONG &&\n                  ev != JSONParser.BIGNUMBER) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Boost should have number. \"\n                    + \"Unexpected \" + JSONParser.getEventString(ev) + \" at [\" + parser.getPosition() + \"], field=\" + sif.getName());\n              }\n\n              boost = (float) parser.getDouble();\n            } else if (\"value\".equals(label)) {\n              normalFieldValue = parseNormalFieldValue(parser.nextEvent(), sif.getName());\n            } else {\n              // If we encounter other unknown map keys, then use a map\n              if (extendedInfo == null) {\n                extendedInfo = new HashMap<>(2);\n              }\n              // for now, the only extended info will be field values\n              // we could either store this as an Object or a SolrInputField\n              Object val = parseNormalFieldValue(parser.nextEvent(), sif.getName());\n              extendedInfo.put(label, val);\n            }\n            break;\n\n          case JSONParser.OBJECT_END:\n            if (extendedInfo != null) {\n              if (normalFieldValue != null) {\n                extendedInfo.put(\"value\", normalFieldValue);\n              }\n              sif.setValue(extendedInfo, boost);\n            } else {\n              sif.setValue(normalFieldValue, boost);\n            }\n            return;\n\n          default:\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing JSON extended field value. \"\n                + \"Unexpected \" + JSONParser.getEventString(ev) + \" at [\" + parser.getPosition() + \"], field=\" + sif.getName());\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9440b5b1eec7788a0edd10385e4d7a614d1024d7","date":1528992889,"type":4,"author":"user","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/JsonLoader.SingleThreadedJsonLoader#parseExtendedFieldValue(SolrInputField,int).mjava","sourceNew":null,"sourceOld":"    private void parseExtendedFieldValue(SolrInputField sif, int ev) throws IOException {\n      assert ev == JSONParser.OBJECT_START;\n\n      Object normalFieldValue = null;\n      Map<String, Object> extendedInfo = null;\n\n      for (; ; ) {\n        ev = parser.nextEvent();\n        switch (ev) {\n          case JSONParser.STRING:\n            String label = parser.getString();\n            if (\"boost\".equals(label)) {\n              ev = parser.nextEvent();\n              if (ev != JSONParser.NUMBER &&\n                  ev != JSONParser.LONG &&\n                  ev != JSONParser.BIGNUMBER) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Boost should have number. \"\n                    + \"Unexpected \" + JSONParser.getEventString(ev) + \" at [\" + parser.getPosition() + \"], field=\" + sif.getName());\n              }\n\n              String message = \"Ignoring field boost: \" + parser.getDouble() + \" as index-time boosts are not supported anymore\";\n              if (WARNED_ABOUT_INDEX_TIME_BOOSTS.compareAndSet(false, true)) {\n                log.warn(message);\n              } else {\n                log.debug(message);\n              }\n            } else if (\"value\".equals(label)) {\n              normalFieldValue = parseNormalFieldValue(parser.nextEvent(), sif.getName());\n            } else {\n              // If we encounter other unknown map keys, then use a map\n              if (extendedInfo == null) {\n                extendedInfo = new HashMap<>(2);\n              }\n              // for now, the only extended info will be field values\n              // we could either store this as an Object or a SolrInputField\n              Object val = parseNormalFieldValue(parser.nextEvent(), sif.getName());\n              extendedInfo.put(label, val);\n            }\n            break;\n\n          case JSONParser.OBJECT_END:\n            if (extendedInfo != null) {\n              if (normalFieldValue != null) {\n                extendedInfo.put(\"value\", normalFieldValue);\n              }\n              sif.setValue(extendedInfo);\n            } else {\n              sif.setValue(normalFieldValue);\n            }\n            return;\n\n          default:\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing JSON extended field value. \"\n                + \"Unexpected \" + JSONParser.getEventString(ev) + \" at [\" + parser.getPosition() + \"], field=\" + sif.getName());\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":4,"author":"Michael Braun","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/JsonLoader.SingleThreadedJsonLoader#parseExtendedFieldValue(SolrInputField,int).mjava","sourceNew":null,"sourceOld":"    private void parseExtendedFieldValue(SolrInputField sif, int ev) throws IOException {\n      assert ev == JSONParser.OBJECT_START;\n\n      Object normalFieldValue = null;\n      Map<String, Object> extendedInfo = null;\n\n      for (; ; ) {\n        ev = parser.nextEvent();\n        switch (ev) {\n          case JSONParser.STRING:\n            String label = parser.getString();\n            if (\"boost\".equals(label)) {\n              ev = parser.nextEvent();\n              if (ev != JSONParser.NUMBER &&\n                  ev != JSONParser.LONG &&\n                  ev != JSONParser.BIGNUMBER) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Boost should have number. \"\n                    + \"Unexpected \" + JSONParser.getEventString(ev) + \" at [\" + parser.getPosition() + \"], field=\" + sif.getName());\n              }\n\n              String message = \"Ignoring field boost: \" + parser.getDouble() + \" as index-time boosts are not supported anymore\";\n              if (WARNED_ABOUT_INDEX_TIME_BOOSTS.compareAndSet(false, true)) {\n                log.warn(message);\n              } else {\n                log.debug(message);\n              }\n            } else if (\"value\".equals(label)) {\n              normalFieldValue = parseNormalFieldValue(parser.nextEvent(), sif.getName());\n            } else {\n              // If we encounter other unknown map keys, then use a map\n              if (extendedInfo == null) {\n                extendedInfo = new HashMap<>(2);\n              }\n              // for now, the only extended info will be field values\n              // we could either store this as an Object or a SolrInputField\n              Object val = parseNormalFieldValue(parser.nextEvent(), sif.getName());\n              extendedInfo.put(label, val);\n            }\n            break;\n\n          case JSONParser.OBJECT_END:\n            if (extendedInfo != null) {\n              if (normalFieldValue != null) {\n                extendedInfo.put(\"value\", normalFieldValue);\n              }\n              sif.setValue(extendedInfo);\n            } else {\n              sif.setValue(normalFieldValue);\n            }\n            return;\n\n          default:\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing JSON extended field value. \"\n                + \"Unexpected \" + JSONParser.getEventString(ev) + \" at [\" + parser.getPosition() + \"], field=\" + sif.getName());\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":4,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/handler/loader/JsonLoader.SingleThreadedJsonLoader#parseExtendedFieldValue(SolrInputField,int).mjava","sourceNew":null,"sourceOld":"    private void parseExtendedFieldValue(SolrInputField sif, int ev) throws IOException {\n      assert ev == JSONParser.OBJECT_START;\n\n      Object normalFieldValue = null;\n      Map<String, Object> extendedInfo = null;\n\n      for (; ; ) {\n        ev = parser.nextEvent();\n        switch (ev) {\n          case JSONParser.STRING:\n            String label = parser.getString();\n            if (\"boost\".equals(label)) {\n              ev = parser.nextEvent();\n              if (ev != JSONParser.NUMBER &&\n                  ev != JSONParser.LONG &&\n                  ev != JSONParser.BIGNUMBER) {\n                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Boost should have number. \"\n                    + \"Unexpected \" + JSONParser.getEventString(ev) + \" at [\" + parser.getPosition() + \"], field=\" + sif.getName());\n              }\n\n              String message = \"Ignoring field boost: \" + parser.getDouble() + \" as index-time boosts are not supported anymore\";\n              if (WARNED_ABOUT_INDEX_TIME_BOOSTS.compareAndSet(false, true)) {\n                log.warn(message);\n              } else {\n                log.debug(message);\n              }\n            } else if (\"value\".equals(label)) {\n              normalFieldValue = parseNormalFieldValue(parser.nextEvent(), sif.getName());\n            } else {\n              // If we encounter other unknown map keys, then use a map\n              if (extendedInfo == null) {\n                extendedInfo = new HashMap<>(2);\n              }\n              // for now, the only extended info will be field values\n              // we could either store this as an Object or a SolrInputField\n              Object val = parseNormalFieldValue(parser.nextEvent(), sif.getName());\n              extendedInfo.put(label, val);\n            }\n            break;\n\n          case JSONParser.OBJECT_END:\n            if (extendedInfo != null) {\n              if (normalFieldValue != null) {\n                extendedInfo.put(\"value\", normalFieldValue);\n              }\n              sif.setValue(extendedInfo);\n            } else {\n              sif.setValue(normalFieldValue);\n            }\n            return;\n\n          default:\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error parsing JSON extended field value. \"\n                + \"Unexpected \" + JSONParser.getEventString(ev) + \" at [\" + parser.getPosition() + \"], field=\" + sif.getName());\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["042e4d934397657ba04c82b46cc5665076bc5c58"],"9440b5b1eec7788a0edd10385e4d7a614d1024d7":["acd9883560fd89e6448b2b447302fe543040cd4f"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["2a63f62e9f506b7a15c76fddc8ad5f22112070c2","6f5f8e831e266692b649e39dad7a64f525aa6d21"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["acd9883560fd89e6448b2b447302fe543040cd4f","9440b5b1eec7788a0edd10385e4d7a614d1024d7"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","ab10d7c14ce9f8db61956611a57a5a377362a633"],"6f5f8e831e266692b649e39dad7a64f525aa6d21":["2a63f62e9f506b7a15c76fddc8ad5f22112070c2"],"ab10d7c14ce9f8db61956611a57a5a377362a633":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"042e4d934397657ba04c82b46cc5665076bc5c58":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2a63f62e9f506b7a15c76fddc8ad5f22112070c2":["ab10d7c14ce9f8db61956611a57a5a377362a633"],"acd9883560fd89e6448b2b447302fe543040cd4f":["6f5f8e831e266692b649e39dad7a64f525aa6d21"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9440b5b1eec7788a0edd10385e4d7a614d1024d7"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["acd9883560fd89e6448b2b447302fe543040cd4f","9440b5b1eec7788a0edd10385e4d7a614d1024d7"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["0a22eafe3f72a4c2945eaad9547e6c78816978f4","ab10d7c14ce9f8db61956611a57a5a377362a633"],"9440b5b1eec7788a0edd10385e4d7a614d1024d7":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":[],"6f5f8e831e266692b649e39dad7a64f525aa6d21":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","acd9883560fd89e6448b2b447302fe543040cd4f"],"042e4d934397657ba04c82b46cc5665076bc5c58":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"ab10d7c14ce9f8db61956611a57a5a377362a633":["0a22eafe3f72a4c2945eaad9547e6c78816978f4","2a63f62e9f506b7a15c76fddc8ad5f22112070c2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["042e4d934397657ba04c82b46cc5665076bc5c58"],"2a63f62e9f506b7a15c76fddc8ad5f22112070c2":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","6f5f8e831e266692b649e39dad7a64f525aa6d21"],"acd9883560fd89e6448b2b447302fe543040cd4f":["9440b5b1eec7788a0edd10385e4d7a614d1024d7","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","0a22eafe3f72a4c2945eaad9547e6c78816978f4","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}