{"path":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getSegmentsInfo(SolrQueryRequest,SolrQueryResponse).mjava","commits":[{"id":"26db0fd7da61a97dcbf4558f4fd1ebed330bbd45","date":1425862488,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getSegmentsInfo(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"/dev/null","sourceNew":"  private SimpleOrderedMap<Object> getSegmentsInfo(SolrQueryRequest req, SolrQueryResponse rsp)\n      throws Exception {\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    SegmentInfos infos =\n        SegmentInfos.readLatestCommit(searcher.getIndexReader().directory());\n\n    List<String> mergeCandidates = getMergeCandidatesNames(req, infos);\n\n    SimpleOrderedMap<Object> segmentInfos = new SimpleOrderedMap<>();\n    SimpleOrderedMap<Object> segmentInfo = null;\n    for (SegmentCommitInfo segmentCommitInfo : infos) {\n      segmentInfo = getSegmentInfo(segmentCommitInfo);\n      if (mergeCandidates.contains(segmentCommitInfo.info.name)) {\n        segmentInfo.add(\"mergeCandidate\", true);\n      }\n      segmentInfos.add((String) segmentInfo.get(\"name\"), segmentInfo);\n    }\n\n    return segmentInfos;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":0,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getSegmentsInfo(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"/dev/null","sourceNew":"  private SimpleOrderedMap<Object> getSegmentsInfo(SolrQueryRequest req, SolrQueryResponse rsp)\n      throws Exception {\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    SegmentInfos infos =\n        SegmentInfos.readLatestCommit(searcher.getIndexReader().directory());\n\n    List<String> mergeCandidates = getMergeCandidatesNames(req, infos);\n\n    SimpleOrderedMap<Object> segmentInfos = new SimpleOrderedMap<>();\n    SimpleOrderedMap<Object> segmentInfo = null;\n    for (SegmentCommitInfo segmentCommitInfo : infos) {\n      segmentInfo = getSegmentInfo(segmentCommitInfo);\n      if (mergeCandidates.contains(segmentCommitInfo.info.name)) {\n        segmentInfo.add(\"mergeCandidate\", true);\n      }\n      segmentInfos.add((String) segmentInfo.get(\"name\"), segmentInfo);\n    }\n\n    return segmentInfos;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1390137e395d2f07f9ba5b8c43d293befe84d563","date":1427947685,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getSegmentsInfo(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getSegmentsInfo(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  private SimpleOrderedMap<Object> getSegmentsInfo(SolrQueryRequest req, SolrQueryResponse rsp)\n      throws Exception {\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    SegmentInfos infos =\n        SegmentInfos.readLatestCommit(searcher.getIndexReader().directory());\n\n    List<String> mergeCandidates = getMergeCandidatesNames(req, infos);\n\n    SimpleOrderedMap<Object> segmentInfos = new SimpleOrderedMap<>();\n    SimpleOrderedMap<Object> segmentInfo = null;\n    for (SegmentCommitInfo segmentCommitInfo : infos) {\n      segmentInfo = getSegmentInfo(segmentCommitInfo);\n      if (mergeCandidates.contains(segmentCommitInfo.info.name)) {\n        segmentInfo.add(\"mergeCandidate\", true);\n      }\n      segmentInfos.add((String) segmentInfo.get(NAME), segmentInfo);\n    }\n\n    return segmentInfos;\n  }\n\n","sourceOld":"  private SimpleOrderedMap<Object> getSegmentsInfo(SolrQueryRequest req, SolrQueryResponse rsp)\n      throws Exception {\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    SegmentInfos infos =\n        SegmentInfos.readLatestCommit(searcher.getIndexReader().directory());\n\n    List<String> mergeCandidates = getMergeCandidatesNames(req, infos);\n\n    SimpleOrderedMap<Object> segmentInfos = new SimpleOrderedMap<>();\n    SimpleOrderedMap<Object> segmentInfo = null;\n    for (SegmentCommitInfo segmentCommitInfo : infos) {\n      segmentInfo = getSegmentInfo(segmentCommitInfo);\n      if (mergeCandidates.contains(segmentCommitInfo.info.name)) {\n        segmentInfo.add(\"mergeCandidate\", true);\n      }\n      segmentInfos.add((String) segmentInfo.get(\"name\"), segmentInfo);\n    }\n\n    return segmentInfos;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getSegmentsInfo(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getSegmentsInfo(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  private SimpleOrderedMap<Object> getSegmentsInfo(SolrQueryRequest req, SolrQueryResponse rsp)\n      throws Exception {\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    SegmentInfos infos =\n        SegmentInfos.readLatestCommit(searcher.getIndexReader().directory());\n\n    List<String> mergeCandidates = getMergeCandidatesNames(req, infos);\n\n    SimpleOrderedMap<Object> segmentInfos = new SimpleOrderedMap<>();\n    SimpleOrderedMap<Object> segmentInfo = null;\n    for (SegmentCommitInfo segmentCommitInfo : infos) {\n      segmentInfo = getSegmentInfo(segmentCommitInfo);\n      if (mergeCandidates.contains(segmentCommitInfo.info.name)) {\n        segmentInfo.add(\"mergeCandidate\", true);\n      }\n      segmentInfos.add((String) segmentInfo.get(NAME), segmentInfo);\n    }\n\n    return segmentInfos;\n  }\n\n","sourceOld":"  private SimpleOrderedMap<Object> getSegmentsInfo(SolrQueryRequest req, SolrQueryResponse rsp)\n      throws Exception {\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    SegmentInfos infos =\n        SegmentInfos.readLatestCommit(searcher.getIndexReader().directory());\n\n    List<String> mergeCandidates = getMergeCandidatesNames(req, infos);\n\n    SimpleOrderedMap<Object> segmentInfos = new SimpleOrderedMap<>();\n    SimpleOrderedMap<Object> segmentInfo = null;\n    for (SegmentCommitInfo segmentCommitInfo : infos) {\n      segmentInfo = getSegmentInfo(segmentCommitInfo);\n      if (mergeCandidates.contains(segmentCommitInfo.info.name)) {\n        segmentInfo.add(\"mergeCandidate\", true);\n      }\n      segmentInfos.add((String) segmentInfo.get(\"name\"), segmentInfo);\n    }\n\n    return segmentInfos;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56fb5e4e4b239474721e13b4cd9542ea2d215451","date":1529091182,"type":3,"author":"Erick","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getSegmentsInfo(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getSegmentsInfo(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  private SimpleOrderedMap<Object> getSegmentsInfo(SolrQueryRequest req, SolrQueryResponse rsp)\n      throws Exception {\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    SegmentInfos infos =\n        SegmentInfos.readLatestCommit(searcher.getIndexReader().directory());\n\n    List<String> mergeCandidates = getMergeCandidatesNames(req, infos);\n\n    SimpleOrderedMap<Object> segmentInfos = new SimpleOrderedMap<>();\n    SimpleOrderedMap<Object> segmentInfo = null;\n    List<SegmentCommitInfo> sortable = new ArrayList<>();\n    sortable.addAll(infos.asList());\n    // Order by the number of live docs. The display is logarithmic so it is a little jumbled visually\n    sortable.sort((s1, s2) -> {\n      return (s2.info.maxDoc() - s2.getDelCount()) - (s1.info.maxDoc() - s1.getDelCount());\n    });\n    for (SegmentCommitInfo segmentCommitInfo : sortable) {\n      segmentInfo = getSegmentInfo(segmentCommitInfo);\n      if (mergeCandidates.contains(segmentCommitInfo.info.name)) {\n        segmentInfo.add(\"mergeCandidate\", true);\n      }\n      segmentInfos.add((String) segmentInfo.get(NAME), segmentInfo);\n    }\n\n    return segmentInfos;\n  }\n\n","sourceOld":"  private SimpleOrderedMap<Object> getSegmentsInfo(SolrQueryRequest req, SolrQueryResponse rsp)\n      throws Exception {\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    SegmentInfos infos =\n        SegmentInfos.readLatestCommit(searcher.getIndexReader().directory());\n\n    List<String> mergeCandidates = getMergeCandidatesNames(req, infos);\n\n    SimpleOrderedMap<Object> segmentInfos = new SimpleOrderedMap<>();\n    SimpleOrderedMap<Object> segmentInfo = null;\n    for (SegmentCommitInfo segmentCommitInfo : infos) {\n      segmentInfo = getSegmentInfo(segmentCommitInfo);\n      if (mergeCandidates.contains(segmentCommitInfo.info.name)) {\n        segmentInfo.add(\"mergeCandidate\", true);\n      }\n      segmentInfos.add((String) segmentInfo.get(NAME), segmentInfo);\n    }\n\n    return segmentInfos;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getSegmentsInfo(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getSegmentsInfo(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  private SimpleOrderedMap<Object> getSegmentsInfo(SolrQueryRequest req, SolrQueryResponse rsp)\n      throws Exception {\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    SegmentInfos infos =\n        SegmentInfos.readLatestCommit(searcher.getIndexReader().directory());\n\n    List<String> mergeCandidates = getMergeCandidatesNames(req, infos);\n\n    SimpleOrderedMap<Object> segmentInfos = new SimpleOrderedMap<>();\n    SimpleOrderedMap<Object> segmentInfo = null;\n    List<SegmentCommitInfo> sortable = new ArrayList<>();\n    sortable.addAll(infos.asList());\n    // Order by the number of live docs. The display is logarithmic so it is a little jumbled visually\n    sortable.sort((s1, s2) -> {\n      return (s2.info.maxDoc() - s2.getDelCount()) - (s1.info.maxDoc() - s1.getDelCount());\n    });\n    for (SegmentCommitInfo segmentCommitInfo : sortable) {\n      segmentInfo = getSegmentInfo(segmentCommitInfo);\n      if (mergeCandidates.contains(segmentCommitInfo.info.name)) {\n        segmentInfo.add(\"mergeCandidate\", true);\n      }\n      segmentInfos.add((String) segmentInfo.get(NAME), segmentInfo);\n    }\n\n    return segmentInfos;\n  }\n\n","sourceOld":"  private SimpleOrderedMap<Object> getSegmentsInfo(SolrQueryRequest req, SolrQueryResponse rsp)\n      throws Exception {\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    SegmentInfos infos =\n        SegmentInfos.readLatestCommit(searcher.getIndexReader().directory());\n\n    List<String> mergeCandidates = getMergeCandidatesNames(req, infos);\n\n    SimpleOrderedMap<Object> segmentInfos = new SimpleOrderedMap<>();\n    SimpleOrderedMap<Object> segmentInfo = null;\n    for (SegmentCommitInfo segmentCommitInfo : infos) {\n      segmentInfo = getSegmentInfo(segmentCommitInfo);\n      if (mergeCandidates.contains(segmentCommitInfo.info.name)) {\n        segmentInfo.add(\"mergeCandidate\", true);\n      }\n      segmentInfos.add((String) segmentInfo.get(NAME), segmentInfo);\n    }\n\n    return segmentInfos;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getSegmentsInfo(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getSegmentsInfo(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  private SimpleOrderedMap<Object> getSegmentsInfo(SolrQueryRequest req, SolrQueryResponse rsp)\n      throws Exception {\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    SegmentInfos infos =\n        SegmentInfos.readLatestCommit(searcher.getIndexReader().directory());\n\n    List<String> mergeCandidates = getMergeCandidatesNames(req, infos);\n\n    SimpleOrderedMap<Object> segmentInfos = new SimpleOrderedMap<>();\n    SimpleOrderedMap<Object> segmentInfo = null;\n    List<SegmentCommitInfo> sortable = new ArrayList<>();\n    sortable.addAll(infos.asList());\n    // Order by the number of live docs. The display is logarithmic so it is a little jumbled visually\n    sortable.sort((s1, s2) -> {\n      return (s2.info.maxDoc() - s2.getDelCount()) - (s1.info.maxDoc() - s1.getDelCount());\n    });\n    for (SegmentCommitInfo segmentCommitInfo : sortable) {\n      segmentInfo = getSegmentInfo(segmentCommitInfo);\n      if (mergeCandidates.contains(segmentCommitInfo.info.name)) {\n        segmentInfo.add(\"mergeCandidate\", true);\n      }\n      segmentInfos.add((String) segmentInfo.get(NAME), segmentInfo);\n    }\n\n    return segmentInfos;\n  }\n\n","sourceOld":"  private SimpleOrderedMap<Object> getSegmentsInfo(SolrQueryRequest req, SolrQueryResponse rsp)\n      throws Exception {\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    SegmentInfos infos =\n        SegmentInfos.readLatestCommit(searcher.getIndexReader().directory());\n\n    List<String> mergeCandidates = getMergeCandidatesNames(req, infos);\n\n    SimpleOrderedMap<Object> segmentInfos = new SimpleOrderedMap<>();\n    SimpleOrderedMap<Object> segmentInfo = null;\n    for (SegmentCommitInfo segmentCommitInfo : infos) {\n      segmentInfo = getSegmentInfo(segmentCommitInfo);\n      if (mergeCandidates.contains(segmentCommitInfo.info.name)) {\n        segmentInfo.add(\"mergeCandidate\", true);\n      }\n      segmentInfos.add((String) segmentInfo.get(NAME), segmentInfo);\n    }\n\n    return segmentInfos;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3470ed04f0378c1ceb02e540e3296dd27c0ae3d5","date":1552136881,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getSegmentsInfo(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getSegmentsInfo(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  private void getSegmentsInfo(SolrQueryRequest req, SolrQueryResponse rsp)\n      throws Exception {\n    boolean withFieldInfo = req.getParams().getBool(WITH_FIELD_INFO, false);\n    boolean withCoreInfo = req.getParams().getBool(WITH_CORE_INFO, false);\n    boolean withSizeInfo = req.getParams().getBool(WITH_SIZE_INFO, false);\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    SegmentInfos infos =\n        SegmentInfos.readLatestCommit(searcher.getIndexReader().directory());\n\n    SimpleOrderedMap<Object> segmentInfos = new SimpleOrderedMap<>();\n\n    SolrCore core = req.getCore();\n    RefCounted<IndexWriter> iwRef = core.getSolrCoreState().getIndexWriter(core);\n    SimpleOrderedMap<Object> infosInfo = new SimpleOrderedMap<>();\n    Version minVersion = infos.getMinSegmentLuceneVersion();\n    if (minVersion != null) {\n      infosInfo.add(\"minSegmentLuceneVersion\", minVersion.toString());\n    }\n    Version commitVersion = infos.getCommitLuceneVersion();\n    if (commitVersion != null) {\n      infosInfo.add(\"commitLuceneVersion\", commitVersion.toString());\n    }\n    infosInfo.add(\"numSegments\", infos.size());\n    infosInfo.add(\"segmentsFileName\", infos.getSegmentsFileName());\n    infosInfo.add(\"totalMaxDoc\", infos.totalMaxDoc());\n    infosInfo.add(\"userData\", infos.userData);\n    if (withCoreInfo) {\n      SimpleOrderedMap<Object> coreInfo = new SimpleOrderedMap<>();\n      infosInfo.add(\"core\", coreInfo);\n      coreInfo.add(\"startTime\", core.getStartTimeStamp().getTime() + \"(\" + core.getStartTimeStamp() + \")\");\n      coreInfo.add(\"dataDir\", core.getDataDir());\n      coreInfo.add(\"indexDir\", core.getIndexDir());\n      coreInfo.add(\"sizeInGB\", (double)core.getIndexSize() / GB);\n\n      if (iwRef != null) {\n        try {\n          IndexWriter iw = iwRef.get();\n          String iwConfigStr = iw.getConfig().toString();\n          SimpleOrderedMap<Object> iwConfig = new SimpleOrderedMap<>();\n          // meh ...\n          String[] lines = iwConfigStr.split(\"\\\\n\");\n          for (String line : lines) {\n            String[] parts = line.split(\"=\");\n            if (parts.length < 2) {\n              continue;\n            }\n            iwConfig.add(parts[0], parts[1]);\n          }\n          coreInfo.add(\"indexWriterConfig\", iwConfig);\n        } finally {\n          iwRef.decref();\n        }\n      }\n    }\n    SimpleOrderedMap<Object> segmentInfo = null;\n    List<SegmentCommitInfo> sortable = new ArrayList<>();\n    sortable.addAll(infos.asList());\n    // Order by the number of live docs. The display is logarithmic so it is a little jumbled visually\n    sortable.sort((s1, s2) ->\n      (s2.info.maxDoc() - s2.getDelCount()) - (s1.info.maxDoc() - s1.getDelCount())\n    );\n\n    List<String> mergeCandidates = new ArrayList<>();\n    SimpleOrderedMap<Object> runningMerges = getMergeInformation(req, infos, mergeCandidates);\n    List<LeafReaderContext> leafContexts = searcher.getIndexReader().leaves();\n    IndexSchema schema = req.getSchema();\n    for (SegmentCommitInfo segmentCommitInfo : sortable) {\n      segmentInfo = getSegmentInfo(segmentCommitInfo, withSizeInfo, withFieldInfo, leafContexts, schema);\n      if (mergeCandidates.contains(segmentCommitInfo.info.name)) {\n        segmentInfo.add(\"mergeCandidate\", true);\n      }\n      segmentInfos.add((String) segmentInfo.get(NAME), segmentInfo);\n    }\n\n    rsp.add(\"info\", infosInfo);\n    if (runningMerges.size() > 0) {\n      rsp.add(\"runningMerges\", runningMerges);\n    }\n    if (withFieldInfo) {\n      rsp.add(\"fieldInfoLegend\", FI_LEGEND);\n    }\n    rsp.add(\"segments\", segmentInfos);\n  }\n\n","sourceOld":"  private SimpleOrderedMap<Object> getSegmentsInfo(SolrQueryRequest req, SolrQueryResponse rsp)\n      throws Exception {\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    SegmentInfos infos =\n        SegmentInfos.readLatestCommit(searcher.getIndexReader().directory());\n\n    List<String> mergeCandidates = getMergeCandidatesNames(req, infos);\n\n    SimpleOrderedMap<Object> segmentInfos = new SimpleOrderedMap<>();\n    SimpleOrderedMap<Object> segmentInfo = null;\n    List<SegmentCommitInfo> sortable = new ArrayList<>();\n    sortable.addAll(infos.asList());\n    // Order by the number of live docs. The display is logarithmic so it is a little jumbled visually\n    sortable.sort((s1, s2) -> {\n      return (s2.info.maxDoc() - s2.getDelCount()) - (s1.info.maxDoc() - s1.getDelCount());\n    });\n    for (SegmentCommitInfo segmentCommitInfo : sortable) {\n      segmentInfo = getSegmentInfo(segmentCommitInfo);\n      if (mergeCandidates.contains(segmentCommitInfo.info.name)) {\n        segmentInfo.add(\"mergeCandidate\", true);\n      }\n      segmentInfos.add((String) segmentInfo.get(NAME), segmentInfo);\n    }\n\n    return segmentInfos;\n  }\n\n","bugFix":null,"bugIntro":["133525af0aa09d87ef4258fd43eed160b462b313"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e4583dbd381e291c87e23144564c59ba3391b188","date":1560187306,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getSegmentsInfo(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getSegmentsInfo(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  private void getSegmentsInfo(SolrQueryRequest req, SolrQueryResponse rsp)\n      throws Exception {\n    boolean withFieldInfo = req.getParams().getBool(FIELD_INFO_PARAM, false);\n    boolean withCoreInfo = req.getParams().getBool(CORE_INFO_PARAM, false);\n    boolean withSizeInfo = req.getParams().getBool(SIZE_INFO_PARAM, false);\n    boolean withRawSizeInfo = req.getParams().getBool(RAW_SIZE_PARAM, false);\n    boolean withRawSizeSummary = req.getParams().getBool(RAW_SIZE_SUMMARY_PARAM, false);\n    boolean withRawSizeDetails = req.getParams().getBool(RAW_SIZE_DETAILS_PARAM, false);\n    if (withRawSizeSummary || withRawSizeDetails) {\n      withRawSizeInfo  = true;\n    }\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    SegmentInfos infos =\n        SegmentInfos.readLatestCommit(searcher.getIndexReader().directory());\n\n    SimpleOrderedMap<Object> segmentInfos = new SimpleOrderedMap<>();\n\n    SolrCore core = req.getCore();\n    RefCounted<IndexWriter> iwRef = core.getSolrCoreState().getIndexWriter(core);\n    SimpleOrderedMap<Object> infosInfo = new SimpleOrderedMap<>();\n    Version minVersion = infos.getMinSegmentLuceneVersion();\n    if (minVersion != null) {\n      infosInfo.add(\"minSegmentLuceneVersion\", minVersion.toString());\n    }\n    Version commitVersion = infos.getCommitLuceneVersion();\n    if (commitVersion != null) {\n      infosInfo.add(\"commitLuceneVersion\", commitVersion.toString());\n    }\n    infosInfo.add(\"numSegments\", infos.size());\n    infosInfo.add(\"segmentsFileName\", infos.getSegmentsFileName());\n    infosInfo.add(\"totalMaxDoc\", infos.totalMaxDoc());\n    infosInfo.add(\"userData\", infos.userData);\n    if (withCoreInfo) {\n      SimpleOrderedMap<Object> coreInfo = new SimpleOrderedMap<>();\n      infosInfo.add(\"core\", coreInfo);\n      coreInfo.add(\"startTime\", core.getStartTimeStamp().getTime() + \"(\" + core.getStartTimeStamp() + \")\");\n      coreInfo.add(\"dataDir\", core.getDataDir());\n      coreInfo.add(\"indexDir\", core.getIndexDir());\n      coreInfo.add(\"sizeInGB\", (double)core.getIndexSize() / GB);\n\n      if (iwRef != null) {\n        try {\n          IndexWriter iw = iwRef.get();\n          String iwConfigStr = iw.getConfig().toString();\n          SimpleOrderedMap<Object> iwConfig = new SimpleOrderedMap<>();\n          // meh ...\n          String[] lines = iwConfigStr.split(\"\\\\n\");\n          for (String line : lines) {\n            String[] parts = line.split(\"=\");\n            if (parts.length < 2) {\n              continue;\n            }\n            iwConfig.add(parts[0], parts[1]);\n          }\n          coreInfo.add(\"indexWriterConfig\", iwConfig);\n        } finally {\n          iwRef.decref();\n        }\n      }\n    }\n    SimpleOrderedMap<Object> segmentInfo = null;\n    List<SegmentCommitInfo> sortable = new ArrayList<>();\n    sortable.addAll(infos.asList());\n    // Order by the number of live docs. The display is logarithmic so it is a little jumbled visually\n    sortable.sort((s1, s2) ->\n      (s2.info.maxDoc() - s2.getDelCount()) - (s1.info.maxDoc() - s1.getDelCount())\n    );\n\n    List<String> mergeCandidates = new ArrayList<>();\n    SimpleOrderedMap<Object> runningMerges = getMergeInformation(req, infos, mergeCandidates);\n    List<LeafReaderContext> leafContexts = searcher.getIndexReader().leaves();\n    IndexSchema schema = req.getSchema();\n    for (SegmentCommitInfo segmentCommitInfo : sortable) {\n      segmentInfo = getSegmentInfo(segmentCommitInfo, withSizeInfo, withFieldInfo, leafContexts, schema);\n      if (mergeCandidates.contains(segmentCommitInfo.info.name)) {\n        segmentInfo.add(\"mergeCandidate\", true);\n      }\n      segmentInfos.add((String) segmentInfo.get(NAME), segmentInfo);\n    }\n\n    rsp.add(\"info\", infosInfo);\n    if (runningMerges.size() > 0) {\n      rsp.add(\"runningMerges\", runningMerges);\n    }\n    if (withFieldInfo) {\n      rsp.add(\"fieldInfoLegend\", FI_LEGEND);\n    }\n    rsp.add(\"segments\", segmentInfos);\n    if (withRawSizeInfo) {\n      IndexSizeEstimator estimator = new IndexSizeEstimator(searcher.getRawReader(), 20, 100, withRawSizeSummary, withRawSizeDetails);\n      Object samplingPercentVal = req.getParams().get(RAW_SIZE_SAMPLING_PERCENT_PARAM);\n      if (samplingPercentVal != null) {\n        estimator.setSamplingPercent(Float.parseFloat(String.valueOf(samplingPercentVal)));\n      }\n      IndexSizeEstimator.Estimate estimate = estimator.estimate();\n      SimpleOrderedMap<Object> estimateMap = new SimpleOrderedMap<>();\n      // make the units more user-friendly\n      estimateMap.add(IndexSizeEstimator.FIELDS_BY_SIZE, estimate.getHumanReadableFieldsBySize());\n      estimateMap.add(IndexSizeEstimator.TYPES_BY_SIZE, estimate.getHumanReadableTypesBySize());\n      if (estimate.getSummary() != null) {\n        estimateMap.add(IndexSizeEstimator.SUMMARY, estimate.getSummary());\n      }\n      if (estimate.getDetails() != null) {\n        estimateMap.add(IndexSizeEstimator.DETAILS, estimate.getDetails());\n      }\n      rsp.add(\"rawSize\", estimateMap);\n    }\n  }\n\n","sourceOld":"  private void getSegmentsInfo(SolrQueryRequest req, SolrQueryResponse rsp)\n      throws Exception {\n    boolean withFieldInfo = req.getParams().getBool(WITH_FIELD_INFO, false);\n    boolean withCoreInfo = req.getParams().getBool(WITH_CORE_INFO, false);\n    boolean withSizeInfo = req.getParams().getBool(WITH_SIZE_INFO, false);\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    SegmentInfos infos =\n        SegmentInfos.readLatestCommit(searcher.getIndexReader().directory());\n\n    SimpleOrderedMap<Object> segmentInfos = new SimpleOrderedMap<>();\n\n    SolrCore core = req.getCore();\n    RefCounted<IndexWriter> iwRef = core.getSolrCoreState().getIndexWriter(core);\n    SimpleOrderedMap<Object> infosInfo = new SimpleOrderedMap<>();\n    Version minVersion = infos.getMinSegmentLuceneVersion();\n    if (minVersion != null) {\n      infosInfo.add(\"minSegmentLuceneVersion\", minVersion.toString());\n    }\n    Version commitVersion = infos.getCommitLuceneVersion();\n    if (commitVersion != null) {\n      infosInfo.add(\"commitLuceneVersion\", commitVersion.toString());\n    }\n    infosInfo.add(\"numSegments\", infos.size());\n    infosInfo.add(\"segmentsFileName\", infos.getSegmentsFileName());\n    infosInfo.add(\"totalMaxDoc\", infos.totalMaxDoc());\n    infosInfo.add(\"userData\", infos.userData);\n    if (withCoreInfo) {\n      SimpleOrderedMap<Object> coreInfo = new SimpleOrderedMap<>();\n      infosInfo.add(\"core\", coreInfo);\n      coreInfo.add(\"startTime\", core.getStartTimeStamp().getTime() + \"(\" + core.getStartTimeStamp() + \")\");\n      coreInfo.add(\"dataDir\", core.getDataDir());\n      coreInfo.add(\"indexDir\", core.getIndexDir());\n      coreInfo.add(\"sizeInGB\", (double)core.getIndexSize() / GB);\n\n      if (iwRef != null) {\n        try {\n          IndexWriter iw = iwRef.get();\n          String iwConfigStr = iw.getConfig().toString();\n          SimpleOrderedMap<Object> iwConfig = new SimpleOrderedMap<>();\n          // meh ...\n          String[] lines = iwConfigStr.split(\"\\\\n\");\n          for (String line : lines) {\n            String[] parts = line.split(\"=\");\n            if (parts.length < 2) {\n              continue;\n            }\n            iwConfig.add(parts[0], parts[1]);\n          }\n          coreInfo.add(\"indexWriterConfig\", iwConfig);\n        } finally {\n          iwRef.decref();\n        }\n      }\n    }\n    SimpleOrderedMap<Object> segmentInfo = null;\n    List<SegmentCommitInfo> sortable = new ArrayList<>();\n    sortable.addAll(infos.asList());\n    // Order by the number of live docs. The display is logarithmic so it is a little jumbled visually\n    sortable.sort((s1, s2) ->\n      (s2.info.maxDoc() - s2.getDelCount()) - (s1.info.maxDoc() - s1.getDelCount())\n    );\n\n    List<String> mergeCandidates = new ArrayList<>();\n    SimpleOrderedMap<Object> runningMerges = getMergeInformation(req, infos, mergeCandidates);\n    List<LeafReaderContext> leafContexts = searcher.getIndexReader().leaves();\n    IndexSchema schema = req.getSchema();\n    for (SegmentCommitInfo segmentCommitInfo : sortable) {\n      segmentInfo = getSegmentInfo(segmentCommitInfo, withSizeInfo, withFieldInfo, leafContexts, schema);\n      if (mergeCandidates.contains(segmentCommitInfo.info.name)) {\n        segmentInfo.add(\"mergeCandidate\", true);\n      }\n      segmentInfos.add((String) segmentInfo.get(NAME), segmentInfo);\n    }\n\n    rsp.add(\"info\", infosInfo);\n    if (runningMerges.size() > 0) {\n      rsp.add(\"runningMerges\", runningMerges);\n    }\n    if (withFieldInfo) {\n      rsp.add(\"fieldInfoLegend\", FI_LEGEND);\n    }\n    rsp.add(\"segments\", segmentInfos);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"23b14fc1cb7939c2aad1d3a40f6282dee0bfda2e","date":1571071547,"type":3,"author":"Koen De Groote","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getSegmentsInfo(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getSegmentsInfo(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  private void getSegmentsInfo(SolrQueryRequest req, SolrQueryResponse rsp)\n      throws Exception {\n    boolean withFieldInfo = req.getParams().getBool(FIELD_INFO_PARAM, false);\n    boolean withCoreInfo = req.getParams().getBool(CORE_INFO_PARAM, false);\n    boolean withSizeInfo = req.getParams().getBool(SIZE_INFO_PARAM, false);\n    boolean withRawSizeInfo = req.getParams().getBool(RAW_SIZE_PARAM, false);\n    boolean withRawSizeSummary = req.getParams().getBool(RAW_SIZE_SUMMARY_PARAM, false);\n    boolean withRawSizeDetails = req.getParams().getBool(RAW_SIZE_DETAILS_PARAM, false);\n    if (withRawSizeSummary || withRawSizeDetails) {\n      withRawSizeInfo  = true;\n    }\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    SegmentInfos infos =\n        SegmentInfos.readLatestCommit(searcher.getIndexReader().directory());\n\n    SimpleOrderedMap<Object> segmentInfos = new SimpleOrderedMap<>();\n\n    SolrCore core = req.getCore();\n    RefCounted<IndexWriter> iwRef = core.getSolrCoreState().getIndexWriter(core);\n    SimpleOrderedMap<Object> infosInfo = new SimpleOrderedMap<>();\n    Version minVersion = infos.getMinSegmentLuceneVersion();\n    if (minVersion != null) {\n      infosInfo.add(\"minSegmentLuceneVersion\", minVersion.toString());\n    }\n    Version commitVersion = infos.getCommitLuceneVersion();\n    if (commitVersion != null) {\n      infosInfo.add(\"commitLuceneVersion\", commitVersion.toString());\n    }\n    infosInfo.add(\"numSegments\", infos.size());\n    infosInfo.add(\"segmentsFileName\", infos.getSegmentsFileName());\n    infosInfo.add(\"totalMaxDoc\", infos.totalMaxDoc());\n    infosInfo.add(\"userData\", infos.userData);\n    if (withCoreInfo) {\n      SimpleOrderedMap<Object> coreInfo = new SimpleOrderedMap<>();\n      infosInfo.add(\"core\", coreInfo);\n      coreInfo.add(\"startTime\", core.getStartTimeStamp().getTime() + \"(\" + core.getStartTimeStamp() + \")\");\n      coreInfo.add(\"dataDir\", core.getDataDir());\n      coreInfo.add(\"indexDir\", core.getIndexDir());\n      coreInfo.add(\"sizeInGB\", (double)core.getIndexSize() / GB);\n\n      if (iwRef != null) {\n        try {\n          IndexWriter iw = iwRef.get();\n          String iwConfigStr = iw.getConfig().toString();\n          SimpleOrderedMap<Object> iwConfig = new SimpleOrderedMap<>();\n          // meh ...\n          String[] lines = iwConfigStr.split(\"\\\\n\");\n          for (String line : lines) {\n            String[] parts = line.split(\"=\");\n            if (parts.length < 2) {\n              continue;\n            }\n            iwConfig.add(parts[0], parts[1]);\n          }\n          coreInfo.add(\"indexWriterConfig\", iwConfig);\n        } finally {\n          iwRef.decref();\n        }\n      }\n    }\n    SimpleOrderedMap<Object> segmentInfo = null;\n    List<SegmentCommitInfo> sortable = new ArrayList<>(infos.asList());\n    // Order by the number of live docs. The display is logarithmic so it is a little jumbled visually\n    sortable.sort((s1, s2) ->\n      (s2.info.maxDoc() - s2.getDelCount()) - (s1.info.maxDoc() - s1.getDelCount())\n    );\n\n    List<String> mergeCandidates = new ArrayList<>();\n    SimpleOrderedMap<Object> runningMerges = getMergeInformation(req, infos, mergeCandidates);\n    List<LeafReaderContext> leafContexts = searcher.getIndexReader().leaves();\n    IndexSchema schema = req.getSchema();\n    for (SegmentCommitInfo segmentCommitInfo : sortable) {\n      segmentInfo = getSegmentInfo(segmentCommitInfo, withSizeInfo, withFieldInfo, leafContexts, schema);\n      if (mergeCandidates.contains(segmentCommitInfo.info.name)) {\n        segmentInfo.add(\"mergeCandidate\", true);\n      }\n      segmentInfos.add((String) segmentInfo.get(NAME), segmentInfo);\n    }\n\n    rsp.add(\"info\", infosInfo);\n    if (runningMerges.size() > 0) {\n      rsp.add(\"runningMerges\", runningMerges);\n    }\n    if (withFieldInfo) {\n      rsp.add(\"fieldInfoLegend\", FI_LEGEND);\n    }\n    rsp.add(\"segments\", segmentInfos);\n    if (withRawSizeInfo) {\n      IndexSizeEstimator estimator = new IndexSizeEstimator(searcher.getRawReader(), 20, 100, withRawSizeSummary, withRawSizeDetails);\n      Object samplingPercentVal = req.getParams().get(RAW_SIZE_SAMPLING_PERCENT_PARAM);\n      if (samplingPercentVal != null) {\n        estimator.setSamplingPercent(Float.parseFloat(String.valueOf(samplingPercentVal)));\n      }\n      IndexSizeEstimator.Estimate estimate = estimator.estimate();\n      SimpleOrderedMap<Object> estimateMap = new SimpleOrderedMap<>();\n      // make the units more user-friendly\n      estimateMap.add(IndexSizeEstimator.FIELDS_BY_SIZE, estimate.getHumanReadableFieldsBySize());\n      estimateMap.add(IndexSizeEstimator.TYPES_BY_SIZE, estimate.getHumanReadableTypesBySize());\n      if (estimate.getSummary() != null) {\n        estimateMap.add(IndexSizeEstimator.SUMMARY, estimate.getSummary());\n      }\n      if (estimate.getDetails() != null) {\n        estimateMap.add(IndexSizeEstimator.DETAILS, estimate.getDetails());\n      }\n      rsp.add(\"rawSize\", estimateMap);\n    }\n  }\n\n","sourceOld":"  private void getSegmentsInfo(SolrQueryRequest req, SolrQueryResponse rsp)\n      throws Exception {\n    boolean withFieldInfo = req.getParams().getBool(FIELD_INFO_PARAM, false);\n    boolean withCoreInfo = req.getParams().getBool(CORE_INFO_PARAM, false);\n    boolean withSizeInfo = req.getParams().getBool(SIZE_INFO_PARAM, false);\n    boolean withRawSizeInfo = req.getParams().getBool(RAW_SIZE_PARAM, false);\n    boolean withRawSizeSummary = req.getParams().getBool(RAW_SIZE_SUMMARY_PARAM, false);\n    boolean withRawSizeDetails = req.getParams().getBool(RAW_SIZE_DETAILS_PARAM, false);\n    if (withRawSizeSummary || withRawSizeDetails) {\n      withRawSizeInfo  = true;\n    }\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    SegmentInfos infos =\n        SegmentInfos.readLatestCommit(searcher.getIndexReader().directory());\n\n    SimpleOrderedMap<Object> segmentInfos = new SimpleOrderedMap<>();\n\n    SolrCore core = req.getCore();\n    RefCounted<IndexWriter> iwRef = core.getSolrCoreState().getIndexWriter(core);\n    SimpleOrderedMap<Object> infosInfo = new SimpleOrderedMap<>();\n    Version minVersion = infos.getMinSegmentLuceneVersion();\n    if (minVersion != null) {\n      infosInfo.add(\"minSegmentLuceneVersion\", minVersion.toString());\n    }\n    Version commitVersion = infos.getCommitLuceneVersion();\n    if (commitVersion != null) {\n      infosInfo.add(\"commitLuceneVersion\", commitVersion.toString());\n    }\n    infosInfo.add(\"numSegments\", infos.size());\n    infosInfo.add(\"segmentsFileName\", infos.getSegmentsFileName());\n    infosInfo.add(\"totalMaxDoc\", infos.totalMaxDoc());\n    infosInfo.add(\"userData\", infos.userData);\n    if (withCoreInfo) {\n      SimpleOrderedMap<Object> coreInfo = new SimpleOrderedMap<>();\n      infosInfo.add(\"core\", coreInfo);\n      coreInfo.add(\"startTime\", core.getStartTimeStamp().getTime() + \"(\" + core.getStartTimeStamp() + \")\");\n      coreInfo.add(\"dataDir\", core.getDataDir());\n      coreInfo.add(\"indexDir\", core.getIndexDir());\n      coreInfo.add(\"sizeInGB\", (double)core.getIndexSize() / GB);\n\n      if (iwRef != null) {\n        try {\n          IndexWriter iw = iwRef.get();\n          String iwConfigStr = iw.getConfig().toString();\n          SimpleOrderedMap<Object> iwConfig = new SimpleOrderedMap<>();\n          // meh ...\n          String[] lines = iwConfigStr.split(\"\\\\n\");\n          for (String line : lines) {\n            String[] parts = line.split(\"=\");\n            if (parts.length < 2) {\n              continue;\n            }\n            iwConfig.add(parts[0], parts[1]);\n          }\n          coreInfo.add(\"indexWriterConfig\", iwConfig);\n        } finally {\n          iwRef.decref();\n        }\n      }\n    }\n    SimpleOrderedMap<Object> segmentInfo = null;\n    List<SegmentCommitInfo> sortable = new ArrayList<>();\n    sortable.addAll(infos.asList());\n    // Order by the number of live docs. The display is logarithmic so it is a little jumbled visually\n    sortable.sort((s1, s2) ->\n      (s2.info.maxDoc() - s2.getDelCount()) - (s1.info.maxDoc() - s1.getDelCount())\n    );\n\n    List<String> mergeCandidates = new ArrayList<>();\n    SimpleOrderedMap<Object> runningMerges = getMergeInformation(req, infos, mergeCandidates);\n    List<LeafReaderContext> leafContexts = searcher.getIndexReader().leaves();\n    IndexSchema schema = req.getSchema();\n    for (SegmentCommitInfo segmentCommitInfo : sortable) {\n      segmentInfo = getSegmentInfo(segmentCommitInfo, withSizeInfo, withFieldInfo, leafContexts, schema);\n      if (mergeCandidates.contains(segmentCommitInfo.info.name)) {\n        segmentInfo.add(\"mergeCandidate\", true);\n      }\n      segmentInfos.add((String) segmentInfo.get(NAME), segmentInfo);\n    }\n\n    rsp.add(\"info\", infosInfo);\n    if (runningMerges.size() > 0) {\n      rsp.add(\"runningMerges\", runningMerges);\n    }\n    if (withFieldInfo) {\n      rsp.add(\"fieldInfoLegend\", FI_LEGEND);\n    }\n    rsp.add(\"segments\", segmentInfos);\n    if (withRawSizeInfo) {\n      IndexSizeEstimator estimator = new IndexSizeEstimator(searcher.getRawReader(), 20, 100, withRawSizeSummary, withRawSizeDetails);\n      Object samplingPercentVal = req.getParams().get(RAW_SIZE_SAMPLING_PERCENT_PARAM);\n      if (samplingPercentVal != null) {\n        estimator.setSamplingPercent(Float.parseFloat(String.valueOf(samplingPercentVal)));\n      }\n      IndexSizeEstimator.Estimate estimate = estimator.estimate();\n      SimpleOrderedMap<Object> estimateMap = new SimpleOrderedMap<>();\n      // make the units more user-friendly\n      estimateMap.add(IndexSizeEstimator.FIELDS_BY_SIZE, estimate.getHumanReadableFieldsBySize());\n      estimateMap.add(IndexSizeEstimator.TYPES_BY_SIZE, estimate.getHumanReadableTypesBySize());\n      if (estimate.getSummary() != null) {\n        estimateMap.add(IndexSizeEstimator.SUMMARY, estimate.getSummary());\n      }\n      if (estimate.getDetails() != null) {\n        estimateMap.add(IndexSizeEstimator.DETAILS, estimate.getDetails());\n      }\n      rsp.add(\"rawSize\", estimateMap);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getSegmentsInfo(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getSegmentsInfo(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  private void getSegmentsInfo(SolrQueryRequest req, SolrQueryResponse rsp)\n      throws Exception {\n    boolean withFieldInfo = req.getParams().getBool(FIELD_INFO_PARAM, false);\n    boolean withCoreInfo = req.getParams().getBool(CORE_INFO_PARAM, false);\n    boolean withSizeInfo = req.getParams().getBool(SIZE_INFO_PARAM, false);\n    boolean withRawSizeInfo = req.getParams().getBool(RAW_SIZE_PARAM, false);\n    boolean withRawSizeSummary = req.getParams().getBool(RAW_SIZE_SUMMARY_PARAM, false);\n    boolean withRawSizeDetails = req.getParams().getBool(RAW_SIZE_DETAILS_PARAM, false);\n    if (withRawSizeSummary || withRawSizeDetails) {\n      withRawSizeInfo  = true;\n    }\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    SegmentInfos infos =\n        SegmentInfos.readLatestCommit(searcher.getIndexReader().directory());\n\n    SimpleOrderedMap<Object> segmentInfos = new SimpleOrderedMap<>();\n\n    SolrCore core = req.getCore();\n    RefCounted<IndexWriter> iwRef = core.getSolrCoreState().getIndexWriter(core);\n    SimpleOrderedMap<Object> infosInfo = new SimpleOrderedMap<>();\n    Version minVersion = infos.getMinSegmentLuceneVersion();\n    if (minVersion != null) {\n      infosInfo.add(\"minSegmentLuceneVersion\", minVersion.toString());\n    }\n    Version commitVersion = infos.getCommitLuceneVersion();\n    if (commitVersion != null) {\n      infosInfo.add(\"commitLuceneVersion\", commitVersion.toString());\n    }\n    infosInfo.add(\"numSegments\", infos.size());\n    infosInfo.add(\"segmentsFileName\", infos.getSegmentsFileName());\n    infosInfo.add(\"totalMaxDoc\", infos.totalMaxDoc());\n    infosInfo.add(\"userData\", infos.userData);\n    if (withCoreInfo) {\n      SimpleOrderedMap<Object> coreInfo = new SimpleOrderedMap<>();\n      infosInfo.add(\"core\", coreInfo);\n      coreInfo.add(\"startTime\", core.getStartTimeStamp().getTime() + \"(\" + core.getStartTimeStamp() + \")\");\n      coreInfo.add(\"dataDir\", core.getDataDir());\n      coreInfo.add(\"indexDir\", core.getIndexDir());\n      coreInfo.add(\"sizeInGB\", (double)core.getIndexSize() / GB);\n\n      if (iwRef != null) {\n        try {\n          IndexWriter iw = iwRef.get();\n          String iwConfigStr = iw.getConfig().toString();\n          SimpleOrderedMap<Object> iwConfig = new SimpleOrderedMap<>();\n          // meh ...\n          String[] lines = iwConfigStr.split(\"\\\\n\");\n          for (String line : lines) {\n            String[] parts = line.split(\"=\");\n            if (parts.length < 2) {\n              continue;\n            }\n            iwConfig.add(parts[0], parts[1]);\n          }\n          coreInfo.add(\"indexWriterConfig\", iwConfig);\n        } finally {\n          iwRef.decref();\n        }\n      }\n    }\n    SimpleOrderedMap<Object> segmentInfo = null;\n    List<SegmentCommitInfo> sortable = new ArrayList<>(infos.asList());\n    // Order by the number of live docs. The display is logarithmic so it is a little jumbled visually\n    sortable.sort((s1, s2) ->\n      (s2.info.maxDoc() - s2.getDelCount()) - (s1.info.maxDoc() - s1.getDelCount())\n    );\n\n    List<String> mergeCandidates = new ArrayList<>();\n    SimpleOrderedMap<Object> runningMerges = getMergeInformation(req, infos, mergeCandidates);\n    List<LeafReaderContext> leafContexts = searcher.getIndexReader().leaves();\n    IndexSchema schema = req.getSchema();\n    for (SegmentCommitInfo segmentCommitInfo : sortable) {\n      segmentInfo = getSegmentInfo(segmentCommitInfo, withSizeInfo, withFieldInfo, leafContexts, schema);\n      if (mergeCandidates.contains(segmentCommitInfo.info.name)) {\n        segmentInfo.add(\"mergeCandidate\", true);\n      }\n      segmentInfos.add((String) segmentInfo.get(NAME), segmentInfo);\n    }\n\n    rsp.add(\"info\", infosInfo);\n    if (runningMerges.size() > 0) {\n      rsp.add(\"runningMerges\", runningMerges);\n    }\n    if (withFieldInfo) {\n      rsp.add(\"fieldInfoLegend\", FI_LEGEND);\n    }\n    rsp.add(\"segments\", segmentInfos);\n    if (withRawSizeInfo) {\n      IndexSizeEstimator estimator = new IndexSizeEstimator(searcher.getRawReader(), 20, 100, withRawSizeSummary, withRawSizeDetails);\n      Object samplingPercentVal = req.getParams().get(RAW_SIZE_SAMPLING_PERCENT_PARAM);\n      if (samplingPercentVal != null) {\n        estimator.setSamplingPercent(Float.parseFloat(String.valueOf(samplingPercentVal)));\n      }\n      IndexSizeEstimator.Estimate estimate = estimator.estimate();\n      SimpleOrderedMap<Object> estimateMap = new SimpleOrderedMap<>();\n      // make the units more user-friendly\n      estimateMap.add(IndexSizeEstimator.FIELDS_BY_SIZE, estimate.getHumanReadableFieldsBySize());\n      estimateMap.add(IndexSizeEstimator.TYPES_BY_SIZE, estimate.getHumanReadableTypesBySize());\n      if (estimate.getSummary() != null) {\n        estimateMap.add(IndexSizeEstimator.SUMMARY, estimate.getSummary());\n      }\n      if (estimate.getDetails() != null) {\n        estimateMap.add(IndexSizeEstimator.DETAILS, estimate.getDetails());\n      }\n      rsp.add(\"rawSize\", estimateMap);\n    }\n  }\n\n","sourceOld":"  private void getSegmentsInfo(SolrQueryRequest req, SolrQueryResponse rsp)\n      throws Exception {\n    boolean withFieldInfo = req.getParams().getBool(FIELD_INFO_PARAM, false);\n    boolean withCoreInfo = req.getParams().getBool(CORE_INFO_PARAM, false);\n    boolean withSizeInfo = req.getParams().getBool(SIZE_INFO_PARAM, false);\n    boolean withRawSizeInfo = req.getParams().getBool(RAW_SIZE_PARAM, false);\n    boolean withRawSizeSummary = req.getParams().getBool(RAW_SIZE_SUMMARY_PARAM, false);\n    boolean withRawSizeDetails = req.getParams().getBool(RAW_SIZE_DETAILS_PARAM, false);\n    if (withRawSizeSummary || withRawSizeDetails) {\n      withRawSizeInfo  = true;\n    }\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    SegmentInfos infos =\n        SegmentInfos.readLatestCommit(searcher.getIndexReader().directory());\n\n    SimpleOrderedMap<Object> segmentInfos = new SimpleOrderedMap<>();\n\n    SolrCore core = req.getCore();\n    RefCounted<IndexWriter> iwRef = core.getSolrCoreState().getIndexWriter(core);\n    SimpleOrderedMap<Object> infosInfo = new SimpleOrderedMap<>();\n    Version minVersion = infos.getMinSegmentLuceneVersion();\n    if (minVersion != null) {\n      infosInfo.add(\"minSegmentLuceneVersion\", minVersion.toString());\n    }\n    Version commitVersion = infos.getCommitLuceneVersion();\n    if (commitVersion != null) {\n      infosInfo.add(\"commitLuceneVersion\", commitVersion.toString());\n    }\n    infosInfo.add(\"numSegments\", infos.size());\n    infosInfo.add(\"segmentsFileName\", infos.getSegmentsFileName());\n    infosInfo.add(\"totalMaxDoc\", infos.totalMaxDoc());\n    infosInfo.add(\"userData\", infos.userData);\n    if (withCoreInfo) {\n      SimpleOrderedMap<Object> coreInfo = new SimpleOrderedMap<>();\n      infosInfo.add(\"core\", coreInfo);\n      coreInfo.add(\"startTime\", core.getStartTimeStamp().getTime() + \"(\" + core.getStartTimeStamp() + \")\");\n      coreInfo.add(\"dataDir\", core.getDataDir());\n      coreInfo.add(\"indexDir\", core.getIndexDir());\n      coreInfo.add(\"sizeInGB\", (double)core.getIndexSize() / GB);\n\n      if (iwRef != null) {\n        try {\n          IndexWriter iw = iwRef.get();\n          String iwConfigStr = iw.getConfig().toString();\n          SimpleOrderedMap<Object> iwConfig = new SimpleOrderedMap<>();\n          // meh ...\n          String[] lines = iwConfigStr.split(\"\\\\n\");\n          for (String line : lines) {\n            String[] parts = line.split(\"=\");\n            if (parts.length < 2) {\n              continue;\n            }\n            iwConfig.add(parts[0], parts[1]);\n          }\n          coreInfo.add(\"indexWriterConfig\", iwConfig);\n        } finally {\n          iwRef.decref();\n        }\n      }\n    }\n    SimpleOrderedMap<Object> segmentInfo = null;\n    List<SegmentCommitInfo> sortable = new ArrayList<>();\n    sortable.addAll(infos.asList());\n    // Order by the number of live docs. The display is logarithmic so it is a little jumbled visually\n    sortable.sort((s1, s2) ->\n      (s2.info.maxDoc() - s2.getDelCount()) - (s1.info.maxDoc() - s1.getDelCount())\n    );\n\n    List<String> mergeCandidates = new ArrayList<>();\n    SimpleOrderedMap<Object> runningMerges = getMergeInformation(req, infos, mergeCandidates);\n    List<LeafReaderContext> leafContexts = searcher.getIndexReader().leaves();\n    IndexSchema schema = req.getSchema();\n    for (SegmentCommitInfo segmentCommitInfo : sortable) {\n      segmentInfo = getSegmentInfo(segmentCommitInfo, withSizeInfo, withFieldInfo, leafContexts, schema);\n      if (mergeCandidates.contains(segmentCommitInfo.info.name)) {\n        segmentInfo.add(\"mergeCandidate\", true);\n      }\n      segmentInfos.add((String) segmentInfo.get(NAME), segmentInfo);\n    }\n\n    rsp.add(\"info\", infosInfo);\n    if (runningMerges.size() > 0) {\n      rsp.add(\"runningMerges\", runningMerges);\n    }\n    if (withFieldInfo) {\n      rsp.add(\"fieldInfoLegend\", FI_LEGEND);\n    }\n    rsp.add(\"segments\", segmentInfos);\n    if (withRawSizeInfo) {\n      IndexSizeEstimator estimator = new IndexSizeEstimator(searcher.getRawReader(), 20, 100, withRawSizeSummary, withRawSizeDetails);\n      Object samplingPercentVal = req.getParams().get(RAW_SIZE_SAMPLING_PERCENT_PARAM);\n      if (samplingPercentVal != null) {\n        estimator.setSamplingPercent(Float.parseFloat(String.valueOf(samplingPercentVal)));\n      }\n      IndexSizeEstimator.Estimate estimate = estimator.estimate();\n      SimpleOrderedMap<Object> estimateMap = new SimpleOrderedMap<>();\n      // make the units more user-friendly\n      estimateMap.add(IndexSizeEstimator.FIELDS_BY_SIZE, estimate.getHumanReadableFieldsBySize());\n      estimateMap.add(IndexSizeEstimator.TYPES_BY_SIZE, estimate.getHumanReadableTypesBySize());\n      if (estimate.getSummary() != null) {\n        estimateMap.add(IndexSizeEstimator.SUMMARY, estimate.getSummary());\n      }\n      if (estimate.getDetails() != null) {\n        estimateMap.add(IndexSizeEstimator.DETAILS, estimate.getDetails());\n      }\n      rsp.add(\"rawSize\", estimateMap);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"133525af0aa09d87ef4258fd43eed160b462b313","date":1588596241,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getSegmentsInfo(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/SegmentsInfoRequestHandler#getSegmentsInfo(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  private void getSegmentsInfo(SolrQueryRequest req, SolrQueryResponse rsp)\n      throws Exception {\n    boolean withFieldInfo = req.getParams().getBool(FIELD_INFO_PARAM, false);\n    boolean withCoreInfo = req.getParams().getBool(CORE_INFO_PARAM, false);\n    boolean withSizeInfo = req.getParams().getBool(SIZE_INFO_PARAM, false);\n    boolean withRawSizeInfo = req.getParams().getBool(RAW_SIZE_PARAM, false);\n    boolean withRawSizeSummary = req.getParams().getBool(RAW_SIZE_SUMMARY_PARAM, false);\n    boolean withRawSizeDetails = req.getParams().getBool(RAW_SIZE_DETAILS_PARAM, false);\n    if (withRawSizeSummary || withRawSizeDetails) {\n      withRawSizeInfo  = true;\n    }\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    SegmentInfos infos =\n        SegmentInfos.readLatestCommit(searcher.getIndexReader().directory());\n\n    SimpleOrderedMap<Object> segmentInfos = new SimpleOrderedMap<>();\n\n    SolrCore core = req.getCore();\n    SimpleOrderedMap<Object> infosInfo = new SimpleOrderedMap<>();\n    Version minVersion = infos.getMinSegmentLuceneVersion();\n    if (minVersion != null) {\n      infosInfo.add(\"minSegmentLuceneVersion\", minVersion.toString());\n    }\n    Version commitVersion = infos.getCommitLuceneVersion();\n    if (commitVersion != null) {\n      infosInfo.add(\"commitLuceneVersion\", commitVersion.toString());\n    }\n    infosInfo.add(\"numSegments\", infos.size());\n    infosInfo.add(\"segmentsFileName\", infos.getSegmentsFileName());\n    infosInfo.add(\"totalMaxDoc\", infos.totalMaxDoc());\n    infosInfo.add(\"userData\", infos.userData);\n    if (withCoreInfo) {\n      SimpleOrderedMap<Object> coreInfo = new SimpleOrderedMap<>();\n      infosInfo.add(\"core\", coreInfo);\n      coreInfo.add(\"startTime\", core.getStartTimeStamp().getTime() + \"(\" + core.getStartTimeStamp() + \")\");\n      coreInfo.add(\"dataDir\", core.getDataDir());\n      coreInfo.add(\"indexDir\", core.getIndexDir());\n      coreInfo.add(\"sizeInGB\", (double)core.getIndexSize() / GB);\n\n      RefCounted<IndexWriter> iwRef = core.getSolrCoreState().getIndexWriter(core);\n      if (iwRef != null) {\n        try {\n          IndexWriter iw = iwRef.get();\n          String iwConfigStr = iw.getConfig().toString();\n          SimpleOrderedMap<Object> iwConfig = new SimpleOrderedMap<>();\n          // meh ...\n          String[] lines = iwConfigStr.split(\"\\\\n\");\n          for (String line : lines) {\n            String[] parts = line.split(\"=\");\n            if (parts.length < 2) {\n              continue;\n            }\n            iwConfig.add(parts[0], parts[1]);\n          }\n          coreInfo.add(\"indexWriterConfig\", iwConfig);\n        } finally {\n          iwRef.decref();\n        }\n      }\n    }\n    SimpleOrderedMap<Object> segmentInfo = null;\n    List<SegmentCommitInfo> sortable = new ArrayList<>(infos.asList());\n    // Order by the number of live docs. The display is logarithmic so it is a little jumbled visually\n    sortable.sort((s1, s2) ->\n      (s2.info.maxDoc() - s2.getDelCount()) - (s1.info.maxDoc() - s1.getDelCount())\n    );\n\n    List<String> mergeCandidates = new ArrayList<>();\n    SimpleOrderedMap<Object> runningMerges = getMergeInformation(req, infos, mergeCandidates);\n    List<LeafReaderContext> leafContexts = searcher.getIndexReader().leaves();\n    IndexSchema schema = req.getSchema();\n    for (SegmentCommitInfo segmentCommitInfo : sortable) {\n      segmentInfo = getSegmentInfo(segmentCommitInfo, withSizeInfo, withFieldInfo, leafContexts, schema);\n      if (mergeCandidates.contains(segmentCommitInfo.info.name)) {\n        segmentInfo.add(\"mergeCandidate\", true);\n      }\n      segmentInfos.add((String) segmentInfo.get(NAME), segmentInfo);\n    }\n\n    rsp.add(\"info\", infosInfo);\n    if (runningMerges.size() > 0) {\n      rsp.add(\"runningMerges\", runningMerges);\n    }\n    if (withFieldInfo) {\n      rsp.add(\"fieldInfoLegend\", FI_LEGEND);\n    }\n    rsp.add(\"segments\", segmentInfos);\n    if (withRawSizeInfo) {\n      IndexSizeEstimator estimator = new IndexSizeEstimator(searcher.getRawReader(), 20, 100, withRawSizeSummary, withRawSizeDetails);\n      Object samplingPercentVal = req.getParams().get(RAW_SIZE_SAMPLING_PERCENT_PARAM);\n      if (samplingPercentVal != null) {\n        estimator.setSamplingPercent(Float.parseFloat(String.valueOf(samplingPercentVal)));\n      }\n      IndexSizeEstimator.Estimate estimate = estimator.estimate();\n      SimpleOrderedMap<Object> estimateMap = new SimpleOrderedMap<>();\n      // make the units more user-friendly\n      estimateMap.add(IndexSizeEstimator.FIELDS_BY_SIZE, estimate.getHumanReadableFieldsBySize());\n      estimateMap.add(IndexSizeEstimator.TYPES_BY_SIZE, estimate.getHumanReadableTypesBySize());\n      if (estimate.getSummary() != null) {\n        estimateMap.add(IndexSizeEstimator.SUMMARY, estimate.getSummary());\n      }\n      if (estimate.getDetails() != null) {\n        estimateMap.add(IndexSizeEstimator.DETAILS, estimate.getDetails());\n      }\n      rsp.add(\"rawSize\", estimateMap);\n    }\n  }\n\n","sourceOld":"  private void getSegmentsInfo(SolrQueryRequest req, SolrQueryResponse rsp)\n      throws Exception {\n    boolean withFieldInfo = req.getParams().getBool(FIELD_INFO_PARAM, false);\n    boolean withCoreInfo = req.getParams().getBool(CORE_INFO_PARAM, false);\n    boolean withSizeInfo = req.getParams().getBool(SIZE_INFO_PARAM, false);\n    boolean withRawSizeInfo = req.getParams().getBool(RAW_SIZE_PARAM, false);\n    boolean withRawSizeSummary = req.getParams().getBool(RAW_SIZE_SUMMARY_PARAM, false);\n    boolean withRawSizeDetails = req.getParams().getBool(RAW_SIZE_DETAILS_PARAM, false);\n    if (withRawSizeSummary || withRawSizeDetails) {\n      withRawSizeInfo  = true;\n    }\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    SegmentInfos infos =\n        SegmentInfos.readLatestCommit(searcher.getIndexReader().directory());\n\n    SimpleOrderedMap<Object> segmentInfos = new SimpleOrderedMap<>();\n\n    SolrCore core = req.getCore();\n    RefCounted<IndexWriter> iwRef = core.getSolrCoreState().getIndexWriter(core);\n    SimpleOrderedMap<Object> infosInfo = new SimpleOrderedMap<>();\n    Version minVersion = infos.getMinSegmentLuceneVersion();\n    if (minVersion != null) {\n      infosInfo.add(\"minSegmentLuceneVersion\", minVersion.toString());\n    }\n    Version commitVersion = infos.getCommitLuceneVersion();\n    if (commitVersion != null) {\n      infosInfo.add(\"commitLuceneVersion\", commitVersion.toString());\n    }\n    infosInfo.add(\"numSegments\", infos.size());\n    infosInfo.add(\"segmentsFileName\", infos.getSegmentsFileName());\n    infosInfo.add(\"totalMaxDoc\", infos.totalMaxDoc());\n    infosInfo.add(\"userData\", infos.userData);\n    if (withCoreInfo) {\n      SimpleOrderedMap<Object> coreInfo = new SimpleOrderedMap<>();\n      infosInfo.add(\"core\", coreInfo);\n      coreInfo.add(\"startTime\", core.getStartTimeStamp().getTime() + \"(\" + core.getStartTimeStamp() + \")\");\n      coreInfo.add(\"dataDir\", core.getDataDir());\n      coreInfo.add(\"indexDir\", core.getIndexDir());\n      coreInfo.add(\"sizeInGB\", (double)core.getIndexSize() / GB);\n\n      if (iwRef != null) {\n        try {\n          IndexWriter iw = iwRef.get();\n          String iwConfigStr = iw.getConfig().toString();\n          SimpleOrderedMap<Object> iwConfig = new SimpleOrderedMap<>();\n          // meh ...\n          String[] lines = iwConfigStr.split(\"\\\\n\");\n          for (String line : lines) {\n            String[] parts = line.split(\"=\");\n            if (parts.length < 2) {\n              continue;\n            }\n            iwConfig.add(parts[0], parts[1]);\n          }\n          coreInfo.add(\"indexWriterConfig\", iwConfig);\n        } finally {\n          iwRef.decref();\n        }\n      }\n    }\n    SimpleOrderedMap<Object> segmentInfo = null;\n    List<SegmentCommitInfo> sortable = new ArrayList<>(infos.asList());\n    // Order by the number of live docs. The display is logarithmic so it is a little jumbled visually\n    sortable.sort((s1, s2) ->\n      (s2.info.maxDoc() - s2.getDelCount()) - (s1.info.maxDoc() - s1.getDelCount())\n    );\n\n    List<String> mergeCandidates = new ArrayList<>();\n    SimpleOrderedMap<Object> runningMerges = getMergeInformation(req, infos, mergeCandidates);\n    List<LeafReaderContext> leafContexts = searcher.getIndexReader().leaves();\n    IndexSchema schema = req.getSchema();\n    for (SegmentCommitInfo segmentCommitInfo : sortable) {\n      segmentInfo = getSegmentInfo(segmentCommitInfo, withSizeInfo, withFieldInfo, leafContexts, schema);\n      if (mergeCandidates.contains(segmentCommitInfo.info.name)) {\n        segmentInfo.add(\"mergeCandidate\", true);\n      }\n      segmentInfos.add((String) segmentInfo.get(NAME), segmentInfo);\n    }\n\n    rsp.add(\"info\", infosInfo);\n    if (runningMerges.size() > 0) {\n      rsp.add(\"runningMerges\", runningMerges);\n    }\n    if (withFieldInfo) {\n      rsp.add(\"fieldInfoLegend\", FI_LEGEND);\n    }\n    rsp.add(\"segments\", segmentInfos);\n    if (withRawSizeInfo) {\n      IndexSizeEstimator estimator = new IndexSizeEstimator(searcher.getRawReader(), 20, 100, withRawSizeSummary, withRawSizeDetails);\n      Object samplingPercentVal = req.getParams().get(RAW_SIZE_SAMPLING_PERCENT_PARAM);\n      if (samplingPercentVal != null) {\n        estimator.setSamplingPercent(Float.parseFloat(String.valueOf(samplingPercentVal)));\n      }\n      IndexSizeEstimator.Estimate estimate = estimator.estimate();\n      SimpleOrderedMap<Object> estimateMap = new SimpleOrderedMap<>();\n      // make the units more user-friendly\n      estimateMap.add(IndexSizeEstimator.FIELDS_BY_SIZE, estimate.getHumanReadableFieldsBySize());\n      estimateMap.add(IndexSizeEstimator.TYPES_BY_SIZE, estimate.getHumanReadableTypesBySize());\n      if (estimate.getSummary() != null) {\n        estimateMap.add(IndexSizeEstimator.SUMMARY, estimate.getSummary());\n      }\n      if (estimate.getDetails() != null) {\n        estimateMap.add(IndexSizeEstimator.DETAILS, estimate.getDetails());\n      }\n      rsp.add(\"rawSize\", estimateMap);\n    }\n  }\n\n","bugFix":["3470ed04f0378c1ceb02e540e3296dd27c0ae3d5"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"23b14fc1cb7939c2aad1d3a40f6282dee0bfda2e":["e4583dbd381e291c87e23144564c59ba3391b188"],"133525af0aa09d87ef4258fd43eed160b462b313":["23b14fc1cb7939c2aad1d3a40f6282dee0bfda2e"],"3470ed04f0378c1ceb02e540e3296dd27c0ae3d5":["56fb5e4e4b239474721e13b4cd9542ea2d215451"],"26db0fd7da61a97dcbf4558f4fd1ebed330bbd45":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e4583dbd381e291c87e23144564c59ba3391b188":["3470ed04f0378c1ceb02e540e3296dd27c0ae3d5"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","26db0fd7da61a97dcbf4558f4fd1ebed330bbd45"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["1390137e395d2f07f9ba5b8c43d293befe84d563","56fb5e4e4b239474721e13b4cd9542ea2d215451"],"56fb5e4e4b239474721e13b4cd9542ea2d215451":["1390137e395d2f07f9ba5b8c43d293befe84d563"],"1390137e395d2f07f9ba5b8c43d293befe84d563":["26db0fd7da61a97dcbf4558f4fd1ebed330bbd45"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","1390137e395d2f07f9ba5b8c43d293befe84d563"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["133525af0aa09d87ef4258fd43eed160b462b313"],"b0b597c65628ca9e73913a07e81691f8229bae35":["e4583dbd381e291c87e23144564c59ba3391b188","23b14fc1cb7939c2aad1d3a40f6282dee0bfda2e"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["1390137e395d2f07f9ba5b8c43d293befe84d563","56fb5e4e4b239474721e13b4cd9542ea2d215451"]},"commit2Childs":{"23b14fc1cb7939c2aad1d3a40f6282dee0bfda2e":["133525af0aa09d87ef4258fd43eed160b462b313","b0b597c65628ca9e73913a07e81691f8229bae35"],"133525af0aa09d87ef4258fd43eed160b462b313":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3470ed04f0378c1ceb02e540e3296dd27c0ae3d5":["e4583dbd381e291c87e23144564c59ba3391b188"],"26db0fd7da61a97dcbf4558f4fd1ebed330bbd45":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","1390137e395d2f07f9ba5b8c43d293befe84d563"],"e4583dbd381e291c87e23144564c59ba3391b188":["23b14fc1cb7939c2aad1d3a40f6282dee0bfda2e","b0b597c65628ca9e73913a07e81691f8229bae35"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["d2638f781be724518ff6c2263d14a48cf6e68017"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"56fb5e4e4b239474721e13b4cd9542ea2d215451":["3470ed04f0378c1ceb02e540e3296dd27c0ae3d5","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"1390137e395d2f07f9ba5b8c43d293befe84d563":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","56fb5e4e4b239474721e13b4cd9542ea2d215451","d2638f781be724518ff6c2263d14a48cf6e68017","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["26db0fd7da61a97dcbf4558f4fd1ebed330bbd45","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","d2638f781be724518ff6c2263d14a48cf6e68017","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}