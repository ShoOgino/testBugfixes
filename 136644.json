{"path":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","pathOld":"solr/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","sourceNew":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, schema.getAnalyzer());\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (termIndexInterval != -1)\n      iwc.setTermIndexInterval(termIndexInterval);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarityProvider(schema.getSimilarityProvider());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n\n    return iwc;\n  }\n\n","sourceOld":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, schema.getAnalyzer());\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (termIndexInterval != -1)\n      iwc.setTermIndexInterval(termIndexInterval);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarityProvider(schema.getSimilarityProvider());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n\n    return iwc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","pathOld":"solr/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","sourceNew":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, schema.getAnalyzer());\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (termIndexInterval != -1)\n      iwc.setTermIndexInterval(termIndexInterval);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarityProvider(schema.getSimilarityProvider());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n\n    return iwc;\n  }\n\n","sourceOld":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, schema.getAnalyzer());\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (termIndexInterval != -1)\n      iwc.setTermIndexInterval(termIndexInterval);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarityProvider(schema.getSimilarityProvider());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n\n    return iwc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","pathOld":"solr/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","sourceNew":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, schema.getAnalyzer());\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (termIndexInterval != -1)\n      iwc.setTermIndexInterval(termIndexInterval);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarityProvider(schema.getSimilarityProvider());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n\n    return iwc;\n  }\n\n","sourceOld":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, schema.getAnalyzer());\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (termIndexInterval != -1)\n      iwc.setTermIndexInterval(termIndexInterval);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarityProvider(schema.getSimilarityProvider());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n\n    return iwc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1ab42b0756bdd98ac6a6767b5a77d10d9ba12b4b","date":1328532481,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","sourceNew":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, schema.getAnalyzer());\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (termIndexInterval != -1)\n      iwc.setTermIndexInterval(termIndexInterval);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n\n    return iwc;\n  }\n\n","sourceOld":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, schema.getAnalyzer());\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (termIndexInterval != -1)\n      iwc.setTermIndexInterval(termIndexInterval);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarityProvider(schema.getSimilarityProvider());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n\n    return iwc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c3465573b8d89796a7dc94c1b6461292f8708c6d","date":1341336998,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","sourceNew":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    // so that we can update the analyzer on core reload, we pass null\n    // for the default analyzer, and explicitly pass an analyzer on \n    // appropriate calls to IndexWriter\n    \n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, null);\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (termIndexInterval != -1)\n      iwc.setTermIndexInterval(termIndexInterval);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n\n    return iwc;\n  }\n\n","sourceOld":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, schema.getAnalyzer());\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (termIndexInterval != -1)\n      iwc.setTermIndexInterval(termIndexInterval);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n\n    return iwc;\n  }\n\n","bugFix":["4e8cc373c801e54cec75daf9f52792cb4b17f536"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","sourceNew":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    // so that we can update the analyzer on core reload, we pass null\n    // for the default analyzer, and explicitly pass an analyzer on \n    // appropriate calls to IndexWriter\n    \n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, null);\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (termIndexInterval != -1)\n      iwc.setTermIndexInterval(termIndexInterval);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n\n    return iwc;\n  }\n\n","sourceOld":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, schema.getAnalyzer());\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (termIndexInterval != -1)\n      iwc.setTermIndexInterval(termIndexInterval);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n\n    return iwc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0667c7011259c2634991cf172c550f2c411df2ae","date":1350053156,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","sourceNew":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    // so that we can update the analyzer on core reload, we pass null\n    // for the default analyzer, and explicitly pass an analyzer on \n    // appropriate calls to IndexWriter\n    \n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, null);\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (termIndexInterval != -1)\n      iwc.setTermIndexInterval(termIndexInterval);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n\n    if (maxIndexingThreads != -1) {\n      iwc.setMaxThreadStates(maxIndexingThreads);\n    }\n\n    return iwc;\n  }\n\n","sourceOld":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    // so that we can update the analyzer on core reload, we pass null\n    // for the default analyzer, and explicitly pass an analyzer on \n    // appropriate calls to IndexWriter\n    \n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, null);\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (termIndexInterval != -1)\n      iwc.setTermIndexInterval(termIndexInterval);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n\n    return iwc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6efad415dcdbcca7d440f909743e6e3152eeb6c0","date":1350055371,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","sourceNew":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    // so that we can update the analyzer on core reload, we pass null\n    // for the default analyzer, and explicitly pass an analyzer on \n    // appropriate calls to IndexWriter\n    \n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, null);\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (termIndexInterval != -1)\n      iwc.setTermIndexInterval(termIndexInterval);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n\n    if (maxIndexingThreads != -1) {\n      iwc.setMaxThreadStates(maxIndexingThreads);\n    }\n\n    return iwc;\n  }\n\n","sourceOld":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    // so that we can update the analyzer on core reload, we pass null\n    // for the default analyzer, and explicitly pass an analyzer on \n    // appropriate calls to IndexWriter\n    \n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, null);\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (termIndexInterval != -1)\n      iwc.setTermIndexInterval(termIndexInterval);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n\n    return iwc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d82832af39f94dbb58a3130fd216ff1d49435589","date":1350147242,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","sourceNew":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    // so that we can update the analyzer on core reload, we pass null\n    // for the default analyzer, and explicitly pass an analyzer on \n    // appropriate calls to IndexWriter\n    \n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, null);\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (termIndexInterval != -1)\n      iwc.setTermIndexInterval(termIndexInterval);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n\n    if (maxIndexingThreads != -1) {\n      iwc.setMaxThreadStates(maxIndexingThreads);\n    }\n\n    return iwc;\n  }\n\n","sourceOld":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    // so that we can update the analyzer on core reload, we pass null\n    // for the default analyzer, and explicitly pass an analyzer on \n    // appropriate calls to IndexWriter\n    \n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, null);\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (termIndexInterval != -1)\n      iwc.setTermIndexInterval(termIndexInterval);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n\n    return iwc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"415fc059c6f2340aed1714220b9578c3f66ed09c","date":1366942705,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","sourceNew":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    // so that we can update the analyzer on core reload, we pass null\n    // for the default analyzer, and explicitly pass an analyzer on \n    // appropriate calls to IndexWriter\n    \n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, null);\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (termIndexInterval != -1)\n      iwc.setTermIndexInterval(termIndexInterval);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n\n    if (maxIndexingThreads != -1) {\n      iwc.setMaxThreadStates(maxIndexingThreads);\n    }\n    \n    if (mergedSegmentWarmerInfo != null) {\n      // TODO: add infostream -> normal logging system (there is an issue somewhere)\n      IndexReaderWarmer warmer = schema.getResourceLoader().newInstance(mergedSegmentWarmerInfo.className, \n                                                                        IndexReaderWarmer.class,\n                                                                        null,\n                                                                        new Class[] { InfoStream.class },\n                                                                        new Object[] { InfoStream.NO_OUTPUT });\n      iwc.setMergedSegmentWarmer(warmer);\n    }\n\n    return iwc;\n  }\n\n","sourceOld":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    // so that we can update the analyzer on core reload, we pass null\n    // for the default analyzer, and explicitly pass an analyzer on \n    // appropriate calls to IndexWriter\n    \n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, null);\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (termIndexInterval != -1)\n      iwc.setTermIndexInterval(termIndexInterval);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n\n    if (maxIndexingThreads != -1) {\n      iwc.setMaxThreadStates(maxIndexingThreads);\n    }\n\n    return iwc;\n  }\n\n","bugFix":null,"bugIntro":["1cb61792cbeba6c44e2530ca5836b96d956adb25","df151630bfbea5338a007b97bfd37e4ec94f873f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0e10d5539266ae943f9fa6befa6ac3481a2419c8","date":1371692194,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","sourceNew":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    // so that we can update the analyzer on core reload, we pass null\n    // for the default analyzer, and explicitly pass an analyzer on \n    // appropriate calls to IndexWriter\n    \n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, null);\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (termIndexInterval != -1)\n      iwc.setTermIndexInterval(termIndexInterval);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n\n    // do this after buildMergePolicy since the backcompat logic \n    // there may modify the effective useCompoundFile\n    iwc.setUseCompoundFile(getUseCompoundFile());\n\n    if (maxIndexingThreads != -1) {\n      iwc.setMaxThreadStates(maxIndexingThreads);\n    }\n    \n    if (mergedSegmentWarmerInfo != null) {\n      // TODO: add infostream -> normal logging system (there is an issue somewhere)\n      IndexReaderWarmer warmer = schema.getResourceLoader().newInstance(mergedSegmentWarmerInfo.className, \n                                                                        IndexReaderWarmer.class,\n                                                                        null,\n                                                                        new Class[] { InfoStream.class },\n                                                                        new Object[] { InfoStream.NO_OUTPUT });\n      iwc.setMergedSegmentWarmer(warmer);\n    }\n\n    return iwc;\n  }\n\n","sourceOld":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    // so that we can update the analyzer on core reload, we pass null\n    // for the default analyzer, and explicitly pass an analyzer on \n    // appropriate calls to IndexWriter\n    \n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, null);\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (termIndexInterval != -1)\n      iwc.setTermIndexInterval(termIndexInterval);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n\n    if (maxIndexingThreads != -1) {\n      iwc.setMaxThreadStates(maxIndexingThreads);\n    }\n    \n    if (mergedSegmentWarmerInfo != null) {\n      // TODO: add infostream -> normal logging system (there is an issue somewhere)\n      IndexReaderWarmer warmer = schema.getResourceLoader().newInstance(mergedSegmentWarmerInfo.className, \n                                                                        IndexReaderWarmer.class,\n                                                                        null,\n                                                                        new Class[] { InfoStream.class },\n                                                                        new Object[] { InfoStream.NO_OUTPUT });\n      iwc.setMergedSegmentWarmer(warmer);\n    }\n\n    return iwc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1cb61792cbeba6c44e2530ca5836b96d956adb25","date":1372469272,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","sourceNew":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    // so that we can update the analyzer on core reload, we pass null\n    // for the default analyzer, and explicitly pass an analyzer on \n    // appropriate calls to IndexWriter\n    \n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, null);\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (termIndexInterval != -1)\n      iwc.setTermIndexInterval(termIndexInterval);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n    iwc.setInfoStream(infoStream);\n\n    // do this after buildMergePolicy since the backcompat logic \n    // there may modify the effective useCompoundFile\n    iwc.setUseCompoundFile(getUseCompoundFile());\n\n    if (maxIndexingThreads != -1) {\n      iwc.setMaxThreadStates(maxIndexingThreads);\n    }\n    \n    if (mergedSegmentWarmerInfo != null) {\n      // TODO: add infostream -> normal logging system (there is an issue somewhere)\n      IndexReaderWarmer warmer = schema.getResourceLoader().newInstance(mergedSegmentWarmerInfo.className, \n                                                                        IndexReaderWarmer.class,\n                                                                        null,\n                                                                        new Class[] { InfoStream.class },\n                                                                        new Object[] { iwc.getInfoStream() });\n      iwc.setMergedSegmentWarmer(warmer);\n    }\n\n    return iwc;\n  }\n\n","sourceOld":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    // so that we can update the analyzer on core reload, we pass null\n    // for the default analyzer, and explicitly pass an analyzer on \n    // appropriate calls to IndexWriter\n    \n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, null);\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (termIndexInterval != -1)\n      iwc.setTermIndexInterval(termIndexInterval);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n\n    // do this after buildMergePolicy since the backcompat logic \n    // there may modify the effective useCompoundFile\n    iwc.setUseCompoundFile(getUseCompoundFile());\n\n    if (maxIndexingThreads != -1) {\n      iwc.setMaxThreadStates(maxIndexingThreads);\n    }\n    \n    if (mergedSegmentWarmerInfo != null) {\n      // TODO: add infostream -> normal logging system (there is an issue somewhere)\n      IndexReaderWarmer warmer = schema.getResourceLoader().newInstance(mergedSegmentWarmerInfo.className, \n                                                                        IndexReaderWarmer.class,\n                                                                        null,\n                                                                        new Class[] { InfoStream.class },\n                                                                        new Object[] { InfoStream.NO_OUTPUT });\n      iwc.setMergedSegmentWarmer(warmer);\n    }\n\n    return iwc;\n  }\n\n","bugFix":["415fc059c6f2340aed1714220b9578c3f66ed09c"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","sourceNew":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    // so that we can update the analyzer on core reload, we pass null\n    // for the default analyzer, and explicitly pass an analyzer on \n    // appropriate calls to IndexWriter\n    \n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, null);\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (termIndexInterval != -1)\n      iwc.setTermIndexInterval(termIndexInterval);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n    iwc.setInfoStream(infoStream);\n\n    // do this after buildMergePolicy since the backcompat logic \n    // there may modify the effective useCompoundFile\n    iwc.setUseCompoundFile(getUseCompoundFile());\n\n    if (maxIndexingThreads != -1) {\n      iwc.setMaxThreadStates(maxIndexingThreads);\n    }\n    \n    if (mergedSegmentWarmerInfo != null) {\n      // TODO: add infostream -> normal logging system (there is an issue somewhere)\n      IndexReaderWarmer warmer = schema.getResourceLoader().newInstance(mergedSegmentWarmerInfo.className, \n                                                                        IndexReaderWarmer.class,\n                                                                        null,\n                                                                        new Class[] { InfoStream.class },\n                                                                        new Object[] { iwc.getInfoStream() });\n      iwc.setMergedSegmentWarmer(warmer);\n    }\n\n    return iwc;\n  }\n\n","sourceOld":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    // so that we can update the analyzer on core reload, we pass null\n    // for the default analyzer, and explicitly pass an analyzer on \n    // appropriate calls to IndexWriter\n    \n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, null);\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (termIndexInterval != -1)\n      iwc.setTermIndexInterval(termIndexInterval);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n\n    if (maxIndexingThreads != -1) {\n      iwc.setMaxThreadStates(maxIndexingThreads);\n    }\n    \n    if (mergedSegmentWarmerInfo != null) {\n      // TODO: add infostream -> normal logging system (there is an issue somewhere)\n      IndexReaderWarmer warmer = schema.getResourceLoader().newInstance(mergedSegmentWarmerInfo.className, \n                                                                        IndexReaderWarmer.class,\n                                                                        null,\n                                                                        new Class[] { InfoStream.class },\n                                                                        new Object[] { InfoStream.NO_OUTPUT });\n      iwc.setMergedSegmentWarmer(warmer);\n    }\n\n    return iwc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a45bec74b98f6fc05f52770cfb425739e6563960","date":1375119292,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","sourceNew":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    // so that we can update the analyzer on core reload, we pass null\n    // for the default analyzer, and explicitly pass an analyzer on \n    // appropriate calls to IndexWriter\n    \n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, null);\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n    iwc.setInfoStream(infoStream);\n\n    // do this after buildMergePolicy since the backcompat logic \n    // there may modify the effective useCompoundFile\n    iwc.setUseCompoundFile(getUseCompoundFile());\n\n    if (maxIndexingThreads != -1) {\n      iwc.setMaxThreadStates(maxIndexingThreads);\n    }\n    \n    if (mergedSegmentWarmerInfo != null) {\n      // TODO: add infostream -> normal logging system (there is an issue somewhere)\n      IndexReaderWarmer warmer = schema.getResourceLoader().newInstance(mergedSegmentWarmerInfo.className, \n                                                                        IndexReaderWarmer.class,\n                                                                        null,\n                                                                        new Class[] { InfoStream.class },\n                                                                        new Object[] { iwc.getInfoStream() });\n      iwc.setMergedSegmentWarmer(warmer);\n    }\n\n    return iwc;\n  }\n\n","sourceOld":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    // so that we can update the analyzer on core reload, we pass null\n    // for the default analyzer, and explicitly pass an analyzer on \n    // appropriate calls to IndexWriter\n    \n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, null);\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (termIndexInterval != -1)\n      iwc.setTermIndexInterval(termIndexInterval);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n    iwc.setInfoStream(infoStream);\n\n    // do this after buildMergePolicy since the backcompat logic \n    // there may modify the effective useCompoundFile\n    iwc.setUseCompoundFile(getUseCompoundFile());\n\n    if (maxIndexingThreads != -1) {\n      iwc.setMaxThreadStates(maxIndexingThreads);\n    }\n    \n    if (mergedSegmentWarmerInfo != null) {\n      // TODO: add infostream -> normal logging system (there is an issue somewhere)\n      IndexReaderWarmer warmer = schema.getResourceLoader().newInstance(mergedSegmentWarmerInfo.className, \n                                                                        IndexReaderWarmer.class,\n                                                                        null,\n                                                                        new Class[] { InfoStream.class },\n                                                                        new Object[] { iwc.getInfoStream() });\n      iwc.setMergedSegmentWarmer(warmer);\n    }\n\n    return iwc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","sourceNew":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    // so that we can update the analyzer on core reload, we pass null\n    // for the default analyzer, and explicitly pass an analyzer on \n    // appropriate calls to IndexWriter\n    \n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, null);\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n    iwc.setInfoStream(infoStream);\n\n    // do this after buildMergePolicy since the backcompat logic \n    // there may modify the effective useCompoundFile\n    iwc.setUseCompoundFile(getUseCompoundFile());\n\n    if (maxIndexingThreads != -1) {\n      iwc.setMaxThreadStates(maxIndexingThreads);\n    }\n    \n    if (mergedSegmentWarmerInfo != null) {\n      // TODO: add infostream -> normal logging system (there is an issue somewhere)\n      IndexReaderWarmer warmer = schema.getResourceLoader().newInstance(mergedSegmentWarmerInfo.className, \n                                                                        IndexReaderWarmer.class,\n                                                                        null,\n                                                                        new Class[] { InfoStream.class },\n                                                                        new Object[] { iwc.getInfoStream() });\n      iwc.setMergedSegmentWarmer(warmer);\n    }\n\n    return iwc;\n  }\n\n","sourceOld":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    // so that we can update the analyzer on core reload, we pass null\n    // for the default analyzer, and explicitly pass an analyzer on \n    // appropriate calls to IndexWriter\n    \n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, null);\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (termIndexInterval != -1)\n      iwc.setTermIndexInterval(termIndexInterval);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n    iwc.setInfoStream(infoStream);\n\n    // do this after buildMergePolicy since the backcompat logic \n    // there may modify the effective useCompoundFile\n    iwc.setUseCompoundFile(getUseCompoundFile());\n\n    if (maxIndexingThreads != -1) {\n      iwc.setMaxThreadStates(maxIndexingThreads);\n    }\n    \n    if (mergedSegmentWarmerInfo != null) {\n      // TODO: add infostream -> normal logging system (there is an issue somewhere)\n      IndexReaderWarmer warmer = schema.getResourceLoader().newInstance(mergedSegmentWarmerInfo.className, \n                                                                        IndexReaderWarmer.class,\n                                                                        null,\n                                                                        new Class[] { InfoStream.class },\n                                                                        new Object[] { iwc.getInfoStream() });\n      iwc.setMergedSegmentWarmer(warmer);\n    }\n\n    return iwc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6e7d674d8857e8df2e386eed8175bd53a1912116","date":1398195958,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","sourceNew":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    // so that we can update the analyzer on core reload, we pass null\n    // for the default analyzer, and explicitly pass an analyzer on \n    // appropriate calls to IndexWriter\n    \n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, null);\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n    iwc.setInfoStream(infoStream);\n\n    // do this after buildMergePolicy since the backcompat logic \n    // there may modify the effective useCompoundFile\n    iwc.setUseCompoundFile(getUseCompoundFile());\n\n    if (maxIndexingThreads != -1) {\n      iwc.setMaxThreadStates(maxIndexingThreads);\n    }\n    \n    if (mergedSegmentWarmerInfo != null) {\n      // TODO: add infostream -> normal logging system (there is an issue somewhere)\n      IndexReaderWarmer warmer = schema.getResourceLoader().newInstance(mergedSegmentWarmerInfo.className, \n                                                                        IndexReaderWarmer.class,\n                                                                        null,\n                                                                        new Class[] { InfoStream.class },\n                                                                        new Object[] { iwc.getInfoStream() });\n      iwc.setMergedSegmentWarmer(warmer);\n    }\n\n    iwc.setCheckIntegrityAtMerge(checkIntegrityAtMerge);\n\n    return iwc;\n  }\n\n","sourceOld":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    // so that we can update the analyzer on core reload, we pass null\n    // for the default analyzer, and explicitly pass an analyzer on \n    // appropriate calls to IndexWriter\n    \n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, null);\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n    iwc.setInfoStream(infoStream);\n\n    // do this after buildMergePolicy since the backcompat logic \n    // there may modify the effective useCompoundFile\n    iwc.setUseCompoundFile(getUseCompoundFile());\n\n    if (maxIndexingThreads != -1) {\n      iwc.setMaxThreadStates(maxIndexingThreads);\n    }\n    \n    if (mergedSegmentWarmerInfo != null) {\n      // TODO: add infostream -> normal logging system (there is an issue somewhere)\n      IndexReaderWarmer warmer = schema.getResourceLoader().newInstance(mergedSegmentWarmerInfo.className, \n                                                                        IndexReaderWarmer.class,\n                                                                        null,\n                                                                        new Class[] { InfoStream.class },\n                                                                        new Object[] { iwc.getInfoStream() });\n      iwc.setMergedSegmentWarmer(warmer);\n    }\n\n    return iwc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","date":1398844771,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","sourceNew":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    // so that we can update the analyzer on core reload, we pass null\n    // for the default analyzer, and explicitly pass an analyzer on \n    // appropriate calls to IndexWriter\n    \n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, null);\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n    iwc.setInfoStream(infoStream);\n\n    // do this after buildMergePolicy since the backcompat logic \n    // there may modify the effective useCompoundFile\n    iwc.setUseCompoundFile(getUseCompoundFile());\n\n    if (maxIndexingThreads != -1) {\n      iwc.setMaxThreadStates(maxIndexingThreads);\n    }\n    \n    if (mergedSegmentWarmerInfo != null) {\n      // TODO: add infostream -> normal logging system (there is an issue somewhere)\n      IndexReaderWarmer warmer = schema.getResourceLoader().newInstance(mergedSegmentWarmerInfo.className, \n                                                                        IndexReaderWarmer.class,\n                                                                        null,\n                                                                        new Class[] { InfoStream.class },\n                                                                        new Object[] { iwc.getInfoStream() });\n      iwc.setMergedSegmentWarmer(warmer);\n    }\n\n    iwc.setCheckIntegrityAtMerge(checkIntegrityAtMerge);\n\n    return iwc;\n  }\n\n","sourceOld":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    // so that we can update the analyzer on core reload, we pass null\n    // for the default analyzer, and explicitly pass an analyzer on \n    // appropriate calls to IndexWriter\n    \n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, null);\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n    iwc.setInfoStream(infoStream);\n\n    // do this after buildMergePolicy since the backcompat logic \n    // there may modify the effective useCompoundFile\n    iwc.setUseCompoundFile(getUseCompoundFile());\n\n    if (maxIndexingThreads != -1) {\n      iwc.setMaxThreadStates(maxIndexingThreads);\n    }\n    \n    if (mergedSegmentWarmerInfo != null) {\n      // TODO: add infostream -> normal logging system (there is an issue somewhere)\n      IndexReaderWarmer warmer = schema.getResourceLoader().newInstance(mergedSegmentWarmerInfo.className, \n                                                                        IndexReaderWarmer.class,\n                                                                        null,\n                                                                        new Class[] { InfoStream.class },\n                                                                        new Object[] { iwc.getInfoStream() });\n      iwc.setMergedSegmentWarmer(warmer);\n    }\n\n    return iwc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","sourceNew":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    // so that we can update the analyzer on core reload, we pass null\n    // for the default analyzer, and explicitly pass an analyzer on \n    // appropriate calls to IndexWriter\n    \n    IndexWriterConfig iwc = new IndexWriterConfig(null);\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n    iwc.setInfoStream(infoStream);\n\n    // do this after buildMergePolicy since the backcompat logic \n    // there may modify the effective useCompoundFile\n    iwc.setUseCompoundFile(getUseCompoundFile());\n\n    if (maxIndexingThreads != -1) {\n      iwc.setMaxThreadStates(maxIndexingThreads);\n    }\n    \n    if (mergedSegmentWarmerInfo != null) {\n      // TODO: add infostream -> normal logging system (there is an issue somewhere)\n      IndexReaderWarmer warmer = schema.getResourceLoader().newInstance(mergedSegmentWarmerInfo.className, \n                                                                        IndexReaderWarmer.class,\n                                                                        null,\n                                                                        new Class[] { InfoStream.class },\n                                                                        new Object[] { iwc.getInfoStream() });\n      iwc.setMergedSegmentWarmer(warmer);\n    }\n\n    iwc.setCheckIntegrityAtMerge(checkIntegrityAtMerge);\n\n    return iwc;\n  }\n\n","sourceOld":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    // so that we can update the analyzer on core reload, we pass null\n    // for the default analyzer, and explicitly pass an analyzer on \n    // appropriate calls to IndexWriter\n    \n    IndexWriterConfig iwc = new IndexWriterConfig(luceneVersion, null);\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n    iwc.setInfoStream(infoStream);\n\n    // do this after buildMergePolicy since the backcompat logic \n    // there may modify the effective useCompoundFile\n    iwc.setUseCompoundFile(getUseCompoundFile());\n\n    if (maxIndexingThreads != -1) {\n      iwc.setMaxThreadStates(maxIndexingThreads);\n    }\n    \n    if (mergedSegmentWarmerInfo != null) {\n      // TODO: add infostream -> normal logging system (there is an issue somewhere)\n      IndexReaderWarmer warmer = schema.getResourceLoader().newInstance(mergedSegmentWarmerInfo.className, \n                                                                        IndexReaderWarmer.class,\n                                                                        null,\n                                                                        new Class[] { InfoStream.class },\n                                                                        new Object[] { iwc.getInfoStream() });\n      iwc.setMergedSegmentWarmer(warmer);\n    }\n\n    iwc.setCheckIntegrityAtMerge(checkIntegrityAtMerge);\n\n    return iwc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6ac4bff3307e88928bf48cd1a283ff7da1f82464","date":1411914960,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","sourceNew":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    // so that we can update the analyzer on core reload, we pass null\n    // for the default analyzer, and explicitly pass an analyzer on \n    // appropriate calls to IndexWriter\n    \n    IndexWriterConfig iwc = new IndexWriterConfig(null);\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n    iwc.setInfoStream(infoStream);\n\n    // do this after buildMergePolicy since the backcompat logic \n    // there may modify the effective useCompoundFile\n    iwc.setUseCompoundFile(getUseCompoundFile());\n\n    if (maxIndexingThreads != -1) {\n      iwc.setMaxThreadStates(maxIndexingThreads);\n    }\n    \n    if (mergedSegmentWarmerInfo != null) {\n      // TODO: add infostream -> normal logging system (there is an issue somewhere)\n      IndexReaderWarmer warmer = schema.getResourceLoader().newInstance(mergedSegmentWarmerInfo.className, \n                                                                        IndexReaderWarmer.class,\n                                                                        null,\n                                                                        new Class[] { InfoStream.class },\n                                                                        new Object[] { iwc.getInfoStream() });\n      iwc.setMergedSegmentWarmer(warmer);\n    }\n\n    return iwc;\n  }\n\n","sourceOld":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    // so that we can update the analyzer on core reload, we pass null\n    // for the default analyzer, and explicitly pass an analyzer on \n    // appropriate calls to IndexWriter\n    \n    IndexWriterConfig iwc = new IndexWriterConfig(null);\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n    iwc.setInfoStream(infoStream);\n\n    // do this after buildMergePolicy since the backcompat logic \n    // there may modify the effective useCompoundFile\n    iwc.setUseCompoundFile(getUseCompoundFile());\n\n    if (maxIndexingThreads != -1) {\n      iwc.setMaxThreadStates(maxIndexingThreads);\n    }\n    \n    if (mergedSegmentWarmerInfo != null) {\n      // TODO: add infostream -> normal logging system (there is an issue somewhere)\n      IndexReaderWarmer warmer = schema.getResourceLoader().newInstance(mergedSegmentWarmerInfo.className, \n                                                                        IndexReaderWarmer.class,\n                                                                        null,\n                                                                        new Class[] { InfoStream.class },\n                                                                        new Object[] { iwc.getInfoStream() });\n      iwc.setMergedSegmentWarmer(warmer);\n    }\n\n    iwc.setCheckIntegrityAtMerge(checkIntegrityAtMerge);\n\n    return iwc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9bb9a29a5e71a90295f175df8919802993142c9a","date":1412517673,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","sourceNew":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    // so that we can update the analyzer on core reload, we pass null\n    // for the default analyzer, and explicitly pass an analyzer on \n    // appropriate calls to IndexWriter\n    \n    IndexWriterConfig iwc = new IndexWriterConfig(null);\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n    iwc.setInfoStream(infoStream);\n\n    // do this after buildMergePolicy since the backcompat logic \n    // there may modify the effective useCompoundFile\n    iwc.setUseCompoundFile(getUseCompoundFile());\n\n    if (maxIndexingThreads != -1) {\n      iwc.setMaxThreadStates(maxIndexingThreads);\n    }\n    \n    if (mergedSegmentWarmerInfo != null) {\n      // TODO: add infostream -> normal logging system (there is an issue somewhere)\n      IndexReaderWarmer warmer = schema.getResourceLoader().newInstance(mergedSegmentWarmerInfo.className, \n                                                                        IndexReaderWarmer.class,\n                                                                        null,\n                                                                        new Class[] { InfoStream.class },\n                                                                        new Object[] { iwc.getInfoStream() });\n      iwc.setMergedSegmentWarmer(warmer);\n    }\n\n    return iwc;\n  }\n\n","sourceOld":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    // so that we can update the analyzer on core reload, we pass null\n    // for the default analyzer, and explicitly pass an analyzer on \n    // appropriate calls to IndexWriter\n    \n    IndexWriterConfig iwc = new IndexWriterConfig(null);\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n    iwc.setInfoStream(infoStream);\n\n    // do this after buildMergePolicy since the backcompat logic \n    // there may modify the effective useCompoundFile\n    iwc.setUseCompoundFile(getUseCompoundFile());\n\n    if (maxIndexingThreads != -1) {\n      iwc.setMaxThreadStates(maxIndexingThreads);\n    }\n    \n    if (mergedSegmentWarmerInfo != null) {\n      // TODO: add infostream -> normal logging system (there is an issue somewhere)\n      IndexReaderWarmer warmer = schema.getResourceLoader().newInstance(mergedSegmentWarmerInfo.className, \n                                                                        IndexReaderWarmer.class,\n                                                                        null,\n                                                                        new Class[] { InfoStream.class },\n                                                                        new Object[] { iwc.getInfoStream() });\n      iwc.setMergedSegmentWarmer(warmer);\n    }\n\n    iwc.setCheckIntegrityAtMerge(checkIntegrityAtMerge);\n\n    return iwc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5c1c5aa8e88aa52c9e1cbfc696b611d3a56223c0","date":1422781929,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/SolrIndexConfig#toIndexWriterConfig(IndexSchema).mjava","sourceNew":"  public IndexWriterConfig toIndexWriterConfig(SolrCore core) {\n    IndexSchema schema = core.getLatestSchema();\n    IndexWriterConfig iwc = new IndexWriterConfig(new DelayedSchemaAnalyzer(core));\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n    iwc.setInfoStream(infoStream);\n\n    // do this after buildMergePolicy since the backcompat logic \n    // there may modify the effective useCompoundFile\n    iwc.setUseCompoundFile(getUseCompoundFile());\n\n    if (maxIndexingThreads != -1) {\n      iwc.setMaxThreadStates(maxIndexingThreads);\n    }\n    \n    if (mergedSegmentWarmerInfo != null) {\n      // TODO: add infostream -> normal logging system (there is an issue somewhere)\n      IndexReaderWarmer warmer = schema.getResourceLoader().newInstance(mergedSegmentWarmerInfo.className, \n                                                                        IndexReaderWarmer.class,\n                                                                        null,\n                                                                        new Class[] { InfoStream.class },\n                                                                        new Object[] { iwc.getInfoStream() });\n      iwc.setMergedSegmentWarmer(warmer);\n    }\n\n    return iwc;\n  }\n\n","sourceOld":"  public IndexWriterConfig toIndexWriterConfig(IndexSchema schema) {\n    // so that we can update the analyzer on core reload, we pass null\n    // for the default analyzer, and explicitly pass an analyzer on \n    // appropriate calls to IndexWriter\n    \n    IndexWriterConfig iwc = new IndexWriterConfig(null);\n    if (maxBufferedDocs != -1)\n      iwc.setMaxBufferedDocs(maxBufferedDocs);\n\n    if (ramBufferSizeMB != -1)\n      iwc.setRAMBufferSizeMB(ramBufferSizeMB);\n\n    if (writeLockTimeout != -1)\n      iwc.setWriteLockTimeout(writeLockTimeout);\n\n    iwc.setSimilarity(schema.getSimilarity());\n    iwc.setMergePolicy(buildMergePolicy(schema));\n    iwc.setMergeScheduler(buildMergeScheduler(schema));\n    iwc.setInfoStream(infoStream);\n\n    // do this after buildMergePolicy since the backcompat logic \n    // there may modify the effective useCompoundFile\n    iwc.setUseCompoundFile(getUseCompoundFile());\n\n    if (maxIndexingThreads != -1) {\n      iwc.setMaxThreadStates(maxIndexingThreads);\n    }\n    \n    if (mergedSegmentWarmerInfo != null) {\n      // TODO: add infostream -> normal logging system (there is an issue somewhere)\n      IndexReaderWarmer warmer = schema.getResourceLoader().newInstance(mergedSegmentWarmerInfo.className, \n                                                                        IndexReaderWarmer.class,\n                                                                        null,\n                                                                        new Class[] { InfoStream.class },\n                                                                        new Object[] { iwc.getInfoStream() });\n      iwc.setMergedSegmentWarmer(warmer);\n    }\n\n    return iwc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"1cb61792cbeba6c44e2530ca5836b96d956adb25":["0e10d5539266ae943f9fa6befa6ac3481a2419c8"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["37a0f60745e53927c4c876cfe5b5a58170f0646c","a45bec74b98f6fc05f52770cfb425739e6563960"],"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":["a45bec74b98f6fc05f52770cfb425739e6563960","6e7d674d8857e8df2e386eed8175bd53a1912116"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["415fc059c6f2340aed1714220b9578c3f66ed09c","1cb61792cbeba6c44e2530ca5836b96d956adb25"],"a45bec74b98f6fc05f52770cfb425739e6563960":["1cb61792cbeba6c44e2530ca5836b96d956adb25"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"1ab42b0756bdd98ac6a6767b5a77d10d9ba12b4b":["c26f00b574427b55127e869b935845554afde1fa"],"6e7d674d8857e8df2e386eed8175bd53a1912116":["a45bec74b98f6fc05f52770cfb425739e6563960"],"c3465573b8d89796a7dc94c1b6461292f8708c6d":["1ab42b0756bdd98ac6a6767b5a77d10d9ba12b4b"],"6ac4bff3307e88928bf48cd1a283ff7da1f82464":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"5c1c5aa8e88aa52c9e1cbfc696b611d3a56223c0":["9bb9a29a5e71a90295f175df8919802993142c9a"],"6efad415dcdbcca7d440f909743e6e3152eeb6c0":["c3465573b8d89796a7dc94c1b6461292f8708c6d","0667c7011259c2634991cf172c550f2c411df2ae"],"0667c7011259c2634991cf172c550f2c411df2ae":["c3465573b8d89796a7dc94c1b6461292f8708c6d"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d82832af39f94dbb58a3130fd216ff1d49435589":["c3465573b8d89796a7dc94c1b6461292f8708c6d","0667c7011259c2634991cf172c550f2c411df2ae"],"9bb9a29a5e71a90295f175df8919802993142c9a":["d0ef034a4f10871667ae75181537775ddcf8ade4","6ac4bff3307e88928bf48cd1a283ff7da1f82464"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["1ab42b0756bdd98ac6a6767b5a77d10d9ba12b4b","c3465573b8d89796a7dc94c1b6461292f8708c6d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["6e7d674d8857e8df2e386eed8175bd53a1912116"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"415fc059c6f2340aed1714220b9578c3f66ed09c":["0667c7011259c2634991cf172c550f2c411df2ae"],"0e10d5539266ae943f9fa6befa6ac3481a2419c8":["415fc059c6f2340aed1714220b9578c3f66ed09c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5c1c5aa8e88aa52c9e1cbfc696b611d3a56223c0"]},"commit2Childs":{"1cb61792cbeba6c44e2530ca5836b96d956adb25":["37a0f60745e53927c4c876cfe5b5a58170f0646c","a45bec74b98f6fc05f52770cfb425739e6563960"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":[],"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":[],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec"],"a45bec74b98f6fc05f52770cfb425739e6563960":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","6e7d674d8857e8df2e386eed8175bd53a1912116"],"c26f00b574427b55127e869b935845554afde1fa":["1ab42b0756bdd98ac6a6767b5a77d10d9ba12b4b"],"1ab42b0756bdd98ac6a6767b5a77d10d9ba12b4b":["c3465573b8d89796a7dc94c1b6461292f8708c6d","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"6e7d674d8857e8df2e386eed8175bd53a1912116":["c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","d0ef034a4f10871667ae75181537775ddcf8ade4"],"c3465573b8d89796a7dc94c1b6461292f8708c6d":["6efad415dcdbcca7d440f909743e6e3152eeb6c0","0667c7011259c2634991cf172c550f2c411df2ae","d82832af39f94dbb58a3130fd216ff1d49435589","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"6ac4bff3307e88928bf48cd1a283ff7da1f82464":["9bb9a29a5e71a90295f175df8919802993142c9a"],"5c1c5aa8e88aa52c9e1cbfc696b611d3a56223c0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6efad415dcdbcca7d440f909743e6e3152eeb6c0":[],"0667c7011259c2634991cf172c550f2c411df2ae":["6efad415dcdbcca7d440f909743e6e3152eeb6c0","d82832af39f94dbb58a3130fd216ff1d49435589","415fc059c6f2340aed1714220b9578c3f66ed09c"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"d82832af39f94dbb58a3130fd216ff1d49435589":[],"9bb9a29a5e71a90295f175df8919802993142c9a":["5c1c5aa8e88aa52c9e1cbfc696b611d3a56223c0"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["6ac4bff3307e88928bf48cd1a283ff7da1f82464","9bb9a29a5e71a90295f175df8919802993142c9a"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"415fc059c6f2340aed1714220b9578c3f66ed09c":["37a0f60745e53927c4c876cfe5b5a58170f0646c","0e10d5539266ae943f9fa6befa6ac3481a2419c8"],"0e10d5539266ae943f9fa6befa6ac3481a2419c8":["1cb61792cbeba6c44e2530ca5836b96d956adb25"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","6efad415dcdbcca7d440f909743e6e3152eeb6c0","d82832af39f94dbb58a3130fd216ff1d49435589","fe33227f6805edab2036cbb80645cc4e2d1fa424","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}