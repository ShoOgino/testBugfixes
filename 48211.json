{"path":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","commits":[{"id":"aabae793f43472efdf1dcdaae4e01e28cfc23ccd","date":1161750034,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"/dev/null","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\r\n   * and ensure a hitcollector receives same docs and scores\r\n   */\r\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\r\n    //System.out.println(\"Checking \"+q);\r\n    final Weight w = q.weight(s);\r\n    final Scorer scorer = w.scorer(s.getIndexReader());\r\n\r\n    // FUTURE: ensure scorer.doc()==-1\r\n    \r\n    if (BooleanQuery.getUseScorer14()) return;  // 1.4 doesn't support skipTo\r\n\r\n    final int[] which = new int[1];\r\n    final int[] sdoc = new int[] {-1};\r\n    final float maxDiff = 1e-5f;\r\n    s.search(q,new HitCollector() {\r\n      public void collect(int doc, float score) {\r\n        try {\r\n          boolean more = (which[0]++&0x02)==0 ? scorer.skipTo(sdoc[0]+1) : scorer.next();\r\n          sdoc[0] = scorer.doc();\r\n          float scorerScore = scorer.score();\r\n          float scoreDiff = Math.abs(score-scorerScore);\r\n          scoreDiff=0; // TODO: remove this go get LUCENE-697 failures \r\n          if (more==false || doc != sdoc[0] || scoreDiff>maxDiff) {\r\n            throw new RuntimeException(\"ERROR matching docs:\"\r\n                    +\"\\n\\tscorer.more=\" + more + \" doc=\"+sdoc[0] + \" score=\"+scorerScore\r\n                    +\"\\n\\thitCollector.doc=\" + doc + \" score=\"+score\r\n                    +\"\\n\\t Scorer=\" + scorer\r\n                    +\"\\n\\t Query=\" + q\r\n                    +\"\\n\\t Searcher=\" + s\r\n            );\r\n          }\r\n        } catch (IOException e) {\r\n          throw new RuntimeException(e);\r\n        }\r\n      }\r\n    });\r\n\r\n    // make sure next call to scorer is false.\r\n    TestCase.assertFalse((which[0]++&0x02)==0 ? scorer.skipTo(sdoc[0]+1) : scorer.next());\r\n  }\r\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"76349ae49451ab1e1e63e8eeb254f82684b1da25","date":1176847207,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\r\n   * and ensure a hitcollector receives same docs and scores\r\n   */\r\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\r\n    //System.out.println(\"Checking \"+q);\r\n    final Weight w = q.weight(s);\r\n    final Scorer scorer = w.scorer(s.getIndexReader());\r\n\r\n    // FUTURE: ensure scorer.doc()==-1\r\n    \r\n    if (BooleanQuery.getUseScorer14()) return;  // 1.4 doesn't support skipTo\r\n\r\n    final int[] which = new int[1];\r\n    final int[] sdoc = new int[] {-1};\r\n    final float maxDiff = 1e-5f;\r\n    s.search(q,new HitCollector() {\r\n      public void collect(int doc, float score) {\r\n        try {\r\n          boolean more = (which[0]++&0x02)==0 ? scorer.skipTo(sdoc[0]+1) : scorer.next();\r\n          sdoc[0] = scorer.doc();\r\n          float scorerScore = scorer.score();\r\n          float scoreDiff = Math.abs(score-scorerScore);\r\n          scoreDiff=0; // TODO: remove this go get LUCENE-697 failures \r\n          if (more==false || doc != sdoc[0] || scoreDiff>maxDiff) {\r\n            throw new RuntimeException(\"ERROR matching docs:\"\r\n                    +\"\\n\\tscorer.more=\" + more + \" doc=\"+sdoc[0] + \" scorerScore=\"+scorerScore\r\n                    +\" scoreDiff=\"+scoreDiff + \" maxDiff=\"+maxDiff\r\n                    +\"\\n\\thitCollector.doc=\" + doc + \" score=\"+score\r\n                    +\"\\n\\t Scorer=\" + scorer\r\n                    +\"\\n\\t Query=\" + q\r\n                    +\"\\n\\t Searcher=\" + s\r\n            );\r\n          }\r\n        } catch (IOException e) {\r\n          throw new RuntimeException(e);\r\n        }\r\n      }\r\n    });\r\n\r\n    // make sure next call to scorer is false.\r\n    TestCase.assertFalse((which[0]++&0x02)==0 ? scorer.skipTo(sdoc[0]+1) : scorer.next());\r\n  }\r\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\r\n   * and ensure a hitcollector receives same docs and scores\r\n   */\r\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\r\n    //System.out.println(\"Checking \"+q);\r\n    final Weight w = q.weight(s);\r\n    final Scorer scorer = w.scorer(s.getIndexReader());\r\n\r\n    // FUTURE: ensure scorer.doc()==-1\r\n    \r\n    if (BooleanQuery.getUseScorer14()) return;  // 1.4 doesn't support skipTo\r\n\r\n    final int[] which = new int[1];\r\n    final int[] sdoc = new int[] {-1};\r\n    final float maxDiff = 1e-5f;\r\n    s.search(q,new HitCollector() {\r\n      public void collect(int doc, float score) {\r\n        try {\r\n          boolean more = (which[0]++&0x02)==0 ? scorer.skipTo(sdoc[0]+1) : scorer.next();\r\n          sdoc[0] = scorer.doc();\r\n          float scorerScore = scorer.score();\r\n          float scoreDiff = Math.abs(score-scorerScore);\r\n          scoreDiff=0; // TODO: remove this go get LUCENE-697 failures \r\n          if (more==false || doc != sdoc[0] || scoreDiff>maxDiff) {\r\n            throw new RuntimeException(\"ERROR matching docs:\"\r\n                    +\"\\n\\tscorer.more=\" + more + \" doc=\"+sdoc[0] + \" score=\"+scorerScore\r\n                    +\"\\n\\thitCollector.doc=\" + doc + \" score=\"+score\r\n                    +\"\\n\\t Scorer=\" + scorer\r\n                    +\"\\n\\t Query=\" + q\r\n                    +\"\\n\\t Searcher=\" + s\r\n            );\r\n          }\r\n        } catch (IOException e) {\r\n          throw new RuntimeException(e);\r\n        }\r\n      }\r\n    });\r\n\r\n    // make sure next call to scorer is false.\r\n    TestCase.assertFalse((which[0]++&0x02)==0 ? scorer.skipTo(sdoc[0]+1) : scorer.next());\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"492d71f81abcc186afa0074702472ecb6b7dc997","date":1177385598,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final Weight w = q.weight(s);\n    final Scorer scorer = w.scorer(s.getIndexReader());\n\n    // FUTURE: ensure scorer.doc()==-1\n    \n    if (BooleanQuery.getUseScorer14()) return;  // 1.4 doesn't support skipTo\n\n    final int[] which = new int[1];\n    final int[] sdoc = new int[] {-1};\n    final float maxDiff = 1e-5f;\n    s.search(q,new HitCollector() {\n      public void collect(int doc, float score) {\n        try {\n          boolean more = (which[0]++&0x02)==0 ? scorer.skipTo(sdoc[0]+1) : scorer.next();\n          sdoc[0] = scorer.doc();\n          float scorerScore = scorer.score();\n          float scoreDiff = Math.abs(score-scorerScore);\n          scoreDiff=0; // TODO: remove this go get LUCENE-697 failures \n          if (more==false || doc != sdoc[0] || scoreDiff>maxDiff) {\n            throw new RuntimeException(\"ERROR matching docs:\"\n                    +\"\\n\\tscorer.more=\" + more + \" doc=\"+sdoc[0] + \" scorerScore=\"+scorerScore\n                    +\" scoreDiff=\"+scoreDiff + \" maxDiff=\"+maxDiff\n                    +\"\\n\\thitCollector.doc=\" + doc + \" score=\"+score\n                    +\"\\n\\t Scorer=\" + scorer\n                    +\"\\n\\t Query=\" + q\n                    +\"\\n\\t Searcher=\" + s\n            );\n          }\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    });\n\n    // make sure next call to scorer is false.\n    TestCase.assertFalse((which[0]++&0x02)==0 ? scorer.skipTo(sdoc[0]+1) : scorer.next());\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\r\n   * and ensure a hitcollector receives same docs and scores\r\n   */\r\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\r\n    //System.out.println(\"Checking \"+q);\r\n    final Weight w = q.weight(s);\r\n    final Scorer scorer = w.scorer(s.getIndexReader());\r\n\r\n    // FUTURE: ensure scorer.doc()==-1\r\n    \r\n    if (BooleanQuery.getUseScorer14()) return;  // 1.4 doesn't support skipTo\r\n\r\n    final int[] which = new int[1];\r\n    final int[] sdoc = new int[] {-1};\r\n    final float maxDiff = 1e-5f;\r\n    s.search(q,new HitCollector() {\r\n      public void collect(int doc, float score) {\r\n        try {\r\n          boolean more = (which[0]++&0x02)==0 ? scorer.skipTo(sdoc[0]+1) : scorer.next();\r\n          sdoc[0] = scorer.doc();\r\n          float scorerScore = scorer.score();\r\n          float scoreDiff = Math.abs(score-scorerScore);\r\n          scoreDiff=0; // TODO: remove this go get LUCENE-697 failures \r\n          if (more==false || doc != sdoc[0] || scoreDiff>maxDiff) {\r\n            throw new RuntimeException(\"ERROR matching docs:\"\r\n                    +\"\\n\\tscorer.more=\" + more + \" doc=\"+sdoc[0] + \" scorerScore=\"+scorerScore\r\n                    +\" scoreDiff=\"+scoreDiff + \" maxDiff=\"+maxDiff\r\n                    +\"\\n\\thitCollector.doc=\" + doc + \" score=\"+score\r\n                    +\"\\n\\t Scorer=\" + scorer\r\n                    +\"\\n\\t Query=\" + q\r\n                    +\"\\n\\t Searcher=\" + s\r\n            );\r\n          }\r\n        } catch (IOException e) {\r\n          throw new RuntimeException(e);\r\n        }\r\n      }\r\n    });\r\n\r\n    // make sure next call to scorer is false.\r\n    TestCase.assertFalse((which[0]++&0x02)==0 ? scorer.skipTo(sdoc[0]+1) : scorer.next());\r\n  }\r\n\n","bugFix":null,"bugIntro":["b3e493496c35fb4f17315b8827d1ba1ae1585554","b52f4d438f568f7beafda3cf347790a4bfe32928","b52f4d438f568f7beafda3cf347790a4bfe32928"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b3e493496c35fb4f17315b8827d1ba1ae1585554","date":1177392767,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n   \n    if (BooleanQuery.getUseScorer14()) return;  // 1.4 doesn't support skipTo\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {skip_op},\n        {next_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n      final int order[] = orders[k];\n      //System.out.print(\"Order:\");for (int i = 0; i < order.length; i++) System.out.print(order[i]==skip_op ? \" skip()\":\" next()\"); System.out.println();\n      final int opidx[] = {0};\n\n      final Weight w = q.weight(s);\n      final Scorer scorer = w.scorer(s.getIndexReader());\n      \n      if (scorer instanceof BooleanScorer || scorer instanceof BooleanScorer2) {\n        return; // TODO change this if BooleanScorers would once again guarantee docs in order. \n      }\n\n      // FUTURE: ensure scorer.doc()==-1\n\n      final int[] sdoc = new int[] {-1};\n      final float maxDiff = 1e-5f;\n      s.search(q,new HitCollector() {\n        public void collect(int doc, float score) {\n          try {\n            int op = order[(opidx[0]++)%order.length];\n            //System.out.println(op==skip_op ? \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n            boolean more = op==skip_op ? scorer.skipTo(sdoc[0]+1) : scorer.next();\n            sdoc[0] = scorer.doc();\n            float scorerScore = scorer.score();\n            float scoreDiff = Math.abs(score-scorerScore);\n            if (more==false || doc != sdoc[0] || scoreDiff>maxDiff) {\n              StringBuffer sbord = new StringBuffer();\n              for (int i = 0; i < order.length; i++) \n                sbord.append(order[i]==skip_op ? \" skip()\":\" next()\");\n              throw new RuntimeException(\"ERROR matching docs:\"\n                  +\"\\n\\tscorer.more=\" + more + \" doc=\"+sdoc[0] + \" scorerScore=\"+scorerScore\n                  +\" scoreDiff=\"+scoreDiff + \" maxDiff=\"+maxDiff\n                  +\"\\n\\thitCollector.doc=\" + doc + \" score=\"+score\n                  +\"\\n\\t Scorer=\" + scorer\n                  +\"\\n\\t Query=\" + q\n                  +\"\\n\\t Searcher=\" + s\n                  +\"\\n\\t Order=\" + sbord\n              );\n            }\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      });\n      \n      // make sure next call to scorer is false.\n      int op = order[(opidx[0]++)%order.length];\n      //System.out.println(op==skip_op ? \"last: skip()\":\"last: next()\");\n      boolean more = op==skip_op ? scorer.skipTo(sdoc[0]+1) : scorer.next();\n      TestCase.assertFalse(more);\n    }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final Weight w = q.weight(s);\n    final Scorer scorer = w.scorer(s.getIndexReader());\n\n    // FUTURE: ensure scorer.doc()==-1\n    \n    if (BooleanQuery.getUseScorer14()) return;  // 1.4 doesn't support skipTo\n\n    final int[] which = new int[1];\n    final int[] sdoc = new int[] {-1};\n    final float maxDiff = 1e-5f;\n    s.search(q,new HitCollector() {\n      public void collect(int doc, float score) {\n        try {\n          boolean more = (which[0]++&0x02)==0 ? scorer.skipTo(sdoc[0]+1) : scorer.next();\n          sdoc[0] = scorer.doc();\n          float scorerScore = scorer.score();\n          float scoreDiff = Math.abs(score-scorerScore);\n          scoreDiff=0; // TODO: remove this go get LUCENE-697 failures \n          if (more==false || doc != sdoc[0] || scoreDiff>maxDiff) {\n            throw new RuntimeException(\"ERROR matching docs:\"\n                    +\"\\n\\tscorer.more=\" + more + \" doc=\"+sdoc[0] + \" scorerScore=\"+scorerScore\n                    +\" scoreDiff=\"+scoreDiff + \" maxDiff=\"+maxDiff\n                    +\"\\n\\thitCollector.doc=\" + doc + \" score=\"+score\n                    +\"\\n\\t Scorer=\" + scorer\n                    +\"\\n\\t Query=\" + q\n                    +\"\\n\\t Searcher=\" + s\n            );\n          }\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    });\n\n    // make sure next call to scorer is false.\n    TestCase.assertFalse((which[0]++&0x02)==0 ? scorer.skipTo(sdoc[0]+1) : scorer.next());\n  }\n\n","bugFix":["492d71f81abcc186afa0074702472ecb6b7dc997"],"bugIntro":["facd440f562ba04187b82c36465181d6ba7030fa"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6212677fdd165340d4284ad2530970c664042d6e","date":1180380790,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n   \n    if (BooleanQuery.getAllowDocsOutOfOrder()) return;  // 1.4 doesn't support skipTo\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {skip_op},\n        {next_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n      final int order[] = orders[k];\n      //System.out.print(\"Order:\");for (int i = 0; i < order.length; i++) System.out.print(order[i]==skip_op ? \" skip()\":\" next()\"); System.out.println();\n      final int opidx[] = {0};\n\n      final Weight w = q.weight(s);\n      final Scorer scorer = w.scorer(s.getIndexReader());\n      \n      // FUTURE: ensure scorer.doc()==-1\n\n      final int[] sdoc = new int[] {-1};\n      final float maxDiff = 1e-5f;\n      s.search(q,new HitCollector() {\n        public void collect(int doc, float score) {\n          try {\n            int op = order[(opidx[0]++)%order.length];\n            //System.out.println(op==skip_op ? \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n            boolean more = op==skip_op ? scorer.skipTo(sdoc[0]+1) : scorer.next();\n            sdoc[0] = scorer.doc();\n            float scorerScore = scorer.score();\n            float scoreDiff = Math.abs(score-scorerScore);\n            if (more==false || doc != sdoc[0] || scoreDiff>maxDiff) {\n              StringBuffer sbord = new StringBuffer();\n              for (int i = 0; i < order.length; i++) \n                sbord.append(order[i]==skip_op ? \" skip()\":\" next()\");\n              throw new RuntimeException(\"ERROR matching docs:\"\n                  +\"\\n\\tscorer.more=\" + more + \" doc=\"+sdoc[0] + \" scorerScore=\"+scorerScore\n                  +\" scoreDiff=\"+scoreDiff + \" maxDiff=\"+maxDiff\n                  +\"\\n\\thitCollector.doc=\" + doc + \" score=\"+score\n                  +\"\\n\\t Scorer=\" + scorer\n                  +\"\\n\\t Query=\" + q\n                  +\"\\n\\t Searcher=\" + s\n                  +\"\\n\\t Order=\" + sbord\n              );\n            }\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      });\n      \n      // make sure next call to scorer is false.\n      int op = order[(opidx[0]++)%order.length];\n      //System.out.println(op==skip_op ? \"last: skip()\":\"last: next()\");\n      boolean more = op==skip_op ? scorer.skipTo(sdoc[0]+1) : scorer.next();\n      TestCase.assertFalse(more);\n    }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n   \n    if (BooleanQuery.getUseScorer14()) return;  // 1.4 doesn't support skipTo\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {skip_op},\n        {next_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n      final int order[] = orders[k];\n      //System.out.print(\"Order:\");for (int i = 0; i < order.length; i++) System.out.print(order[i]==skip_op ? \" skip()\":\" next()\"); System.out.println();\n      final int opidx[] = {0};\n\n      final Weight w = q.weight(s);\n      final Scorer scorer = w.scorer(s.getIndexReader());\n      \n      if (scorer instanceof BooleanScorer || scorer instanceof BooleanScorer2) {\n        return; // TODO change this if BooleanScorers would once again guarantee docs in order. \n      }\n\n      // FUTURE: ensure scorer.doc()==-1\n\n      final int[] sdoc = new int[] {-1};\n      final float maxDiff = 1e-5f;\n      s.search(q,new HitCollector() {\n        public void collect(int doc, float score) {\n          try {\n            int op = order[(opidx[0]++)%order.length];\n            //System.out.println(op==skip_op ? \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n            boolean more = op==skip_op ? scorer.skipTo(sdoc[0]+1) : scorer.next();\n            sdoc[0] = scorer.doc();\n            float scorerScore = scorer.score();\n            float scoreDiff = Math.abs(score-scorerScore);\n            if (more==false || doc != sdoc[0] || scoreDiff>maxDiff) {\n              StringBuffer sbord = new StringBuffer();\n              for (int i = 0; i < order.length; i++) \n                sbord.append(order[i]==skip_op ? \" skip()\":\" next()\");\n              throw new RuntimeException(\"ERROR matching docs:\"\n                  +\"\\n\\tscorer.more=\" + more + \" doc=\"+sdoc[0] + \" scorerScore=\"+scorerScore\n                  +\" scoreDiff=\"+scoreDiff + \" maxDiff=\"+maxDiff\n                  +\"\\n\\thitCollector.doc=\" + doc + \" score=\"+score\n                  +\"\\n\\t Scorer=\" + scorer\n                  +\"\\n\\t Query=\" + q\n                  +\"\\n\\t Searcher=\" + s\n                  +\"\\n\\t Order=\" + sbord\n              );\n            }\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      });\n      \n      // make sure next call to scorer is false.\n      int op = order[(opidx[0]++)%order.length];\n      //System.out.println(op==skip_op ? \"last: skip()\":\"last: next()\");\n      boolean more = op==skip_op ? scorer.skipTo(sdoc[0]+1) : scorer.next();\n      TestCase.assertFalse(more);\n    }\n  }\n\n","bugFix":null,"bugIntro":["facd440f562ba04187b82c36465181d6ba7030fa"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"facd440f562ba04187b82c36465181d6ba7030fa","date":1181183679,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    \n    if (BooleanQuery.getAllowDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n      final int order[] = orders[k];\n      //System.out.print(\"Order:\");for (int i = 0; i < order.length; i++) System.out.print(order[i]==skip_op ? \" skip()\":\" next()\"); System.out.println();\n      final int opidx[] = {0};\n\n      final Weight w = q.weight(s);\n      final Scorer scorer = w.scorer(s.getIndexReader());\n      \n      // FUTURE: ensure scorer.doc()==-1\n\n      final int[] sdoc = new int[] {-1};\n      final float maxDiff = 1e-5f;\n      s.search(q,new HitCollector() {\n        public void collect(int doc, float score) {\n          try {\n            int op = order[(opidx[0]++)%order.length];\n            //System.out.println(op==skip_op ? \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n            boolean more = op==skip_op ? scorer.skipTo(sdoc[0]+1) : scorer.next();\n            sdoc[0] = scorer.doc();\n            float scorerScore = scorer.score();\n            float scorerScore2 = scorer.score();\n            float scoreDiff = Math.abs(score-scorerScore);\n            float scorerDiff = Math.abs(scorerScore2-scorerScore);\n            if (!more || doc != sdoc[0] || scoreDiff>maxDiff || scorerDiff>maxDiff) {\n              StringBuffer sbord = new StringBuffer();\n              for (int i = 0; i < order.length; i++) \n                sbord.append(order[i]==skip_op ? \" skip()\":\" next()\");\n              throw new RuntimeException(\"ERROR matching docs:\"\n                  +\"\\n\\t\"+(doc!=sdoc[0]?\"--> \":\"\")+\"doc=\"+sdoc[0]\n                  +\"\\n\\t\"+(!more?\"--> \":\"\")+\"tscorer.more=\" + more \n                  +\"\\n\\t\"+(scoreDiff>maxDiff?\"--> \":\"\")+\"scorerScore=\"+scorerScore+\" scoreDiff=\"+scoreDiff + \" maxDiff=\"+maxDiff\n                  +\"\\n\\t\"+(scorerDiff>maxDiff?\"--> \":\"\")+\"scorerScore2=\"+scorerScore2+\" scorerDiff=\"+scorerDiff\n                  +\"\\n\\thitCollector.doc=\" + doc + \" score=\"+score\n                  +\"\\n\\t Scorer=\" + scorer\n                  +\"\\n\\t Query=\" + q + \"  \"+q.getClass().getName()\n                  +\"\\n\\t Searcher=\" + s\n                  +\"\\n\\t Order=\" + sbord\n                  +\"\\n\\t Op=\" + (op==skip_op ? \" skip()\":\" next()\")\n              );\n            }\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      });\n      \n      // make sure next call to scorer is false.\n      int op = order[(opidx[0]++)%order.length];\n      //System.out.println(op==skip_op ? \"last: skip()\":\"last: next()\");\n      boolean more = op==skip_op ? scorer.skipTo(sdoc[0]+1) : scorer.next();\n      TestCase.assertFalse(more);\n    }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n   \n    if (BooleanQuery.getAllowDocsOutOfOrder()) return;  // 1.4 doesn't support skipTo\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {skip_op},\n        {next_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n      final int order[] = orders[k];\n      //System.out.print(\"Order:\");for (int i = 0; i < order.length; i++) System.out.print(order[i]==skip_op ? \" skip()\":\" next()\"); System.out.println();\n      final int opidx[] = {0};\n\n      final Weight w = q.weight(s);\n      final Scorer scorer = w.scorer(s.getIndexReader());\n      \n      // FUTURE: ensure scorer.doc()==-1\n\n      final int[] sdoc = new int[] {-1};\n      final float maxDiff = 1e-5f;\n      s.search(q,new HitCollector() {\n        public void collect(int doc, float score) {\n          try {\n            int op = order[(opidx[0]++)%order.length];\n            //System.out.println(op==skip_op ? \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n            boolean more = op==skip_op ? scorer.skipTo(sdoc[0]+1) : scorer.next();\n            sdoc[0] = scorer.doc();\n            float scorerScore = scorer.score();\n            float scoreDiff = Math.abs(score-scorerScore);\n            if (more==false || doc != sdoc[0] || scoreDiff>maxDiff) {\n              StringBuffer sbord = new StringBuffer();\n              for (int i = 0; i < order.length; i++) \n                sbord.append(order[i]==skip_op ? \" skip()\":\" next()\");\n              throw new RuntimeException(\"ERROR matching docs:\"\n                  +\"\\n\\tscorer.more=\" + more + \" doc=\"+sdoc[0] + \" scorerScore=\"+scorerScore\n                  +\" scoreDiff=\"+scoreDiff + \" maxDiff=\"+maxDiff\n                  +\"\\n\\thitCollector.doc=\" + doc + \" score=\"+score\n                  +\"\\n\\t Scorer=\" + scorer\n                  +\"\\n\\t Query=\" + q\n                  +\"\\n\\t Searcher=\" + s\n                  +\"\\n\\t Order=\" + sbord\n              );\n            }\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      });\n      \n      // make sure next call to scorer is false.\n      int op = order[(opidx[0]++)%order.length];\n      //System.out.println(op==skip_op ? \"last: skip()\":\"last: next()\");\n      boolean more = op==skip_op ? scorer.skipTo(sdoc[0]+1) : scorer.next();\n      TestCase.assertFalse(more);\n    }\n  }\n\n","bugFix":["6212677fdd165340d4284ad2530970c664042d6e","b3e493496c35fb4f17315b8827d1ba1ae1585554"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"63bc3238545c6012bd44f5d294077997f236bc4e","date":1233087321,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    \n    if (BooleanQuery.getAllowDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n      final int order[] = orders[k];\n      //System.out.print(\"Order:\");for (int i = 0; i < order.length; i++) System.out.print(order[i]==skip_op ? \" skip()\":\" next()\"); System.out.println();\n      final int opidx[] = {0};\n\n      final Weight w = q.weight(s);\n      final Scorer scorer = w.scorer(s.getIndexReader());\n      \n      // FUTURE: ensure scorer.doc()==-1\n\n      final int[] sdoc = new int[] {-1};\n      final float maxDiff = 1e-5f;\n      s.search(q,new MultiReaderHitCollector() {\n        private int base = -1;\n        public void collect(int doc, float score) {\n          doc = doc + base;\n          try {\n            int op = order[(opidx[0]++)%order.length];\n            //System.out.println(op==skip_op ? \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n            boolean more = op==skip_op ? scorer.skipTo(sdoc[0]+1) : scorer.next();\n            sdoc[0] = scorer.doc();\n            float scorerScore = scorer.score();\n            float scorerScore2 = scorer.score();\n            float scoreDiff = Math.abs(score-scorerScore);\n            float scorerDiff = Math.abs(scorerScore2-scorerScore);\n            if (!more || doc != sdoc[0] || scoreDiff>maxDiff || scorerDiff>maxDiff) {\n              StringBuffer sbord = new StringBuffer();\n              for (int i = 0; i < order.length; i++) \n                sbord.append(order[i]==skip_op ? \" skip()\":\" next()\");\n              throw new RuntimeException(\"ERROR matching docs:\"\n                  +\"\\n\\t\"+(doc!=sdoc[0]?\"--> \":\"\")+\"doc=\"+sdoc[0]\n                  +\"\\n\\t\"+(!more?\"--> \":\"\")+\"tscorer.more=\" + more \n                  +\"\\n\\t\"+(scoreDiff>maxDiff?\"--> \":\"\")+\"scorerScore=\"+scorerScore+\" scoreDiff=\"+scoreDiff + \" maxDiff=\"+maxDiff\n                  +\"\\n\\t\"+(scorerDiff>maxDiff?\"--> \":\"\")+\"scorerScore2=\"+scorerScore2+\" scorerDiff=\"+scorerDiff\n                  +\"\\n\\thitCollector.doc=\" + doc + \" score=\"+score\n                  +\"\\n\\t Scorer=\" + scorer\n                  +\"\\n\\t Query=\" + q + \"  \"+q.getClass().getName()\n                  +\"\\n\\t Searcher=\" + s\n                  +\"\\n\\t Order=\" + sbord\n                  +\"\\n\\t Op=\" + (op==skip_op ? \" skip()\":\" next()\")\n              );\n            }\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n        public void setNextReader(IndexReader reader, int docBase) {\n          base = docBase;\n        }\n      });\n      \n      // make sure next call to scorer is false.\n      int op = order[(opidx[0]++)%order.length];\n      //System.out.println(op==skip_op ? \"last: skip()\":\"last: next()\");\n      boolean more = op==skip_op ? scorer.skipTo(sdoc[0]+1) : scorer.next();\n      TestCase.assertFalse(more);\n    }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    \n    if (BooleanQuery.getAllowDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n      final int order[] = orders[k];\n      //System.out.print(\"Order:\");for (int i = 0; i < order.length; i++) System.out.print(order[i]==skip_op ? \" skip()\":\" next()\"); System.out.println();\n      final int opidx[] = {0};\n\n      final Weight w = q.weight(s);\n      final Scorer scorer = w.scorer(s.getIndexReader());\n      \n      // FUTURE: ensure scorer.doc()==-1\n\n      final int[] sdoc = new int[] {-1};\n      final float maxDiff = 1e-5f;\n      s.search(q,new HitCollector() {\n        public void collect(int doc, float score) {\n          try {\n            int op = order[(opidx[0]++)%order.length];\n            //System.out.println(op==skip_op ? \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n            boolean more = op==skip_op ? scorer.skipTo(sdoc[0]+1) : scorer.next();\n            sdoc[0] = scorer.doc();\n            float scorerScore = scorer.score();\n            float scorerScore2 = scorer.score();\n            float scoreDiff = Math.abs(score-scorerScore);\n            float scorerDiff = Math.abs(scorerScore2-scorerScore);\n            if (!more || doc != sdoc[0] || scoreDiff>maxDiff || scorerDiff>maxDiff) {\n              StringBuffer sbord = new StringBuffer();\n              for (int i = 0; i < order.length; i++) \n                sbord.append(order[i]==skip_op ? \" skip()\":\" next()\");\n              throw new RuntimeException(\"ERROR matching docs:\"\n                  +\"\\n\\t\"+(doc!=sdoc[0]?\"--> \":\"\")+\"doc=\"+sdoc[0]\n                  +\"\\n\\t\"+(!more?\"--> \":\"\")+\"tscorer.more=\" + more \n                  +\"\\n\\t\"+(scoreDiff>maxDiff?\"--> \":\"\")+\"scorerScore=\"+scorerScore+\" scoreDiff=\"+scoreDiff + \" maxDiff=\"+maxDiff\n                  +\"\\n\\t\"+(scorerDiff>maxDiff?\"--> \":\"\")+\"scorerScore2=\"+scorerScore2+\" scorerDiff=\"+scorerDiff\n                  +\"\\n\\thitCollector.doc=\" + doc + \" score=\"+score\n                  +\"\\n\\t Scorer=\" + scorer\n                  +\"\\n\\t Query=\" + q + \"  \"+q.getClass().getName()\n                  +\"\\n\\t Searcher=\" + s\n                  +\"\\n\\t Order=\" + sbord\n                  +\"\\n\\t Op=\" + (op==skip_op ? \" skip()\":\" next()\")\n              );\n            }\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      });\n      \n      // make sure next call to scorer is false.\n      int op = order[(opidx[0]++)%order.length];\n      //System.out.println(op==skip_op ? \"last: skip()\":\"last: next()\");\n      boolean more = op==skip_op ? scorer.skipTo(sdoc[0]+1) : scorer.next();\n      TestCase.assertFalse(more);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"64714133cf5ec732e3bbceee63351bb9af0117dc","date":1239647636,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    \n    if (BooleanQuery.getAllowDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n      final int order[] = orders[k];\n      //System.out.print(\"Order:\");for (int i = 0; i < order.length; i++) System.out.print(order[i]==skip_op ? \" skip()\":\" next()\"); System.out.println();\n      final int opidx[] = {0};\n\n      final Weight w = q.weight(s);\n      final Scorer scorer = w.scorer(s.getIndexReader());\n      \n      // FUTURE: ensure scorer.doc()==-1\n\n      final int[] sdoc = new int[] {-1};\n      final float maxDiff = 1e-5f;\n      s.search(q,new Collector() {\n        private int base = 0;\n        private Scorer sc;\n        public void setScorer(Scorer scorer) throws IOException {\n          this.sc = scorer;\n        }\n        public void collect(int doc) throws IOException {\n          doc = doc + base;\n          float score = sc.score();\n          try {\n            int op = order[(opidx[0]++)%order.length];\n            //System.out.println(op==skip_op ? \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n            boolean more = op==skip_op ? scorer.skipTo(sdoc[0]+1) : scorer.next();\n            sdoc[0] = scorer.doc();\n            float scorerScore = scorer.score();\n            float scorerScore2 = scorer.score();\n            float scoreDiff = Math.abs(score-scorerScore);\n            float scorerDiff = Math.abs(scorerScore2-scorerScore);\n            if (!more || doc != sdoc[0] || scoreDiff>maxDiff || scorerDiff>maxDiff) {\n              StringBuffer sbord = new StringBuffer();\n              for (int i = 0; i < order.length; i++) \n                sbord.append(order[i]==skip_op ? \" skip()\":\" next()\");\n              throw new RuntimeException(\"ERROR matching docs:\"\n                  +\"\\n\\t\"+(doc!=sdoc[0]?\"--> \":\"\")+\"doc=\"+sdoc[0]\n                  +\"\\n\\t\"+(!more?\"--> \":\"\")+\"tscorer.more=\" + more \n                  +\"\\n\\t\"+(scoreDiff>maxDiff?\"--> \":\"\")+\"scorerScore=\"+scorerScore+\" scoreDiff=\"+scoreDiff + \" maxDiff=\"+maxDiff\n                  +\"\\n\\t\"+(scorerDiff>maxDiff?\"--> \":\"\")+\"scorerScore2=\"+scorerScore2+\" scorerDiff=\"+scorerDiff\n                  +\"\\n\\thitCollector.doc=\" + doc + \" score=\"+score\n                  +\"\\n\\t Scorer=\" + scorer\n                  +\"\\n\\t Query=\" + q + \"  \"+q.getClass().getName()\n                  +\"\\n\\t Searcher=\" + s\n                  +\"\\n\\t Order=\" + sbord\n                  +\"\\n\\t Op=\" + (op==skip_op ? \" skip()\":\" next()\")\n              );\n            }\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n        public void setNextReader(IndexReader reader, int docBase) {\n          base = docBase;\n        }\n      });\n      \n      // make sure next call to scorer is false.\n      int op = order[(opidx[0]++)%order.length];\n      //System.out.println(op==skip_op ? \"last: skip()\":\"last: next()\");\n      boolean more = op==skip_op ? scorer.skipTo(sdoc[0]+1) : scorer.next();\n      TestCase.assertFalse(more);\n    }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    \n    if (BooleanQuery.getAllowDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n      final int order[] = orders[k];\n      //System.out.print(\"Order:\");for (int i = 0; i < order.length; i++) System.out.print(order[i]==skip_op ? \" skip()\":\" next()\"); System.out.println();\n      final int opidx[] = {0};\n\n      final Weight w = q.weight(s);\n      final Scorer scorer = w.scorer(s.getIndexReader());\n      \n      // FUTURE: ensure scorer.doc()==-1\n\n      final int[] sdoc = new int[] {-1};\n      final float maxDiff = 1e-5f;\n      s.search(q,new MultiReaderHitCollector() {\n        private int base = -1;\n        public void collect(int doc, float score) {\n          doc = doc + base;\n          try {\n            int op = order[(opidx[0]++)%order.length];\n            //System.out.println(op==skip_op ? \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n            boolean more = op==skip_op ? scorer.skipTo(sdoc[0]+1) : scorer.next();\n            sdoc[0] = scorer.doc();\n            float scorerScore = scorer.score();\n            float scorerScore2 = scorer.score();\n            float scoreDiff = Math.abs(score-scorerScore);\n            float scorerDiff = Math.abs(scorerScore2-scorerScore);\n            if (!more || doc != sdoc[0] || scoreDiff>maxDiff || scorerDiff>maxDiff) {\n              StringBuffer sbord = new StringBuffer();\n              for (int i = 0; i < order.length; i++) \n                sbord.append(order[i]==skip_op ? \" skip()\":\" next()\");\n              throw new RuntimeException(\"ERROR matching docs:\"\n                  +\"\\n\\t\"+(doc!=sdoc[0]?\"--> \":\"\")+\"doc=\"+sdoc[0]\n                  +\"\\n\\t\"+(!more?\"--> \":\"\")+\"tscorer.more=\" + more \n                  +\"\\n\\t\"+(scoreDiff>maxDiff?\"--> \":\"\")+\"scorerScore=\"+scorerScore+\" scoreDiff=\"+scoreDiff + \" maxDiff=\"+maxDiff\n                  +\"\\n\\t\"+(scorerDiff>maxDiff?\"--> \":\"\")+\"scorerScore2=\"+scorerScore2+\" scorerDiff=\"+scorerDiff\n                  +\"\\n\\thitCollector.doc=\" + doc + \" score=\"+score\n                  +\"\\n\\t Scorer=\" + scorer\n                  +\"\\n\\t Query=\" + q + \"  \"+q.getClass().getName()\n                  +\"\\n\\t Searcher=\" + s\n                  +\"\\n\\t Order=\" + sbord\n                  +\"\\n\\t Op=\" + (op==skip_op ? \" skip()\":\" next()\")\n              );\n            }\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n        public void setNextReader(IndexReader reader, int docBase) {\n          base = docBase;\n        }\n      });\n      \n      // make sure next call to scorer is false.\n      int op = order[(opidx[0]++)%order.length];\n      //System.out.println(op==skip_op ? \"last: skip()\":\"last: next()\");\n      boolean more = op==skip_op ? scorer.skipTo(sdoc[0]+1) : scorer.next();\n      TestCase.assertFalse(more);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"30a558487f2298c2c19ceca9103c1b6865d64708","date":1244393921,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    \n    if (BooleanQuery.getAllowDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n      final int order[] = orders[k];\n      //System.out.print(\"Order:\");for (int i = 0; i < order.length; i++) System.out.print(order[i]==skip_op ? \" skip()\":\" next()\"); System.out.println();\n      final int opidx[] = {0};\n\n      final Weight w = q.weight(s);\n      final Scorer scorer = w.scorer(s.getIndexReader());\n      \n      // FUTURE: ensure scorer.doc()==-1\n\n      final int[] sdoc = new int[] {-1};\n      final float maxDiff = 1e-5f;\n      s.search(q,new Collector() {\n        private int base = 0;\n        private Scorer sc;\n        public void setScorer(Scorer scorer) throws IOException {\n          this.sc = scorer;\n        }\n        public void collect(int doc) throws IOException {\n          doc = doc + base;\n          float score = sc.score();\n          try {\n            int op = order[(opidx[0]++)%order.length];\n            //System.out.println(op==skip_op ? \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n            boolean more = op == skip_op ? scorer.advance(sdoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS\n                : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n            sdoc[0] = scorer.docID();\n            float scorerScore = scorer.score();\n            float scorerScore2 = scorer.score();\n            float scoreDiff = Math.abs(score-scorerScore);\n            float scorerDiff = Math.abs(scorerScore2-scorerScore);\n            if (!more || doc != sdoc[0] || scoreDiff>maxDiff || scorerDiff>maxDiff) {\n              StringBuffer sbord = new StringBuffer();\n              for (int i = 0; i < order.length; i++) \n                sbord.append(order[i]==skip_op ? \" skip()\":\" next()\");\n              throw new RuntimeException(\"ERROR matching docs:\"\n                  +\"\\n\\t\"+(doc!=sdoc[0]?\"--> \":\"\")+\"doc=\"+sdoc[0]\n                  +\"\\n\\t\"+(!more?\"--> \":\"\")+\"tscorer.more=\" + more \n                  +\"\\n\\t\"+(scoreDiff>maxDiff?\"--> \":\"\")+\"scorerScore=\"+scorerScore+\" scoreDiff=\"+scoreDiff + \" maxDiff=\"+maxDiff\n                  +\"\\n\\t\"+(scorerDiff>maxDiff?\"--> \":\"\")+\"scorerScore2=\"+scorerScore2+\" scorerDiff=\"+scorerDiff\n                  +\"\\n\\thitCollector.doc=\" + doc + \" score=\"+score\n                  +\"\\n\\t Scorer=\" + scorer\n                  +\"\\n\\t Query=\" + q + \"  \"+q.getClass().getName()\n                  +\"\\n\\t Searcher=\" + s\n                  +\"\\n\\t Order=\" + sbord\n                  +\"\\n\\t Op=\" + (op==skip_op ? \" skip()\":\" next()\")\n              );\n            }\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n        public void setNextReader(IndexReader reader, int docBase) {\n          base = docBase;\n        }\n      });\n      \n      // make sure next call to scorer is false.\n      int op = order[(opidx[0]++)%order.length];\n      //System.out.println(op==skip_op ? \"last: skip()\":\"last: next()\");\n      boolean more = (op == skip_op ? scorer.advance(sdoc[0] + 1) : scorer\n          .nextDoc()) != DocIdSetIterator.NO_MORE_DOCS;\n      Assert.assertFalse(more);\n    }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    \n    if (BooleanQuery.getAllowDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n      final int order[] = orders[k];\n      //System.out.print(\"Order:\");for (int i = 0; i < order.length; i++) System.out.print(order[i]==skip_op ? \" skip()\":\" next()\"); System.out.println();\n      final int opidx[] = {0};\n\n      final Weight w = q.weight(s);\n      final Scorer scorer = w.scorer(s.getIndexReader());\n      \n      // FUTURE: ensure scorer.doc()==-1\n\n      final int[] sdoc = new int[] {-1};\n      final float maxDiff = 1e-5f;\n      s.search(q,new Collector() {\n        private int base = 0;\n        private Scorer sc;\n        public void setScorer(Scorer scorer) throws IOException {\n          this.sc = scorer;\n        }\n        public void collect(int doc) throws IOException {\n          doc = doc + base;\n          float score = sc.score();\n          try {\n            int op = order[(opidx[0]++)%order.length];\n            //System.out.println(op==skip_op ? \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n            boolean more = op==skip_op ? scorer.skipTo(sdoc[0]+1) : scorer.next();\n            sdoc[0] = scorer.doc();\n            float scorerScore = scorer.score();\n            float scorerScore2 = scorer.score();\n            float scoreDiff = Math.abs(score-scorerScore);\n            float scorerDiff = Math.abs(scorerScore2-scorerScore);\n            if (!more || doc != sdoc[0] || scoreDiff>maxDiff || scorerDiff>maxDiff) {\n              StringBuffer sbord = new StringBuffer();\n              for (int i = 0; i < order.length; i++) \n                sbord.append(order[i]==skip_op ? \" skip()\":\" next()\");\n              throw new RuntimeException(\"ERROR matching docs:\"\n                  +\"\\n\\t\"+(doc!=sdoc[0]?\"--> \":\"\")+\"doc=\"+sdoc[0]\n                  +\"\\n\\t\"+(!more?\"--> \":\"\")+\"tscorer.more=\" + more \n                  +\"\\n\\t\"+(scoreDiff>maxDiff?\"--> \":\"\")+\"scorerScore=\"+scorerScore+\" scoreDiff=\"+scoreDiff + \" maxDiff=\"+maxDiff\n                  +\"\\n\\t\"+(scorerDiff>maxDiff?\"--> \":\"\")+\"scorerScore2=\"+scorerScore2+\" scorerDiff=\"+scorerDiff\n                  +\"\\n\\thitCollector.doc=\" + doc + \" score=\"+score\n                  +\"\\n\\t Scorer=\" + scorer\n                  +\"\\n\\t Query=\" + q + \"  \"+q.getClass().getName()\n                  +\"\\n\\t Searcher=\" + s\n                  +\"\\n\\t Order=\" + sbord\n                  +\"\\n\\t Op=\" + (op==skip_op ? \" skip()\":\" next()\")\n              );\n            }\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n        public void setNextReader(IndexReader reader, int docBase) {\n          base = docBase;\n        }\n      });\n      \n      // make sure next call to scorer is false.\n      int op = order[(opidx[0]++)%order.length];\n      //System.out.println(op==skip_op ? \"last: skip()\":\"last: next()\");\n      boolean more = op==skip_op ? scorer.skipTo(sdoc[0]+1) : scorer.next();\n      TestCase.assertFalse(more);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"052fac7830290bd38a04cddee1a121ee07656b56","date":1245780702,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    \n    if (BooleanQuery.getAllowDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n      final int order[] = orders[k];\n      //System.out.print(\"Order:\");for (int i = 0; i < order.length; i++) System.out.print(order[i]==skip_op ? \" skip()\":\" next()\"); System.out.println();\n      final int opidx[] = {0};\n\n      final QueryWeight w = q.queryWeight(s);\n      final Scorer scorer = w.scorer(s.getIndexReader(), true, false);\n      \n      // FUTURE: ensure scorer.doc()==-1\n\n      final int[] sdoc = new int[] {-1};\n      final float maxDiff = 1e-5f;\n      s.search(q,new Collector() {\n        private int base = 0;\n        private Scorer sc;\n        public void setScorer(Scorer scorer) throws IOException {\n          this.sc = scorer;\n        }\n        public void collect(int doc) throws IOException {\n          doc = doc + base;\n          float score = sc.score();\n          try {\n            int op = order[(opidx[0]++)%order.length];\n            //System.out.println(op==skip_op ? \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n            boolean more = op == skip_op ? scorer.advance(sdoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS\n                : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n            sdoc[0] = scorer.docID();\n            float scorerScore = scorer.score();\n            float scorerScore2 = scorer.score();\n            float scoreDiff = Math.abs(score-scorerScore);\n            float scorerDiff = Math.abs(scorerScore2-scorerScore);\n            if (!more || doc != sdoc[0] || scoreDiff>maxDiff || scorerDiff>maxDiff) {\n              StringBuffer sbord = new StringBuffer();\n              for (int i = 0; i < order.length; i++) \n                sbord.append(order[i]==skip_op ? \" skip()\":\" next()\");\n              throw new RuntimeException(\"ERROR matching docs:\"\n                  +\"\\n\\t\"+(doc!=sdoc[0]?\"--> \":\"\")+\"doc=\"+sdoc[0]\n                  +\"\\n\\t\"+(!more?\"--> \":\"\")+\"tscorer.more=\" + more \n                  +\"\\n\\t\"+(scoreDiff>maxDiff?\"--> \":\"\")+\"scorerScore=\"+scorerScore+\" scoreDiff=\"+scoreDiff + \" maxDiff=\"+maxDiff\n                  +\"\\n\\t\"+(scorerDiff>maxDiff?\"--> \":\"\")+\"scorerScore2=\"+scorerScore2+\" scorerDiff=\"+scorerDiff\n                  +\"\\n\\thitCollector.doc=\" + doc + \" score=\"+score\n                  +\"\\n\\t Scorer=\" + scorer\n                  +\"\\n\\t Query=\" + q + \"  \"+q.getClass().getName()\n                  +\"\\n\\t Searcher=\" + s\n                  +\"\\n\\t Order=\" + sbord\n                  +\"\\n\\t Op=\" + (op==skip_op ? \" skip()\":\" next()\")\n              );\n            }\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n        public void setNextReader(IndexReader reader, int docBase) {\n          base = docBase;\n        }\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      });\n      \n      // make sure next call to scorer is false.\n      int op = order[(opidx[0]++)%order.length];\n      //System.out.println(op==skip_op ? \"last: skip()\":\"last: next()\");\n      boolean more = (op == skip_op ? scorer.advance(sdoc[0] + 1) : scorer\n          .nextDoc()) != DocIdSetIterator.NO_MORE_DOCS;\n      Assert.assertFalse(more);\n    }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    \n    if (BooleanQuery.getAllowDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n      final int order[] = orders[k];\n      //System.out.print(\"Order:\");for (int i = 0; i < order.length; i++) System.out.print(order[i]==skip_op ? \" skip()\":\" next()\"); System.out.println();\n      final int opidx[] = {0};\n\n      final Weight w = q.weight(s);\n      final Scorer scorer = w.scorer(s.getIndexReader());\n      \n      // FUTURE: ensure scorer.doc()==-1\n\n      final int[] sdoc = new int[] {-1};\n      final float maxDiff = 1e-5f;\n      s.search(q,new Collector() {\n        private int base = 0;\n        private Scorer sc;\n        public void setScorer(Scorer scorer) throws IOException {\n          this.sc = scorer;\n        }\n        public void collect(int doc) throws IOException {\n          doc = doc + base;\n          float score = sc.score();\n          try {\n            int op = order[(opidx[0]++)%order.length];\n            //System.out.println(op==skip_op ? \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n            boolean more = op == skip_op ? scorer.advance(sdoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS\n                : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n            sdoc[0] = scorer.docID();\n            float scorerScore = scorer.score();\n            float scorerScore2 = scorer.score();\n            float scoreDiff = Math.abs(score-scorerScore);\n            float scorerDiff = Math.abs(scorerScore2-scorerScore);\n            if (!more || doc != sdoc[0] || scoreDiff>maxDiff || scorerDiff>maxDiff) {\n              StringBuffer sbord = new StringBuffer();\n              for (int i = 0; i < order.length; i++) \n                sbord.append(order[i]==skip_op ? \" skip()\":\" next()\");\n              throw new RuntimeException(\"ERROR matching docs:\"\n                  +\"\\n\\t\"+(doc!=sdoc[0]?\"--> \":\"\")+\"doc=\"+sdoc[0]\n                  +\"\\n\\t\"+(!more?\"--> \":\"\")+\"tscorer.more=\" + more \n                  +\"\\n\\t\"+(scoreDiff>maxDiff?\"--> \":\"\")+\"scorerScore=\"+scorerScore+\" scoreDiff=\"+scoreDiff + \" maxDiff=\"+maxDiff\n                  +\"\\n\\t\"+(scorerDiff>maxDiff?\"--> \":\"\")+\"scorerScore2=\"+scorerScore2+\" scorerDiff=\"+scorerDiff\n                  +\"\\n\\thitCollector.doc=\" + doc + \" score=\"+score\n                  +\"\\n\\t Scorer=\" + scorer\n                  +\"\\n\\t Query=\" + q + \"  \"+q.getClass().getName()\n                  +\"\\n\\t Searcher=\" + s\n                  +\"\\n\\t Order=\" + sbord\n                  +\"\\n\\t Op=\" + (op==skip_op ? \" skip()\":\" next()\")\n              );\n            }\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n        public void setNextReader(IndexReader reader, int docBase) {\n          base = docBase;\n        }\n      });\n      \n      // make sure next call to scorer is false.\n      int op = order[(opidx[0]++)%order.length];\n      //System.out.println(op==skip_op ? \"last: skip()\":\"last: next()\");\n      boolean more = (op == skip_op ? scorer.advance(sdoc[0] + 1) : scorer\n          .nextDoc()) != DocIdSetIterator.NO_MORE_DOCS;\n      Assert.assertFalse(more);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8d6c98c690b593cea727f68742684c979ead1a0a","date":1248688202,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    \n    if (BooleanQuery.getAllowDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n      final int order[] = orders[k];\n      //System.out.print(\"Order:\");for (int i = 0; i < order.length; i++) System.out.print(order[i]==skip_op ? \" skip()\":\" next()\"); System.out.println();\n      final int opidx[] = {0};\n\n      final QueryWeight w = q.queryWeight(s);\n      final Scorer scorer = w.scorer(s.getIndexReader(), true, false);\n      if (scorer == null) {\n        continue;\n      }\n\n      // FUTURE: ensure scorer.doc()==-1\n\n      final int[] sdoc = new int[] {-1};\n      final float maxDiff = 1e-5f;\n      s.search(q,new Collector() {\n        private int base = 0;\n        private Scorer sc;\n        public void setScorer(Scorer scorer) throws IOException {\n          this.sc = scorer;\n        }\n        public void collect(int doc) throws IOException {\n          doc = doc + base;\n          float score = sc.score();\n          try {\n            int op = order[(opidx[0]++)%order.length];\n            //System.out.println(op==skip_op ? \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n            boolean more = op == skip_op ? scorer.advance(sdoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS\n                : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n            sdoc[0] = scorer.docID();\n            float scorerScore = scorer.score();\n            float scorerScore2 = scorer.score();\n            float scoreDiff = Math.abs(score-scorerScore);\n            float scorerDiff = Math.abs(scorerScore2-scorerScore);\n            if (!more || doc != sdoc[0] || scoreDiff>maxDiff || scorerDiff>maxDiff) {\n              StringBuffer sbord = new StringBuffer();\n              for (int i = 0; i < order.length; i++) \n                sbord.append(order[i]==skip_op ? \" skip()\":\" next()\");\n              throw new RuntimeException(\"ERROR matching docs:\"\n                  +\"\\n\\t\"+(doc!=sdoc[0]?\"--> \":\"\")+\"doc=\"+sdoc[0]\n                  +\"\\n\\t\"+(!more?\"--> \":\"\")+\"tscorer.more=\" + more \n                  +\"\\n\\t\"+(scoreDiff>maxDiff?\"--> \":\"\")+\"scorerScore=\"+scorerScore+\" scoreDiff=\"+scoreDiff + \" maxDiff=\"+maxDiff\n                  +\"\\n\\t\"+(scorerDiff>maxDiff?\"--> \":\"\")+\"scorerScore2=\"+scorerScore2+\" scorerDiff=\"+scorerDiff\n                  +\"\\n\\thitCollector.doc=\" + doc + \" score=\"+score\n                  +\"\\n\\t Scorer=\" + scorer\n                  +\"\\n\\t Query=\" + q + \"  \"+q.getClass().getName()\n                  +\"\\n\\t Searcher=\" + s\n                  +\"\\n\\t Order=\" + sbord\n                  +\"\\n\\t Op=\" + (op==skip_op ? \" skip()\":\" next()\")\n              );\n            }\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n        public void setNextReader(IndexReader reader, int docBase) {\n          base = docBase;\n        }\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      });\n      \n      // make sure next call to scorer is false.\n      int op = order[(opidx[0]++)%order.length];\n      //System.out.println(op==skip_op ? \"last: skip()\":\"last: next()\");\n      boolean more = (op == skip_op ? scorer.advance(sdoc[0] + 1) : scorer\n          .nextDoc()) != DocIdSetIterator.NO_MORE_DOCS;\n      Assert.assertFalse(more);\n    }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    \n    if (BooleanQuery.getAllowDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n      final int order[] = orders[k];\n      //System.out.print(\"Order:\");for (int i = 0; i < order.length; i++) System.out.print(order[i]==skip_op ? \" skip()\":\" next()\"); System.out.println();\n      final int opidx[] = {0};\n\n      final QueryWeight w = q.queryWeight(s);\n      final Scorer scorer = w.scorer(s.getIndexReader(), true, false);\n      \n      // FUTURE: ensure scorer.doc()==-1\n\n      final int[] sdoc = new int[] {-1};\n      final float maxDiff = 1e-5f;\n      s.search(q,new Collector() {\n        private int base = 0;\n        private Scorer sc;\n        public void setScorer(Scorer scorer) throws IOException {\n          this.sc = scorer;\n        }\n        public void collect(int doc) throws IOException {\n          doc = doc + base;\n          float score = sc.score();\n          try {\n            int op = order[(opidx[0]++)%order.length];\n            //System.out.println(op==skip_op ? \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n            boolean more = op == skip_op ? scorer.advance(sdoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS\n                : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n            sdoc[0] = scorer.docID();\n            float scorerScore = scorer.score();\n            float scorerScore2 = scorer.score();\n            float scoreDiff = Math.abs(score-scorerScore);\n            float scorerDiff = Math.abs(scorerScore2-scorerScore);\n            if (!more || doc != sdoc[0] || scoreDiff>maxDiff || scorerDiff>maxDiff) {\n              StringBuffer sbord = new StringBuffer();\n              for (int i = 0; i < order.length; i++) \n                sbord.append(order[i]==skip_op ? \" skip()\":\" next()\");\n              throw new RuntimeException(\"ERROR matching docs:\"\n                  +\"\\n\\t\"+(doc!=sdoc[0]?\"--> \":\"\")+\"doc=\"+sdoc[0]\n                  +\"\\n\\t\"+(!more?\"--> \":\"\")+\"tscorer.more=\" + more \n                  +\"\\n\\t\"+(scoreDiff>maxDiff?\"--> \":\"\")+\"scorerScore=\"+scorerScore+\" scoreDiff=\"+scoreDiff + \" maxDiff=\"+maxDiff\n                  +\"\\n\\t\"+(scorerDiff>maxDiff?\"--> \":\"\")+\"scorerScore2=\"+scorerScore2+\" scorerDiff=\"+scorerDiff\n                  +\"\\n\\thitCollector.doc=\" + doc + \" score=\"+score\n                  +\"\\n\\t Scorer=\" + scorer\n                  +\"\\n\\t Query=\" + q + \"  \"+q.getClass().getName()\n                  +\"\\n\\t Searcher=\" + s\n                  +\"\\n\\t Order=\" + sbord\n                  +\"\\n\\t Op=\" + (op==skip_op ? \" skip()\":\" next()\")\n              );\n            }\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n        public void setNextReader(IndexReader reader, int docBase) {\n          base = docBase;\n        }\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      });\n      \n      // make sure next call to scorer is false.\n      int op = order[(opidx[0]++)%order.length];\n      //System.out.println(op==skip_op ? \"last: skip()\":\"last: next()\");\n      boolean more = (op == skip_op ? scorer.advance(sdoc[0] + 1) : scorer\n          .nextDoc()) != DocIdSetIterator.NO_MORE_DOCS;\n      Assert.assertFalse(more);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe941135bdfc28c81e20b4d21422f8726af34925","date":1250040150,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    \n    if (BooleanQuery.getAllowDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n      final int order[] = orders[k];\n      //System.out.print(\"Order:\");for (int i = 0; i < order.length; i++) System.out.print(order[i]==skip_op ? \" skip()\":\" next()\"); System.out.println();\n      final int opidx[] = {0};\n\n      final Weight w = q.weight(s);\n      final Scorer scorer = w.scorer(s.getIndexReader(), true, false);\n      if (scorer == null) {\n        continue;\n      }\n\n      // FUTURE: ensure scorer.doc()==-1\n\n      final int[] sdoc = new int[] {-1};\n      final float maxDiff = 1e-5f;\n      s.search(q,new Collector() {\n        private int base = 0;\n        private Scorer sc;\n        public void setScorer(Scorer scorer) throws IOException {\n          this.sc = scorer;\n        }\n        public void collect(int doc) throws IOException {\n          doc = doc + base;\n          float score = sc.score();\n          try {\n            int op = order[(opidx[0]++)%order.length];\n            //System.out.println(op==skip_op ? \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n            boolean more = op == skip_op ? scorer.advance(sdoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS\n                : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n            sdoc[0] = scorer.docID();\n            float scorerScore = scorer.score();\n            float scorerScore2 = scorer.score();\n            float scoreDiff = Math.abs(score-scorerScore);\n            float scorerDiff = Math.abs(scorerScore2-scorerScore);\n            if (!more || doc != sdoc[0] || scoreDiff>maxDiff || scorerDiff>maxDiff) {\n              StringBuffer sbord = new StringBuffer();\n              for (int i = 0; i < order.length; i++) \n                sbord.append(order[i]==skip_op ? \" skip()\":\" next()\");\n              throw new RuntimeException(\"ERROR matching docs:\"\n                  +\"\\n\\t\"+(doc!=sdoc[0]?\"--> \":\"\")+\"doc=\"+sdoc[0]\n                  +\"\\n\\t\"+(!more?\"--> \":\"\")+\"tscorer.more=\" + more \n                  +\"\\n\\t\"+(scoreDiff>maxDiff?\"--> \":\"\")+\"scorerScore=\"+scorerScore+\" scoreDiff=\"+scoreDiff + \" maxDiff=\"+maxDiff\n                  +\"\\n\\t\"+(scorerDiff>maxDiff?\"--> \":\"\")+\"scorerScore2=\"+scorerScore2+\" scorerDiff=\"+scorerDiff\n                  +\"\\n\\thitCollector.doc=\" + doc + \" score=\"+score\n                  +\"\\n\\t Scorer=\" + scorer\n                  +\"\\n\\t Query=\" + q + \"  \"+q.getClass().getName()\n                  +\"\\n\\t Searcher=\" + s\n                  +\"\\n\\t Order=\" + sbord\n                  +\"\\n\\t Op=\" + (op==skip_op ? \" skip()\":\" next()\")\n              );\n            }\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n        public void setNextReader(IndexReader reader, int docBase) {\n          base = docBase;\n        }\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      });\n      \n      // make sure next call to scorer is false.\n      int op = order[(opidx[0]++)%order.length];\n      //System.out.println(op==skip_op ? \"last: skip()\":\"last: next()\");\n      boolean more = (op == skip_op ? scorer.advance(sdoc[0] + 1) : scorer\n          .nextDoc()) != DocIdSetIterator.NO_MORE_DOCS;\n      Assert.assertFalse(more);\n    }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    \n    if (BooleanQuery.getAllowDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n      final int order[] = orders[k];\n      //System.out.print(\"Order:\");for (int i = 0; i < order.length; i++) System.out.print(order[i]==skip_op ? \" skip()\":\" next()\"); System.out.println();\n      final int opidx[] = {0};\n\n      final QueryWeight w = q.queryWeight(s);\n      final Scorer scorer = w.scorer(s.getIndexReader(), true, false);\n      if (scorer == null) {\n        continue;\n      }\n\n      // FUTURE: ensure scorer.doc()==-1\n\n      final int[] sdoc = new int[] {-1};\n      final float maxDiff = 1e-5f;\n      s.search(q,new Collector() {\n        private int base = 0;\n        private Scorer sc;\n        public void setScorer(Scorer scorer) throws IOException {\n          this.sc = scorer;\n        }\n        public void collect(int doc) throws IOException {\n          doc = doc + base;\n          float score = sc.score();\n          try {\n            int op = order[(opidx[0]++)%order.length];\n            //System.out.println(op==skip_op ? \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n            boolean more = op == skip_op ? scorer.advance(sdoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS\n                : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n            sdoc[0] = scorer.docID();\n            float scorerScore = scorer.score();\n            float scorerScore2 = scorer.score();\n            float scoreDiff = Math.abs(score-scorerScore);\n            float scorerDiff = Math.abs(scorerScore2-scorerScore);\n            if (!more || doc != sdoc[0] || scoreDiff>maxDiff || scorerDiff>maxDiff) {\n              StringBuffer sbord = new StringBuffer();\n              for (int i = 0; i < order.length; i++) \n                sbord.append(order[i]==skip_op ? \" skip()\":\" next()\");\n              throw new RuntimeException(\"ERROR matching docs:\"\n                  +\"\\n\\t\"+(doc!=sdoc[0]?\"--> \":\"\")+\"doc=\"+sdoc[0]\n                  +\"\\n\\t\"+(!more?\"--> \":\"\")+\"tscorer.more=\" + more \n                  +\"\\n\\t\"+(scoreDiff>maxDiff?\"--> \":\"\")+\"scorerScore=\"+scorerScore+\" scoreDiff=\"+scoreDiff + \" maxDiff=\"+maxDiff\n                  +\"\\n\\t\"+(scorerDiff>maxDiff?\"--> \":\"\")+\"scorerScore2=\"+scorerScore2+\" scorerDiff=\"+scorerDiff\n                  +\"\\n\\thitCollector.doc=\" + doc + \" score=\"+score\n                  +\"\\n\\t Scorer=\" + scorer\n                  +\"\\n\\t Query=\" + q + \"  \"+q.getClass().getName()\n                  +\"\\n\\t Searcher=\" + s\n                  +\"\\n\\t Order=\" + sbord\n                  +\"\\n\\t Op=\" + (op==skip_op ? \" skip()\":\" next()\")\n              );\n            }\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n        public void setNextReader(IndexReader reader, int docBase) {\n          base = docBase;\n        }\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      });\n      \n      // make sure next call to scorer is false.\n      int op = order[(opidx[0]++)%order.length];\n      //System.out.println(op==skip_op ? \"last: skip()\":\"last: next()\");\n      boolean more = (op == skip_op ? scorer.advance(sdoc[0] + 1) : scorer\n          .nextDoc()) != DocIdSetIterator.NO_MORE_DOCS;\n      Assert.assertFalse(more);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e69f59b863731d864bf3047235e718f0f88f8841","date":1250105498,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    \n    if (BooleanQuery.getAllowDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n      IndexReader[] readers = s.getIndexReader().getSequentialSubReaders();\n\n      for (int x = 0; x < readers.length; x++) {\n        IndexReader reader = readers[x];\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n\n        final Weight w = q.weight(s);\n        final Scorer scorer = w.scorer(reader, true, false);\n        if (scorer == null) {\n          continue;\n        }\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final int[] sdoc = new int[] { -1 };\n        final float maxDiff = 1e-5f;\n        s.search(q, new Collector() {\n          private int base = 0;\n          private Scorer sc;\n\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          public void collect(int doc) throws IOException {\n            doc = doc + base;\n            float score = sc.score();\n            try {\n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(sdoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              sdoc[0] = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != sdoc[0] || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuffer sbord = new StringBuffer();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != sdoc[0] ? \"--> \" : \"\") + \"doc=\" + sdoc[0]\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          public void setNextReader(IndexReader reader, int docBase) {\n            base = docBase;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        // make sure next call to scorer is false.\n        int op = order[(opidx[0]++) % order.length];\n        // System.out.println(op==skip_op ? \"last: skip()\":\"last: next()\");\n        boolean more = (op == skip_op ? scorer.advance(sdoc[0] + 1) : scorer\n            .nextDoc()) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(more);\n      }\n    }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    \n    if (BooleanQuery.getAllowDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n      final int order[] = orders[k];\n      //System.out.print(\"Order:\");for (int i = 0; i < order.length; i++) System.out.print(order[i]==skip_op ? \" skip()\":\" next()\"); System.out.println();\n      final int opidx[] = {0};\n\n      final Weight w = q.weight(s);\n      final Scorer scorer = w.scorer(s.getIndexReader(), true, false);\n      if (scorer == null) {\n        continue;\n      }\n\n      // FUTURE: ensure scorer.doc()==-1\n\n      final int[] sdoc = new int[] {-1};\n      final float maxDiff = 1e-5f;\n      s.search(q,new Collector() {\n        private int base = 0;\n        private Scorer sc;\n        public void setScorer(Scorer scorer) throws IOException {\n          this.sc = scorer;\n        }\n        public void collect(int doc) throws IOException {\n          doc = doc + base;\n          float score = sc.score();\n          try {\n            int op = order[(opidx[0]++)%order.length];\n            //System.out.println(op==skip_op ? \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n            boolean more = op == skip_op ? scorer.advance(sdoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS\n                : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n            sdoc[0] = scorer.docID();\n            float scorerScore = scorer.score();\n            float scorerScore2 = scorer.score();\n            float scoreDiff = Math.abs(score-scorerScore);\n            float scorerDiff = Math.abs(scorerScore2-scorerScore);\n            if (!more || doc != sdoc[0] || scoreDiff>maxDiff || scorerDiff>maxDiff) {\n              StringBuffer sbord = new StringBuffer();\n              for (int i = 0; i < order.length; i++) \n                sbord.append(order[i]==skip_op ? \" skip()\":\" next()\");\n              throw new RuntimeException(\"ERROR matching docs:\"\n                  +\"\\n\\t\"+(doc!=sdoc[0]?\"--> \":\"\")+\"doc=\"+sdoc[0]\n                  +\"\\n\\t\"+(!more?\"--> \":\"\")+\"tscorer.more=\" + more \n                  +\"\\n\\t\"+(scoreDiff>maxDiff?\"--> \":\"\")+\"scorerScore=\"+scorerScore+\" scoreDiff=\"+scoreDiff + \" maxDiff=\"+maxDiff\n                  +\"\\n\\t\"+(scorerDiff>maxDiff?\"--> \":\"\")+\"scorerScore2=\"+scorerScore2+\" scorerDiff=\"+scorerDiff\n                  +\"\\n\\thitCollector.doc=\" + doc + \" score=\"+score\n                  +\"\\n\\t Scorer=\" + scorer\n                  +\"\\n\\t Query=\" + q + \"  \"+q.getClass().getName()\n                  +\"\\n\\t Searcher=\" + s\n                  +\"\\n\\t Order=\" + sbord\n                  +\"\\n\\t Op=\" + (op==skip_op ? \" skip()\":\" next()\")\n              );\n            }\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n        public void setNextReader(IndexReader reader, int docBase) {\n          base = docBase;\n        }\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      });\n      \n      // make sure next call to scorer is false.\n      int op = order[(opidx[0]++)%order.length];\n      //System.out.println(op==skip_op ? \"last: skip()\":\"last: next()\");\n      boolean more = (op == skip_op ? scorer.advance(sdoc[0] + 1) : scorer\n          .nextDoc()) != DocIdSetIterator.NO_MORE_DOCS;\n      Assert.assertFalse(more);\n    }\n  }\n\n","bugFix":null,"bugIntro":["45fa1757f5581a10e9c63294cf292a14c92d23b1","45fa1757f5581a10e9c63294cf292a14c92d23b1","4d3e8520fd031bab31fd0e4d480e55958bc45efe","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1ffe619bf5bbe00453bab7103c36fd38c8417f6c","date":1250619947,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    \n    if (BooleanQuery.getAllowDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n\n        final Weight w = q.weight(s);\n        final Scorer scorer = w.scorer(s.getIndexReader(), true, false);\n        if (scorer == null) {\n          continue;\n        }\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final int[] sdoc = new int[] { -1 };\n        final float maxDiff = 1e-5f;\n        s.search(q, new Collector() {\n          private int base = 0;\n          private Scorer sc;\n\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          public void collect(int doc) throws IOException {\n            doc = doc + base;\n            float score = sc.score();\n            try {\n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(sdoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              sdoc[0] = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != sdoc[0] || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuffer sbord = new StringBuffer();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != sdoc[0] ? \"--> \" : \"\") + \"doc=\" + sdoc[0]\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          public void setNextReader(IndexReader reader, int docBase) {\n            base = docBase;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        // make sure next call to scorer is false.\n        int op = order[(opidx[0]++) % order.length];\n        // System.out.println(op==skip_op ? \"last: skip()\":\"last: next()\");\n        boolean more = (op == skip_op ? scorer.advance(sdoc[0] + 1) : scorer\n            .nextDoc()) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(more);\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    \n    if (BooleanQuery.getAllowDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n      IndexReader[] readers = s.getIndexReader().getSequentialSubReaders();\n\n      for (int x = 0; x < readers.length; x++) {\n        IndexReader reader = readers[x];\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n\n        final Weight w = q.weight(s);\n        final Scorer scorer = w.scorer(reader, true, false);\n        if (scorer == null) {\n          continue;\n        }\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final int[] sdoc = new int[] { -1 };\n        final float maxDiff = 1e-5f;\n        s.search(q, new Collector() {\n          private int base = 0;\n          private Scorer sc;\n\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          public void collect(int doc) throws IOException {\n            doc = doc + base;\n            float score = sc.score();\n            try {\n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(sdoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              sdoc[0] = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != sdoc[0] || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuffer sbord = new StringBuffer();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != sdoc[0] ? \"--> \" : \"\") + \"doc=\" + sdoc[0]\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          public void setNextReader(IndexReader reader, int docBase) {\n            base = docBase;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        // make sure next call to scorer is false.\n        int op = order[(opidx[0]++) % order.length];\n        // System.out.println(op==skip_op ? \"last: skip()\":\"last: next()\");\n        boolean more = (op == skip_op ? scorer.advance(sdoc[0] + 1) : scorer\n            .nextDoc()) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4625cb7ffd7c9caaf2d62b206ba9a382d68da82c","date":1254521470,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    \n    if (BooleanQuery.getAllowDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n\n        final Weight w = q.weight(s);\n        final Scorer scorer = w.scorer(s.getIndexReader(), true, false);\n        if (scorer == null) {\n          continue;\n        }\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final int[] sdoc = new int[] { -1 };\n        final float maxDiff = 1e-5f;\n        s.search(q, new Collector() {\n          private int base = 0;\n          private Scorer sc;\n\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          public void collect(int doc) throws IOException {\n            doc = doc + base;\n            float score = sc.score();\n            try {\n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(sdoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              sdoc[0] = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != sdoc[0] || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != sdoc[0] ? \"--> \" : \"\") + \"doc=\" + sdoc[0]\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          public void setNextReader(IndexReader reader, int docBase) {\n            base = docBase;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        // make sure next call to scorer is false.\n        int op = order[(opidx[0]++) % order.length];\n        // System.out.println(op==skip_op ? \"last: skip()\":\"last: next()\");\n        boolean more = (op == skip_op ? scorer.advance(sdoc[0] + 1) : scorer\n            .nextDoc()) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(more);\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    \n    if (BooleanQuery.getAllowDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n\n        final Weight w = q.weight(s);\n        final Scorer scorer = w.scorer(s.getIndexReader(), true, false);\n        if (scorer == null) {\n          continue;\n        }\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final int[] sdoc = new int[] { -1 };\n        final float maxDiff = 1e-5f;\n        s.search(q, new Collector() {\n          private int base = 0;\n          private Scorer sc;\n\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          public void collect(int doc) throws IOException {\n            doc = doc + base;\n            float score = sc.score();\n            try {\n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(sdoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              sdoc[0] = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != sdoc[0] || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuffer sbord = new StringBuffer();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != sdoc[0] ? \"--> \" : \"\") + \"doc=\" + sdoc[0]\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          public void setNextReader(IndexReader reader, int docBase) {\n            base = docBase;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        // make sure next call to scorer is false.\n        int op = order[(opidx[0]++) % order.length];\n        // System.out.println(op==skip_op ? \"last: skip()\":\"last: next()\");\n        boolean more = (op == skip_op ? scorer.advance(sdoc[0] + 1) : scorer\n            .nextDoc()) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(more);\n      }\n  }\n\n","bugFix":null,"bugIntro":["45fa1757f5581a10e9c63294cf292a14c92d23b1","45fa1757f5581a10e9c63294cf292a14c92d23b1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"131a9e895609b4da33662dc087e0bc6303e1e29c","date":1255458397,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    \n    if (q.weight(s).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private IndexReader reader;\n          private Scorer scorer;\n\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = q.weight(s);\n                scorer = w.scorer(reader, true, false);\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          public void setNextReader(IndexReader reader, int docBase) {\n            this.reader = reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        List<IndexReader> readerList = new ArrayList<IndexReader>();\n        ReaderUtil.gatherSubReaders(readerList, s.getIndexReader());\n        IndexReader[] readers = (IndexReader[]) readerList.toArray(new IndexReader[0]);\n        for(int i = 0; i < readers.length; i++) {\n          IndexReader reader = readers[i];\n          Weight w = q.weight(s);\n          Scorer scorer = w.scorer(reader, true, false);\n          \n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n      \n            if (more && lastDoc[0] != -1) \n              Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    \n    if (BooleanQuery.getAllowDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n\n        final Weight w = q.weight(s);\n        final Scorer scorer = w.scorer(s.getIndexReader(), true, false);\n        if (scorer == null) {\n          continue;\n        }\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final int[] sdoc = new int[] { -1 };\n        final float maxDiff = 1e-5f;\n        s.search(q, new Collector() {\n          private int base = 0;\n          private Scorer sc;\n\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          public void collect(int doc) throws IOException {\n            doc = doc + base;\n            float score = sc.score();\n            try {\n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(sdoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              sdoc[0] = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != sdoc[0] || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != sdoc[0] ? \"--> \" : \"\") + \"doc=\" + sdoc[0]\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          public void setNextReader(IndexReader reader, int docBase) {\n            base = docBase;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        // make sure next call to scorer is false.\n        int op = order[(opidx[0]++) % order.length];\n        // System.out.println(op==skip_op ? \"last: skip()\":\"last: next()\");\n        boolean more = (op == skip_op ? scorer.advance(sdoc[0] + 1) : scorer\n            .nextDoc()) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(more);\n      }\n  }\n\n","bugFix":null,"bugIntro":["45fa1757f5581a10e9c63294cf292a14c92d23b1","45fa1757f5581a10e9c63294cf292a14c92d23b1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1326054a8d3aa66382d49decc7f330955c9c6f71","date":1257386139,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    \n    if (q.weight(s).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private IndexReader reader;\n          private Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = q.weight(s);\n                scorer = w.scorer(reader, true, false);\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) {\n            this.reader = reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        List<IndexReader> readerList = new ArrayList<IndexReader>();\n        ReaderUtil.gatherSubReaders(readerList, s.getIndexReader());\n        IndexReader[] readers = (IndexReader[]) readerList.toArray(new IndexReader[0]);\n        for(int i = 0; i < readers.length; i++) {\n          IndexReader reader = readers[i];\n          Weight w = q.weight(s);\n          Scorer scorer = w.scorer(reader, true, false);\n          \n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n      \n            if (more && lastDoc[0] != -1) \n              Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    \n    if (q.weight(s).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private IndexReader reader;\n          private Scorer scorer;\n\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = q.weight(s);\n                scorer = w.scorer(reader, true, false);\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          public void setNextReader(IndexReader reader, int docBase) {\n            this.reader = reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        List<IndexReader> readerList = new ArrayList<IndexReader>();\n        ReaderUtil.gatherSubReaders(readerList, s.getIndexReader());\n        IndexReader[] readers = (IndexReader[]) readerList.toArray(new IndexReader[0]);\n        for(int i = 0; i < readers.length; i++) {\n          IndexReader reader = readers[i];\n          Weight w = q.weight(s);\n          Scorer scorer = w.scorer(reader, true, false);\n          \n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n      \n            if (more && lastDoc[0] != -1) \n              Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e450c7d50c2fc84c963d0d7ade9d3217d868064d","date":1259932067,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    \n    if (q.weight(s).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private IndexReader reader;\n          private Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = q.weight(s);\n                scorer = w.scorer(reader, true, false);\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) {\n            this.reader = reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        List<IndexReader> readerList = new ArrayList<IndexReader>();\n        ReaderUtil.gatherSubReaders(readerList, s.getIndexReader());\n        IndexReader[] readers =  readerList.toArray(new IndexReader[0]);\n        for(int i = 0; i < readers.length; i++) {\n          IndexReader reader = readers[i];\n          Weight w = q.weight(s);\n          Scorer scorer = w.scorer(reader, true, false);\n          \n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n      \n            if (more && lastDoc[0] != -1) \n              Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    \n    if (q.weight(s).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private IndexReader reader;\n          private Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = q.weight(s);\n                scorer = w.scorer(reader, true, false);\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) {\n            this.reader = reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        List<IndexReader> readerList = new ArrayList<IndexReader>();\n        ReaderUtil.gatherSubReaders(readerList, s.getIndexReader());\n        IndexReader[] readers = (IndexReader[]) readerList.toArray(new IndexReader[0]);\n        for(int i = 0; i < readers.length; i++) {\n          IndexReader reader = readers[i];\n          Weight w = q.weight(s);\n          Scorer scorer = w.scorer(reader, true, false);\n          \n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n      \n            if (more && lastDoc[0] != -1) \n              Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f5d8d97303550346f85fd577f90d64cf196cebd1","date":1262890343,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    \n    if (q.weight(s).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final IndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private IndexReader reader;\n          private Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = q.weight(s);\n                scorer = w.scorer(reader, true, false);\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final IndexReader previousReader = lastReader[0];\n              Weight w = q.weight(new IndexSearcher(previousReader));\n              Scorer scorer = w.scorer(previousReader, true, false);\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n            }\n            this.reader = reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final IndexReader previousReader = lastReader[0];\n          Weight w = q.weight(new IndexSearcher(previousReader));\n          Scorer scorer = w.scorer(previousReader, true, false);\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    \n    if (q.weight(s).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private IndexReader reader;\n          private Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = q.weight(s);\n                scorer = w.scorer(reader, true, false);\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) {\n            this.reader = reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        List<IndexReader> readerList = new ArrayList<IndexReader>();\n        ReaderUtil.gatherSubReaders(readerList, s.getIndexReader());\n        IndexReader[] readers =  readerList.toArray(new IndexReader[0]);\n        for(int i = 0; i < readers.length; i++) {\n          IndexReader reader = readers[i];\n          Weight w = q.weight(s);\n          Scorer scorer = w.scorer(reader, true, false);\n          \n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n      \n            if (more && lastDoc[0] != -1) \n              Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":["b52f4d438f568f7beafda3cf347790a4bfe32928","b52f4d438f568f7beafda3cf347790a4bfe32928"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    \n    if (q.weight(s).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final IndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private IndexReader reader;\n          private Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = q.weight(s);\n                scorer = w.scorer(reader, true, false);\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final IndexReader previousReader = lastReader[0];\n              Weight w = q.weight(new IndexSearcher(previousReader));\n              Scorer scorer = w.scorer(previousReader, true, false);\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n            }\n            this.reader = reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final IndexReader previousReader = lastReader[0];\n          Weight w = q.weight(new IndexSearcher(previousReader));\n          Scorer scorer = w.scorer(previousReader, true, false);\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    \n    if (q.weight(s).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final IndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private IndexReader reader;\n          private Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = q.weight(s);\n                scorer = w.scorer(reader, true, false);\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(IndexReader reader, int docBase) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final IndexReader previousReader = lastReader[0];\n              Weight w = q.weight(new IndexSearcher(previousReader));\n              Scorer scorer = w.scorer(previousReader, true, false);\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n            }\n            this.reader = reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final IndexReader previousReader = lastReader[0];\n          Weight w = q.weight(new IndexSearcher(previousReader));\n          Scorer scorer = w.scorer(previousReader, true, false);\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"1ffe619bf5bbe00453bab7103c36fd38c8417f6c":["e69f59b863731d864bf3047235e718f0f88f8841"],"b3e493496c35fb4f17315b8827d1ba1ae1585554":["492d71f81abcc186afa0074702472ecb6b7dc997"],"64714133cf5ec732e3bbceee63351bb9af0117dc":["63bc3238545c6012bd44f5d294077997f236bc4e"],"e69f59b863731d864bf3047235e718f0f88f8841":["fe941135bdfc28c81e20b4d21422f8726af34925"],"131a9e895609b4da33662dc087e0bc6303e1e29c":["4625cb7ffd7c9caaf2d62b206ba9a382d68da82c"],"fe941135bdfc28c81e20b4d21422f8726af34925":["8d6c98c690b593cea727f68742684c979ead1a0a"],"6212677fdd165340d4284ad2530970c664042d6e":["b3e493496c35fb4f17315b8827d1ba1ae1585554"],"e450c7d50c2fc84c963d0d7ade9d3217d868064d":["1326054a8d3aa66382d49decc7f330955c9c6f71"],"63bc3238545c6012bd44f5d294077997f236bc4e":["facd440f562ba04187b82c36465181d6ba7030fa"],"aabae793f43472efdf1dcdaae4e01e28cfc23ccd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"492d71f81abcc186afa0074702472ecb6b7dc997":["76349ae49451ab1e1e63e8eeb254f82684b1da25"],"facd440f562ba04187b82c36465181d6ba7030fa":["6212677fdd165340d4284ad2530970c664042d6e"],"1326054a8d3aa66382d49decc7f330955c9c6f71":["131a9e895609b4da33662dc087e0bc6303e1e29c"],"30a558487f2298c2c19ceca9103c1b6865d64708":["64714133cf5ec732e3bbceee63351bb9af0117dc"],"76349ae49451ab1e1e63e8eeb254f82684b1da25":["aabae793f43472efdf1dcdaae4e01e28cfc23ccd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8d6c98c690b593cea727f68742684c979ead1a0a":["052fac7830290bd38a04cddee1a121ee07656b56"],"4625cb7ffd7c9caaf2d62b206ba9a382d68da82c":["1ffe619bf5bbe00453bab7103c36fd38c8417f6c"],"f5d8d97303550346f85fd577f90d64cf196cebd1":["e450c7d50c2fc84c963d0d7ade9d3217d868064d"],"052fac7830290bd38a04cddee1a121ee07656b56":["30a558487f2298c2c19ceca9103c1b6865d64708"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["f5d8d97303550346f85fd577f90d64cf196cebd1"]},"commit2Childs":{"1ffe619bf5bbe00453bab7103c36fd38c8417f6c":["4625cb7ffd7c9caaf2d62b206ba9a382d68da82c"],"b3e493496c35fb4f17315b8827d1ba1ae1585554":["6212677fdd165340d4284ad2530970c664042d6e"],"64714133cf5ec732e3bbceee63351bb9af0117dc":["30a558487f2298c2c19ceca9103c1b6865d64708"],"e69f59b863731d864bf3047235e718f0f88f8841":["1ffe619bf5bbe00453bab7103c36fd38c8417f6c"],"fe941135bdfc28c81e20b4d21422f8726af34925":["e69f59b863731d864bf3047235e718f0f88f8841"],"131a9e895609b4da33662dc087e0bc6303e1e29c":["1326054a8d3aa66382d49decc7f330955c9c6f71"],"6212677fdd165340d4284ad2530970c664042d6e":["facd440f562ba04187b82c36465181d6ba7030fa"],"e450c7d50c2fc84c963d0d7ade9d3217d868064d":["f5d8d97303550346f85fd577f90d64cf196cebd1"],"63bc3238545c6012bd44f5d294077997f236bc4e":["64714133cf5ec732e3bbceee63351bb9af0117dc"],"aabae793f43472efdf1dcdaae4e01e28cfc23ccd":["76349ae49451ab1e1e63e8eeb254f82684b1da25"],"492d71f81abcc186afa0074702472ecb6b7dc997":["b3e493496c35fb4f17315b8827d1ba1ae1585554"],"facd440f562ba04187b82c36465181d6ba7030fa":["63bc3238545c6012bd44f5d294077997f236bc4e"],"1326054a8d3aa66382d49decc7f330955c9c6f71":["e450c7d50c2fc84c963d0d7ade9d3217d868064d"],"30a558487f2298c2c19ceca9103c1b6865d64708":["052fac7830290bd38a04cddee1a121ee07656b56"],"76349ae49451ab1e1e63e8eeb254f82684b1da25":["492d71f81abcc186afa0074702472ecb6b7dc997"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["aabae793f43472efdf1dcdaae4e01e28cfc23ccd"],"8d6c98c690b593cea727f68742684c979ead1a0a":["fe941135bdfc28c81e20b4d21422f8726af34925"],"4625cb7ffd7c9caaf2d62b206ba9a382d68da82c":["131a9e895609b4da33662dc087e0bc6303e1e29c"],"f5d8d97303550346f85fd577f90d64cf196cebd1":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"052fac7830290bd38a04cddee1a121ee07656b56":["8d6c98c690b593cea727f68742684c979ead1a0a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}