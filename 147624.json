{"path":"solr/core/src/test/org/apache/solr/handler/TestContainerPlugin#testApi().mjava","commits":[{"id":"650b520f2a4daa4b0712e2393dc29ae7f21f10ac","date":1593054531,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestContainerPlugin#testApi().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testApi() throws Exception {\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .configure();\n    String errPath = \"/error/details[0]/errorMessages[0]\";\n    try {\n      PluginMeta plugin = new PluginMeta();\n      plugin.name = \"testplugin\";\n      plugin.klass = C2.class.getName();\n      //test with an invalid class\n      V2Request req = new V2Request.Builder(\"/cluster/plugin\")\n          .forceV2(true)\n          .withMethod(POST)\n          .withPayload(singletonMap(\"add\", plugin))\n          .build();\n      expectError(req, cluster.getSolrClient(), errPath, \"No method with @Command in class\");\n\n      //test with an invalid class\n      plugin.klass = C1.class.getName();\n      expectError(req, cluster.getSolrClient(), errPath, \"No @EndPoints\");\n\n      //test with a valid class. This should succeed now\n      plugin.klass = C3.class.getName();\n      req.process(cluster.getSolrClient());\n\n      //just check if the plugin is indeed registered\n      V2Request readPluginState = new V2Request.Builder(\"/cluster/plugin\")\n          .forceV2(true)\n          .withMethod(GET)\n          .build();\n      V2Response rsp = readPluginState.process(cluster.getSolrClient());\n      assertEquals(C3.class.getName(), rsp._getStr(\"/plugin/testplugin/class\", null));\n\n      //let's test the plugin\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/plugin/my/plugin\")\n              .forceV2(true)\n              .withMethod(GET)\n              .build().process(cluster.getSolrClient()),\n          ImmutableMap.of(\"/testkey\", \"testval\"));\n\n      //now remove the plugin\n      new V2Request.Builder(\"/cluster/plugin\")\n          .withMethod(POST)\n          .forceV2(true)\n          .withPayload(\"{remove : testplugin}\")\n          .build()\n          .process(cluster.getSolrClient());\n\n      //verify it is removed\n      rsp = readPluginState.process(cluster.getSolrClient());\n      assertEquals(null, rsp._get(\"/plugin/testplugin/class\", null));\n\n      //test with a class  @EndPoint methods. This also uses a template in the path name\n      plugin.klass = C4.class.getName();\n      plugin.name = \"collections\";\n      expectError(req, cluster.getSolrClient(), errPath, \"path must not have a prefix: collections\");\n\n      plugin.name = \"my-random-name\";\n      req.process(cluster.getSolrClient());\n\n      //let's test the plugin\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/my-random-name/my/plugin\")\n              .forceV2(true)\n              .withMethod(GET)\n              .build().process(cluster.getSolrClient()),\n          ImmutableMap.of(\"/method.name\", \"m1\"));\n\n  TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/my-random-name/their/plugin\")\n              .forceV2(true)\n              .withMethod(GET)\n              .build().process(cluster.getSolrClient()),\n          ImmutableMap.of(\"/method.name\", \"m2\"));\n\n    } finally {\n      cluster.shutdown();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e2c4fba12438c1407e259b55774b5bbb707046a8","date":1593319746,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestContainerPlugin#testApi().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestContainerPlugin#testApi().mjava","sourceNew":"  @Test\n  public void testApi() throws Exception {\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .configure();\n    String errPath = \"/error/details[0]/errorMessages[0]\";\n    try {\n      PluginMeta plugin = new PluginMeta();\n      plugin.name = \"testplugin\";\n      plugin.klass = C2.class.getName();\n      //test with an invalid class\n      V2Request req = new V2Request.Builder(\"/cluster/plugin\")\n          .forceV2(true)\n          .withMethod(POST)\n          .withPayload(singletonMap(\"add\", plugin))\n          .build();\n      expectError(req, cluster.getSolrClient(), errPath, \"No method with @Command in class\");\n\n      //test with an invalid class\n      plugin.klass = C1.class.getName();\n      expectError(req, cluster.getSolrClient(), errPath, \"No @EndPoints\");\n\n      //test with a valid class. This should succeed now\n      plugin.klass = C3.class.getName();\n      req.process(cluster.getSolrClient());\n\n      //just check if the plugin is indeed registered\n      V2Request readPluginState = new V2Request.Builder(\"/cluster/plugin\")\n          .forceV2(true)\n          .withMethod(GET)\n          .build();\n      V2Response rsp = readPluginState.process(cluster.getSolrClient());\n      assertEquals(C3.class.getName(), rsp._getStr(\"/plugin/testplugin/class\", null));\n\n      //let's test the plugin\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/plugin/my/plugin\")\n              .forceV2(true)\n              .withMethod(GET)\n              .build().process(cluster.getSolrClient()),\n          ImmutableMap.of(\"/testkey\", \"testval\"));\n\n      //now remove the plugin\n      new V2Request.Builder(\"/cluster/plugin\")\n          .withMethod(POST)\n          .forceV2(true)\n          .withPayload(\"{remove : testplugin}\")\n          .build()\n          .process(cluster.getSolrClient());\n\n      //verify it is removed\n      rsp = readPluginState.process(cluster.getSolrClient());\n      assertEquals(null, rsp._get(\"/plugin/testplugin/class\", null));\n\n      //test with a class  @EndPoint methods. This also uses a template in the path name\n      plugin.klass = C4.class.getName();\n      plugin.name = \"collections\";\n      plugin.pathPrefix = \"collections\";\n      expectError(req, cluster.getSolrClient(), errPath, \"path must not have a prefix: collections\");\n\n      plugin.name = \"my-random-name\";\n      plugin.pathPrefix = \"my-random-prefix\";\n\n      req.process(cluster.getSolrClient());\n\n      //let's test the plugin\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/my-random-name/my/plugin\")\n              .forceV2(true)\n              .withMethod(GET)\n              .build().process(cluster.getSolrClient()),\n          ImmutableMap.of(\"/method.name\", \"m1\"));\n\n  TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/my-random-prefix/their/plugin\")\n              .forceV2(true)\n              .withMethod(GET)\n              .build().process(cluster.getSolrClient()),\n          ImmutableMap.of(\"/method.name\", \"m2\"));\n\n    } finally {\n      cluster.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testApi() throws Exception {\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .configure();\n    String errPath = \"/error/details[0]/errorMessages[0]\";\n    try {\n      PluginMeta plugin = new PluginMeta();\n      plugin.name = \"testplugin\";\n      plugin.klass = C2.class.getName();\n      //test with an invalid class\n      V2Request req = new V2Request.Builder(\"/cluster/plugin\")\n          .forceV2(true)\n          .withMethod(POST)\n          .withPayload(singletonMap(\"add\", plugin))\n          .build();\n      expectError(req, cluster.getSolrClient(), errPath, \"No method with @Command in class\");\n\n      //test with an invalid class\n      plugin.klass = C1.class.getName();\n      expectError(req, cluster.getSolrClient(), errPath, \"No @EndPoints\");\n\n      //test with a valid class. This should succeed now\n      plugin.klass = C3.class.getName();\n      req.process(cluster.getSolrClient());\n\n      //just check if the plugin is indeed registered\n      V2Request readPluginState = new V2Request.Builder(\"/cluster/plugin\")\n          .forceV2(true)\n          .withMethod(GET)\n          .build();\n      V2Response rsp = readPluginState.process(cluster.getSolrClient());\n      assertEquals(C3.class.getName(), rsp._getStr(\"/plugin/testplugin/class\", null));\n\n      //let's test the plugin\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/plugin/my/plugin\")\n              .forceV2(true)\n              .withMethod(GET)\n              .build().process(cluster.getSolrClient()),\n          ImmutableMap.of(\"/testkey\", \"testval\"));\n\n      //now remove the plugin\n      new V2Request.Builder(\"/cluster/plugin\")\n          .withMethod(POST)\n          .forceV2(true)\n          .withPayload(\"{remove : testplugin}\")\n          .build()\n          .process(cluster.getSolrClient());\n\n      //verify it is removed\n      rsp = readPluginState.process(cluster.getSolrClient());\n      assertEquals(null, rsp._get(\"/plugin/testplugin/class\", null));\n\n      //test with a class  @EndPoint methods. This also uses a template in the path name\n      plugin.klass = C4.class.getName();\n      plugin.name = \"collections\";\n      expectError(req, cluster.getSolrClient(), errPath, \"path must not have a prefix: collections\");\n\n      plugin.name = \"my-random-name\";\n      req.process(cluster.getSolrClient());\n\n      //let's test the plugin\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/my-random-name/my/plugin\")\n              .forceV2(true)\n              .withMethod(GET)\n              .build().process(cluster.getSolrClient()),\n          ImmutableMap.of(\"/method.name\", \"m1\"));\n\n  TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/my-random-name/their/plugin\")\n              .forceV2(true)\n              .withMethod(GET)\n              .build().process(cluster.getSolrClient()),\n          ImmutableMap.of(\"/method.name\", \"m2\"));\n\n    } finally {\n      cluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86cd0c5a55b09b85b88e1b3e857145f321a696d8","date":1593668656,"type":3,"author":"noblepaul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestContainerPlugin#testApi().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestContainerPlugin#testApi().mjava","sourceNew":"  @Test\n  public void testApi() throws Exception {\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .configure();\n    String errPath = \"/error/details[0]/errorMessages[0]\";\n    try {\n      PluginMeta plugin = new PluginMeta();\n      plugin.name = \"testplugin\";\n      plugin.klass = C2.class.getName();\n      //test with an invalid class\n      V2Request req = new V2Request.Builder(\"/cluster/plugin\")\n          .forceV2(true)\n          .withMethod(POST)\n          .withPayload(singletonMap(\"add\", plugin))\n          .build();\n      expectError(req, cluster.getSolrClient(), errPath, \"No method with @Command in class\");\n\n      //test with an invalid class\n      plugin.klass = C1.class.getName();\n      expectError(req, cluster.getSolrClient(), errPath, \"No @EndPoints\");\n\n      //test with a valid class. This should succeed now\n      plugin.klass = C3.class.getName();\n      req.process(cluster.getSolrClient());\n\n      //just check if the plugin is indeed registered\n      V2Request readPluginState = new V2Request.Builder(\"/cluster/plugin\")\n          .forceV2(true)\n          .withMethod(GET)\n          .build();\n      V2Response rsp = readPluginState.process(cluster.getSolrClient());\n      assertEquals(C3.class.getName(), rsp._getStr(\"/plugin/testplugin/class\", null));\n\n      //let's test the plugin\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/plugin/my/plugin\")\n              .forceV2(true)\n              .withMethod(GET)\n              .build().process(cluster.getSolrClient()),\n          ImmutableMap.of(\"/testkey\", \"testval\"));\n\n      //now remove the plugin\n      new V2Request.Builder(\"/cluster/plugin\")\n          .withMethod(POST)\n          .forceV2(true)\n          .withPayload(\"{remove : testplugin}\")\n          .build()\n          .process(cluster.getSolrClient());\n\n      //verify it is removed\n      rsp = readPluginState.process(cluster.getSolrClient());\n      assertEquals(null, rsp._get(\"/plugin/testplugin/class\", null));\n\n      //test with a class  @EndPoint methods. This also uses a template in the path name\n      plugin.klass = C4.class.getName();\n      plugin.name = \"collections\";\n      plugin.pathPrefix = \"collections\";\n      expectError(req, cluster.getSolrClient(), errPath, \"path must not have a prefix: collections\");\n\n      plugin.name = \"my-random-name\";\n      plugin.pathPrefix = \"my-random-prefix\";\n\n      req.process(cluster.getSolrClient());\n\n      //let's test the plugin\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/my-random-name/my/plugin\")\n              .forceV2(true)\n              .withMethod(GET)\n              .build().process(cluster.getSolrClient()),\n          ImmutableMap.of(\"/method.name\", \"m1\"));\n\n  TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/my-random-prefix/their/plugin\")\n              .forceV2(true)\n              .withMethod(GET)\n              .build().process(cluster.getSolrClient()),\n          ImmutableMap.of(\"/method.name\", \"m2\"));\n      //now remove the plugin\n      new V2Request.Builder(\"/cluster/plugin\")\n          .withMethod(POST)\n          .forceV2(true)\n          .withPayload(\"{remove : my-random-name}\")\n          .build()\n          .process(cluster.getSolrClient());\n\n      expectFail( () -> new V2Request.Builder(\"/my-random-prefix/their/plugin\")\n          .forceV2(true)\n          .withMethod(GET)\n          .build()\n          .process(cluster.getSolrClient()));\n      expectFail(() -> new V2Request.Builder(\"/my-random-prefix/their/plugin\")\n          .forceV2(true)\n          .withMethod(GET)\n          .build()\n          .process(cluster.getSolrClient()));\n    } finally {\n      cluster.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testApi() throws Exception {\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .configure();\n    String errPath = \"/error/details[0]/errorMessages[0]\";\n    try {\n      PluginMeta plugin = new PluginMeta();\n      plugin.name = \"testplugin\";\n      plugin.klass = C2.class.getName();\n      //test with an invalid class\n      V2Request req = new V2Request.Builder(\"/cluster/plugin\")\n          .forceV2(true)\n          .withMethod(POST)\n          .withPayload(singletonMap(\"add\", plugin))\n          .build();\n      expectError(req, cluster.getSolrClient(), errPath, \"No method with @Command in class\");\n\n      //test with an invalid class\n      plugin.klass = C1.class.getName();\n      expectError(req, cluster.getSolrClient(), errPath, \"No @EndPoints\");\n\n      //test with a valid class. This should succeed now\n      plugin.klass = C3.class.getName();\n      req.process(cluster.getSolrClient());\n\n      //just check if the plugin is indeed registered\n      V2Request readPluginState = new V2Request.Builder(\"/cluster/plugin\")\n          .forceV2(true)\n          .withMethod(GET)\n          .build();\n      V2Response rsp = readPluginState.process(cluster.getSolrClient());\n      assertEquals(C3.class.getName(), rsp._getStr(\"/plugin/testplugin/class\", null));\n\n      //let's test the plugin\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/plugin/my/plugin\")\n              .forceV2(true)\n              .withMethod(GET)\n              .build().process(cluster.getSolrClient()),\n          ImmutableMap.of(\"/testkey\", \"testval\"));\n\n      //now remove the plugin\n      new V2Request.Builder(\"/cluster/plugin\")\n          .withMethod(POST)\n          .forceV2(true)\n          .withPayload(\"{remove : testplugin}\")\n          .build()\n          .process(cluster.getSolrClient());\n\n      //verify it is removed\n      rsp = readPluginState.process(cluster.getSolrClient());\n      assertEquals(null, rsp._get(\"/plugin/testplugin/class\", null));\n\n      //test with a class  @EndPoint methods. This also uses a template in the path name\n      plugin.klass = C4.class.getName();\n      plugin.name = \"collections\";\n      plugin.pathPrefix = \"collections\";\n      expectError(req, cluster.getSolrClient(), errPath, \"path must not have a prefix: collections\");\n\n      plugin.name = \"my-random-name\";\n      plugin.pathPrefix = \"my-random-prefix\";\n\n      req.process(cluster.getSolrClient());\n\n      //let's test the plugin\n      TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/my-random-name/my/plugin\")\n              .forceV2(true)\n              .withMethod(GET)\n              .build().process(cluster.getSolrClient()),\n          ImmutableMap.of(\"/method.name\", \"m1\"));\n\n  TestDistribPackageStore.assertResponseValues(10,\n          () -> new V2Request.Builder(\"/my-random-prefix/their/plugin\")\n              .forceV2(true)\n              .withMethod(GET)\n              .build().process(cluster.getSolrClient()),\n          ImmutableMap.of(\"/method.name\", \"m2\"));\n\n    } finally {\n      cluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"650b520f2a4daa4b0712e2393dc29ae7f21f10ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e2c4fba12438c1407e259b55774b5bbb707046a8":["650b520f2a4daa4b0712e2393dc29ae7f21f10ac"],"86cd0c5a55b09b85b88e1b3e857145f321a696d8":["e2c4fba12438c1407e259b55774b5bbb707046a8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["86cd0c5a55b09b85b88e1b3e857145f321a696d8"]},"commit2Childs":{"650b520f2a4daa4b0712e2393dc29ae7f21f10ac":["e2c4fba12438c1407e259b55774b5bbb707046a8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["650b520f2a4daa4b0712e2393dc29ae7f21f10ac"],"e2c4fba12438c1407e259b55774b5bbb707046a8":["86cd0c5a55b09b85b88e1b3e857145f321a696d8"],"86cd0c5a55b09b85b88e1b3e857145f321a696d8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}