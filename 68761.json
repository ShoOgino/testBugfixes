{"path":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#obtain().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#obtain().mjava","pathOld":"lucene/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#obtain().mjava","sourceNew":"  @Override\n  public synchronized boolean obtain() throws IOException {\n\n    if (lockExists()) {\n      // Our instance is already locked:\n      return false;\n    }\n\n    // Ensure that lockDir exists and is a directory.\n    if (!lockDir.exists()) {\n      if (!lockDir.mkdirs())\n        throw new IOException(\"Cannot create directory: \" +\n                              lockDir.getAbsolutePath());\n    } else if (!lockDir.isDirectory()) {\n      throw new IOException(\"Found regular file where directory expected: \" + \n                            lockDir.getAbsolutePath());\n    }\n\n    String canonicalPath = path.getCanonicalPath();\n\n    boolean markedHeld = false;\n\n    try {\n\n      // Make sure nobody else in-process has this lock held\n      // already, and, mark it held if not:\n\n      synchronized(LOCK_HELD) {\n        if (LOCK_HELD.contains(canonicalPath)) {\n          // Someone else in this JVM already has the lock:\n          return false;\n        } else {\n          // This \"reserves\" the fact that we are the one\n          // thread trying to obtain this lock, so we own\n          // the only instance of a channel against this\n          // file:\n          LOCK_HELD.add(canonicalPath);\n          markedHeld = true;\n        }\n      }\n\n      try {\n        f = new RandomAccessFile(path, \"rw\");\n      } catch (IOException e) {\n        // On Windows, we can get intermittent \"Access\n        // Denied\" here.  So, we treat this as failure to\n        // acquire the lock, but, store the reason in case\n        // there is in fact a real error case.\n        failureReason = e;\n        f = null;\n      }\n\n      if (f != null) {\n        try {\n          channel = f.getChannel();\n          try {\n            lock = channel.tryLock();\n          } catch (IOException e) {\n            // At least on OS X, we will sometimes get an\n            // intermittent \"Permission Denied\" IOException,\n            // which seems to simply mean \"you failed to get\n            // the lock\".  But other IOExceptions could be\n            // \"permanent\" (eg, locking is not supported via\n            // the filesystem).  So, we record the failure\n            // reason here; the timeout obtain (usually the\n            // one calling us) will use this as \"root cause\"\n            // if it fails to get the lock.\n            failureReason = e;\n          } finally {\n            if (lock == null) {\n              try {\n                channel.close();\n              } finally {\n                channel = null;\n              }\n            }\n          }\n        } finally {\n          if (channel == null) {\n            try {\n              f.close();\n            } finally {\n              f = null;\n            }\n          }\n        }\n      }\n\n    } finally {\n      if (markedHeld && !lockExists()) {\n        synchronized(LOCK_HELD) {\n          if (LOCK_HELD.contains(canonicalPath)) {\n            LOCK_HELD.remove(canonicalPath);\n          }\n        }\n      }\n    }\n    return lockExists();\n  }\n\n","sourceOld":"  @Override\n  public synchronized boolean obtain() throws IOException {\n\n    if (lockExists()) {\n      // Our instance is already locked:\n      return false;\n    }\n\n    // Ensure that lockDir exists and is a directory.\n    if (!lockDir.exists()) {\n      if (!lockDir.mkdirs())\n        throw new IOException(\"Cannot create directory: \" +\n                              lockDir.getAbsolutePath());\n    } else if (!lockDir.isDirectory()) {\n      throw new IOException(\"Found regular file where directory expected: \" + \n                            lockDir.getAbsolutePath());\n    }\n\n    String canonicalPath = path.getCanonicalPath();\n\n    boolean markedHeld = false;\n\n    try {\n\n      // Make sure nobody else in-process has this lock held\n      // already, and, mark it held if not:\n\n      synchronized(LOCK_HELD) {\n        if (LOCK_HELD.contains(canonicalPath)) {\n          // Someone else in this JVM already has the lock:\n          return false;\n        } else {\n          // This \"reserves\" the fact that we are the one\n          // thread trying to obtain this lock, so we own\n          // the only instance of a channel against this\n          // file:\n          LOCK_HELD.add(canonicalPath);\n          markedHeld = true;\n        }\n      }\n\n      try {\n        f = new RandomAccessFile(path, \"rw\");\n      } catch (IOException e) {\n        // On Windows, we can get intermittent \"Access\n        // Denied\" here.  So, we treat this as failure to\n        // acquire the lock, but, store the reason in case\n        // there is in fact a real error case.\n        failureReason = e;\n        f = null;\n      }\n\n      if (f != null) {\n        try {\n          channel = f.getChannel();\n          try {\n            lock = channel.tryLock();\n          } catch (IOException e) {\n            // At least on OS X, we will sometimes get an\n            // intermittent \"Permission Denied\" IOException,\n            // which seems to simply mean \"you failed to get\n            // the lock\".  But other IOExceptions could be\n            // \"permanent\" (eg, locking is not supported via\n            // the filesystem).  So, we record the failure\n            // reason here; the timeout obtain (usually the\n            // one calling us) will use this as \"root cause\"\n            // if it fails to get the lock.\n            failureReason = e;\n          } finally {\n            if (lock == null) {\n              try {\n                channel.close();\n              } finally {\n                channel = null;\n              }\n            }\n          }\n        } finally {\n          if (channel == null) {\n            try {\n              f.close();\n            } finally {\n              f = null;\n            }\n          }\n        }\n      }\n\n    } finally {\n      if (markedHeld && !lockExists()) {\n        synchronized(LOCK_HELD) {\n          if (LOCK_HELD.contains(canonicalPath)) {\n            LOCK_HELD.remove(canonicalPath);\n          }\n        }\n      }\n    }\n    return lockExists();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0451c421afa567194fd4312af9389e07003a7941","date":1331317047,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#obtain().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#obtain().mjava","sourceNew":"  @Override\n  public synchronized boolean obtain() throws IOException {\n\n    if (lockExists()) {\n      // Our instance is already locked:\n      return false;\n    }\n\n    // Ensure that lockDir exists and is a directory.\n    if (!lockDir.exists()) {\n      if (!lockDir.mkdirs())\n        throw new IOException(\"Cannot create directory: \" +\n                              lockDir.getAbsolutePath());\n    } else if (!lockDir.isDirectory()) {\n      // TODO: NoSuchDirectoryException instead?\n      throw new IOException(\"Found regular file where directory expected: \" + \n                            lockDir.getAbsolutePath());\n    }\n\n    String canonicalPath = path.getCanonicalPath();\n\n    boolean markedHeld = false;\n\n    try {\n\n      // Make sure nobody else in-process has this lock held\n      // already, and, mark it held if not:\n\n      synchronized(LOCK_HELD) {\n        if (LOCK_HELD.contains(canonicalPath)) {\n          // Someone else in this JVM already has the lock:\n          return false;\n        } else {\n          // This \"reserves\" the fact that we are the one\n          // thread trying to obtain this lock, so we own\n          // the only instance of a channel against this\n          // file:\n          LOCK_HELD.add(canonicalPath);\n          markedHeld = true;\n        }\n      }\n\n      try {\n        f = new RandomAccessFile(path, \"rw\");\n      } catch (IOException e) {\n        // On Windows, we can get intermittent \"Access\n        // Denied\" here.  So, we treat this as failure to\n        // acquire the lock, but, store the reason in case\n        // there is in fact a real error case.\n        failureReason = e;\n        f = null;\n      }\n\n      if (f != null) {\n        try {\n          channel = f.getChannel();\n          try {\n            lock = channel.tryLock();\n          } catch (IOException e) {\n            // At least on OS X, we will sometimes get an\n            // intermittent \"Permission Denied\" IOException,\n            // which seems to simply mean \"you failed to get\n            // the lock\".  But other IOExceptions could be\n            // \"permanent\" (eg, locking is not supported via\n            // the filesystem).  So, we record the failure\n            // reason here; the timeout obtain (usually the\n            // one calling us) will use this as \"root cause\"\n            // if it fails to get the lock.\n            failureReason = e;\n          } finally {\n            if (lock == null) {\n              try {\n                channel.close();\n              } finally {\n                channel = null;\n              }\n            }\n          }\n        } finally {\n          if (channel == null) {\n            try {\n              f.close();\n            } finally {\n              f = null;\n            }\n          }\n        }\n      }\n\n    } finally {\n      if (markedHeld && !lockExists()) {\n        synchronized(LOCK_HELD) {\n          if (LOCK_HELD.contains(canonicalPath)) {\n            LOCK_HELD.remove(canonicalPath);\n          }\n        }\n      }\n    }\n    return lockExists();\n  }\n\n","sourceOld":"  @Override\n  public synchronized boolean obtain() throws IOException {\n\n    if (lockExists()) {\n      // Our instance is already locked:\n      return false;\n    }\n\n    // Ensure that lockDir exists and is a directory.\n    if (!lockDir.exists()) {\n      if (!lockDir.mkdirs())\n        throw new IOException(\"Cannot create directory: \" +\n                              lockDir.getAbsolutePath());\n    } else if (!lockDir.isDirectory()) {\n      throw new IOException(\"Found regular file where directory expected: \" + \n                            lockDir.getAbsolutePath());\n    }\n\n    String canonicalPath = path.getCanonicalPath();\n\n    boolean markedHeld = false;\n\n    try {\n\n      // Make sure nobody else in-process has this lock held\n      // already, and, mark it held if not:\n\n      synchronized(LOCK_HELD) {\n        if (LOCK_HELD.contains(canonicalPath)) {\n          // Someone else in this JVM already has the lock:\n          return false;\n        } else {\n          // This \"reserves\" the fact that we are the one\n          // thread trying to obtain this lock, so we own\n          // the only instance of a channel against this\n          // file:\n          LOCK_HELD.add(canonicalPath);\n          markedHeld = true;\n        }\n      }\n\n      try {\n        f = new RandomAccessFile(path, \"rw\");\n      } catch (IOException e) {\n        // On Windows, we can get intermittent \"Access\n        // Denied\" here.  So, we treat this as failure to\n        // acquire the lock, but, store the reason in case\n        // there is in fact a real error case.\n        failureReason = e;\n        f = null;\n      }\n\n      if (f != null) {\n        try {\n          channel = f.getChannel();\n          try {\n            lock = channel.tryLock();\n          } catch (IOException e) {\n            // At least on OS X, we will sometimes get an\n            // intermittent \"Permission Denied\" IOException,\n            // which seems to simply mean \"you failed to get\n            // the lock\".  But other IOExceptions could be\n            // \"permanent\" (eg, locking is not supported via\n            // the filesystem).  So, we record the failure\n            // reason here; the timeout obtain (usually the\n            // one calling us) will use this as \"root cause\"\n            // if it fails to get the lock.\n            failureReason = e;\n          } finally {\n            if (lock == null) {\n              try {\n                channel.close();\n              } finally {\n                channel = null;\n              }\n            }\n          }\n        } finally {\n          if (channel == null) {\n            try {\n              f.close();\n            } finally {\n              f = null;\n            }\n          }\n        }\n      }\n\n    } finally {\n      if (markedHeld && !lockExists()) {\n        synchronized(LOCK_HELD) {\n          if (LOCK_HELD.contains(canonicalPath)) {\n            LOCK_HELD.remove(canonicalPath);\n          }\n        }\n      }\n    }\n    return lockExists();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#obtain().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#obtain().mjava","sourceNew":"  @Override\n  public synchronized boolean obtain() throws IOException {\n\n    if (lockExists()) {\n      // Our instance is already locked:\n      return false;\n    }\n\n    // Ensure that lockDir exists and is a directory.\n    if (!lockDir.exists()) {\n      if (!lockDir.mkdirs())\n        throw new IOException(\"Cannot create directory: \" +\n                              lockDir.getAbsolutePath());\n    } else if (!lockDir.isDirectory()) {\n      // TODO: NoSuchDirectoryException instead?\n      throw new IOException(\"Found regular file where directory expected: \" + \n                            lockDir.getAbsolutePath());\n    }\n\n    String canonicalPath = path.getCanonicalPath();\n\n    boolean markedHeld = false;\n\n    try {\n\n      // Make sure nobody else in-process has this lock held\n      // already, and, mark it held if not:\n\n      synchronized(LOCK_HELD) {\n        if (LOCK_HELD.contains(canonicalPath)) {\n          // Someone else in this JVM already has the lock:\n          return false;\n        } else {\n          // This \"reserves\" the fact that we are the one\n          // thread trying to obtain this lock, so we own\n          // the only instance of a channel against this\n          // file:\n          LOCK_HELD.add(canonicalPath);\n          markedHeld = true;\n        }\n      }\n\n      try {\n        f = new RandomAccessFile(path, \"rw\");\n      } catch (IOException e) {\n        // On Windows, we can get intermittent \"Access\n        // Denied\" here.  So, we treat this as failure to\n        // acquire the lock, but, store the reason in case\n        // there is in fact a real error case.\n        failureReason = e;\n        f = null;\n      }\n\n      if (f != null) {\n        try {\n          channel = f.getChannel();\n          try {\n            lock = channel.tryLock();\n          } catch (IOException e) {\n            // At least on OS X, we will sometimes get an\n            // intermittent \"Permission Denied\" IOException,\n            // which seems to simply mean \"you failed to get\n            // the lock\".  But other IOExceptions could be\n            // \"permanent\" (eg, locking is not supported via\n            // the filesystem).  So, we record the failure\n            // reason here; the timeout obtain (usually the\n            // one calling us) will use this as \"root cause\"\n            // if it fails to get the lock.\n            failureReason = e;\n          } finally {\n            if (lock == null) {\n              try {\n                channel.close();\n              } finally {\n                channel = null;\n              }\n            }\n          }\n        } finally {\n          if (channel == null) {\n            try {\n              f.close();\n            } finally {\n              f = null;\n            }\n          }\n        }\n      }\n\n    } finally {\n      if (markedHeld && !lockExists()) {\n        synchronized(LOCK_HELD) {\n          if (LOCK_HELD.contains(canonicalPath)) {\n            LOCK_HELD.remove(canonicalPath);\n          }\n        }\n      }\n    }\n    return lockExists();\n  }\n\n","sourceOld":"  @Override\n  public synchronized boolean obtain() throws IOException {\n\n    if (lockExists()) {\n      // Our instance is already locked:\n      return false;\n    }\n\n    // Ensure that lockDir exists and is a directory.\n    if (!lockDir.exists()) {\n      if (!lockDir.mkdirs())\n        throw new IOException(\"Cannot create directory: \" +\n                              lockDir.getAbsolutePath());\n    } else if (!lockDir.isDirectory()) {\n      throw new IOException(\"Found regular file where directory expected: \" + \n                            lockDir.getAbsolutePath());\n    }\n\n    String canonicalPath = path.getCanonicalPath();\n\n    boolean markedHeld = false;\n\n    try {\n\n      // Make sure nobody else in-process has this lock held\n      // already, and, mark it held if not:\n\n      synchronized(LOCK_HELD) {\n        if (LOCK_HELD.contains(canonicalPath)) {\n          // Someone else in this JVM already has the lock:\n          return false;\n        } else {\n          // This \"reserves\" the fact that we are the one\n          // thread trying to obtain this lock, so we own\n          // the only instance of a channel against this\n          // file:\n          LOCK_HELD.add(canonicalPath);\n          markedHeld = true;\n        }\n      }\n\n      try {\n        f = new RandomAccessFile(path, \"rw\");\n      } catch (IOException e) {\n        // On Windows, we can get intermittent \"Access\n        // Denied\" here.  So, we treat this as failure to\n        // acquire the lock, but, store the reason in case\n        // there is in fact a real error case.\n        failureReason = e;\n        f = null;\n      }\n\n      if (f != null) {\n        try {\n          channel = f.getChannel();\n          try {\n            lock = channel.tryLock();\n          } catch (IOException e) {\n            // At least on OS X, we will sometimes get an\n            // intermittent \"Permission Denied\" IOException,\n            // which seems to simply mean \"you failed to get\n            // the lock\".  But other IOExceptions could be\n            // \"permanent\" (eg, locking is not supported via\n            // the filesystem).  So, we record the failure\n            // reason here; the timeout obtain (usually the\n            // one calling us) will use this as \"root cause\"\n            // if it fails to get the lock.\n            failureReason = e;\n          } finally {\n            if (lock == null) {\n              try {\n                channel.close();\n              } finally {\n                channel = null;\n              }\n            }\n          }\n        } finally {\n          if (channel == null) {\n            try {\n              f.close();\n            } finally {\n              f = null;\n            }\n          }\n        }\n      }\n\n    } finally {\n      if (markedHeld && !lockExists()) {\n        synchronized(LOCK_HELD) {\n          if (LOCK_HELD.contains(canonicalPath)) {\n            LOCK_HELD.remove(canonicalPath);\n          }\n        }\n      }\n    }\n    return lockExists();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"19275ba31e621f6da1b83bf13af75233876fd3d4","date":1374846698,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#obtain().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#obtain().mjava","sourceNew":"  @Override\n  public synchronized boolean obtain() throws IOException {\n\n    if (lockExists()) {\n      // Our instance is already locked:\n      return false;\n    }\n\n    // Ensure that lockDir exists and is a directory.\n    if (!lockDir.exists()) {\n      if (!lockDir.mkdirs())\n        throw new IOException(\"Cannot create directory: \" +\n                              lockDir.getAbsolutePath());\n    } else if (!lockDir.isDirectory()) {\n      // TODO: NoSuchDirectoryException instead?\n      throw new IOException(\"Found regular file where directory expected: \" + \n                            lockDir.getAbsolutePath());\n    }\n\n    String canonicalPath = path.getCanonicalPath();\n\n    boolean markedHeld = false;\n\n    try {\n\n      // Make sure nobody else in-process has this lock held\n      // already, and, mark it held if not:\n\n      synchronized(LOCK_HELD) {\n        if (LOCK_HELD.contains(canonicalPath)) {\n          // Someone else in this JVM already has the lock:\n          return false;\n        } else {\n          // This \"reserves\" the fact that we are the one\n          // thread trying to obtain this lock, so we own\n          // the only instance of a channel against this\n          // file:\n          LOCK_HELD.add(canonicalPath);\n          markedHeld = true;\n        }\n      }\n\n      try {\n        f = new RandomAccessFile(path, \"rw\");\n      } catch (IOException e) {\n        // On Windows, we can get intermittent \"Access\n        // Denied\" here.  So, we treat this as failure to\n        // acquire the lock, but, store the reason in case\n        // there is in fact a real error case.\n        failureReason = e;\n        f = null;\n      }\n\n      if (f != null) {\n        try {\n          channel = f.getChannel();\n          try {\n            lock = channel.tryLock();\n          } catch (IOException e) {\n            // At least on OS X, we will sometimes get an\n            // intermittent \"Permission Denied\" IOException,\n            // which seems to simply mean \"you failed to get\n            // the lock\".  But other IOExceptions could be\n            // \"permanent\" (eg, locking is not supported via\n            // the filesystem).  So, we record the failure\n            // reason here; the timeout obtain (usually the\n            // one calling us) will use this as \"root cause\"\n            // if it fails to get the lock.\n            failureReason = e;\n          } finally {\n            if (lock == null) {\n              try {\n                channel.close();\n              } finally {\n                channel = null;\n              }\n            }\n          }\n        } finally {\n          if (channel == null) {\n            try {\n              f.close();\n            } finally {\n              f = null;\n            }\n          }\n        }\n      }\n\n    } finally {\n      if (markedHeld && !lockExists()) {\n        synchronized(LOCK_HELD) {\n          if (LOCK_HELD.contains(canonicalPath)) {\n            LOCK_HELD.remove(canonicalPath);\n          }\n        }\n      }\n    }\n    return lockExists();\n  }\n\n","sourceOld":"  @Override\n  public synchronized boolean obtain() throws IOException {\n\n    if (lockExists()) {\n      // Our instance is already locked:\n      return false;\n    }\n\n    // Ensure that lockDir exists and is a directory.\n    if (!lockDir.exists()) {\n      if (!lockDir.mkdirs())\n        throw new IOException(\"Cannot create directory: \" +\n                              lockDir.getAbsolutePath());\n    } else if (!lockDir.isDirectory()) {\n      // TODO: NoSuchDirectoryException instead?\n      throw new IOException(\"Found regular file where directory expected: \" + \n                            lockDir.getAbsolutePath());\n    }\n\n    String canonicalPath = path.getCanonicalPath();\n\n    boolean markedHeld = false;\n\n    try {\n\n      // Make sure nobody else in-process has this lock held\n      // already, and, mark it held if not:\n\n      synchronized(LOCK_HELD) {\n        if (LOCK_HELD.contains(canonicalPath)) {\n          // Someone else in this JVM already has the lock:\n          return false;\n        } else {\n          // This \"reserves\" the fact that we are the one\n          // thread trying to obtain this lock, so we own\n          // the only instance of a channel against this\n          // file:\n          LOCK_HELD.add(canonicalPath);\n          markedHeld = true;\n        }\n      }\n\n      try {\n        f = new RandomAccessFile(path, \"rw\");\n      } catch (IOException e) {\n        // On Windows, we can get intermittent \"Access\n        // Denied\" here.  So, we treat this as failure to\n        // acquire the lock, but, store the reason in case\n        // there is in fact a real error case.\n        failureReason = e;\n        f = null;\n      }\n\n      if (f != null) {\n        try {\n          channel = f.getChannel();\n          try {\n            lock = channel.tryLock();\n          } catch (IOException e) {\n            // At least on OS X, we will sometimes get an\n            // intermittent \"Permission Denied\" IOException,\n            // which seems to simply mean \"you failed to get\n            // the lock\".  But other IOExceptions could be\n            // \"permanent\" (eg, locking is not supported via\n            // the filesystem).  So, we record the failure\n            // reason here; the timeout obtain (usually the\n            // one calling us) will use this as \"root cause\"\n            // if it fails to get the lock.\n            failureReason = e;\n          } finally {\n            if (lock == null) {\n              try {\n                channel.close();\n              } finally {\n                channel = null;\n              }\n            }\n          }\n        } finally {\n          if (channel == null) {\n            try {\n              f.close();\n            } finally {\n              f = null;\n            }\n          }\n        }\n      }\n\n    } finally {\n      if (markedHeld && !lockExists()) {\n        synchronized(LOCK_HELD) {\n          if (LOCK_HELD.contains(canonicalPath)) {\n            LOCK_HELD.remove(canonicalPath);\n          }\n        }\n      }\n    }\n    return lockExists();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#obtain().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#obtain().mjava","sourceNew":"  @Override\n  public synchronized boolean obtain() throws IOException {\n\n    if (lockExists()) {\n      // Our instance is already locked:\n      return false;\n    }\n\n    // Ensure that lockDir exists and is a directory.\n    if (!lockDir.exists()) {\n      if (!lockDir.mkdirs())\n        throw new IOException(\"Cannot create directory: \" +\n                              lockDir.getAbsolutePath());\n    } else if (!lockDir.isDirectory()) {\n      // TODO: NoSuchDirectoryException instead?\n      throw new IOException(\"Found regular file where directory expected: \" + \n                            lockDir.getAbsolutePath());\n    }\n\n    String canonicalPath = path.getCanonicalPath();\n\n    boolean markedHeld = false;\n\n    try {\n\n      // Make sure nobody else in-process has this lock held\n      // already, and, mark it held if not:\n\n      synchronized(LOCK_HELD) {\n        if (LOCK_HELD.contains(canonicalPath)) {\n          // Someone else in this JVM already has the lock:\n          return false;\n        } else {\n          // This \"reserves\" the fact that we are the one\n          // thread trying to obtain this lock, so we own\n          // the only instance of a channel against this\n          // file:\n          LOCK_HELD.add(canonicalPath);\n          markedHeld = true;\n        }\n      }\n\n      try {\n        f = new RandomAccessFile(path, \"rw\");\n      } catch (IOException e) {\n        // On Windows, we can get intermittent \"Access\n        // Denied\" here.  So, we treat this as failure to\n        // acquire the lock, but, store the reason in case\n        // there is in fact a real error case.\n        failureReason = e;\n        f = null;\n      }\n\n      if (f != null) {\n        try {\n          channel = f.getChannel();\n          try {\n            lock = channel.tryLock();\n          } catch (IOException e) {\n            // At least on OS X, we will sometimes get an\n            // intermittent \"Permission Denied\" IOException,\n            // which seems to simply mean \"you failed to get\n            // the lock\".  But other IOExceptions could be\n            // \"permanent\" (eg, locking is not supported via\n            // the filesystem).  So, we record the failure\n            // reason here; the timeout obtain (usually the\n            // one calling us) will use this as \"root cause\"\n            // if it fails to get the lock.\n            failureReason = e;\n          } finally {\n            if (lock == null) {\n              try {\n                channel.close();\n              } finally {\n                channel = null;\n              }\n            }\n          }\n        } finally {\n          if (channel == null) {\n            try {\n              f.close();\n            } finally {\n              f = null;\n            }\n          }\n        }\n      }\n\n    } finally {\n      if (markedHeld && !lockExists()) {\n        synchronized(LOCK_HELD) {\n          if (LOCK_HELD.contains(canonicalPath)) {\n            LOCK_HELD.remove(canonicalPath);\n          }\n        }\n      }\n    }\n    return lockExists();\n  }\n\n","sourceOld":"  @Override\n  public synchronized boolean obtain() throws IOException {\n\n    if (lockExists()) {\n      // Our instance is already locked:\n      return false;\n    }\n\n    // Ensure that lockDir exists and is a directory.\n    if (!lockDir.exists()) {\n      if (!lockDir.mkdirs())\n        throw new IOException(\"Cannot create directory: \" +\n                              lockDir.getAbsolutePath());\n    } else if (!lockDir.isDirectory()) {\n      // TODO: NoSuchDirectoryException instead?\n      throw new IOException(\"Found regular file where directory expected: \" + \n                            lockDir.getAbsolutePath());\n    }\n\n    String canonicalPath = path.getCanonicalPath();\n\n    boolean markedHeld = false;\n\n    try {\n\n      // Make sure nobody else in-process has this lock held\n      // already, and, mark it held if not:\n\n      synchronized(LOCK_HELD) {\n        if (LOCK_HELD.contains(canonicalPath)) {\n          // Someone else in this JVM already has the lock:\n          return false;\n        } else {\n          // This \"reserves\" the fact that we are the one\n          // thread trying to obtain this lock, so we own\n          // the only instance of a channel against this\n          // file:\n          LOCK_HELD.add(canonicalPath);\n          markedHeld = true;\n        }\n      }\n\n      try {\n        f = new RandomAccessFile(path, \"rw\");\n      } catch (IOException e) {\n        // On Windows, we can get intermittent \"Access\n        // Denied\" here.  So, we treat this as failure to\n        // acquire the lock, but, store the reason in case\n        // there is in fact a real error case.\n        failureReason = e;\n        f = null;\n      }\n\n      if (f != null) {\n        try {\n          channel = f.getChannel();\n          try {\n            lock = channel.tryLock();\n          } catch (IOException e) {\n            // At least on OS X, we will sometimes get an\n            // intermittent \"Permission Denied\" IOException,\n            // which seems to simply mean \"you failed to get\n            // the lock\".  But other IOExceptions could be\n            // \"permanent\" (eg, locking is not supported via\n            // the filesystem).  So, we record the failure\n            // reason here; the timeout obtain (usually the\n            // one calling us) will use this as \"root cause\"\n            // if it fails to get the lock.\n            failureReason = e;\n          } finally {\n            if (lock == null) {\n              try {\n                channel.close();\n              } finally {\n                channel = null;\n              }\n            }\n          }\n        } finally {\n          if (channel == null) {\n            try {\n              f.close();\n            } finally {\n              f = null;\n            }\n          }\n        }\n      }\n\n    } finally {\n      if (markedHeld && !lockExists()) {\n        synchronized(LOCK_HELD) {\n          if (LOCK_HELD.contains(canonicalPath)) {\n            LOCK_HELD.remove(canonicalPath);\n          }\n        }\n      }\n    }\n    return lockExists();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"50805be75df24f05d29a4d2a496c7ec825cde9eb","date":1398078566,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#obtain().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#obtain().mjava","sourceNew":"  @Override\n  public synchronized boolean obtain() throws IOException {\n\n    if (lockExists()) {\n      // Our instance is already locked:\n      return false;\n    }\n\n    // Ensure that lockDir exists and is a directory.\n    if (!lockDir.exists()) {\n      if (!lockDir.mkdirs())\n        throw new IOException(\"Cannot create directory: \" +\n            lockDir.getAbsolutePath());\n    } else if (!lockDir.isDirectory()) {\n      // TODO: NoSuchDirectoryException instead?\n      throw new IOException(\"Found regular file where directory expected: \" + \n          lockDir.getAbsolutePath());\n    }\n    \n    channel = FileChannel.open(path.toPath(), StandardOpenOption.CREATE, StandardOpenOption.WRITE);\n    boolean success = false;\n    try {\n      lock = channel.tryLock();\n      success = true;\n    } catch (IOException | OverlappingFileLockException e) {\n      // At least on OS X, we will sometimes get an\n      // intermittent \"Permission Denied\" IOException,\n      // which seems to simply mean \"you failed to get\n      // the lock\".  But other IOExceptions could be\n      // \"permanent\" (eg, locking is not supported via\n      // the filesystem).  So, we record the failure\n      // reason here; the timeout obtain (usually the\n      // one calling us) will use this as \"root cause\"\n      // if it fails to get the lock.\n      failureReason = e;\n    } finally {\n      if (!success) {\n        try {\n          IOUtils.closeWhileHandlingException(channel);\n        } finally {\n          channel = null;\n        }\n      }\n    }\n    return lockExists();\n  }\n\n","sourceOld":"  @Override\n  public synchronized boolean obtain() throws IOException {\n\n    if (lockExists()) {\n      // Our instance is already locked:\n      return false;\n    }\n\n    // Ensure that lockDir exists and is a directory.\n    if (!lockDir.exists()) {\n      if (!lockDir.mkdirs())\n        throw new IOException(\"Cannot create directory: \" +\n                              lockDir.getAbsolutePath());\n    } else if (!lockDir.isDirectory()) {\n      // TODO: NoSuchDirectoryException instead?\n      throw new IOException(\"Found regular file where directory expected: \" + \n                            lockDir.getAbsolutePath());\n    }\n\n    String canonicalPath = path.getCanonicalPath();\n\n    boolean markedHeld = false;\n\n    try {\n\n      // Make sure nobody else in-process has this lock held\n      // already, and, mark it held if not:\n\n      synchronized(LOCK_HELD) {\n        if (LOCK_HELD.contains(canonicalPath)) {\n          // Someone else in this JVM already has the lock:\n          return false;\n        } else {\n          // This \"reserves\" the fact that we are the one\n          // thread trying to obtain this lock, so we own\n          // the only instance of a channel against this\n          // file:\n          LOCK_HELD.add(canonicalPath);\n          markedHeld = true;\n        }\n      }\n\n      try {\n        f = new RandomAccessFile(path, \"rw\");\n      } catch (IOException e) {\n        // On Windows, we can get intermittent \"Access\n        // Denied\" here.  So, we treat this as failure to\n        // acquire the lock, but, store the reason in case\n        // there is in fact a real error case.\n        failureReason = e;\n        f = null;\n      }\n\n      if (f != null) {\n        try {\n          channel = f.getChannel();\n          try {\n            lock = channel.tryLock();\n          } catch (IOException e) {\n            // At least on OS X, we will sometimes get an\n            // intermittent \"Permission Denied\" IOException,\n            // which seems to simply mean \"you failed to get\n            // the lock\".  But other IOExceptions could be\n            // \"permanent\" (eg, locking is not supported via\n            // the filesystem).  So, we record the failure\n            // reason here; the timeout obtain (usually the\n            // one calling us) will use this as \"root cause\"\n            // if it fails to get the lock.\n            failureReason = e;\n          } finally {\n            if (lock == null) {\n              try {\n                channel.close();\n              } finally {\n                channel = null;\n              }\n            }\n          }\n        } finally {\n          if (channel == null) {\n            try {\n              f.close();\n            } finally {\n              f = null;\n            }\n          }\n        }\n      }\n\n    } finally {\n      if (markedHeld && !lockExists()) {\n        synchronized(LOCK_HELD) {\n          if (LOCK_HELD.contains(canonicalPath)) {\n            LOCK_HELD.remove(canonicalPath);\n          }\n        }\n      }\n    }\n    return lockExists();\n  }\n\n","bugFix":null,"bugIntro":["ac6772b4ba3c5fe1e4aae992238c5f7cdce74f0b","8fa71d5bc6be53f5f21420ccbcaecad4dd879728"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ac6772b4ba3c5fe1e4aae992238c5f7cdce74f0b","date":1398175632,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#obtain().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#obtain().mjava","sourceNew":"  @Override\n  public synchronized boolean obtain() throws IOException {\n\n    if (lock != null) {\n      // Our instance is already locked:\n      return false;\n    }\n\n    // Ensure that lockDir exists and is a directory.\n    if (!lockDir.exists()) {\n      if (!lockDir.mkdirs())\n        throw new IOException(\"Cannot create directory: \" +\n            lockDir.getAbsolutePath());\n    } else if (!lockDir.isDirectory()) {\n      // TODO: NoSuchDirectoryException instead?\n      throw new IOException(\"Found regular file where directory expected: \" + \n          lockDir.getAbsolutePath());\n    }\n    \n    channel = FileChannel.open(path.toPath(), StandardOpenOption.CREATE, StandardOpenOption.WRITE);\n    boolean success = false;\n    try {\n      lock = channel.tryLock();\n      success = lock != null;\n    } catch (IOException | OverlappingFileLockException e) {\n      // At least on OS X, we will sometimes get an\n      // intermittent \"Permission Denied\" IOException,\n      // which seems to simply mean \"you failed to get\n      // the lock\".  But other IOExceptions could be\n      // \"permanent\" (eg, locking is not supported via\n      // the filesystem).  So, we record the failure\n      // reason here; the timeout obtain (usually the\n      // one calling us) will use this as \"root cause\"\n      // if it fails to get the lock.\n      failureReason = e;\n    } finally {\n      if (!success) {\n        try {\n          IOUtils.closeWhileHandlingException(channel);\n        } finally {\n          channel = null;\n        }\n      }\n    }\n    return lock != null;\n  }\n\n","sourceOld":"  @Override\n  public synchronized boolean obtain() throws IOException {\n\n    if (lockExists()) {\n      // Our instance is already locked:\n      return false;\n    }\n\n    // Ensure that lockDir exists and is a directory.\n    if (!lockDir.exists()) {\n      if (!lockDir.mkdirs())\n        throw new IOException(\"Cannot create directory: \" +\n            lockDir.getAbsolutePath());\n    } else if (!lockDir.isDirectory()) {\n      // TODO: NoSuchDirectoryException instead?\n      throw new IOException(\"Found regular file where directory expected: \" + \n          lockDir.getAbsolutePath());\n    }\n    \n    channel = FileChannel.open(path.toPath(), StandardOpenOption.CREATE, StandardOpenOption.WRITE);\n    boolean success = false;\n    try {\n      lock = channel.tryLock();\n      success = true;\n    } catch (IOException | OverlappingFileLockException e) {\n      // At least on OS X, we will sometimes get an\n      // intermittent \"Permission Denied\" IOException,\n      // which seems to simply mean \"you failed to get\n      // the lock\".  But other IOExceptions could be\n      // \"permanent\" (eg, locking is not supported via\n      // the filesystem).  So, we record the failure\n      // reason here; the timeout obtain (usually the\n      // one calling us) will use this as \"root cause\"\n      // if it fails to get the lock.\n      failureReason = e;\n    } finally {\n      if (!success) {\n        try {\n          IOUtils.closeWhileHandlingException(channel);\n        } finally {\n          channel = null;\n        }\n      }\n    }\n    return lockExists();\n  }\n\n","bugFix":["245fee3e499fae1fc0c33a80a6dd979f9c5f49e2","50805be75df24f05d29a4d2a496c7ec825cde9eb"],"bugIntro":["8fa71d5bc6be53f5f21420ccbcaecad4dd879728"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","date":1398844771,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#obtain().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#obtain().mjava","sourceNew":"  @Override\n  public synchronized boolean obtain() throws IOException {\n\n    if (lock != null) {\n      // Our instance is already locked:\n      return false;\n    }\n\n    // Ensure that lockDir exists and is a directory.\n    if (!lockDir.exists()) {\n      if (!lockDir.mkdirs())\n        throw new IOException(\"Cannot create directory: \" +\n            lockDir.getAbsolutePath());\n    } else if (!lockDir.isDirectory()) {\n      // TODO: NoSuchDirectoryException instead?\n      throw new IOException(\"Found regular file where directory expected: \" + \n          lockDir.getAbsolutePath());\n    }\n    \n    channel = FileChannel.open(path.toPath(), StandardOpenOption.CREATE, StandardOpenOption.WRITE);\n    boolean success = false;\n    try {\n      lock = channel.tryLock();\n      success = lock != null;\n    } catch (IOException | OverlappingFileLockException e) {\n      // At least on OS X, we will sometimes get an\n      // intermittent \"Permission Denied\" IOException,\n      // which seems to simply mean \"you failed to get\n      // the lock\".  But other IOExceptions could be\n      // \"permanent\" (eg, locking is not supported via\n      // the filesystem).  So, we record the failure\n      // reason here; the timeout obtain (usually the\n      // one calling us) will use this as \"root cause\"\n      // if it fails to get the lock.\n      failureReason = e;\n    } finally {\n      if (!success) {\n        try {\n          IOUtils.closeWhileHandlingException(channel);\n        } finally {\n          channel = null;\n        }\n      }\n    }\n    return lock != null;\n  }\n\n","sourceOld":"  @Override\n  public synchronized boolean obtain() throws IOException {\n\n    if (lockExists()) {\n      // Our instance is already locked:\n      return false;\n    }\n\n    // Ensure that lockDir exists and is a directory.\n    if (!lockDir.exists()) {\n      if (!lockDir.mkdirs())\n        throw new IOException(\"Cannot create directory: \" +\n            lockDir.getAbsolutePath());\n    } else if (!lockDir.isDirectory()) {\n      // TODO: NoSuchDirectoryException instead?\n      throw new IOException(\"Found regular file where directory expected: \" + \n          lockDir.getAbsolutePath());\n    }\n    \n    channel = FileChannel.open(path.toPath(), StandardOpenOption.CREATE, StandardOpenOption.WRITE);\n    boolean success = false;\n    try {\n      lock = channel.tryLock();\n      success = true;\n    } catch (IOException | OverlappingFileLockException e) {\n      // At least on OS X, we will sometimes get an\n      // intermittent \"Permission Denied\" IOException,\n      // which seems to simply mean \"you failed to get\n      // the lock\".  But other IOExceptions could be\n      // \"permanent\" (eg, locking is not supported via\n      // the filesystem).  So, we record the failure\n      // reason here; the timeout obtain (usually the\n      // one calling us) will use this as \"root cause\"\n      // if it fails to get the lock.\n      failureReason = e;\n    } finally {\n      if (!success) {\n        try {\n          IOUtils.closeWhileHandlingException(channel);\n        } finally {\n          channel = null;\n        }\n      }\n    }\n    return lockExists();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8fa71d5bc6be53f5f21420ccbcaecad4dd879728","date":1402044934,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#obtain().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#obtain().mjava","sourceNew":"  @Override\n  public synchronized boolean obtain() throws IOException {\n\n    if (lock != null) {\n      // Our instance is already locked:\n      return false;\n    }\n\n    // Ensure that lockDir exists and is a directory.\n    if (!lockDir.exists()) {\n      if (!lockDir.mkdirs())\n        throw new IOException(\"Cannot create directory: \" +\n            lockDir.getAbsolutePath());\n    } else if (!lockDir.isDirectory()) {\n      // TODO: NoSuchDirectoryException instead?\n      throw new IOException(\"Found regular file where directory expected: \" + \n          lockDir.getAbsolutePath());\n    }\n    final String canonicalPath = path.getCanonicalPath();\n    // Make sure nobody else in-process has this lock held\n    // already, and, mark it held if not:\n    // This is a pretty crazy workaround for some documented\n    // but yet awkward JVM behavior:\n    //\n    //   On some systems, closing a channel releases all locks held by the Java virtual machine on the underlying file\n    //   regardless of whether the locks were acquired via that channel or via another channel open on the same file.\n    //   It is strongly recommended that, within a program, a unique channel be used to acquire all locks on any given\n    //   file.\n    //\n    // This essentially means if we close \"A\" channel for a given file all locks might be released... the odd part\n    // is that we can't re-obtain the lock in the same JVM but from a different process if that happens. Nevertheless\n    // this is super trappy. See LUCENE-5738\n    boolean obtained = false;\n    if (LOCK_HELD.add(canonicalPath)) {\n      try {\n        channel = FileChannel.open(path.toPath(), StandardOpenOption.CREATE, StandardOpenOption.WRITE);\n        try {\n          lock = channel.tryLock();\n          obtained = lock != null;\n        } catch (IOException | OverlappingFileLockException e) {\n          // At least on OS X, we will sometimes get an\n          // intermittent \"Permission Denied\" IOException,\n          // which seems to simply mean \"you failed to get\n          // the lock\".  But other IOExceptions could be\n          // \"permanent\" (eg, locking is not supported via\n          // the filesystem).  So, we record the failure\n          // reason here; the timeout obtain (usually the\n          // one calling us) will use this as \"root cause\"\n          // if it fails to get the lock.\n          failureReason = e;\n        }\n      } finally {\n        if (obtained == false) { // not successful - clear up and move out\n          clearLockHeld(path);\n          final FileChannel toClose = channel;\n          channel = null;\n          IOUtils.closeWhileHandlingException(toClose);\n        }\n      }\n    }\n    return obtained;\n  }\n\n","sourceOld":"  @Override\n  public synchronized boolean obtain() throws IOException {\n\n    if (lock != null) {\n      // Our instance is already locked:\n      return false;\n    }\n\n    // Ensure that lockDir exists and is a directory.\n    if (!lockDir.exists()) {\n      if (!lockDir.mkdirs())\n        throw new IOException(\"Cannot create directory: \" +\n            lockDir.getAbsolutePath());\n    } else if (!lockDir.isDirectory()) {\n      // TODO: NoSuchDirectoryException instead?\n      throw new IOException(\"Found regular file where directory expected: \" + \n          lockDir.getAbsolutePath());\n    }\n    \n    channel = FileChannel.open(path.toPath(), StandardOpenOption.CREATE, StandardOpenOption.WRITE);\n    boolean success = false;\n    try {\n      lock = channel.tryLock();\n      success = lock != null;\n    } catch (IOException | OverlappingFileLockException e) {\n      // At least on OS X, we will sometimes get an\n      // intermittent \"Permission Denied\" IOException,\n      // which seems to simply mean \"you failed to get\n      // the lock\".  But other IOExceptions could be\n      // \"permanent\" (eg, locking is not supported via\n      // the filesystem).  So, we record the failure\n      // reason here; the timeout obtain (usually the\n      // one calling us) will use this as \"root cause\"\n      // if it fails to get the lock.\n      failureReason = e;\n    } finally {\n      if (!success) {\n        try {\n          IOUtils.closeWhileHandlingException(channel);\n        } finally {\n          channel = null;\n        }\n      }\n    }\n    return lock != null;\n  }\n\n","bugFix":["50805be75df24f05d29a4d2a496c7ec825cde9eb","f118a5ec962b5e2658d313e6f4e6f28faa3bcb39","ac6772b4ba3c5fe1e4aae992238c5f7cdce74f0b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4abec28b874149a7223e32cc7a01704c27790de","date":1410644789,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#obtain().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#obtain().mjava","sourceNew":"  @Override\n  public synchronized boolean obtain() throws IOException {\n\n    if (lock != null) {\n      // Our instance is already locked:\n      return false;\n    }\n\n    // Ensure that lockDir exists and is a directory.\n    Files.createDirectories(lockDir);\n    try {\n      Files.createFile(path);\n    } catch (IOException ignore) {\n      // we must create the file to have a truly canonical path.\n      // if its already created, we don't care. if it cant be created, it will fail below.\n    }\n    final Path canonicalPath = path.toRealPath();\n    // Make sure nobody else in-process has this lock held\n    // already, and, mark it held if not:\n    // This is a pretty crazy workaround for some documented\n    // but yet awkward JVM behavior:\n    //\n    //   On some systems, closing a channel releases all locks held by the Java virtual machine on the underlying file\n    //   regardless of whether the locks were acquired via that channel or via another channel open on the same file.\n    //   It is strongly recommended that, within a program, a unique channel be used to acquire all locks on any given\n    //   file.\n    //\n    // This essentially means if we close \"A\" channel for a given file all locks might be released... the odd part\n    // is that we can't re-obtain the lock in the same JVM but from a different process if that happens. Nevertheless\n    // this is super trappy. See LUCENE-5738\n    boolean obtained = false;\n    if (LOCK_HELD.add(canonicalPath.toString())) {\n      try {\n        channel = FileChannel.open(path, StandardOpenOption.CREATE, StandardOpenOption.WRITE);\n        try {\n          lock = channel.tryLock();\n          obtained = lock != null;\n        } catch (IOException | OverlappingFileLockException e) {\n          // At least on OS X, we will sometimes get an\n          // intermittent \"Permission Denied\" IOException,\n          // which seems to simply mean \"you failed to get\n          // the lock\".  But other IOExceptions could be\n          // \"permanent\" (eg, locking is not supported via\n          // the filesystem).  So, we record the failure\n          // reason here; the timeout obtain (usually the\n          // one calling us) will use this as \"root cause\"\n          // if it fails to get the lock.\n          failureReason = e;\n        }\n      } finally {\n        if (obtained == false) { // not successful - clear up and move out\n          clearLockHeld(path);\n          final FileChannel toClose = channel;\n          channel = null;\n          IOUtils.closeWhileHandlingException(toClose);\n        }\n      }\n    }\n    return obtained;\n  }\n\n","sourceOld":"  @Override\n  public synchronized boolean obtain() throws IOException {\n\n    if (lock != null) {\n      // Our instance is already locked:\n      return false;\n    }\n\n    // Ensure that lockDir exists and is a directory.\n    if (!lockDir.exists()) {\n      if (!lockDir.mkdirs())\n        throw new IOException(\"Cannot create directory: \" +\n            lockDir.getAbsolutePath());\n    } else if (!lockDir.isDirectory()) {\n      // TODO: NoSuchDirectoryException instead?\n      throw new IOException(\"Found regular file where directory expected: \" + \n          lockDir.getAbsolutePath());\n    }\n    final String canonicalPath = path.getCanonicalPath();\n    // Make sure nobody else in-process has this lock held\n    // already, and, mark it held if not:\n    // This is a pretty crazy workaround for some documented\n    // but yet awkward JVM behavior:\n    //\n    //   On some systems, closing a channel releases all locks held by the Java virtual machine on the underlying file\n    //   regardless of whether the locks were acquired via that channel or via another channel open on the same file.\n    //   It is strongly recommended that, within a program, a unique channel be used to acquire all locks on any given\n    //   file.\n    //\n    // This essentially means if we close \"A\" channel for a given file all locks might be released... the odd part\n    // is that we can't re-obtain the lock in the same JVM but from a different process if that happens. Nevertheless\n    // this is super trappy. See LUCENE-5738\n    boolean obtained = false;\n    if (LOCK_HELD.add(canonicalPath)) {\n      try {\n        channel = FileChannel.open(path.toPath(), StandardOpenOption.CREATE, StandardOpenOption.WRITE);\n        try {\n          lock = channel.tryLock();\n          obtained = lock != null;\n        } catch (IOException | OverlappingFileLockException e) {\n          // At least on OS X, we will sometimes get an\n          // intermittent \"Permission Denied\" IOException,\n          // which seems to simply mean \"you failed to get\n          // the lock\".  But other IOExceptions could be\n          // \"permanent\" (eg, locking is not supported via\n          // the filesystem).  So, we record the failure\n          // reason here; the timeout obtain (usually the\n          // one calling us) will use this as \"root cause\"\n          // if it fails to get the lock.\n          failureReason = e;\n        }\n      } finally {\n        if (obtained == false) { // not successful - clear up and move out\n          clearLockHeld(path);\n          final FileChannel toClose = channel;\n          channel = null;\n          IOUtils.closeWhileHandlingException(toClose);\n        }\n      }\n    }\n    return obtained;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"285cdc737de75b7cc7c284a156b20214deb67bca","date":1415535483,"type":4,"author":"Uwe Schindler","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/store/NativeFSLock[NativeFSLockFactory]#obtain().mjava","sourceNew":null,"sourceOld":"  @Override\n  public synchronized boolean obtain() throws IOException {\n\n    if (lock != null) {\n      // Our instance is already locked:\n      return false;\n    }\n\n    // Ensure that lockDir exists and is a directory.\n    Files.createDirectories(lockDir);\n    try {\n      Files.createFile(path);\n    } catch (IOException ignore) {\n      // we must create the file to have a truly canonical path.\n      // if its already created, we don't care. if it cant be created, it will fail below.\n    }\n    final Path canonicalPath = path.toRealPath();\n    // Make sure nobody else in-process has this lock held\n    // already, and, mark it held if not:\n    // This is a pretty crazy workaround for some documented\n    // but yet awkward JVM behavior:\n    //\n    //   On some systems, closing a channel releases all locks held by the Java virtual machine on the underlying file\n    //   regardless of whether the locks were acquired via that channel or via another channel open on the same file.\n    //   It is strongly recommended that, within a program, a unique channel be used to acquire all locks on any given\n    //   file.\n    //\n    // This essentially means if we close \"A\" channel for a given file all locks might be released... the odd part\n    // is that we can't re-obtain the lock in the same JVM but from a different process if that happens. Nevertheless\n    // this is super trappy. See LUCENE-5738\n    boolean obtained = false;\n    if (LOCK_HELD.add(canonicalPath.toString())) {\n      try {\n        channel = FileChannel.open(path, StandardOpenOption.CREATE, StandardOpenOption.WRITE);\n        try {\n          lock = channel.tryLock();\n          obtained = lock != null;\n        } catch (IOException | OverlappingFileLockException e) {\n          // At least on OS X, we will sometimes get an\n          // intermittent \"Permission Denied\" IOException,\n          // which seems to simply mean \"you failed to get\n          // the lock\".  But other IOExceptions could be\n          // \"permanent\" (eg, locking is not supported via\n          // the filesystem).  So, we record the failure\n          // reason here; the timeout obtain (usually the\n          // one calling us) will use this as \"root cause\"\n          // if it fails to get the lock.\n          failureReason = e;\n        }\n      } finally {\n        if (obtained == false) { // not successful - clear up and move out\n          clearLockHeld(path);\n          final FileChannel toClose = channel;\n          channel = null;\n          IOUtils.closeWhileHandlingException(toClose);\n        }\n      }\n    }\n    return obtained;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"38e3b736c7ca086d61b7dbb841c905ee115490da":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","0451c421afa567194fd4312af9389e07003a7941"],"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":["50805be75df24f05d29a4d2a496c7ec825cde9eb","ac6772b4ba3c5fe1e4aae992238c5f7cdce74f0b"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"285cdc737de75b7cc7c284a156b20214deb67bca":["f4abec28b874149a7223e32cc7a01704c27790de"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["0451c421afa567194fd4312af9389e07003a7941"],"f4abec28b874149a7223e32cc7a01704c27790de":["8fa71d5bc6be53f5f21420ccbcaecad4dd879728"],"ac6772b4ba3c5fe1e4aae992238c5f7cdce74f0b":["50805be75df24f05d29a4d2a496c7ec825cde9eb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["0451c421afa567194fd4312af9389e07003a7941"],"50805be75df24f05d29a4d2a496c7ec825cde9eb":["19275ba31e621f6da1b83bf13af75233876fd3d4"],"0451c421afa567194fd4312af9389e07003a7941":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["285cdc737de75b7cc7c284a156b20214deb67bca"],"8fa71d5bc6be53f5f21420ccbcaecad4dd879728":["ac6772b4ba3c5fe1e4aae992238c5f7cdce74f0b"]},"commit2Childs":{"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["38e3b736c7ca086d61b7dbb841c905ee115490da","0451c421afa567194fd4312af9389e07003a7941"],"285cdc737de75b7cc7c284a156b20214deb67bca":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["50805be75df24f05d29a4d2a496c7ec825cde9eb"],"f4abec28b874149a7223e32cc7a01704c27790de":["285cdc737de75b7cc7c284a156b20214deb67bca"],"ac6772b4ba3c5fe1e4aae992238c5f7cdce74f0b":["c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","8fa71d5bc6be53f5f21420ccbcaecad4dd879728"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"50805be75df24f05d29a4d2a496c7ec825cde9eb":["c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","ac6772b4ba3c5fe1e4aae992238c5f7cdce74f0b"],"0451c421afa567194fd4312af9389e07003a7941":["38e3b736c7ca086d61b7dbb841c905ee115490da","19275ba31e621f6da1b83bf13af75233876fd3d4","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee"],"8fa71d5bc6be53f5f21420ccbcaecad4dd879728":["f4abec28b874149a7223e32cc7a01704c27790de"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["38e3b736c7ca086d61b7dbb841c905ee115490da","c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}