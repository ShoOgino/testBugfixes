{"path":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#run().mjava","commits":[{"id":"c2045b132a2396bb23dff28d2d9f349a6907d36e","date":1367513076,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#run().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void run() {\n    // TODO: maybe use private thread ticktock timer, in\n    // case clock shift messes up nanoTime?\n    long lastReopenStartNS = System.nanoTime();\n\n    //System.out.println(\"reopen: start\");\n    while (!finish) {\n\n      // TODO: try to guestimate how long reopen might\n      // take based on past data?\n\n      // Loop until we've waiting long enough before the\n      // next reopen:\n      while (!finish) {\n\n        // True if we have someone waiting for reopened searcher:\n        boolean hasWaiting = waitingGen > searchingGen;\n        final long nextReopenStartNS = lastReopenStartNS + (hasWaiting ? targetMinStaleNS : targetMaxStaleNS);\n\n        final long sleepNS = nextReopenStartNS - System.nanoTime();\n\n        if (sleepNS > 0) {\n          reopenLock.lock();\n          try {\n            reopenCond.awaitNanos(sleepNS);\n          } catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n            return;\n          } finally {\n            reopenLock.unlock();\n          }\n        } else {\n          break;\n        }\n      }\n\n      if (finish) {\n        break;\n      }\n\n      lastReopenStartNS = System.nanoTime();\n      // Save the gen as of when we started the reopen; the\n      // listener (HandleRefresh above) copies this to\n      // searchingGen once the reopen completes:\n      refreshStartGen = writer.getAndIncrementGeneration();\n      try {\n        manager.maybeRefreshBlocking();\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["a9b907a7568aa04bcad16628b3ede514dd0266ab"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a9b907a7568aa04bcad16628b3ede514dd0266ab","date":1392986355,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#run().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#run().mjava","sourceNew":"  @Override\n  public void run() {\n    // TODO: maybe use private thread ticktock timer, in\n    // case clock shift messes up nanoTime?\n    long lastReopenStartNS = System.nanoTime();\n\n    //System.out.println(\"reopen: start\");\n    while (!finish) {\n\n      // TODO: try to guestimate how long reopen might\n      // take based on past data?\n\n      // Loop until we've waiting long enough before the\n      // next reopen:\n      while (!finish) {\n\n        // Need lock before finding out if has waiting\n        reopenLock.lock();\n        try {\n          // True if we have someone waiting for reopened searcher:\n          boolean hasWaiting = waitingGen > searchingGen;\n          final long nextReopenStartNS = lastReopenStartNS + (hasWaiting ? targetMinStaleNS : targetMaxStaleNS);\n\n          final long sleepNS = nextReopenStartNS - System.nanoTime();\n\n          if (sleepNS > 0) {\n            reopenCond.awaitNanos(sleepNS);\n          } else {\n            break;\n          }\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n          return;\n        } finally {\n          reopenLock.unlock();\n        }\n      }\n\n      if (finish) {\n        break;\n      }\n\n      lastReopenStartNS = System.nanoTime();\n      // Save the gen as of when we started the reopen; the\n      // listener (HandleRefresh above) copies this to\n      // searchingGen once the reopen completes:\n      refreshStartGen = writer.getAndIncrementGeneration();\n      try {\n        manager.maybeRefreshBlocking();\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    // TODO: maybe use private thread ticktock timer, in\n    // case clock shift messes up nanoTime?\n    long lastReopenStartNS = System.nanoTime();\n\n    //System.out.println(\"reopen: start\");\n    while (!finish) {\n\n      // TODO: try to guestimate how long reopen might\n      // take based on past data?\n\n      // Loop until we've waiting long enough before the\n      // next reopen:\n      while (!finish) {\n\n        // True if we have someone waiting for reopened searcher:\n        boolean hasWaiting = waitingGen > searchingGen;\n        final long nextReopenStartNS = lastReopenStartNS + (hasWaiting ? targetMinStaleNS : targetMaxStaleNS);\n\n        final long sleepNS = nextReopenStartNS - System.nanoTime();\n\n        if (sleepNS > 0) {\n          reopenLock.lock();\n          try {\n            reopenCond.awaitNanos(sleepNS);\n          } catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n            return;\n          } finally {\n            reopenLock.unlock();\n          }\n        } else {\n          break;\n        }\n      }\n\n      if (finish) {\n        break;\n      }\n\n      lastReopenStartNS = System.nanoTime();\n      // Save the gen as of when we started the reopen; the\n      // listener (HandleRefresh above) copies this to\n      // searchingGen once the reopen completes:\n      refreshStartGen = writer.getAndIncrementGeneration();\n      try {\n        manager.maybeRefreshBlocking();\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      }\n    }\n  }\n\n","bugFix":["c2045b132a2396bb23dff28d2d9f349a6907d36e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"427bf5b96e9aacef8f01879bc1b93c3619c43439","date":1464134313,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#run().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#run().mjava","sourceNew":"  @Override\n  public void run() {\n    // TODO: maybe use private thread ticktock timer, in\n    // case clock shift messes up nanoTime?\n    long lastReopenStartNS = System.nanoTime();\n\n    //System.out.println(\"reopen: start\");\n    while (!finish) {\n\n      // TODO: try to guestimate how long reopen might\n      // take based on past data?\n\n      // Loop until we've waiting long enough before the\n      // next reopen:\n      while (!finish) {\n\n        // Need lock before finding out if has waiting\n        reopenLock.lock();\n        try {\n          // True if we have someone waiting for reopened searcher:\n          boolean hasWaiting = waitingGen > searchingGen;\n          final long nextReopenStartNS = lastReopenStartNS + (hasWaiting ? targetMinStaleNS : targetMaxStaleNS);\n\n          final long sleepNS = nextReopenStartNS - System.nanoTime();\n\n          if (sleepNS > 0) {\n            reopenCond.awaitNanos(sleepNS);\n          } else {\n            break;\n          }\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n          return;\n        } finally {\n          reopenLock.unlock();\n        }\n      }\n\n      if (finish) {\n        break;\n      }\n\n      lastReopenStartNS = System.nanoTime();\n      // Save the gen as of when we started the reopen; the\n      // listener (HandleRefresh above) copies this to\n      // searchingGen once the reopen completes:\n      refreshStartGen = writer.getLastSequenceNumber();\n      try {\n        manager.maybeRefreshBlocking();\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    // TODO: maybe use private thread ticktock timer, in\n    // case clock shift messes up nanoTime?\n    long lastReopenStartNS = System.nanoTime();\n\n    //System.out.println(\"reopen: start\");\n    while (!finish) {\n\n      // TODO: try to guestimate how long reopen might\n      // take based on past data?\n\n      // Loop until we've waiting long enough before the\n      // next reopen:\n      while (!finish) {\n\n        // Need lock before finding out if has waiting\n        reopenLock.lock();\n        try {\n          // True if we have someone waiting for reopened searcher:\n          boolean hasWaiting = waitingGen > searchingGen;\n          final long nextReopenStartNS = lastReopenStartNS + (hasWaiting ? targetMinStaleNS : targetMaxStaleNS);\n\n          final long sleepNS = nextReopenStartNS - System.nanoTime();\n\n          if (sleepNS > 0) {\n            reopenCond.awaitNanos(sleepNS);\n          } else {\n            break;\n          }\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n          return;\n        } finally {\n          reopenLock.unlock();\n        }\n      }\n\n      if (finish) {\n        break;\n      }\n\n      lastReopenStartNS = System.nanoTime();\n      // Save the gen as of when we started the reopen; the\n      // listener (HandleRefresh above) copies this to\n      // searchingGen once the reopen completes:\n      refreshStartGen = writer.getAndIncrementGeneration();\n      try {\n        manager.maybeRefreshBlocking();\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6483e4260c08168709c02238ae083a51519a28dd","date":1465117546,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#run().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#run().mjava","sourceNew":"  @Override\n  public void run() {\n    // TODO: maybe use private thread ticktock timer, in\n    // case clock shift messes up nanoTime?\n    long lastReopenStartNS = System.nanoTime();\n\n    //System.out.println(\"reopen: start\");\n    while (!finish) {\n\n      // TODO: try to guestimate how long reopen might\n      // take based on past data?\n\n      // Loop until we've waiting long enough before the\n      // next reopen:\n      while (!finish) {\n\n        // Need lock before finding out if has waiting\n        reopenLock.lock();\n        try {\n          // True if we have someone waiting for reopened searcher:\n          boolean hasWaiting = waitingGen > searchingGen;\n          final long nextReopenStartNS = lastReopenStartNS + (hasWaiting ? targetMinStaleNS : targetMaxStaleNS);\n\n          final long sleepNS = nextReopenStartNS - System.nanoTime();\n\n          if (sleepNS > 0) {\n            reopenCond.awaitNanos(sleepNS);\n          } else {\n            break;\n          }\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n          return;\n        } finally {\n          reopenLock.unlock();\n        }\n      }\n\n      if (finish) {\n        break;\n      }\n\n      lastReopenStartNS = System.nanoTime();\n      // Save the gen as of when we started the reopen; the\n      // listener (HandleRefresh above) copies this to\n      // searchingGen once the reopen completes:\n      refreshStartGen = writer.getLastSequenceNumber();\n      try {\n        manager.maybeRefreshBlocking();\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    // TODO: maybe use private thread ticktock timer, in\n    // case clock shift messes up nanoTime?\n    long lastReopenStartNS = System.nanoTime();\n\n    //System.out.println(\"reopen: start\");\n    while (!finish) {\n\n      // TODO: try to guestimate how long reopen might\n      // take based on past data?\n\n      // Loop until we've waiting long enough before the\n      // next reopen:\n      while (!finish) {\n\n        // Need lock before finding out if has waiting\n        reopenLock.lock();\n        try {\n          // True if we have someone waiting for reopened searcher:\n          boolean hasWaiting = waitingGen > searchingGen;\n          final long nextReopenStartNS = lastReopenStartNS + (hasWaiting ? targetMinStaleNS : targetMaxStaleNS);\n\n          final long sleepNS = nextReopenStartNS - System.nanoTime();\n\n          if (sleepNS > 0) {\n            reopenCond.awaitNanos(sleepNS);\n          } else {\n            break;\n          }\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n          return;\n        } finally {\n          reopenLock.unlock();\n        }\n      }\n\n      if (finish) {\n        break;\n      }\n\n      lastReopenStartNS = System.nanoTime();\n      // Save the gen as of when we started the reopen; the\n      // listener (HandleRefresh above) copies this to\n      // searchingGen once the reopen completes:\n      refreshStartGen = writer.getAndIncrementGeneration();\n      try {\n        manager.maybeRefreshBlocking();\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"191128ac5b85671b1671e2c857437694283b6ebf","date":1465297861,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#run().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#run().mjava","sourceNew":"  @Override\n  public void run() {\n    // TODO: maybe use private thread ticktock timer, in\n    // case clock shift messes up nanoTime?\n    long lastReopenStartNS = System.nanoTime();\n\n    //System.out.println(\"reopen: start\");\n    while (!finish) {\n\n      // TODO: try to guestimate how long reopen might\n      // take based on past data?\n\n      // Loop until we've waiting long enough before the\n      // next reopen:\n      while (!finish) {\n\n        // Need lock before finding out if has waiting\n        reopenLock.lock();\n        try {\n          // True if we have someone waiting for reopened searcher:\n          boolean hasWaiting = waitingGen > searchingGen;\n          final long nextReopenStartNS = lastReopenStartNS + (hasWaiting ? targetMinStaleNS : targetMaxStaleNS);\n\n          final long sleepNS = nextReopenStartNS - System.nanoTime();\n\n          if (sleepNS > 0) {\n            reopenCond.awaitNanos(sleepNS);\n          } else {\n            break;\n          }\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n          return;\n        } finally {\n          reopenLock.unlock();\n        }\n      }\n\n      if (finish) {\n        break;\n      }\n\n      lastReopenStartNS = System.nanoTime();\n      // Save the gen as of when we started the reopen; the\n      // listener (HandleRefresh above) copies this to\n      // searchingGen once the reopen completes:\n      refreshStartGen = writer.getLastSequenceNumber();\n      try {\n        manager.maybeRefreshBlocking();\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    // TODO: maybe use private thread ticktock timer, in\n    // case clock shift messes up nanoTime?\n    long lastReopenStartNS = System.nanoTime();\n\n    //System.out.println(\"reopen: start\");\n    while (!finish) {\n\n      // TODO: try to guestimate how long reopen might\n      // take based on past data?\n\n      // Loop until we've waiting long enough before the\n      // next reopen:\n      while (!finish) {\n\n        // Need lock before finding out if has waiting\n        reopenLock.lock();\n        try {\n          // True if we have someone waiting for reopened searcher:\n          boolean hasWaiting = waitingGen > searchingGen;\n          final long nextReopenStartNS = lastReopenStartNS + (hasWaiting ? targetMinStaleNS : targetMaxStaleNS);\n\n          final long sleepNS = nextReopenStartNS - System.nanoTime();\n\n          if (sleepNS > 0) {\n            reopenCond.awaitNanos(sleepNS);\n          } else {\n            break;\n          }\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n          return;\n        } finally {\n          reopenLock.unlock();\n        }\n      }\n\n      if (finish) {\n        break;\n      }\n\n      lastReopenStartNS = System.nanoTime();\n      // Save the gen as of when we started the reopen; the\n      // listener (HandleRefresh above) copies this to\n      // searchingGen once the reopen completes:\n      refreshStartGen = writer.getAndIncrementGeneration();\n      try {\n        manager.maybeRefreshBlocking();\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"730b7b729dd280f1fec51e6b252f24c4de2a68e1","date":1465891767,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#run().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#run().mjava","sourceNew":"  @Override\n  public void run() {\n    // TODO: maybe use private thread ticktock timer, in\n    // case clock shift messes up nanoTime?\n    long lastReopenStartNS = System.nanoTime();\n\n    //System.out.println(\"reopen: start\");\n    while (!finish) {\n\n      // TODO: try to guestimate how long reopen might\n      // take based on past data?\n\n      // Loop until we've waiting long enough before the\n      // next reopen:\n      while (!finish) {\n\n        // Need lock before finding out if has waiting\n        reopenLock.lock();\n        try {\n          // True if we have someone waiting for reopened searcher:\n          boolean hasWaiting = waitingGen > searchingGen;\n          final long nextReopenStartNS = lastReopenStartNS + (hasWaiting ? targetMinStaleNS : targetMaxStaleNS);\n\n          final long sleepNS = nextReopenStartNS - System.nanoTime();\n\n          if (sleepNS > 0) {\n            reopenCond.awaitNanos(sleepNS);\n          } else {\n            break;\n          }\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n          return;\n        } finally {\n          reopenLock.unlock();\n        }\n      }\n\n      if (finish) {\n        break;\n      }\n\n      lastReopenStartNS = System.nanoTime();\n      // Save the gen as of when we started the reopen; the\n      // listener (HandleRefresh above) copies this to\n      // searchingGen once the reopen completes:\n      refreshStartGen = writer.getMaxCompletedSequenceNumber();\n      try {\n        manager.maybeRefreshBlocking();\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    // TODO: maybe use private thread ticktock timer, in\n    // case clock shift messes up nanoTime?\n    long lastReopenStartNS = System.nanoTime();\n\n    //System.out.println(\"reopen: start\");\n    while (!finish) {\n\n      // TODO: try to guestimate how long reopen might\n      // take based on past data?\n\n      // Loop until we've waiting long enough before the\n      // next reopen:\n      while (!finish) {\n\n        // Need lock before finding out if has waiting\n        reopenLock.lock();\n        try {\n          // True if we have someone waiting for reopened searcher:\n          boolean hasWaiting = waitingGen > searchingGen;\n          final long nextReopenStartNS = lastReopenStartNS + (hasWaiting ? targetMinStaleNS : targetMaxStaleNS);\n\n          final long sleepNS = nextReopenStartNS - System.nanoTime();\n\n          if (sleepNS > 0) {\n            reopenCond.awaitNanos(sleepNS);\n          } else {\n            break;\n          }\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n          return;\n        } finally {\n          reopenLock.unlock();\n        }\n      }\n\n      if (finish) {\n        break;\n      }\n\n      lastReopenStartNS = System.nanoTime();\n      // Save the gen as of when we started the reopen; the\n      // listener (HandleRefresh above) copies this to\n      // searchingGen once the reopen completes:\n      refreshStartGen = writer.getLastSequenceNumber();\n      try {\n        manager.maybeRefreshBlocking();\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57dc82c7b33cd580e7ab5179019bc78f3d7f8e79","date":1465913303,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#run().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#run().mjava","sourceNew":"  @Override\n  public void run() {\n    // TODO: maybe use private thread ticktock timer, in\n    // case clock shift messes up nanoTime?\n    long lastReopenStartNS = System.nanoTime();\n\n    //System.out.println(\"reopen: start\");\n    while (!finish) {\n\n      // TODO: try to guestimate how long reopen might\n      // take based on past data?\n\n      // Loop until we've waiting long enough before the\n      // next reopen:\n      while (!finish) {\n\n        // Need lock before finding out if has waiting\n        reopenLock.lock();\n        try {\n          // True if we have someone waiting for reopened searcher:\n          boolean hasWaiting = waitingGen > searchingGen;\n          final long nextReopenStartNS = lastReopenStartNS + (hasWaiting ? targetMinStaleNS : targetMaxStaleNS);\n\n          final long sleepNS = nextReopenStartNS - System.nanoTime();\n\n          if (sleepNS > 0) {\n            reopenCond.awaitNanos(sleepNS);\n          } else {\n            break;\n          }\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n          return;\n        } finally {\n          reopenLock.unlock();\n        }\n      }\n\n      if (finish) {\n        break;\n      }\n\n      lastReopenStartNS = System.nanoTime();\n      // Save the gen as of when we started the reopen; the\n      // listener (HandleRefresh above) copies this to\n      // searchingGen once the reopen completes:\n      refreshStartGen = writer.getMaxCompletedSequenceNumber();\n      try {\n        manager.maybeRefreshBlocking();\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    // TODO: maybe use private thread ticktock timer, in\n    // case clock shift messes up nanoTime?\n    long lastReopenStartNS = System.nanoTime();\n\n    //System.out.println(\"reopen: start\");\n    while (!finish) {\n\n      // TODO: try to guestimate how long reopen might\n      // take based on past data?\n\n      // Loop until we've waiting long enough before the\n      // next reopen:\n      while (!finish) {\n\n        // Need lock before finding out if has waiting\n        reopenLock.lock();\n        try {\n          // True if we have someone waiting for reopened searcher:\n          boolean hasWaiting = waitingGen > searchingGen;\n          final long nextReopenStartNS = lastReopenStartNS + (hasWaiting ? targetMinStaleNS : targetMaxStaleNS);\n\n          final long sleepNS = nextReopenStartNS - System.nanoTime();\n\n          if (sleepNS > 0) {\n            reopenCond.awaitNanos(sleepNS);\n          } else {\n            break;\n          }\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n          return;\n        } finally {\n          reopenLock.unlock();\n        }\n      }\n\n      if (finish) {\n        break;\n      }\n\n      lastReopenStartNS = System.nanoTime();\n      // Save the gen as of when we started the reopen; the\n      // listener (HandleRefresh above) copies this to\n      // searchingGen once the reopen completes:\n      refreshStartGen = writer.getLastSequenceNumber();\n      try {\n        manager.maybeRefreshBlocking();\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#run().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#run().mjava","sourceNew":"  @Override\n  public void run() {\n    // TODO: maybe use private thread ticktock timer, in\n    // case clock shift messes up nanoTime?\n    long lastReopenStartNS = System.nanoTime();\n\n    //System.out.println(\"reopen: start\");\n    while (!finish) {\n\n      // TODO: try to guestimate how long reopen might\n      // take based on past data?\n\n      // Loop until we've waiting long enough before the\n      // next reopen:\n      while (!finish) {\n\n        // Need lock before finding out if has waiting\n        reopenLock.lock();\n        try {\n          // True if we have someone waiting for reopened searcher:\n          boolean hasWaiting = waitingGen > searchingGen;\n          final long nextReopenStartNS = lastReopenStartNS + (hasWaiting ? targetMinStaleNS : targetMaxStaleNS);\n\n          final long sleepNS = nextReopenStartNS - System.nanoTime();\n\n          if (sleepNS > 0) {\n            reopenCond.awaitNanos(sleepNS);\n          } else {\n            break;\n          }\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n          return;\n        } finally {\n          reopenLock.unlock();\n        }\n      }\n\n      if (finish) {\n        break;\n      }\n\n      lastReopenStartNS = System.nanoTime();\n      // Save the gen as of when we started the reopen; the\n      // listener (HandleRefresh above) copies this to\n      // searchingGen once the reopen completes:\n      refreshStartGen = writer.getMaxCompletedSequenceNumber();\n      try {\n        manager.maybeRefreshBlocking();\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    // TODO: maybe use private thread ticktock timer, in\n    // case clock shift messes up nanoTime?\n    long lastReopenStartNS = System.nanoTime();\n\n    //System.out.println(\"reopen: start\");\n    while (!finish) {\n\n      // TODO: try to guestimate how long reopen might\n      // take based on past data?\n\n      // Loop until we've waiting long enough before the\n      // next reopen:\n      while (!finish) {\n\n        // Need lock before finding out if has waiting\n        reopenLock.lock();\n        try {\n          // True if we have someone waiting for reopened searcher:\n          boolean hasWaiting = waitingGen > searchingGen;\n          final long nextReopenStartNS = lastReopenStartNS + (hasWaiting ? targetMinStaleNS : targetMaxStaleNS);\n\n          final long sleepNS = nextReopenStartNS - System.nanoTime();\n\n          if (sleepNS > 0) {\n            reopenCond.awaitNanos(sleepNS);\n          } else {\n            break;\n          }\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n          return;\n        } finally {\n          reopenLock.unlock();\n        }\n      }\n\n      if (finish) {\n        break;\n      }\n\n      lastReopenStartNS = System.nanoTime();\n      // Save the gen as of when we started the reopen; the\n      // listener (HandleRefresh above) copies this to\n      // searchingGen once the reopen completes:\n      refreshStartGen = writer.getAndIncrementGeneration();\n      try {\n        manager.maybeRefreshBlocking();\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b07024a7318c25225dc4d070cf6d047315b73aaf","date":1586885963,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#run().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ControlledRealTimeReopenThread#run().mjava","sourceNew":"  @Override\n  public void run() {\n    // TODO: maybe use private thread ticktock timer, in\n    // case clock shift messes up nanoTime?\n    long lastReopenStartNS = System.nanoTime();\n\n    //System.out.println(\"reopen: start\");\n    while (!finish) {\n\n      // TODO: try to guestimate how long reopen might\n      // take based on past data?\n\n      // Loop until we've waiting long enough before the\n      // next reopen:\n      while (!finish) {\n\n        // Need lock before finding out if has waiting\n        reopenLock.lock();\n        try {\n          // True if we have someone waiting for reopened searcher:\n          boolean hasWaiting = waitingGen > searchingGen;\n          final long nextReopenStartNS = lastReopenStartNS + (hasWaiting ? targetMinStaleNS : targetMaxStaleNS);\n\n          final long sleepNS = nextReopenStartNS - System.nanoTime();\n\n          if (sleepNS > 0) {\n            reopenCond.awaitNanos(sleepNS);\n          } else {\n            break;\n          }\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n          return;\n        } finally {\n          reopenLock.unlock();\n        }\n      }\n\n      if (finish) {\n        break;\n      }\n\n      lastReopenStartNS = System.nanoTime();\n      try {\n        manager.maybeRefreshBlocking();\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    // TODO: maybe use private thread ticktock timer, in\n    // case clock shift messes up nanoTime?\n    long lastReopenStartNS = System.nanoTime();\n\n    //System.out.println(\"reopen: start\");\n    while (!finish) {\n\n      // TODO: try to guestimate how long reopen might\n      // take based on past data?\n\n      // Loop until we've waiting long enough before the\n      // next reopen:\n      while (!finish) {\n\n        // Need lock before finding out if has waiting\n        reopenLock.lock();\n        try {\n          // True if we have someone waiting for reopened searcher:\n          boolean hasWaiting = waitingGen > searchingGen;\n          final long nextReopenStartNS = lastReopenStartNS + (hasWaiting ? targetMinStaleNS : targetMaxStaleNS);\n\n          final long sleepNS = nextReopenStartNS - System.nanoTime();\n\n          if (sleepNS > 0) {\n            reopenCond.awaitNanos(sleepNS);\n          } else {\n            break;\n          }\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n          return;\n        } finally {\n          reopenLock.unlock();\n        }\n      }\n\n      if (finish) {\n        break;\n      }\n\n      lastReopenStartNS = System.nanoTime();\n      // Save the gen as of when we started the reopen; the\n      // listener (HandleRefresh above) copies this to\n      // searchingGen once the reopen completes:\n      refreshStartGen = writer.getMaxCompletedSequenceNumber();\n      try {\n        manager.maybeRefreshBlocking();\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b07024a7318c25225dc4d070cf6d047315b73aaf":["57dc82c7b33cd580e7ab5179019bc78f3d7f8e79"],"c2045b132a2396bb23dff28d2d9f349a6907d36e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a9b907a7568aa04bcad16628b3ede514dd0266ab":["c2045b132a2396bb23dff28d2d9f349a6907d36e"],"730b7b729dd280f1fec51e6b252f24c4de2a68e1":["191128ac5b85671b1671e2c857437694283b6ebf"],"6483e4260c08168709c02238ae083a51519a28dd":["a9b907a7568aa04bcad16628b3ede514dd0266ab","427bf5b96e9aacef8f01879bc1b93c3619c43439"],"191128ac5b85671b1671e2c857437694283b6ebf":["a9b907a7568aa04bcad16628b3ede514dd0266ab","6483e4260c08168709c02238ae083a51519a28dd"],"57dc82c7b33cd580e7ab5179019bc78f3d7f8e79":["191128ac5b85671b1671e2c857437694283b6ebf","730b7b729dd280f1fec51e6b252f24c4de2a68e1"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a9b907a7568aa04bcad16628b3ede514dd0266ab","57dc82c7b33cd580e7ab5179019bc78f3d7f8e79"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b07024a7318c25225dc4d070cf6d047315b73aaf"],"427bf5b96e9aacef8f01879bc1b93c3619c43439":["a9b907a7568aa04bcad16628b3ede514dd0266ab"]},"commit2Childs":{"b07024a7318c25225dc4d070cf6d047315b73aaf":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c2045b132a2396bb23dff28d2d9f349a6907d36e":["a9b907a7568aa04bcad16628b3ede514dd0266ab"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c2045b132a2396bb23dff28d2d9f349a6907d36e"],"a9b907a7568aa04bcad16628b3ede514dd0266ab":["6483e4260c08168709c02238ae083a51519a28dd","191128ac5b85671b1671e2c857437694283b6ebf","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","427bf5b96e9aacef8f01879bc1b93c3619c43439"],"730b7b729dd280f1fec51e6b252f24c4de2a68e1":["57dc82c7b33cd580e7ab5179019bc78f3d7f8e79"],"6483e4260c08168709c02238ae083a51519a28dd":["191128ac5b85671b1671e2c857437694283b6ebf"],"57dc82c7b33cd580e7ab5179019bc78f3d7f8e79":["b07024a7318c25225dc4d070cf6d047315b73aaf","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"191128ac5b85671b1671e2c857437694283b6ebf":["730b7b729dd280f1fec51e6b252f24c4de2a68e1","57dc82c7b33cd580e7ab5179019bc78f3d7f8e79"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"427bf5b96e9aacef8f01879bc1b93c3619c43439":["6483e4260c08168709c02238ae083a51519a28dd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}