{"path":"sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/FetcherTask#run(ServerThread).mjava","commits":[{"id":"05d36e0b328ec96237035fbcca240e73631396e5","date":1020520725,"type":0,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/FetcherTask#run(ServerThread).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * this will be called by the fetcher thread and will do all the work\n     *\n     * @TODO probably split this up into different processing steps\n     * @param thread  Description of the Parameter\n     */\n    public void run(ServerThread thread)\n    {\n\n        taskState.setState(FT_STARTED); // state information is always set to make the thread monitor happy\n\n        log = thread.getLog();\n        HostManager hm = ((FetcherThread)thread).getHostManager();\n\n        errorLog = thread.getErrorLog();\n\n        // startTime = System.currentTimeMillis();\n        int threadNr = ((FetcherThread) thread).getThreadNumber();\n\n        log.log(\"start\");\n        base = contextUrl = actURLMessage.getUrl();\n        String urlString = actURLMessage.getURLString();\n        String host = contextUrl.getHost();\n        int hostPos = urlString.indexOf(host);\n        int hostLen = host.length();\n\n        HostInfo hi = hm.getHostInfo(host); // get and create\n\n        if(!hi.isHealthy())\n        {\n            // we make this check as late as possible to get the most current information\n            log.log(\"Bad Host: \" + contextUrl + \"; returning\");\n            System.out.println(\"[\" + threadNr + \"] bad host: \" + this.actURLMessage.getUrl());\n\n            taskState.setState(FT_READY, null);\n            return;\n        }\n\n        foundUrls = new java.util.LinkedList();\n\n        HTTPConnection conn = null;\n\n        title = \"*untitled*\";\n\n        int size = 1;\n\n        InputStream in = null;\n        bytesRead = 0;\n\n\n        try\n        {\n\n            URL ipURL = contextUrl;\n\n            taskState.setState(FT_OPENCONNECTION, urlString);\n\n            log.log(\"connecting to \" + ipURL.getHost());\n            taskState.setState(FT_CONNECTING, ipURL);\n            conn = new HTTPConnection(host);\n\n            conn.setDefaultTimeout(75000);\n            // 75 s\n            conn.setDefaultAllowUserInteraction(false);\n\n            taskState.setState(this.FT_GETTING, ipURL);\n            log.log(\"getting\");\n\n            HTTPResponse response = conn.Get(ipURL.getFile(), \"\", headers);\n            response.setReadIncrement(2720);\n            int statusCode = response.getStatusCode();\n            byte[] fullBuffer = null;\n            String contentType = \"\";\n            int contentLength = 0;\n\n            if (statusCode != 404 && statusCode != 403)\n            {\n                // read up to Constants.FETCHERTASK_MAXFILESIZE bytes into a byte array\n                taskState.setState(FT_READING, ipURL);\n                contentType = response.getHeader(\"Content-Type\");\n                String length = response.getHeader(\"Content-Length\");\n                if (length != null)\n                {\n                    contentLength = Integer.parseInt(length);\n                }\n                log.log(\"reading\");\n\n                fullBuffer = response.getData(Constants.FETCHERTASK_MAXFILESIZE); // max. 2 MB\n                if (fullBuffer != null)\n                {\n                    contentLength = fullBuffer.length;\n                    this.bytesRead += contentLength;\n                }\n            }\n            //conn.stop();    // close connection. todo: Do some caching...\n\n\n            /*\n             *  conn.disconnect();\n             */\n            if (isInterrupted)\n            {\n                System.out.println(\"FetcherTask: interrupted while reading. File truncated\");\n                log.log(\"interrupted while reading. File truncated\");\n            }\n            else\n            {\n                if (fullBuffer != null)\n                {\n                    taskState.setState(FT_SCANNING, ipURL);\n\n                    log.log(\"read file (\" + fullBuffer.length + \" bytes). Now scanning.\");\n\n                    if (contentType.startsWith(\"text/html\"))\n                    {\n\n                        // ouch. I haven't found a better solution yet. just slower ones.\n                        char[] fullCharBuffer = new char[contentLength];\n                        new InputStreamReader(new ByteArrayInputStream(fullBuffer)).read(fullCharBuffer);\n                        Tokenizer tok = new Tokenizer();\n                        tok.setLinkHandler(this);\n                        tok.parse(new SimpleCharArrayReader(fullCharBuffer));\n                    }\n                    else\n                    {\n                        // System.out.println(\"Discovered unknown content type: \" + contentType + \" at \" + urlString);\n                        errorLog.log(\"[\" + threadNr + \"] Discovered unknown content type at \" + urlString + \": \" + contentType + \". just storing\");\n                    }\n                    log.log(\"scanned\");\n                }\n                taskState.setState(FT_STORING, ipURL);\n                messageHandler.putMessages(foundUrls);\n                storage.store(new WebDocument(contextUrl, contentType, fullBuffer, statusCode, actURLMessage.getReferer(), contentLength, title));\n                log.log(\"stored\");\n            }\n        }\n        catch (InterruptedIOException e)\n        {\n            // timeout while reading this file\n            System.out.println(\"[\" + threadNr + \"] FetcherTask: Timeout while opening: \" + this.actURLMessage.getUrl());\n            errorLog.log(\"error: Timeout: \" + this.actURLMessage.getUrl());\n            hi.badRequest();\n        }\n        catch (FileNotFoundException e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] FetcherTask: File not Found: \" + this.actURLMessage.getUrl());\n            errorLog.log(\"error: File not Found: \" + this.actURLMessage.getUrl());\n        }\n        catch(NoRouteToHostException e)\n        {\n            // router is down or firewall prevents to connect\n            hi.setReachable(false);\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n        }\n        catch(ConnectException e)\n        {\n            // no server is listening at this port\n            hi.setReachable(false);\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n        }\n        catch (SocketException e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"]: SocketException:\" + e.getMessage());\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n\n        }\n        catch(UnknownHostException e)\n        {\n            // IP Address not to be determined\n            hi.setReachable(false);\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n\n        }\n        catch (IOException e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: IOException: \" + e.getClass().getName() + \": \" + e.getMessage());\n\n        }\n        catch (OutOfMemoryError ome)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] Task \" + this.taskNr + \" OutOfMemory after \" + size + \" bytes\");\n            errorLog.log(\"error: OutOfMemory after \" + size + \" bytes\");\n        }\n        catch (Throwable e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getMessage() + \" type: \" + e.getClass().getName());\n            e.printStackTrace();\n            System.out.println(\"[\" + threadNr + \"]: stopping\");\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage() + \"; stopping\");\n\n        }\n        finally\n        {\n\n            if (isInterrupted)\n            {\n                System.out.println(\"Task was interrupted\");\n                log.log(\"interrupted\");\n                taskState.setState(FT_INTERRUPTED);\n            }\n        }\n        if (isInterrupted)\n        {\n            System.out.println(\"Task: closed everything\");\n        }\n        /*\n         *  }\n         */\n        taskState.setState(FT_CLOSING);\n        conn.stop();\n\n        taskState.setState(FT_READY);\n        foundUrls = null;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"12c7634bf3bb6da687c9b32ca310e7fb8fac8e1e","date":1022957716,"type":3,"author":"cmarschner","isMerge":false,"pathNew":"sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/FetcherTask#run(ServerThread).mjava","pathOld":"sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/FetcherTask#run(ServerThread).mjava","sourceNew":"    /**\n     * this will be called by the fetcher thread and will do all the work\n     *\n     * @TODO probably split this up into different processing steps\n     * @param thread  Description of the Parameter\n     */\n    public void run(ServerThread thread)\n    {\n\n        taskState.setState(FT_STARTED); // state information is always set to make the thread monitor happy\n\n        log = thread.getLog();\n        HostManager hm = ((FetcherThread)thread).getHostManager();\n\n        errorLog = thread.getErrorLog();\n\n        // startTime = System.currentTimeMillis();\n        int threadNr = ((FetcherThread) thread).getThreadNumber();\n\n        log.log(\"start\");\n        base = contextUrl = actURLMessage.getUrl();\n        String urlString = actURLMessage.getURLString();\n        String host = contextUrl.getHost();\n        int hostPos = urlString.indexOf(host);\n        int hostLen = host.length();\n\n        HostInfo hi = hm.getHostInfo(host); // get and create\n\n        if(!hi.isHealthy())\n        {\n            // we make this check as late as possible to get the most current information\n            log.log(\"Bad Host: \" + contextUrl + \"; returning\");\n            System.out.println(\"[\" + threadNr + \"] bad host: \" + this.actURLMessage.getUrl());\n\n            taskState.setState(FT_READY, null);\n            return;\n        }\n\n        foundUrls = new java.util.LinkedList();\n\n        HTTPConnection conn = null;\n\n        title = \"*untitled*\";\n\n        int size = 1;\n\n        InputStream in = null;\n        bytesRead = 0;\n\n\n        try\n        {\n\n            URL ipURL = contextUrl;\n\n            taskState.setState(FT_OPENCONNECTION, urlString);\n\n            log.log(\"connecting to \" + ipURL.getHost());\n            taskState.setState(FT_CONNECTING, ipURL);\n            conn = new HTTPConnection(host);\n\n            conn.setDefaultTimeout(75000);\n            // 75 s\n            conn.setDefaultAllowUserInteraction(false);\n\n            taskState.setState(this.FT_GETTING, ipURL);\n            log.log(\"getting\");\n\n            HTTPResponse response = conn.Get(ipURL.getFile(), \"\", headers);\n            response.setReadIncrement(2720);\n            int statusCode = response.getStatusCode();\n            byte[] fullBuffer = null;\n            String contentType = \"\";\n            int contentLength = 0;\n\n            if (statusCode != 404 && statusCode != 403)\n            {\n                // read up to Constants.FETCHERTASK_MAXFILESIZE bytes into a byte array\n                taskState.setState(FT_READING, ipURL);\n                contentType = response.getHeader(\"Content-Type\");\n                String length = response.getHeader(\"Content-Length\");\n                if (length != null)\n                {\n                    contentLength = Integer.parseInt(length);\n                }\n                log.log(\"reading\");\n\n                fullBuffer = response.getData(Constants.FETCHERTASK_MAXFILESIZE); // max. 2 MB\n                if (fullBuffer != null)\n                {\n                    contentLength = fullBuffer.length;\n                    this.bytesRead += contentLength;\n                }\n            }\n            //conn.stop();    // close connection. todo: Do some caching...\n\n\n            /*\n             *  conn.disconnect();\n             */\n            if (isInterrupted)\n            {\n                System.out.println(\"FetcherTask: interrupted while reading. File truncated\");\n                log.log(\"interrupted while reading. File truncated\");\n            }\n            else\n            {\n                if (fullBuffer != null)\n                {\n                    taskState.setState(FT_SCANNING, ipURL);\n\n                    log.log(\"read file (\" + fullBuffer.length + \" bytes). Now scanning.\");\n\n                    if (contentType.startsWith(\"text/html\"))\n                    {\n\n                        // ouch. I haven't found a better solution yet. just slower ones.\n                        char[] fullCharBuffer = new char[contentLength];\n                        new InputStreamReader(new ByteArrayInputStream(fullBuffer)).read(fullCharBuffer);\n                        Tokenizer tok = new Tokenizer();\n                        tok.setLinkHandler(this);\n                        tok.parse(new SimpleCharArrayReader(fullCharBuffer));\n                    }\n                    else\n                    {\n                        // System.out.println(\"Discovered unknown content type: \" + contentType + \" at \" + urlString);\n                        errorLog.log(\"[\" + threadNr + \"] Discovered unknown content type at \" + urlString + \": \" + contentType + \". just storing\");\n                    }\n                    log.log(\"scanned\");\n                }\n                taskState.setState(FT_STORING, ipURL);\n                linkStorage.storeLinks(foundUrls);\n                //messageHandler.putMessages(foundUrls);\n                docStorage.store(new WebDocument(contextUrl, contentType, fullBuffer, statusCode, actURLMessage.getReferer(), contentLength, title));\n                log.log(\"stored\");\n            }\n        }\n        catch (InterruptedIOException e)\n        {\n            // timeout while reading this file\n            System.out.println(\"[\" + threadNr + \"] FetcherTask: Timeout while opening: \" + this.actURLMessage.getUrl());\n            errorLog.log(\"error: Timeout: \" + this.actURLMessage.getUrl());\n            hi.badRequest();\n        }\n        catch (FileNotFoundException e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] FetcherTask: File not Found: \" + this.actURLMessage.getUrl());\n            errorLog.log(\"error: File not Found: \" + this.actURLMessage.getUrl());\n        }\n        catch(NoRouteToHostException e)\n        {\n            // router is down or firewall prevents to connect\n            hi.setReachable(false);\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n        }\n        catch(ConnectException e)\n        {\n            // no server is listening at this port\n            hi.setReachable(false);\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n        }\n        catch (SocketException e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"]: SocketException:\" + e.getMessage());\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n\n        }\n        catch(UnknownHostException e)\n        {\n            // IP Address not to be determined\n            hi.setReachable(false);\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n\n        }\n        catch (IOException e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: IOException: \" + e.getClass().getName() + \": \" + e.getMessage());\n\n        }\n        catch (OutOfMemoryError ome)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] Task \" + this.taskNr + \" OutOfMemory after \" + size + \" bytes\");\n            errorLog.log(\"error: OutOfMemory after \" + size + \" bytes\");\n        }\n        catch (Throwable e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getMessage() + \" type: \" + e.getClass().getName());\n            e.printStackTrace();\n            System.out.println(\"[\" + threadNr + \"]: stopping\");\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage() + \"; stopping\");\n\n        }\n        finally\n        {\n\n            if (isInterrupted)\n            {\n                System.out.println(\"Task was interrupted\");\n                log.log(\"interrupted\");\n                taskState.setState(FT_INTERRUPTED);\n            }\n        }\n        if (isInterrupted)\n        {\n            System.out.println(\"Task: closed everything\");\n        }\n        /*\n         *  }\n         */\n        taskState.setState(FT_CLOSING);\n        conn.stop();\n\n        taskState.setState(FT_READY);\n        foundUrls = null;\n    }\n\n","sourceOld":"    /**\n     * this will be called by the fetcher thread and will do all the work\n     *\n     * @TODO probably split this up into different processing steps\n     * @param thread  Description of the Parameter\n     */\n    public void run(ServerThread thread)\n    {\n\n        taskState.setState(FT_STARTED); // state information is always set to make the thread monitor happy\n\n        log = thread.getLog();\n        HostManager hm = ((FetcherThread)thread).getHostManager();\n\n        errorLog = thread.getErrorLog();\n\n        // startTime = System.currentTimeMillis();\n        int threadNr = ((FetcherThread) thread).getThreadNumber();\n\n        log.log(\"start\");\n        base = contextUrl = actURLMessage.getUrl();\n        String urlString = actURLMessage.getURLString();\n        String host = contextUrl.getHost();\n        int hostPos = urlString.indexOf(host);\n        int hostLen = host.length();\n\n        HostInfo hi = hm.getHostInfo(host); // get and create\n\n        if(!hi.isHealthy())\n        {\n            // we make this check as late as possible to get the most current information\n            log.log(\"Bad Host: \" + contextUrl + \"; returning\");\n            System.out.println(\"[\" + threadNr + \"] bad host: \" + this.actURLMessage.getUrl());\n\n            taskState.setState(FT_READY, null);\n            return;\n        }\n\n        foundUrls = new java.util.LinkedList();\n\n        HTTPConnection conn = null;\n\n        title = \"*untitled*\";\n\n        int size = 1;\n\n        InputStream in = null;\n        bytesRead = 0;\n\n\n        try\n        {\n\n            URL ipURL = contextUrl;\n\n            taskState.setState(FT_OPENCONNECTION, urlString);\n\n            log.log(\"connecting to \" + ipURL.getHost());\n            taskState.setState(FT_CONNECTING, ipURL);\n            conn = new HTTPConnection(host);\n\n            conn.setDefaultTimeout(75000);\n            // 75 s\n            conn.setDefaultAllowUserInteraction(false);\n\n            taskState.setState(this.FT_GETTING, ipURL);\n            log.log(\"getting\");\n\n            HTTPResponse response = conn.Get(ipURL.getFile(), \"\", headers);\n            response.setReadIncrement(2720);\n            int statusCode = response.getStatusCode();\n            byte[] fullBuffer = null;\n            String contentType = \"\";\n            int contentLength = 0;\n\n            if (statusCode != 404 && statusCode != 403)\n            {\n                // read up to Constants.FETCHERTASK_MAXFILESIZE bytes into a byte array\n                taskState.setState(FT_READING, ipURL);\n                contentType = response.getHeader(\"Content-Type\");\n                String length = response.getHeader(\"Content-Length\");\n                if (length != null)\n                {\n                    contentLength = Integer.parseInt(length);\n                }\n                log.log(\"reading\");\n\n                fullBuffer = response.getData(Constants.FETCHERTASK_MAXFILESIZE); // max. 2 MB\n                if (fullBuffer != null)\n                {\n                    contentLength = fullBuffer.length;\n                    this.bytesRead += contentLength;\n                }\n            }\n            //conn.stop();    // close connection. todo: Do some caching...\n\n\n            /*\n             *  conn.disconnect();\n             */\n            if (isInterrupted)\n            {\n                System.out.println(\"FetcherTask: interrupted while reading. File truncated\");\n                log.log(\"interrupted while reading. File truncated\");\n            }\n            else\n            {\n                if (fullBuffer != null)\n                {\n                    taskState.setState(FT_SCANNING, ipURL);\n\n                    log.log(\"read file (\" + fullBuffer.length + \" bytes). Now scanning.\");\n\n                    if (contentType.startsWith(\"text/html\"))\n                    {\n\n                        // ouch. I haven't found a better solution yet. just slower ones.\n                        char[] fullCharBuffer = new char[contentLength];\n                        new InputStreamReader(new ByteArrayInputStream(fullBuffer)).read(fullCharBuffer);\n                        Tokenizer tok = new Tokenizer();\n                        tok.setLinkHandler(this);\n                        tok.parse(new SimpleCharArrayReader(fullCharBuffer));\n                    }\n                    else\n                    {\n                        // System.out.println(\"Discovered unknown content type: \" + contentType + \" at \" + urlString);\n                        errorLog.log(\"[\" + threadNr + \"] Discovered unknown content type at \" + urlString + \": \" + contentType + \". just storing\");\n                    }\n                    log.log(\"scanned\");\n                }\n                taskState.setState(FT_STORING, ipURL);\n                messageHandler.putMessages(foundUrls);\n                storage.store(new WebDocument(contextUrl, contentType, fullBuffer, statusCode, actURLMessage.getReferer(), contentLength, title));\n                log.log(\"stored\");\n            }\n        }\n        catch (InterruptedIOException e)\n        {\n            // timeout while reading this file\n            System.out.println(\"[\" + threadNr + \"] FetcherTask: Timeout while opening: \" + this.actURLMessage.getUrl());\n            errorLog.log(\"error: Timeout: \" + this.actURLMessage.getUrl());\n            hi.badRequest();\n        }\n        catch (FileNotFoundException e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] FetcherTask: File not Found: \" + this.actURLMessage.getUrl());\n            errorLog.log(\"error: File not Found: \" + this.actURLMessage.getUrl());\n        }\n        catch(NoRouteToHostException e)\n        {\n            // router is down or firewall prevents to connect\n            hi.setReachable(false);\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n        }\n        catch(ConnectException e)\n        {\n            // no server is listening at this port\n            hi.setReachable(false);\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n        }\n        catch (SocketException e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"]: SocketException:\" + e.getMessage());\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n\n        }\n        catch(UnknownHostException e)\n        {\n            // IP Address not to be determined\n            hi.setReachable(false);\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n\n        }\n        catch (IOException e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: IOException: \" + e.getClass().getName() + \": \" + e.getMessage());\n\n        }\n        catch (OutOfMemoryError ome)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] Task \" + this.taskNr + \" OutOfMemory after \" + size + \" bytes\");\n            errorLog.log(\"error: OutOfMemory after \" + size + \" bytes\");\n        }\n        catch (Throwable e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getMessage() + \" type: \" + e.getClass().getName());\n            e.printStackTrace();\n            System.out.println(\"[\" + threadNr + \"]: stopping\");\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage() + \"; stopping\");\n\n        }\n        finally\n        {\n\n            if (isInterrupted)\n            {\n                System.out.println(\"Task was interrupted\");\n                log.log(\"interrupted\");\n                taskState.setState(FT_INTERRUPTED);\n            }\n        }\n        if (isInterrupted)\n        {\n            System.out.println(\"Task: closed everything\");\n        }\n        /*\n         *  }\n         */\n        taskState.setState(FT_CLOSING);\n        conn.stop();\n\n        taskState.setState(FT_READY);\n        foundUrls = null;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"19f3112e7cf0a35b5b8d45069103cd045ed7a583","date":1024322313,"type":3,"author":"cmarschner","isMerge":false,"pathNew":"sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/FetcherTask#run(ServerThread).mjava","pathOld":"sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/FetcherTask#run(ServerThread).mjava","sourceNew":"    /**\n     * this will be called by the fetcher thread and will do all the work\n     *\n     * @TODO probably split this up into different processing steps\n     * @param thread  Description of the Parameter\n     */\n    public void run(ServerThread thread)\n    {\n\n        taskState.setState(FT_STARTED); // state information is always set to make the thread monitor happy\n\n        log = thread.getLog();\n        hostManager = ((FetcherThread)thread).getHostManager();\n\n        //HostManager hm = ((FetcherThread)thread).getHostManager();\n\n        errorLog = thread.getErrorLog();\n\n        // startTime = System.currentTimeMillis();\n        int threadNr = ((FetcherThread) thread).getThreadNumber();\n\n        log.log(\"start\");\n        base = contextUrl = actURLMessage.getUrl();\n        String urlString = actURLMessage.getURLString();\n        String host = contextUrl.getHost().toLowerCase();\n        int hostPos = urlString.indexOf(host);\n        int hostLen = host.length();\n\n        HostInfo hi = hostManager.getHostInfo(host); // get and create\n\n        if(!hi.isHealthy())\n        {\n            // we make this check as late as possible to get the most current information\n            log.log(\"Bad Host: \" + contextUrl + \"; returning\");\n            System.out.println(\"[\" + threadNr + \"] bad host: \" + this.actURLMessage.getUrl());\n\n            taskState.setState(FT_READY, null);\n            return;\n        }\n\n        foundUrls = new java.util.LinkedList();\n\n        HTTPConnection conn = null;\n\n        title = \"*untitled*\";\n\n        int size = 1;\n\n        InputStream in = null;\n        bytesRead = 0;\n\n\n        try\n        {\n\n            URL ipURL = contextUrl;\n\n            taskState.setState(FT_OPENCONNECTION, urlString);\n\n            log.log(\"connecting to \" + ipURL.getHost());\n            taskState.setState(FT_CONNECTING, ipURL);\n            conn = new HTTPConnection(host);\n\n            conn.setDefaultTimeout(75000);\n            // 75 s\n            conn.setDefaultAllowUserInteraction(false);\n\n            taskState.setState(this.FT_GETTING, ipURL);\n            log.log(\"getting\");\n\n            HTTPResponse response = conn.Get(ipURL.getFile(), \"\", headers);\n            response.setReadIncrement(2720);\n            int statusCode = response.getStatusCode();\n            byte[] fullBuffer = null;\n            String contentType = \"\";\n            int contentLength = 0;\n            Date date = null;\n\n            if (statusCode != 404 && statusCode != 403)\n            {\n                // read up to Constants.FETCHERTASK_MAXFILESIZE bytes into a byte array\n                taskState.setState(FT_READING, ipURL);\n                contentType = response.getHeader(\"Content-Type\");\n                String length = response.getHeader(\"Content-Length\");\n                date = response.getHeaderAsDate(\"Last-Modified\");\n\n                if (length != null)\n                {\n                    contentLength = Integer.parseInt(length);\n                }\n                log.log(\"reading\");\n\n                fullBuffer = response.getData(Constants.FETCHERTASK_MAXFILESIZE); // max. 2 MB\n                base = contextUrl = response.getEffectiveURI().toURL();\n                // may have changed after a 30x result code\n                // to do: record the link between original and effective URL\n                // like this the effectiveURL may be crawled twice\n\n\n                if (fullBuffer != null)\n                {\n                    contentLength = fullBuffer.length;\n                    this.bytesRead += contentLength;\n                }\n            }\n            //conn.stop();    // close connection. todo: Do some caching...\n\n\n            /*\n             *  conn.disconnect();\n             */\n            if (isInterrupted)\n            {\n                System.out.println(\"FetcherTask: interrupted while reading. File truncated\");\n                log.log(\"interrupted while reading. File truncated\");\n            }\n            else\n            {\n                if (fullBuffer != null)\n                {\n                    taskState.setState(FT_SCANNING, ipURL);\n\n                    log.log(\"read file (\" + fullBuffer.length + \" bytes). Now scanning.\");\n\n                    if (contentType.startsWith(\"text/html\"))\n                    {\n\n                        // ouch. I haven't found a better solution yet. just slower ones.\n                        char[] fullCharBuffer = new char[contentLength];\n                        new InputStreamReader(new ByteArrayInputStream(fullBuffer)).read(fullCharBuffer);\n                        Tokenizer tok = new Tokenizer();\n                        tok.setLinkHandler(this);\n                        tok.parse(new SimpleCharArrayReader(fullCharBuffer));\n                    }\n                    else\n                    {\n                        // System.out.println(\"Discovered unknown content type: \" + contentType + \" at \" + urlString);\n                        errorLog.log(\"[\" + threadNr + \"] Discovered unknown content type at \" + urlString + \": \" + contentType + \". just storing\");\n                    }\n                    log.log(\"scanned\");\n                }\n                taskState.setState(FT_STORING, ipURL);\n                linkStorage.storeLinks(foundUrls);\n                //messageHandler.putMessages(foundUrls);\n                docStorage.store(new WebDocument(contextUrl, contentType, fullBuffer, statusCode, actURLMessage.getReferer(), contentLength, title, hostManager));\n                log.log(\"stored\");\n            }\n        }\n        catch (InterruptedIOException e)\n        {\n            // timeout while reading this file\n            System.out.println(\"[\" + threadNr + \"] FetcherTask: Timeout while opening: \" + this.actURLMessage.getUrl());\n            errorLog.log(\"error: Timeout: \" + this.actURLMessage.getUrl());\n            hi.badRequest();\n        }\n        catch (FileNotFoundException e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] FetcherTask: File not Found: \" + this.actURLMessage.getUrl());\n            errorLog.log(\"error: File not Found: \" + this.actURLMessage.getUrl());\n        }\n        catch(NoRouteToHostException e)\n        {\n            // router is down or firewall prevents to connect\n            hi.setReachable(false);\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n        }\n        catch(ConnectException e)\n        {\n            // no server is listening at this port\n            hi.setReachable(false);\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n        }\n        catch (SocketException e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"]: SocketException:\" + e.getMessage());\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n\n        }\n        catch(UnknownHostException e)\n        {\n            // IP Address not to be determined\n            hi.setReachable(false);\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n\n        }\n        catch (IOException e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: IOException: \" + e.getClass().getName() + \": \" + e.getMessage());\n\n        }\n        catch (OutOfMemoryError ome)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] Task \" + this.taskNr + \" OutOfMemory after \" + size + \" bytes\");\n            errorLog.log(\"error: OutOfMemory after \" + size + \" bytes\");\n        }\n        catch (Throwable e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getMessage() + \" type: \" + e.getClass().getName());\n            e.printStackTrace();\n            System.out.println(\"[\" + threadNr + \"]: stopping\");\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage() + \"; stopping\");\n\n        }\n        finally\n        {\n\n            if (isInterrupted)\n            {\n                System.out.println(\"Task was interrupted\");\n                log.log(\"interrupted\");\n                taskState.setState(FT_INTERRUPTED);\n            }\n        }\n        if (isInterrupted)\n        {\n            System.out.println(\"Task: closed everything\");\n        }\n        /*\n         *  }\n         */\n        taskState.setState(FT_CLOSING);\n        conn.stop();\n\n        taskState.setState(FT_READY);\n        foundUrls = null;\n    }\n\n","sourceOld":"    /**\n     * this will be called by the fetcher thread and will do all the work\n     *\n     * @TODO probably split this up into different processing steps\n     * @param thread  Description of the Parameter\n     */\n    public void run(ServerThread thread)\n    {\n\n        taskState.setState(FT_STARTED); // state information is always set to make the thread monitor happy\n\n        log = thread.getLog();\n        HostManager hm = ((FetcherThread)thread).getHostManager();\n\n        errorLog = thread.getErrorLog();\n\n        // startTime = System.currentTimeMillis();\n        int threadNr = ((FetcherThread) thread).getThreadNumber();\n\n        log.log(\"start\");\n        base = contextUrl = actURLMessage.getUrl();\n        String urlString = actURLMessage.getURLString();\n        String host = contextUrl.getHost();\n        int hostPos = urlString.indexOf(host);\n        int hostLen = host.length();\n\n        HostInfo hi = hm.getHostInfo(host); // get and create\n\n        if(!hi.isHealthy())\n        {\n            // we make this check as late as possible to get the most current information\n            log.log(\"Bad Host: \" + contextUrl + \"; returning\");\n            System.out.println(\"[\" + threadNr + \"] bad host: \" + this.actURLMessage.getUrl());\n\n            taskState.setState(FT_READY, null);\n            return;\n        }\n\n        foundUrls = new java.util.LinkedList();\n\n        HTTPConnection conn = null;\n\n        title = \"*untitled*\";\n\n        int size = 1;\n\n        InputStream in = null;\n        bytesRead = 0;\n\n\n        try\n        {\n\n            URL ipURL = contextUrl;\n\n            taskState.setState(FT_OPENCONNECTION, urlString);\n\n            log.log(\"connecting to \" + ipURL.getHost());\n            taskState.setState(FT_CONNECTING, ipURL);\n            conn = new HTTPConnection(host);\n\n            conn.setDefaultTimeout(75000);\n            // 75 s\n            conn.setDefaultAllowUserInteraction(false);\n\n            taskState.setState(this.FT_GETTING, ipURL);\n            log.log(\"getting\");\n\n            HTTPResponse response = conn.Get(ipURL.getFile(), \"\", headers);\n            response.setReadIncrement(2720);\n            int statusCode = response.getStatusCode();\n            byte[] fullBuffer = null;\n            String contentType = \"\";\n            int contentLength = 0;\n\n            if (statusCode != 404 && statusCode != 403)\n            {\n                // read up to Constants.FETCHERTASK_MAXFILESIZE bytes into a byte array\n                taskState.setState(FT_READING, ipURL);\n                contentType = response.getHeader(\"Content-Type\");\n                String length = response.getHeader(\"Content-Length\");\n                if (length != null)\n                {\n                    contentLength = Integer.parseInt(length);\n                }\n                log.log(\"reading\");\n\n                fullBuffer = response.getData(Constants.FETCHERTASK_MAXFILESIZE); // max. 2 MB\n                if (fullBuffer != null)\n                {\n                    contentLength = fullBuffer.length;\n                    this.bytesRead += contentLength;\n                }\n            }\n            //conn.stop();    // close connection. todo: Do some caching...\n\n\n            /*\n             *  conn.disconnect();\n             */\n            if (isInterrupted)\n            {\n                System.out.println(\"FetcherTask: interrupted while reading. File truncated\");\n                log.log(\"interrupted while reading. File truncated\");\n            }\n            else\n            {\n                if (fullBuffer != null)\n                {\n                    taskState.setState(FT_SCANNING, ipURL);\n\n                    log.log(\"read file (\" + fullBuffer.length + \" bytes). Now scanning.\");\n\n                    if (contentType.startsWith(\"text/html\"))\n                    {\n\n                        // ouch. I haven't found a better solution yet. just slower ones.\n                        char[] fullCharBuffer = new char[contentLength];\n                        new InputStreamReader(new ByteArrayInputStream(fullBuffer)).read(fullCharBuffer);\n                        Tokenizer tok = new Tokenizer();\n                        tok.setLinkHandler(this);\n                        tok.parse(new SimpleCharArrayReader(fullCharBuffer));\n                    }\n                    else\n                    {\n                        // System.out.println(\"Discovered unknown content type: \" + contentType + \" at \" + urlString);\n                        errorLog.log(\"[\" + threadNr + \"] Discovered unknown content type at \" + urlString + \": \" + contentType + \". just storing\");\n                    }\n                    log.log(\"scanned\");\n                }\n                taskState.setState(FT_STORING, ipURL);\n                linkStorage.storeLinks(foundUrls);\n                //messageHandler.putMessages(foundUrls);\n                docStorage.store(new WebDocument(contextUrl, contentType, fullBuffer, statusCode, actURLMessage.getReferer(), contentLength, title));\n                log.log(\"stored\");\n            }\n        }\n        catch (InterruptedIOException e)\n        {\n            // timeout while reading this file\n            System.out.println(\"[\" + threadNr + \"] FetcherTask: Timeout while opening: \" + this.actURLMessage.getUrl());\n            errorLog.log(\"error: Timeout: \" + this.actURLMessage.getUrl());\n            hi.badRequest();\n        }\n        catch (FileNotFoundException e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] FetcherTask: File not Found: \" + this.actURLMessage.getUrl());\n            errorLog.log(\"error: File not Found: \" + this.actURLMessage.getUrl());\n        }\n        catch(NoRouteToHostException e)\n        {\n            // router is down or firewall prevents to connect\n            hi.setReachable(false);\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n        }\n        catch(ConnectException e)\n        {\n            // no server is listening at this port\n            hi.setReachable(false);\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n        }\n        catch (SocketException e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"]: SocketException:\" + e.getMessage());\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n\n        }\n        catch(UnknownHostException e)\n        {\n            // IP Address not to be determined\n            hi.setReachable(false);\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n\n        }\n        catch (IOException e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: IOException: \" + e.getClass().getName() + \": \" + e.getMessage());\n\n        }\n        catch (OutOfMemoryError ome)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] Task \" + this.taskNr + \" OutOfMemory after \" + size + \" bytes\");\n            errorLog.log(\"error: OutOfMemory after \" + size + \" bytes\");\n        }\n        catch (Throwable e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getMessage() + \" type: \" + e.getClass().getName());\n            e.printStackTrace();\n            System.out.println(\"[\" + threadNr + \"]: stopping\");\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage() + \"; stopping\");\n\n        }\n        finally\n        {\n\n            if (isInterrupted)\n            {\n                System.out.println(\"Task was interrupted\");\n                log.log(\"interrupted\");\n                taskState.setState(FT_INTERRUPTED);\n            }\n        }\n        if (isInterrupted)\n        {\n            System.out.println(\"Task: closed everything\");\n        }\n        /*\n         *  }\n         */\n        taskState.setState(FT_CLOSING);\n        conn.stop();\n\n        taskState.setState(FT_READY);\n        foundUrls = null;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e56132d241479de027bc013a7094c731e7bb581e","date":1024361110,"type":3,"author":"cmarschner","isMerge":false,"pathNew":"sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/FetcherTask#run(ServerThread).mjava","pathOld":"sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/FetcherTask#run(ServerThread).mjava","sourceNew":"    /**\n     * this will be called by the fetcher thread and will do all the work\n     *\n     * @TODO probably split this up into different processing steps\n     * @param thread  Description of the Parameter\n     */\n    public void run(ServerThread thread)\n    {\n\n        taskState.setState(FT_STARTED); // state information is always set to make the thread monitor happy\n\n        log = thread.getLog();\n        hostManager = ((FetcherThread)thread).getHostManager();\n\n        //HostManager hm = ((FetcherThread)thread).getHostManager();\n\n        errorLog = thread.getErrorLog();\n\n        // startTime = System.currentTimeMillis();\n        int threadNr = ((FetcherThread) thread).getThreadNumber();\n\n        log.log(\"start\");\n        base = contextUrl = actURLMessage.getUrl();\n        String urlString = actURLMessage.getURLString();\n        String host = contextUrl.getHost().toLowerCase();\n        int hostPos = urlString.indexOf(host);\n        int hostLen = host.length();\n\n        HostInfo hi = hostManager.getHostInfo(host); // get and create\n\n        if(!hi.isHealthy())\n        {\n            // we make this check as late as possible to get the most current information\n            log.log(\"Bad Host: \" + contextUrl + \"; returning\");\n            System.out.println(\"[\" + threadNr + \"] bad host: \" + this.actURLMessage.getUrl());\n\n            taskState.setState(FT_READY, null);\n            return;\n        }\n\n        foundUrls = new java.util.LinkedList();\n\n        HTTPConnection conn = null;\n\n        title = \"*untitled*\";\n\n        int size = 1;\n\n        InputStream in = null;\n        bytesRead = 0;\n\n\n        try\n        {\n\n            URL ipURL = contextUrl;\n\n            taskState.setState(FT_OPENCONNECTION, urlString);\n\n            log.log(\"connecting to \" + ipURL.getHost());\n            taskState.setState(FT_CONNECTING, ipURL);\n            conn = new HTTPConnection(host);\n\n            conn.setDefaultTimeout(75000);\n            // 75 s\n            conn.setDefaultAllowUserInteraction(false);\n\n            taskState.setState(this.FT_GETTING, ipURL);\n            log.log(\"getting\");\n\n            HTTPResponse response = conn.Get(ipURL.getFile(), \"\", headers);\n            response.setReadIncrement(2720);\n            int statusCode = response.getStatusCode();\n            byte[] fullBuffer = null;\n            String contentType = \"\";\n            int contentLength = 0;\n            Date date = null;\n\n            if (statusCode != 404 && statusCode != 403)\n            {\n                // read up to Constants.FETCHERTASK_MAXFILESIZE bytes into a byte array\n                taskState.setState(FT_READING, ipURL);\n                contentType = response.getHeader(\"Content-Type\");\n                String length = response.getHeader(\"Content-Length\");\n                date = response.getHeaderAsDate(\"Last-Modified\");\n\n                if (length != null)\n                {\n                    contentLength = Integer.parseInt(length);\n                }\n                log.log(\"reading\");\n\n                fullBuffer = response.getData(Constants.FETCHERTASK_MAXFILESIZE); // max. 2 MB\n                base = contextUrl = response.getEffectiveURI().toURL();\n                // may have changed after a 30x result code\n                // to do: record the link between original and effective URL\n                // like this the effectiveURL may be crawled twice\n\n\n                if (fullBuffer != null)\n                {\n                    contentLength = fullBuffer.length;\n                    this.bytesRead += contentLength;\n                }\n            }\n            //conn.stop();    // close connection. todo: Do some caching...\n\n\n            /*\n             *  conn.disconnect();\n             */\n            if (isInterrupted)\n            {\n                System.out.println(\"FetcherTask: interrupted while reading. File truncated\");\n                log.log(\"interrupted while reading. File truncated\");\n            }\n            else\n            {\n                if (fullBuffer != null)\n                {\n                    taskState.setState(FT_SCANNING, ipURL);\n\n                    log.log(\"read file (\" + fullBuffer.length + \" bytes). Now scanning.\");\n\n                    if (contentType.startsWith(\"text/html\"))\n                    {\n\n                        // ouch. I haven't found a better solution yet. just slower ones.\n                        char[] fullCharBuffer = new char[contentLength];\n                        new InputStreamReader(new ByteArrayInputStream(fullBuffer)).read(fullCharBuffer);\n                        Tokenizer tok = new Tokenizer();\n                        tok.setLinkHandler(this);\n                        tok.parse(new SimpleCharArrayReader(fullCharBuffer));\n\n                        taskState.setState(FT_STORING, ipURL);\n                        linkStorage.storeLinks(foundUrls);\n                        WebDocument d = new WebDocument(contextUrl, contentType, statusCode, actURLMessage.getReferer(), contentLength, title, date, hostManager);\n                        d.addField(\"content\", fullCharBuffer);\n                        docStorage.store(d);\n                    }\n                    else\n                    {\n                        // System.out.println(\"Discovered unknown content type: \" + contentType + \" at \" + urlString);\n                        //errorLog.log(\"[\" + threadNr + \"] Discovered unknown content type at \" + urlString + \": \" + contentType + \". just storing\");\n                        taskState.setState(FT_STORING, ipURL);\n                        linkStorage.storeLinks(foundUrls);\n                        WebDocument d = new WebDocument(contextUrl, contentType, statusCode, actURLMessage.getReferer(), contentLength, title, date, hostManager);\n                        d.addField(\"content\", fullBuffer);\n                        docStorage.store(d);\n                    }\n                    log.log(\"scanned\");\n                }\n\n                log.log(\"stored\");\n            }\n        }\n        catch (InterruptedIOException e)\n        {\n            // timeout while reading this file\n            //System.out.println(\"[\" + threadNr + \"] FetcherTask: Timeout while opening: \" + this.actURLMessage.getUrl());\n            errorLog.log(\"error: Timeout: \" + this.actURLMessage.getUrl());\n            hi.badRequest();\n        }\n        catch (FileNotFoundException e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            //System.out.println(\"[\" + threadNr + \"] FetcherTask: File not Found: \" + this.actURLMessage.getUrl());\n            errorLog.log(\"error: File not Found: \" + this.actURLMessage.getUrl());\n        }\n        catch(NoRouteToHostException e)\n        {\n            // router is down or firewall prevents to connect\n            hi.setReachable(false);\n            taskState.setState(FT_EXCEPTION);\n            //System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n        }\n        catch(ConnectException e)\n        {\n            // no server is listening at this port\n            hi.setReachable(false);\n            taskState.setState(FT_EXCEPTION);\n            //System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n        }\n        catch (SocketException e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            //System.out.println(\"[\" + threadNr + \"]: SocketException:\" + e.getMessage());\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n\n        }\n        catch(UnknownHostException e)\n        {\n            // IP Address not to be determined\n            hi.setReachable(false);\n            taskState.setState(FT_EXCEPTION);\n            //System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n\n        }\n        catch (IOException e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            //System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: IOException: \" + e.getClass().getName() + \": \" + e.getMessage());\n\n        }\n        catch (OutOfMemoryError ome)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] Task \" + this.taskNr + \" OutOfMemory after \" + size + \" bytes\");\n            errorLog.log(\"error: OutOfMemory after \" + size + \" bytes\");\n        }\n        catch (Throwable e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getMessage() + \" type: \" + e.getClass().getName());\n            e.printStackTrace();\n            System.out.println(\"[\" + threadNr + \"]: stopping\");\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage() + \"; stopping\");\n\n        }\n        finally\n        {\n\n            if (isInterrupted)\n            {\n                System.out.println(\"Task was interrupted\");\n                log.log(\"interrupted\");\n                taskState.setState(FT_INTERRUPTED);\n            }\n        }\n        if (isInterrupted)\n        {\n            System.out.println(\"Task: closed everything\");\n        }\n        /*\n         *  }\n         */\n        taskState.setState(FT_CLOSING);\n        conn.stop();\n\n        taskState.setState(FT_READY);\n        foundUrls = null;\n    }\n\n","sourceOld":"    /**\n     * this will be called by the fetcher thread and will do all the work\n     *\n     * @TODO probably split this up into different processing steps\n     * @param thread  Description of the Parameter\n     */\n    public void run(ServerThread thread)\n    {\n\n        taskState.setState(FT_STARTED); // state information is always set to make the thread monitor happy\n\n        log = thread.getLog();\n        hostManager = ((FetcherThread)thread).getHostManager();\n\n        //HostManager hm = ((FetcherThread)thread).getHostManager();\n\n        errorLog = thread.getErrorLog();\n\n        // startTime = System.currentTimeMillis();\n        int threadNr = ((FetcherThread) thread).getThreadNumber();\n\n        log.log(\"start\");\n        base = contextUrl = actURLMessage.getUrl();\n        String urlString = actURLMessage.getURLString();\n        String host = contextUrl.getHost().toLowerCase();\n        int hostPos = urlString.indexOf(host);\n        int hostLen = host.length();\n\n        HostInfo hi = hostManager.getHostInfo(host); // get and create\n\n        if(!hi.isHealthy())\n        {\n            // we make this check as late as possible to get the most current information\n            log.log(\"Bad Host: \" + contextUrl + \"; returning\");\n            System.out.println(\"[\" + threadNr + \"] bad host: \" + this.actURLMessage.getUrl());\n\n            taskState.setState(FT_READY, null);\n            return;\n        }\n\n        foundUrls = new java.util.LinkedList();\n\n        HTTPConnection conn = null;\n\n        title = \"*untitled*\";\n\n        int size = 1;\n\n        InputStream in = null;\n        bytesRead = 0;\n\n\n        try\n        {\n\n            URL ipURL = contextUrl;\n\n            taskState.setState(FT_OPENCONNECTION, urlString);\n\n            log.log(\"connecting to \" + ipURL.getHost());\n            taskState.setState(FT_CONNECTING, ipURL);\n            conn = new HTTPConnection(host);\n\n            conn.setDefaultTimeout(75000);\n            // 75 s\n            conn.setDefaultAllowUserInteraction(false);\n\n            taskState.setState(this.FT_GETTING, ipURL);\n            log.log(\"getting\");\n\n            HTTPResponse response = conn.Get(ipURL.getFile(), \"\", headers);\n            response.setReadIncrement(2720);\n            int statusCode = response.getStatusCode();\n            byte[] fullBuffer = null;\n            String contentType = \"\";\n            int contentLength = 0;\n            Date date = null;\n\n            if (statusCode != 404 && statusCode != 403)\n            {\n                // read up to Constants.FETCHERTASK_MAXFILESIZE bytes into a byte array\n                taskState.setState(FT_READING, ipURL);\n                contentType = response.getHeader(\"Content-Type\");\n                String length = response.getHeader(\"Content-Length\");\n                date = response.getHeaderAsDate(\"Last-Modified\");\n\n                if (length != null)\n                {\n                    contentLength = Integer.parseInt(length);\n                }\n                log.log(\"reading\");\n\n                fullBuffer = response.getData(Constants.FETCHERTASK_MAXFILESIZE); // max. 2 MB\n                base = contextUrl = response.getEffectiveURI().toURL();\n                // may have changed after a 30x result code\n                // to do: record the link between original and effective URL\n                // like this the effectiveURL may be crawled twice\n\n\n                if (fullBuffer != null)\n                {\n                    contentLength = fullBuffer.length;\n                    this.bytesRead += contentLength;\n                }\n            }\n            //conn.stop();    // close connection. todo: Do some caching...\n\n\n            /*\n             *  conn.disconnect();\n             */\n            if (isInterrupted)\n            {\n                System.out.println(\"FetcherTask: interrupted while reading. File truncated\");\n                log.log(\"interrupted while reading. File truncated\");\n            }\n            else\n            {\n                if (fullBuffer != null)\n                {\n                    taskState.setState(FT_SCANNING, ipURL);\n\n                    log.log(\"read file (\" + fullBuffer.length + \" bytes). Now scanning.\");\n\n                    if (contentType.startsWith(\"text/html\"))\n                    {\n\n                        // ouch. I haven't found a better solution yet. just slower ones.\n                        char[] fullCharBuffer = new char[contentLength];\n                        new InputStreamReader(new ByteArrayInputStream(fullBuffer)).read(fullCharBuffer);\n                        Tokenizer tok = new Tokenizer();\n                        tok.setLinkHandler(this);\n                        tok.parse(new SimpleCharArrayReader(fullCharBuffer));\n                    }\n                    else\n                    {\n                        // System.out.println(\"Discovered unknown content type: \" + contentType + \" at \" + urlString);\n                        errorLog.log(\"[\" + threadNr + \"] Discovered unknown content type at \" + urlString + \": \" + contentType + \". just storing\");\n                    }\n                    log.log(\"scanned\");\n                }\n                taskState.setState(FT_STORING, ipURL);\n                linkStorage.storeLinks(foundUrls);\n                //messageHandler.putMessages(foundUrls);\n                docStorage.store(new WebDocument(contextUrl, contentType, fullBuffer, statusCode, actURLMessage.getReferer(), contentLength, title, hostManager));\n                log.log(\"stored\");\n            }\n        }\n        catch (InterruptedIOException e)\n        {\n            // timeout while reading this file\n            System.out.println(\"[\" + threadNr + \"] FetcherTask: Timeout while opening: \" + this.actURLMessage.getUrl());\n            errorLog.log(\"error: Timeout: \" + this.actURLMessage.getUrl());\n            hi.badRequest();\n        }\n        catch (FileNotFoundException e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] FetcherTask: File not Found: \" + this.actURLMessage.getUrl());\n            errorLog.log(\"error: File not Found: \" + this.actURLMessage.getUrl());\n        }\n        catch(NoRouteToHostException e)\n        {\n            // router is down or firewall prevents to connect\n            hi.setReachable(false);\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n        }\n        catch(ConnectException e)\n        {\n            // no server is listening at this port\n            hi.setReachable(false);\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n        }\n        catch (SocketException e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"]: SocketException:\" + e.getMessage());\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n\n        }\n        catch(UnknownHostException e)\n        {\n            // IP Address not to be determined\n            hi.setReachable(false);\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n\n        }\n        catch (IOException e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: IOException: \" + e.getClass().getName() + \": \" + e.getMessage());\n\n        }\n        catch (OutOfMemoryError ome)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] Task \" + this.taskNr + \" OutOfMemory after \" + size + \" bytes\");\n            errorLog.log(\"error: OutOfMemory after \" + size + \" bytes\");\n        }\n        catch (Throwable e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getMessage() + \" type: \" + e.getClass().getName());\n            e.printStackTrace();\n            System.out.println(\"[\" + threadNr + \"]: stopping\");\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage() + \"; stopping\");\n\n        }\n        finally\n        {\n\n            if (isInterrupted)\n            {\n                System.out.println(\"Task was interrupted\");\n                log.log(\"interrupted\");\n                taskState.setState(FT_INTERRUPTED);\n            }\n        }\n        if (isInterrupted)\n        {\n            System.out.println(\"Task: closed everything\");\n        }\n        /*\n         *  }\n         */\n        taskState.setState(FT_CLOSING);\n        conn.stop();\n\n        taskState.setState(FT_READY);\n        foundUrls = null;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"35d2a11130c55c5aebafaa8a680a571684104914","date":1035298963,"type":3,"author":"cmarschner","isMerge":false,"pathNew":"sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/FetcherTask#run(ServerThread).mjava","pathOld":"sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/FetcherTask#run(ServerThread).mjava","sourceNew":"    /**\n     * this will be called by the fetcher thread and will do all the work\n     *\n     * @param thread  Description of the Parameter\n     * @TODO          probably split this up into different processing steps\n     */\n    public void run(ServerThread thread)\n    {\n\n\n        taskState.setState(FT_STARTED);\n        // state information is always set to make the thread monitor happy\n\n        log = thread.getLog();\n        hostManager = ((FetcherThread) thread).getHostManager();\n        hostResolver = hostManager.getHostResolver();\n        base = contextUrl = actURLMessage.getUrl();\n        String urlString = actURLMessage.getURLString();\n        String host = contextUrl.getHost().toLowerCase();\n        HostInfo hi = hostManager.getHostInfo(host);\n//        System.out.println(\"FetcherTask with \" + urlString + \" started\");\n        if(actURLMessage.linkType == URLMessage.LINKTYPE_REDIRECT)\n        {\n            taskState.setState(FT_READY, null);\n            hi.releaseLock();\n            return;     // we've already crawled that (see below)\n        }\n\n        NVPair[] headers = ((FetcherThread) thread).getDefaultHeaders();\n        int numHeaders = ((FetcherThread) thread).getUsedDefaultHeaders();\n        boolean isIncremental = false;\n        if (actURLMessage instanceof WebDocument)\n        {\n            // this is an incremental crawl where we only have to check whether the doc crawled\n            // is newer\n            isIncremental = true;\n            headers[numHeaders] = new NVPair(\"If-Modified-Since\", HTTPClient.Util.httpDate(((WebDocument) actURLMessage).getLastModified()));\n        }\n        //HostManager hm = ((FetcherThread)thread).getHostManager();\n\n        errorLog = thread.getErrorLog();\n\n        // startTime = System.currentTimeMillis();\n        int threadNr = ((FetcherThread) thread).getThreadNumber();\n\n        log.log(\"start\");\n        int hostPos = urlString.indexOf(host);\n        int hostLen = host.length();\n\n        // get and create\n\n        if (!hi.isHealthy())\n        {\n            // we make this check as late as possible to get the most current information\n            log.log(\"Bad Host: \" + contextUrl + \"; returning\");\n//            System.out.println(\"[\" + threadNr + \"] bad host: \" + this.actURLMessage.getUrl());\n\n            taskState.setState(FT_READY, null);\n            hi.releaseLock();\n            return;\n        }\n\n        foundUrls = new java.util.LinkedList();\n\n        HTTPConnection conn = null;\n\n        title = \"\";\n\n        int size = 1;\n\n        InputStream in = null;\n        bytesRead = 0;\n\n        try\n        {\n\n            URL ipURL = contextUrl;\n\n            taskState.setState(FT_OPENCONNECTION, urlString);\n\n            log.log(\"connecting to \" + ipURL.getHost());\n            taskState.setState(FT_CONNECTING, ipURL);\n            conn = new HTTPConnection(host);\n\n            conn.setDefaultTimeout(75000);\n\n            // 75 s\n            conn.setDefaultAllowUserInteraction(false);\n\n            taskState.setState(this.FT_GETTING, ipURL);\n            log.log(\"getting\");\n\n            HTTPResponse response = conn.Get(ipURL.getFile(), \"\", headers);\n            response.setReadIncrement(2720);\n            int statusCode = response.getStatusCode();\n            byte[] fullBuffer = null;\n            String contentType = \"\";\n            int contentLength = 0;\n            Date date = null;\n\n             if (isIncremental)\n            {\n                // experimental\n                System.out.println(\"ftask: if modified since: \" + HTTPClient.Util.httpDate(((WebDocument) actURLMessage).getLastModified()));\n            }\n\n            URL realURL;\n\n            switch (statusCode)\n            {\n                case 404:                // file not found\n                case 403:                    // access forbidden\n\n                    // if this is an incremental crawl, remove the doc from the repository\n                    if (isIncremental)\n                    {\n                        WebDocument d = (WebDocument) actURLMessage;\n                        d.setResultCode(statusCode);\n                        // the repository will remove the doc if this statuscode is matched\n                        docStorage.store(d);\n                    }\n                    // otherwise, do nothing\n                    // Todo: we could add an error marker to the referal link\n                    break;\n                case 304:\n                    // not modified\n                    System.out.println(\"ftask: -> not modified\");\n                    // \"not modified since\"\n                    taskState.setState(FT_STORING, ipURL);\n                    // let the repository take care of the links\n                    // it will determine that this is the old document (because it already\n                    // has a docId), and will put back the links associated with it\n                    try\n                    {\n                        WebDocument doc = (WebDocument) this.actURLMessage;\n                        doc.setModified(false);\n                        docStorage.store(doc);\n                        this.bytesRead += doc.getSize();\n                    }\n                    catch (ClassCastException e)\n                    {\n                        System.out.println(\"error while casting to WebDoc: \" + actURLMessage.getInfo());\n                    }\n                    break;\n                case 301:                // moved permanently\n                case 302:                // moved temporarily\n                case 303:                // see other\n                case 307:                // temporary redirect\n                    /*\n                     *  this is a redirect. save it as a link and return.\n                     *  note that we could read the doc from the open connection here, but this could mean\n                     *  the filters were useless\n                     */\n                    realURL = response.getEffectiveURI().toURL();\n                    foundUrls.add(new URLMessage(realURL, contextUrl, URLMessage.LINKTYPE_REDIRECT, \"\", hostResolver));\n                    linkStorage.storeLinks(foundUrls);\n                    break;\n                default:\n                    // this can be a 30x code that was resolved by the HTTPClient and is passed to us as 200\n                    // we could turn this off and do it ourselves. But then we'd have to take care that\n                    // we don't get into an endless redirection loop -> i.e. extend URLMessage by a counter\n                    // at the moment we add the real URL to the message queue and mark it as a REDIRECT link\n                    // that way it is added to the visited filter. Then we take care that we don't crawl it again\n\n                    // the other possibility is that we receive a \"Location:\" header along with a 200 status code\n                    // I have experienced that HTTPClient has an error with parsing this, so we do it ourselves\n                    //String location = response.getHeader(\"Location\");\n                    realURL = response.getEffectiveURI().toURL();\n\n                    /*if(location != null)\n                    {\n                        //System.out.println(\"interesting: location header with url \" + location);\n                        foundUrls.add(new URLMessage(new URL(location), contextUrl, URLMessage.LINKTYPE_REDIRECT, \"\", hostManager));\n                        this.base = this.contextUrl = location;\n                    }\n                    else*/\n                    if(!(realURL.equals(contextUrl)))\n                    {\n                        //System.out.println(\"interesting: redirect with url \" + realURL + \" -context: \" + contextUrl);\n                        foundUrls.add(new URLMessage(realURL, contextUrl, URLMessage.LINKTYPE_REDIRECT, \"\", hostResolver));\n                        this.base = this.contextUrl = realURL;\n                        //System.out.println(response);\n\n                    }\n\n\n\n\n                    if (isIncremental)\n                    {\n                        // experimental\n                        System.out.println(\"ftask: -> was modified at \" + response.getHeaderAsDate(\"Last-Modified\"));\n                    }\n                    // read up to Constants.FETCHERTASK_MAXFILESIZE bytes into a byte array\n                    taskState.setState(FT_READING, ipURL);\n                    contentType = response.getHeader(\"Content-Type\");\n                    String length = response.getHeader(\"Content-Length\");\n                    date = response.getHeaderAsDate(\"Last-Modified\");\n\n                    if (length != null)\n                    {\n                        contentLength = Integer.parseInt(length);\n                    }\n                    log.log(\"reading\");\n                    realURL = response.getEffectiveURI().toURL();\n                    if (contentType != null && contentType.startsWith(\"text/html\"))\n                    {\n                        fullBuffer = response.getData(Constants.FETCHERTASK_MAXFILESIZE);\n                        hi.releaseLock();\n                        // max. 2 MB\n                        if (fullBuffer != null)\n                        {\n                            contentLength = fullBuffer.length;\n                            this.bytesRead += contentLength;\n                        }\n\n                        /*\n                         *  conn.disconnect();\n                         */\n                        if (isInterrupted)\n                        {\n                            System.out.println(\"FetcherTask: interrupted while reading. File truncated\");\n                            log.log(\"interrupted while reading. File truncated\");\n                        }\n                        else\n                        {\n                            if (fullBuffer != null)\n                            {\n                                taskState.setState(FT_SCANNING, ipURL);\n\n                                log.log(\"read file (\" + fullBuffer.length + \" bytes). Now scanning.\");\n\n                                // convert the bytes to Java characters\n                                // ouch. I haven't found a better solution yet. just slower ones.\n                                // remember: for better runtime performance avoid decorators, since they\n                                // multiply function calls\n                                char[] fullCharBuffer = new char[contentLength];\n                                new InputStreamReader(new ByteArrayInputStream(fullBuffer)).read(fullCharBuffer);\n                                Tokenizer tok = new Tokenizer();\n                                tok.setLinkHandler(this);\n                                tok.parse(new SimpleCharArrayReader(fullCharBuffer));\n\n                                taskState.setState(FT_STORING, ipURL);\n                                linkStorage.storeLinks(foundUrls);\n                                WebDocument d;\n                                if (isIncremental)\n                                {\n                                    d = ((WebDocument) this.actURLMessage);\n                                    d.setModified(true);\n                                    // file is new or newer\n                                    d.setUrl(contextUrl);\n                                    d.setMimeType(contentType);\n                                    d.setResultCode(statusCode);\n                                    d.setSize(contentLength);\n                                    d.setTitle(title);\n                                    d.setLastModified(date);\n                                }\n                                else\n                                {\n                                    d = new WebDocument(contextUrl, contentType, statusCode, actURLMessage.getReferer(), contentLength, title, date, hostResolver);\n                                }\n                                d.addField(\"content\", fullCharBuffer);\n                                d.addField(\"contentBytes\", fullBuffer);\n                                docStorage.store(d);\n                            }\n\n                            log.log(\"scanned\");\n                        }\n\n                        log.log(\"stored\");\n                    }\n                    else\n                    {\n                        // System.out.println(\"Discovered unknown content type: \" + contentType + \" at \" + urlString);\n                        //errorLog.log(\"[\" + threadNr + \"] Discovered unknown content type at \" + urlString + \": \" + contentType + \". just storing\");\n                        taskState.setState(FT_STORING, ipURL);\n                        linkStorage.storeLinks(foundUrls);\n                        WebDocument d = new WebDocument(contextUrl, contentType, statusCode, actURLMessage.getReferer(),\n                        /*\n                         *  contentLength\n                         */\n                                0, title, date, hostResolver);\n                        //d.addField(\"content\", fullBuffer);\n                        //d.addField(\"content\", null);\n                        docStorage.store(d);\n                    }\n                    break;\n            }\n            /*\n             *  switch\n             */\n            //conn.stop();    // close connection. todo: Do some caching...\n\n        }\n        catch (InterruptedIOException e)\n        {\n            // timeout while reading this file\n            //System.out.println(\"[\" + threadNr + \"] FetcherTask: Timeout while opening: \" + this.actURLMessage.getUrl());\n            errorLog.log(\"error: Timeout: \" + this.actURLMessage.getUrl());\n            hi.badRequest();\n        }\n        catch (FileNotFoundException e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            //System.out.println(\"[\" + threadNr + \"] FetcherTask: File not Found: \" + this.actURLMessage.getUrl());\n            errorLog.log(\"error: File not Found: \" + this.actURLMessage.getUrl());\n        }\n        catch (NoRouteToHostException e)\n        {\n            // router is down or firewall prevents to connect\n            hi.setReachable(false);\n            taskState.setState(FT_EXCEPTION);\n            //System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n        }\n        catch (ConnectException e)\n        {\n            // no server is listening at this port\n            hi.setReachable(false);\n            taskState.setState(FT_EXCEPTION);\n            //System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n\n        }\n        catch (SocketException e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            //System.out.println(\"[\" + threadNr + \"]: SocketException:\" + e.getMessage());\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n\n        }\n        catch (UnknownHostException e)\n        {\n            // IP Address not to be determined\n            hi.setReachable(false);\n            taskState.setState(FT_EXCEPTION);\n            //System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n\n        }\n        catch (IOException e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            //System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: IOException: \" + e.getClass().getName() + \": \" + e.getMessage());\n\n        }\n        catch (OutOfMemoryError ome)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] Task \" + this.taskNr + \" OutOfMemory after \" + size + \" bytes\");\n            errorLog.log(\"error: OutOfMemory after \" + size + \" bytes\");\n        }\n        catch (Throwable e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getMessage() + \" type: \" + e.getClass().getName());\n            e.printStackTrace();\n            System.out.println(\"[\" + threadNr + \"]: stopping\");\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage() + \"; stopping\");\n        }\n        finally\n        {\n            hi.releaseLock();\n\n            if (isInterrupted)\n            {\n                System.out.println(\"Task was interrupted\");\n                log.log(\"interrupted\");\n                taskState.setState(FT_INTERRUPTED);\n            }\n        }\n        if (isInterrupted)\n        {\n            System.out.println(\"Task: closed everything\");\n        }\n        /*\n         *  }\n         */\n        taskState.setState(FT_CLOSING);\n        conn.stop();\n        taskState.setState(FT_READY);\n        foundUrls = null;\n    }\n\n","sourceOld":"    /**\n     * this will be called by the fetcher thread and will do all the work\n     *\n     * @TODO probably split this up into different processing steps\n     * @param thread  Description of the Parameter\n     */\n    public void run(ServerThread thread)\n    {\n\n        taskState.setState(FT_STARTED); // state information is always set to make the thread monitor happy\n\n        log = thread.getLog();\n        hostManager = ((FetcherThread)thread).getHostManager();\n\n        //HostManager hm = ((FetcherThread)thread).getHostManager();\n\n        errorLog = thread.getErrorLog();\n\n        // startTime = System.currentTimeMillis();\n        int threadNr = ((FetcherThread) thread).getThreadNumber();\n\n        log.log(\"start\");\n        base = contextUrl = actURLMessage.getUrl();\n        String urlString = actURLMessage.getURLString();\n        String host = contextUrl.getHost().toLowerCase();\n        int hostPos = urlString.indexOf(host);\n        int hostLen = host.length();\n\n        HostInfo hi = hostManager.getHostInfo(host); // get and create\n\n        if(!hi.isHealthy())\n        {\n            // we make this check as late as possible to get the most current information\n            log.log(\"Bad Host: \" + contextUrl + \"; returning\");\n            System.out.println(\"[\" + threadNr + \"] bad host: \" + this.actURLMessage.getUrl());\n\n            taskState.setState(FT_READY, null);\n            return;\n        }\n\n        foundUrls = new java.util.LinkedList();\n\n        HTTPConnection conn = null;\n\n        title = \"*untitled*\";\n\n        int size = 1;\n\n        InputStream in = null;\n        bytesRead = 0;\n\n\n        try\n        {\n\n            URL ipURL = contextUrl;\n\n            taskState.setState(FT_OPENCONNECTION, urlString);\n\n            log.log(\"connecting to \" + ipURL.getHost());\n            taskState.setState(FT_CONNECTING, ipURL);\n            conn = new HTTPConnection(host);\n\n            conn.setDefaultTimeout(75000);\n            // 75 s\n            conn.setDefaultAllowUserInteraction(false);\n\n            taskState.setState(this.FT_GETTING, ipURL);\n            log.log(\"getting\");\n\n            HTTPResponse response = conn.Get(ipURL.getFile(), \"\", headers);\n            response.setReadIncrement(2720);\n            int statusCode = response.getStatusCode();\n            byte[] fullBuffer = null;\n            String contentType = \"\";\n            int contentLength = 0;\n            Date date = null;\n\n            if (statusCode != 404 && statusCode != 403)\n            {\n                // read up to Constants.FETCHERTASK_MAXFILESIZE bytes into a byte array\n                taskState.setState(FT_READING, ipURL);\n                contentType = response.getHeader(\"Content-Type\");\n                String length = response.getHeader(\"Content-Length\");\n                date = response.getHeaderAsDate(\"Last-Modified\");\n\n                if (length != null)\n                {\n                    contentLength = Integer.parseInt(length);\n                }\n                log.log(\"reading\");\n\n                fullBuffer = response.getData(Constants.FETCHERTASK_MAXFILESIZE); // max. 2 MB\n                base = contextUrl = response.getEffectiveURI().toURL();\n                // may have changed after a 30x result code\n                // to do: record the link between original and effective URL\n                // like this the effectiveURL may be crawled twice\n\n\n                if (fullBuffer != null)\n                {\n                    contentLength = fullBuffer.length;\n                    this.bytesRead += contentLength;\n                }\n            }\n            //conn.stop();    // close connection. todo: Do some caching...\n\n\n            /*\n             *  conn.disconnect();\n             */\n            if (isInterrupted)\n            {\n                System.out.println(\"FetcherTask: interrupted while reading. File truncated\");\n                log.log(\"interrupted while reading. File truncated\");\n            }\n            else\n            {\n                if (fullBuffer != null)\n                {\n                    taskState.setState(FT_SCANNING, ipURL);\n\n                    log.log(\"read file (\" + fullBuffer.length + \" bytes). Now scanning.\");\n\n                    if (contentType.startsWith(\"text/html\"))\n                    {\n\n                        // ouch. I haven't found a better solution yet. just slower ones.\n                        char[] fullCharBuffer = new char[contentLength];\n                        new InputStreamReader(new ByteArrayInputStream(fullBuffer)).read(fullCharBuffer);\n                        Tokenizer tok = new Tokenizer();\n                        tok.setLinkHandler(this);\n                        tok.parse(new SimpleCharArrayReader(fullCharBuffer));\n\n                        taskState.setState(FT_STORING, ipURL);\n                        linkStorage.storeLinks(foundUrls);\n                        WebDocument d = new WebDocument(contextUrl, contentType, statusCode, actURLMessage.getReferer(), contentLength, title, date, hostManager);\n                        d.addField(\"content\", fullCharBuffer);\n                        docStorage.store(d);\n                    }\n                    else\n                    {\n                        // System.out.println(\"Discovered unknown content type: \" + contentType + \" at \" + urlString);\n                        //errorLog.log(\"[\" + threadNr + \"] Discovered unknown content type at \" + urlString + \": \" + contentType + \". just storing\");\n                        taskState.setState(FT_STORING, ipURL);\n                        linkStorage.storeLinks(foundUrls);\n                        WebDocument d = new WebDocument(contextUrl, contentType, statusCode, actURLMessage.getReferer(), contentLength, title, date, hostManager);\n                        d.addField(\"content\", fullBuffer);\n                        docStorage.store(d);\n                    }\n                    log.log(\"scanned\");\n                }\n\n                log.log(\"stored\");\n            }\n        }\n        catch (InterruptedIOException e)\n        {\n            // timeout while reading this file\n            //System.out.println(\"[\" + threadNr + \"] FetcherTask: Timeout while opening: \" + this.actURLMessage.getUrl());\n            errorLog.log(\"error: Timeout: \" + this.actURLMessage.getUrl());\n            hi.badRequest();\n        }\n        catch (FileNotFoundException e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            //System.out.println(\"[\" + threadNr + \"] FetcherTask: File not Found: \" + this.actURLMessage.getUrl());\n            errorLog.log(\"error: File not Found: \" + this.actURLMessage.getUrl());\n        }\n        catch(NoRouteToHostException e)\n        {\n            // router is down or firewall prevents to connect\n            hi.setReachable(false);\n            taskState.setState(FT_EXCEPTION);\n            //System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n        }\n        catch(ConnectException e)\n        {\n            // no server is listening at this port\n            hi.setReachable(false);\n            taskState.setState(FT_EXCEPTION);\n            //System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n        }\n        catch (SocketException e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            //System.out.println(\"[\" + threadNr + \"]: SocketException:\" + e.getMessage());\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n\n        }\n        catch(UnknownHostException e)\n        {\n            // IP Address not to be determined\n            hi.setReachable(false);\n            taskState.setState(FT_EXCEPTION);\n            //System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n\n        }\n        catch (IOException e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            //System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: IOException: \" + e.getClass().getName() + \": \" + e.getMessage());\n\n        }\n        catch (OutOfMemoryError ome)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] Task \" + this.taskNr + \" OutOfMemory after \" + size + \" bytes\");\n            errorLog.log(\"error: OutOfMemory after \" + size + \" bytes\");\n        }\n        catch (Throwable e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getMessage() + \" type: \" + e.getClass().getName());\n            e.printStackTrace();\n            System.out.println(\"[\" + threadNr + \"]: stopping\");\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage() + \"; stopping\");\n\n        }\n        finally\n        {\n\n            if (isInterrupted)\n            {\n                System.out.println(\"Task was interrupted\");\n                log.log(\"interrupted\");\n                taskState.setState(FT_INTERRUPTED);\n            }\n        }\n        if (isInterrupted)\n        {\n            System.out.println(\"Task: closed everything\");\n        }\n        /*\n         *  }\n         */\n        taskState.setState(FT_CLOSING);\n        conn.stop();\n\n        taskState.setState(FT_READY);\n        foundUrls = null;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"afc16d717d9ed1a8e45371668ca6de674164d624","date":1103345442,"type":4,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"/dev/null","pathOld":"sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/FetcherTask#run(ServerThread).mjava","sourceNew":null,"sourceOld":"    /**\n     * this will be called by the fetcher thread and will do all the work\n     *\n     * @param thread  Description of the Parameter\n     * @TODO          probably split this up into different processing steps\n     */\n    public void run(ServerThread thread)\n    {\n\n\n        taskState.setState(FT_STARTED);\n        // state information is always set to make the thread monitor happy\n\n        log = thread.getLog();\n        hostManager = ((FetcherThread) thread).getHostManager();\n        hostResolver = hostManager.getHostResolver();\n        base = contextUrl = actURLMessage.getUrl();\n        String urlString = actURLMessage.getURLString();\n        String host = contextUrl.getHost().toLowerCase();\n        HostInfo hi = hostManager.getHostInfo(host);\n//        System.out.println(\"FetcherTask with \" + urlString + \" started\");\n        if(actURLMessage.linkType == URLMessage.LINKTYPE_REDIRECT)\n        {\n            taskState.setState(FT_READY, null);\n            hi.releaseLock();\n            return;     // we've already crawled that (see below)\n        }\n\n        NVPair[] headers = ((FetcherThread) thread).getDefaultHeaders();\n        int numHeaders = ((FetcherThread) thread).getUsedDefaultHeaders();\n        boolean isIncremental = false;\n        if (actURLMessage instanceof WebDocument)\n        {\n            // this is an incremental crawl where we only have to check whether the doc crawled\n            // is newer\n            isIncremental = true;\n            headers[numHeaders] = new NVPair(\"If-Modified-Since\", HTTPClient.Util.httpDate(((WebDocument) actURLMessage).getLastModified()));\n        }\n        //HostManager hm = ((FetcherThread)thread).getHostManager();\n\n        errorLog = thread.getErrorLog();\n\n        // startTime = System.currentTimeMillis();\n        int threadNr = ((FetcherThread) thread).getThreadNumber();\n\n        log.log(\"start\");\n        int hostPos = urlString.indexOf(host);\n        int hostLen = host.length();\n\n        // get and create\n\n        if (!hi.isHealthy())\n        {\n            // we make this check as late as possible to get the most current information\n            log.log(\"Bad Host: \" + contextUrl + \"; returning\");\n//            System.out.println(\"[\" + threadNr + \"] bad host: \" + this.actURLMessage.getUrl());\n\n            taskState.setState(FT_READY, null);\n            hi.releaseLock();\n            return;\n        }\n\n        foundUrls = new java.util.LinkedList();\n\n        HTTPConnection conn = null;\n\n        title = \"\";\n\n        int size = 1;\n\n        InputStream in = null;\n        bytesRead = 0;\n\n        try\n        {\n\n            URL ipURL = contextUrl;\n\n            taskState.setState(FT_OPENCONNECTION, urlString);\n\n            log.log(\"connecting to \" + ipURL.getHost());\n            taskState.setState(FT_CONNECTING, ipURL);\n            conn = new HTTPConnection(host);\n\n            conn.setDefaultTimeout(75000);\n\n            // 75 s\n            conn.setDefaultAllowUserInteraction(false);\n\n            taskState.setState(this.FT_GETTING, ipURL);\n            log.log(\"getting\");\n\n            HTTPResponse response = conn.Get(ipURL.getFile(), \"\", headers);\n            response.setReadIncrement(2720);\n            int statusCode = response.getStatusCode();\n            byte[] fullBuffer = null;\n            String contentType = \"\";\n            int contentLength = 0;\n            Date date = null;\n\n             if (isIncremental)\n            {\n                // experimental\n                System.out.println(\"ftask: if modified since: \" + HTTPClient.Util.httpDate(((WebDocument) actURLMessage).getLastModified()));\n            }\n\n            URL realURL;\n\n            switch (statusCode)\n            {\n                case 404:                // file not found\n                case 403:                    // access forbidden\n\n                    // if this is an incremental crawl, remove the doc from the repository\n                    if (isIncremental)\n                    {\n                        WebDocument d = (WebDocument) actURLMessage;\n                        d.setResultCode(statusCode);\n                        // the repository will remove the doc if this statuscode is matched\n                        docStorage.store(d);\n                    }\n                    // otherwise, do nothing\n                    // Todo: we could add an error marker to the referal link\n                    break;\n                case 304:\n                    // not modified\n                    System.out.println(\"ftask: -> not modified\");\n                    // \"not modified since\"\n                    taskState.setState(FT_STORING, ipURL);\n                    // let the repository take care of the links\n                    // it will determine that this is the old document (because it already\n                    // has a docId), and will put back the links associated with it\n                    try\n                    {\n                        WebDocument doc = (WebDocument) this.actURLMessage;\n                        doc.setModified(false);\n                        docStorage.store(doc);\n                        this.bytesRead += doc.getSize();\n                    }\n                    catch (ClassCastException e)\n                    {\n                        System.out.println(\"error while casting to WebDoc: \" + actURLMessage.getInfo());\n                    }\n                    break;\n                case 301:                // moved permanently\n                case 302:                // moved temporarily\n                case 303:                // see other\n                case 307:                // temporary redirect\n                    /*\n                     *  this is a redirect. save it as a link and return.\n                     *  note that we could read the doc from the open connection here, but this could mean\n                     *  the filters were useless\n                     */\n                    realURL = response.getEffectiveURI().toURL();\n                    foundUrls.add(new URLMessage(realURL, contextUrl, URLMessage.LINKTYPE_REDIRECT, \"\", hostResolver));\n                    linkStorage.storeLinks(foundUrls);\n                    break;\n                default:\n                    // this can be a 30x code that was resolved by the HTTPClient and is passed to us as 200\n                    // we could turn this off and do it ourselves. But then we'd have to take care that\n                    // we don't get into an endless redirection loop -> i.e. extend URLMessage by a counter\n                    // at the moment we add the real URL to the message queue and mark it as a REDIRECT link\n                    // that way it is added to the visited filter. Then we take care that we don't crawl it again\n\n                    // the other possibility is that we receive a \"Location:\" header along with a 200 status code\n                    // I have experienced that HTTPClient has an error with parsing this, so we do it ourselves\n                    //String location = response.getHeader(\"Location\");\n                    realURL = response.getEffectiveURI().toURL();\n\n                    /*if(location != null)\n                    {\n                        //System.out.println(\"interesting: location header with url \" + location);\n                        foundUrls.add(new URLMessage(new URL(location), contextUrl, URLMessage.LINKTYPE_REDIRECT, \"\", hostManager));\n                        this.base = this.contextUrl = location;\n                    }\n                    else*/\n                    if(!(realURL.equals(contextUrl)))\n                    {\n                        //System.out.println(\"interesting: redirect with url \" + realURL + \" -context: \" + contextUrl);\n                        foundUrls.add(new URLMessage(realURL, contextUrl, URLMessage.LINKTYPE_REDIRECT, \"\", hostResolver));\n                        this.base = this.contextUrl = realURL;\n                        //System.out.println(response);\n\n                    }\n\n\n\n\n                    if (isIncremental)\n                    {\n                        // experimental\n                        System.out.println(\"ftask: -> was modified at \" + response.getHeaderAsDate(\"Last-Modified\"));\n                    }\n                    // read up to Constants.FETCHERTASK_MAXFILESIZE bytes into a byte array\n                    taskState.setState(FT_READING, ipURL);\n                    contentType = response.getHeader(\"Content-Type\");\n                    String length = response.getHeader(\"Content-Length\");\n                    date = response.getHeaderAsDate(\"Last-Modified\");\n\n                    if (length != null)\n                    {\n                        contentLength = Integer.parseInt(length);\n                    }\n                    log.log(\"reading\");\n                    realURL = response.getEffectiveURI().toURL();\n                    if (contentType != null && contentType.startsWith(\"text/html\"))\n                    {\n                        fullBuffer = response.getData(Constants.FETCHERTASK_MAXFILESIZE);\n                        hi.releaseLock();\n                        // max. 2 MB\n                        if (fullBuffer != null)\n                        {\n                            contentLength = fullBuffer.length;\n                            this.bytesRead += contentLength;\n                        }\n\n                        /*\n                         *  conn.disconnect();\n                         */\n                        if (isInterrupted)\n                        {\n                            System.out.println(\"FetcherTask: interrupted while reading. File truncated\");\n                            log.log(\"interrupted while reading. File truncated\");\n                        }\n                        else\n                        {\n                            if (fullBuffer != null)\n                            {\n                                taskState.setState(FT_SCANNING, ipURL);\n\n                                log.log(\"read file (\" + fullBuffer.length + \" bytes). Now scanning.\");\n\n                                // convert the bytes to Java characters\n                                // ouch. I haven't found a better solution yet. just slower ones.\n                                // remember: for better runtime performance avoid decorators, since they\n                                // multiply function calls\n                                char[] fullCharBuffer = new char[contentLength];\n                                new InputStreamReader(new ByteArrayInputStream(fullBuffer)).read(fullCharBuffer);\n                                Tokenizer tok = new Tokenizer();\n                                tok.setLinkHandler(this);\n                                tok.parse(new SimpleCharArrayReader(fullCharBuffer));\n\n                                taskState.setState(FT_STORING, ipURL);\n                                linkStorage.storeLinks(foundUrls);\n                                WebDocument d;\n                                if (isIncremental)\n                                {\n                                    d = ((WebDocument) this.actURLMessage);\n                                    d.setModified(true);\n                                    // file is new or newer\n                                    d.setUrl(contextUrl);\n                                    d.setMimeType(contentType);\n                                    d.setResultCode(statusCode);\n                                    d.setSize(contentLength);\n                                    d.setTitle(title);\n                                    d.setLastModified(date);\n                                }\n                                else\n                                {\n                                    d = new WebDocument(contextUrl, contentType, statusCode, actURLMessage.getReferer(), contentLength, title, date, hostResolver);\n                                }\n                                d.addField(\"content\", fullCharBuffer);\n                                d.addField(\"contentBytes\", fullBuffer);\n                                docStorage.store(d);\n                            }\n\n                            log.log(\"scanned\");\n                        }\n\n                        log.log(\"stored\");\n                    }\n                    else\n                    {\n                        // System.out.println(\"Discovered unknown content type: \" + contentType + \" at \" + urlString);\n                        //errorLog.log(\"[\" + threadNr + \"] Discovered unknown content type at \" + urlString + \": \" + contentType + \". just storing\");\n                        taskState.setState(FT_STORING, ipURL);\n                        linkStorage.storeLinks(foundUrls);\n                        WebDocument d = new WebDocument(contextUrl, contentType, statusCode, actURLMessage.getReferer(),\n                        /*\n                         *  contentLength\n                         */\n                                0, title, date, hostResolver);\n                        //d.addField(\"content\", fullBuffer);\n                        //d.addField(\"content\", null);\n                        docStorage.store(d);\n                    }\n                    break;\n            }\n            /*\n             *  switch\n             */\n            //conn.stop();    // close connection. todo: Do some caching...\n\n        }\n        catch (InterruptedIOException e)\n        {\n            // timeout while reading this file\n            //System.out.println(\"[\" + threadNr + \"] FetcherTask: Timeout while opening: \" + this.actURLMessage.getUrl());\n            errorLog.log(\"error: Timeout: \" + this.actURLMessage.getUrl());\n            hi.badRequest();\n        }\n        catch (FileNotFoundException e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            //System.out.println(\"[\" + threadNr + \"] FetcherTask: File not Found: \" + this.actURLMessage.getUrl());\n            errorLog.log(\"error: File not Found: \" + this.actURLMessage.getUrl());\n        }\n        catch (NoRouteToHostException e)\n        {\n            // router is down or firewall prevents to connect\n            hi.setReachable(false);\n            taskState.setState(FT_EXCEPTION);\n            //System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n        }\n        catch (ConnectException e)\n        {\n            // no server is listening at this port\n            hi.setReachable(false);\n            taskState.setState(FT_EXCEPTION);\n            //System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n\n        }\n        catch (SocketException e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            //System.out.println(\"[\" + threadNr + \"]: SocketException:\" + e.getMessage());\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n\n        }\n        catch (UnknownHostException e)\n        {\n            // IP Address not to be determined\n            hi.setReachable(false);\n            taskState.setState(FT_EXCEPTION);\n            //System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage());\n\n        }\n        catch (IOException e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            //System.out.println(\"[\" + threadNr + \"] \" + e.getClass().getName() + \": \" + e.getMessage());\n            // e.printStackTrace();\n            errorLog.log(\"error: IOException: \" + e.getClass().getName() + \": \" + e.getMessage());\n\n        }\n        catch (OutOfMemoryError ome)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] Task \" + this.taskNr + \" OutOfMemory after \" + size + \" bytes\");\n            errorLog.log(\"error: OutOfMemory after \" + size + \" bytes\");\n        }\n        catch (Throwable e)\n        {\n            taskState.setState(FT_EXCEPTION);\n            System.out.println(\"[\" + threadNr + \"] \" + e.getMessage() + \" type: \" + e.getClass().getName());\n            e.printStackTrace();\n            System.out.println(\"[\" + threadNr + \"]: stopping\");\n            errorLog.log(\"error: \" + e.getClass().getName() + \": \" + e.getMessage() + \"; stopping\");\n        }\n        finally\n        {\n            hi.releaseLock();\n\n            if (isInterrupted)\n            {\n                System.out.println(\"Task was interrupted\");\n                log.log(\"interrupted\");\n                taskState.setState(FT_INTERRUPTED);\n            }\n        }\n        if (isInterrupted)\n        {\n            System.out.println(\"Task: closed everything\");\n        }\n        /*\n         *  }\n         */\n        taskState.setState(FT_CLOSING);\n        conn.stop();\n        taskState.setState(FT_READY);\n        foundUrls = null;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e56132d241479de027bc013a7094c731e7bb581e":["19f3112e7cf0a35b5b8d45069103cd045ed7a583"],"12c7634bf3bb6da687c9b32ca310e7fb8fac8e1e":["05d36e0b328ec96237035fbcca240e73631396e5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"afc16d717d9ed1a8e45371668ca6de674164d624":["35d2a11130c55c5aebafaa8a680a571684104914"],"05d36e0b328ec96237035fbcca240e73631396e5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"19f3112e7cf0a35b5b8d45069103cd045ed7a583":["12c7634bf3bb6da687c9b32ca310e7fb8fac8e1e"],"35d2a11130c55c5aebafaa8a680a571684104914":["e56132d241479de027bc013a7094c731e7bb581e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["afc16d717d9ed1a8e45371668ca6de674164d624"]},"commit2Childs":{"e56132d241479de027bc013a7094c731e7bb581e":["35d2a11130c55c5aebafaa8a680a571684104914"],"12c7634bf3bb6da687c9b32ca310e7fb8fac8e1e":["19f3112e7cf0a35b5b8d45069103cd045ed7a583"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["05d36e0b328ec96237035fbcca240e73631396e5"],"afc16d717d9ed1a8e45371668ca6de674164d624":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"05d36e0b328ec96237035fbcca240e73631396e5":["12c7634bf3bb6da687c9b32ca310e7fb8fac8e1e"],"19f3112e7cf0a35b5b8d45069103cd045ed7a583":["e56132d241479de027bc013a7094c731e7bb581e"],"35d2a11130c55c5aebafaa8a680a571684104914":["afc16d717d9ed1a8e45371668ca6de674164d624"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}