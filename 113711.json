{"path":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/kuromoji/viterbi/Viterbi#build(char[],int,int).mjava","commits":[{"id":"6ae8b8ec55786d06eb9b03fc7bc86a907e1a3ae2","date":1326399048,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/kuromoji/viterbi/Viterbi#build(char[],int,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Build lattice from input text\n   * @param text\n   */\n  public ViterbiNode[][][] build(char text[], int offset, int length) throws IOException {\n    ViterbiNode[][] startIndexArr = new ViterbiNode[length + 2][];  // text length + BOS and EOS\n    ViterbiNode[][] endIndexArr = new ViterbiNode[length + 2][];  // text length + BOS and EOS\n    int[] startSizeArr = new int[length + 2]; // array to keep ViterbiNode count in startIndexArr\n    int[] endSizeArr = new int[length + 2];   // array to keep ViterbiNode count in endIndexArr\n    FST.Arc<Long> arc = new FST.Arc<Long>();\n    ViterbiNode bosNode = new ViterbiNode(-1, BOS, 0, BOS.length, 0, 0, 0, -1, Type.KNOWN);\n    addToArrays(bosNode, 0, 1, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n    \n    // Process user dictionary;\n    if (useUserDictionary) {\n      processUserDictionary(text, offset, length, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n    }\n    \n    int unknownWordEndIndex = -1;\t// index of the last character of unknown word\n    \n    final IntsRef wordIdRef = new IntsRef();\n    \n    for (int startIndex = 0; startIndex < length; startIndex++) {\n      // If no token ends where current token starts, skip this index\n      if (endSizeArr[startIndex + 1] == 0) {\n        continue;\n      }\n      \n      int suffixStart = offset + startIndex;\n      int suffixLength = length - startIndex;\n      \n      boolean found = false;\n      arc = fst.getFirstArc(arc);\n      int output = 0;\n      for (int endIndex = 1; endIndex < suffixLength + 1; endIndex++) {\n        int ch = text[suffixStart + endIndex - 1];\n        \n        if (fst.findTargetArc(ch, arc, arc, endIndex == 1) == null) {\n          break; // continue to next position\n        }\n        output += arc.output.intValue();\n\n        if (arc.isFinal()) {\n          output += arc.nextFinalOutput.intValue();\n          found = true; // Don't produce unknown word starting from this index\n          dictionary.lookupWordIds(output, wordIdRef);\n          for (int ofs = 0; ofs < wordIdRef.length; ofs++) {\n            final int wordId = wordIdRef.ints[wordIdRef.offset + ofs];\n            ViterbiNode node = new ViterbiNode(wordId, text, suffixStart, endIndex, dictionary.getLeftId(wordId), dictionary.getRightId(wordId), dictionary.getWordCost(wordId), startIndex, Type.KNOWN);\n            addToArrays(node, startIndex + 1, startIndex + 1 + endIndex, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n          }\n        }\n      }\n      \n      // In the case of normal mode, it doesn't process unknown word greedily.\n      if(!searchMode && unknownWordEndIndex > startIndex){\n        continue;\n      }\n      \n      // Process Unknown Word: hmm what is this isInvoke logic (same no matter what)\n      int unknownWordLength = 0;\n      char firstCharacter = text[suffixStart];\n      boolean isInvoke = characterDefinition.isInvoke(firstCharacter);\n      if (isInvoke){\t// Process \"invoke\"\n        unknownWordLength = unkDictionary.lookup(text, suffixStart, suffixLength);\n      } else if (found == false){\t// Process not \"invoke\"\n        unknownWordLength = unkDictionary.lookup(text, suffixStart, suffixLength);\t\t\t\t\n      }\n      \n      if (unknownWordLength > 0) {      // found unknown word\n        final int characterId = characterDefinition.getCharacterClass(firstCharacter);\n        unkDictionary.lookupWordIds(characterId, wordIdRef); // characters in input text are supposed to be the same\n        for (int ofs = 0; ofs < wordIdRef.length; ofs++) {\n          final int wordId = wordIdRef.ints[wordIdRef.offset + ofs];\n          ViterbiNode node = new ViterbiNode(wordId, text, suffixStart, unknownWordLength, unkDictionary.getLeftId(wordId), unkDictionary.getRightId(wordId), unkDictionary.getWordCost(wordId), startIndex, Type.UNKNOWN);\n          addToArrays(node, startIndex + 1, startIndex + 1 + unknownWordLength, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n        }\n        unknownWordEndIndex = startIndex + unknownWordLength;\n      }\n    }\n    \n    ViterbiNode eosNode = new ViterbiNode(-1, EOS, 0, EOS.length, 0, 0, 0, length + 1, Type.KNOWN);\n    addToArrays(eosNode, length + 1, 0, startIndexArr, endIndexArr, startSizeArr, endSizeArr); //Add EOS node to endIndexArr at index 0\n    \n    ViterbiNode[][][] result = new ViterbiNode[][][]{startIndexArr, endIndexArr};\n    \n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b3be20ca1091c0b7cdb2308b9023606a5e451cec","date":1327877325,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/kuromoji/viterbi/Viterbi#build(char[],int,int).mjava","pathOld":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/kuromoji/viterbi/Viterbi#build(char[],int,int).mjava","sourceNew":"  /**\n   * Build lattice from input text\n   * @param text\n   */\n  public ViterbiNode[][][] build(char text[], int offset, int length) throws IOException {\n    ViterbiNode[][] startIndexArr = new ViterbiNode[length + 2][];  // text length + BOS and EOS\n    ViterbiNode[][] endIndexArr = new ViterbiNode[length + 2][];  // text length + BOS and EOS\n    int[] startSizeArr = new int[length + 2]; // array to keep ViterbiNode count in startIndexArr\n    int[] endSizeArr = new int[length + 2];   // array to keep ViterbiNode count in endIndexArr\n    FST.Arc<Long> arc = new FST.Arc<Long>();\n    ViterbiNode bosNode = new ViterbiNode(-1, BOS, 0, BOS.length, 0, 0, 0, -1, Type.KNOWN);\n    addToArrays(bosNode, 0, 1, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n    \n    final FST.BytesReader fstReader = fst.getBytesReader(0);\n\n    // Process user dictionary;\n    if (useUserDictionary) {\n      processUserDictionary(text, offset, length, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n    }\n    \n    int unknownWordEndIndex = -1;\t// index of the last character of unknown word\n    \n    final IntsRef wordIdRef = new IntsRef();\n    \n    for (int startIndex = 0; startIndex < length; startIndex++) {\n      // If no token ends where current token starts, skip this index\n      if (endSizeArr[startIndex + 1] == 0) {\n        continue;\n      }\n      \n      int suffixStart = offset + startIndex;\n      int suffixLength = length - startIndex;\n      \n      boolean found = false;\n      arc = fst.getFirstArc(arc);\n      int output = 0;\n      for (int endIndex = 1; endIndex < suffixLength + 1; endIndex++) {\n        int ch = text[suffixStart + endIndex - 1];\n        \n        if (fst.findTargetArc(ch, arc, arc, endIndex == 1, fstReader) == null) {\n          break; // continue to next position\n        }\n        output += arc.output.intValue();\n\n        if (arc.isFinal()) {\n          output += arc.nextFinalOutput.intValue();\n          found = true; // Don't produce unknown word starting from this index\n          dictionary.lookupWordIds(output, wordIdRef);\n          for (int ofs = 0; ofs < wordIdRef.length; ofs++) {\n            final int wordId = wordIdRef.ints[wordIdRef.offset + ofs];\n            ViterbiNode node = new ViterbiNode(wordId, text, suffixStart, endIndex, dictionary.getLeftId(wordId), dictionary.getRightId(wordId), dictionary.getWordCost(wordId), startIndex, Type.KNOWN);\n            addToArrays(node, startIndex + 1, startIndex + 1 + endIndex, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n          }\n        }\n      }\n      \n      // In the case of normal mode, it doesn't process unknown word greedily.\n      if(!searchMode && unknownWordEndIndex > startIndex){\n        continue;\n      }\n      \n      // Process Unknown Word: hmm what is this isInvoke logic (same no matter what)\n      int unknownWordLength = 0;\n      char firstCharacter = text[suffixStart];\n      boolean isInvoke = characterDefinition.isInvoke(firstCharacter);\n      if (isInvoke){\t// Process \"invoke\"\n        unknownWordLength = unkDictionary.lookup(text, suffixStart, suffixLength);\n      } else if (found == false){\t// Process not \"invoke\"\n        unknownWordLength = unkDictionary.lookup(text, suffixStart, suffixLength);\t\t\t\t\n      }\n      \n      if (unknownWordLength > 0) {      // found unknown word\n        final int characterId = characterDefinition.getCharacterClass(firstCharacter);\n        unkDictionary.lookupWordIds(characterId, wordIdRef); // characters in input text are supposed to be the same\n        for (int ofs = 0; ofs < wordIdRef.length; ofs++) {\n          final int wordId = wordIdRef.ints[wordIdRef.offset + ofs];\n          ViterbiNode node = new ViterbiNode(wordId, text, suffixStart, unknownWordLength, unkDictionary.getLeftId(wordId), unkDictionary.getRightId(wordId), unkDictionary.getWordCost(wordId), startIndex, Type.UNKNOWN);\n          addToArrays(node, startIndex + 1, startIndex + 1 + unknownWordLength, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n        }\n        unknownWordEndIndex = startIndex + unknownWordLength;\n      }\n    }\n    \n    ViterbiNode eosNode = new ViterbiNode(-1, EOS, 0, EOS.length, 0, 0, 0, length + 1, Type.KNOWN);\n    addToArrays(eosNode, length + 1, 0, startIndexArr, endIndexArr, startSizeArr, endSizeArr); //Add EOS node to endIndexArr at index 0\n    \n    ViterbiNode[][][] result = new ViterbiNode[][][]{startIndexArr, endIndexArr};\n    \n    return result;\n  }\n\n","sourceOld":"  /**\n   * Build lattice from input text\n   * @param text\n   */\n  public ViterbiNode[][][] build(char text[], int offset, int length) throws IOException {\n    ViterbiNode[][] startIndexArr = new ViterbiNode[length + 2][];  // text length + BOS and EOS\n    ViterbiNode[][] endIndexArr = new ViterbiNode[length + 2][];  // text length + BOS and EOS\n    int[] startSizeArr = new int[length + 2]; // array to keep ViterbiNode count in startIndexArr\n    int[] endSizeArr = new int[length + 2];   // array to keep ViterbiNode count in endIndexArr\n    FST.Arc<Long> arc = new FST.Arc<Long>();\n    ViterbiNode bosNode = new ViterbiNode(-1, BOS, 0, BOS.length, 0, 0, 0, -1, Type.KNOWN);\n    addToArrays(bosNode, 0, 1, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n    \n    // Process user dictionary;\n    if (useUserDictionary) {\n      processUserDictionary(text, offset, length, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n    }\n    \n    int unknownWordEndIndex = -1;\t// index of the last character of unknown word\n    \n    final IntsRef wordIdRef = new IntsRef();\n    \n    for (int startIndex = 0; startIndex < length; startIndex++) {\n      // If no token ends where current token starts, skip this index\n      if (endSizeArr[startIndex + 1] == 0) {\n        continue;\n      }\n      \n      int suffixStart = offset + startIndex;\n      int suffixLength = length - startIndex;\n      \n      boolean found = false;\n      arc = fst.getFirstArc(arc);\n      int output = 0;\n      for (int endIndex = 1; endIndex < suffixLength + 1; endIndex++) {\n        int ch = text[suffixStart + endIndex - 1];\n        \n        if (fst.findTargetArc(ch, arc, arc, endIndex == 1) == null) {\n          break; // continue to next position\n        }\n        output += arc.output.intValue();\n\n        if (arc.isFinal()) {\n          output += arc.nextFinalOutput.intValue();\n          found = true; // Don't produce unknown word starting from this index\n          dictionary.lookupWordIds(output, wordIdRef);\n          for (int ofs = 0; ofs < wordIdRef.length; ofs++) {\n            final int wordId = wordIdRef.ints[wordIdRef.offset + ofs];\n            ViterbiNode node = new ViterbiNode(wordId, text, suffixStart, endIndex, dictionary.getLeftId(wordId), dictionary.getRightId(wordId), dictionary.getWordCost(wordId), startIndex, Type.KNOWN);\n            addToArrays(node, startIndex + 1, startIndex + 1 + endIndex, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n          }\n        }\n      }\n      \n      // In the case of normal mode, it doesn't process unknown word greedily.\n      if(!searchMode && unknownWordEndIndex > startIndex){\n        continue;\n      }\n      \n      // Process Unknown Word: hmm what is this isInvoke logic (same no matter what)\n      int unknownWordLength = 0;\n      char firstCharacter = text[suffixStart];\n      boolean isInvoke = characterDefinition.isInvoke(firstCharacter);\n      if (isInvoke){\t// Process \"invoke\"\n        unknownWordLength = unkDictionary.lookup(text, suffixStart, suffixLength);\n      } else if (found == false){\t// Process not \"invoke\"\n        unknownWordLength = unkDictionary.lookup(text, suffixStart, suffixLength);\t\t\t\t\n      }\n      \n      if (unknownWordLength > 0) {      // found unknown word\n        final int characterId = characterDefinition.getCharacterClass(firstCharacter);\n        unkDictionary.lookupWordIds(characterId, wordIdRef); // characters in input text are supposed to be the same\n        for (int ofs = 0; ofs < wordIdRef.length; ofs++) {\n          final int wordId = wordIdRef.ints[wordIdRef.offset + ofs];\n          ViterbiNode node = new ViterbiNode(wordId, text, suffixStart, unknownWordLength, unkDictionary.getLeftId(wordId), unkDictionary.getRightId(wordId), unkDictionary.getWordCost(wordId), startIndex, Type.UNKNOWN);\n          addToArrays(node, startIndex + 1, startIndex + 1 + unknownWordLength, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n        }\n        unknownWordEndIndex = startIndex + unknownWordLength;\n      }\n    }\n    \n    ViterbiNode eosNode = new ViterbiNode(-1, EOS, 0, EOS.length, 0, 0, 0, length + 1, Type.KNOWN);\n    addToArrays(eosNode, length + 1, 0, startIndexArr, endIndexArr, startSizeArr, endSizeArr); //Add EOS node to endIndexArr at index 0\n    \n    ViterbiNode[][][] result = new ViterbiNode[][][]{startIndexArr, endIndexArr};\n    \n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"817882884229bace7dc5d1b75f6b0e4aa1e47122","date":1327879145,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/kuromoji/viterbi/Viterbi#build(char[],int,int).mjava","pathOld":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/kuromoji/viterbi/Viterbi#build(char[],int,int).mjava","sourceNew":"  /**\n   * Build lattice from input text\n   * @param text\n   */\n  public ViterbiNode[][][] build(char text[], int offset, int length) throws IOException {\n    ViterbiNode[][] startIndexArr = new ViterbiNode[length + 2][];  // text length + BOS and EOS\n    ViterbiNode[][] endIndexArr = new ViterbiNode[length + 2][];  // text length + BOS and EOS\n    int[] startSizeArr = new int[length + 2]; // array to keep ViterbiNode count in startIndexArr\n    int[] endSizeArr = new int[length + 2];   // array to keep ViterbiNode count in endIndexArr\n    FST.Arc<Long> arc = new FST.Arc<Long>();\n    ViterbiNode bosNode = new ViterbiNode(-1, BOS, 0, BOS.length, 0, 0, 0, -1, Type.KNOWN);\n    addToArrays(bosNode, 0, 1, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n    \n    final FST.BytesReader fstReader = fst.getBytesReader(0);\n\n    // Process user dictionary;\n    if (useUserDictionary) {\n      processUserDictionary(text, offset, length, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n    }\n    \n    int unknownWordEndIndex = -1;\t// index of the last character of unknown word\n    \n    final IntsRef wordIdRef = new IntsRef();\n    \n    for (int startIndex = 0; startIndex < length; startIndex++) {\n      // If no token ends where current token starts, skip this index\n      if (endSizeArr[startIndex + 1] == 0) {\n        continue;\n      }\n      \n      int suffixStart = offset + startIndex;\n      int suffixLength = length - startIndex;\n      \n      boolean found = false;\n      arc = fst.getFirstArc(arc);\n      int output = 0;\n      for (int endIndex = 1; endIndex < suffixLength + 1; endIndex++) {\n        int ch = text[suffixStart + endIndex - 1];\n        \n        if (fst.findTargetArc(ch, arc, arc, endIndex == 1, fstReader) == null) {\n          break; // continue to next position\n        }\n        output += arc.output.intValue();\n\n        if (arc.isFinal()) {\n          output += arc.nextFinalOutput.intValue();\n          found = true; // Don't produce unknown word starting from this index\n          dictionary.lookupWordIds(output, wordIdRef);\n          for (int ofs = 0; ofs < wordIdRef.length; ofs++) {\n            final int wordId = wordIdRef.ints[wordIdRef.offset + ofs];\n            ViterbiNode node = new ViterbiNode(wordId, text, suffixStart, endIndex, dictionary.getLeftId(wordId), dictionary.getRightId(wordId), dictionary.getWordCost(wordId), startIndex, Type.KNOWN);\n            addToArrays(node, startIndex + 1, startIndex + 1 + endIndex, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n          }\n        }\n      }\n      \n      // In the case of normal mode, it doesn't process unknown word greedily.\n      if(!searchMode && unknownWordEndIndex > startIndex){\n        continue;\n      }\n      \n      // Process Unknown Word: hmm what is this isInvoke logic (same no matter what)\n      int unknownWordLength = 0;\n      char firstCharacter = text[suffixStart];\n      boolean isInvoke = characterDefinition.isInvoke(firstCharacter);\n      if (isInvoke){\t// Process \"invoke\"\n        unknownWordLength = unkDictionary.lookup(text, suffixStart, suffixLength);\n      } else if (found == false){\t// Process not \"invoke\"\n        unknownWordLength = unkDictionary.lookup(text, suffixStart, suffixLength);\t\t\t\t\n      }\n      \n      if (unknownWordLength > 0) {      // found unknown word\n        final int characterId = characterDefinition.getCharacterClass(firstCharacter);\n        unkDictionary.lookupWordIds(characterId, wordIdRef); // characters in input text are supposed to be the same\n        for (int ofs = 0; ofs < wordIdRef.length; ofs++) {\n          final int wordId = wordIdRef.ints[wordIdRef.offset + ofs];\n          ViterbiNode node = new ViterbiNode(wordId, text, suffixStart, unknownWordLength, unkDictionary.getLeftId(wordId), unkDictionary.getRightId(wordId), unkDictionary.getWordCost(wordId), startIndex, Type.UNKNOWN);\n          addToArrays(node, startIndex + 1, startIndex + 1 + unknownWordLength, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n        }\n        unknownWordEndIndex = startIndex + unknownWordLength;\n      }\n    }\n    \n    ViterbiNode eosNode = new ViterbiNode(-1, EOS, 0, EOS.length, 0, 0, 0, length + 1, Type.KNOWN);\n    addToArrays(eosNode, length + 1, 0, startIndexArr, endIndexArr, startSizeArr, endSizeArr); //Add EOS node to endIndexArr at index 0\n    \n    ViterbiNode[][][] result = new ViterbiNode[][][]{startIndexArr, endIndexArr};\n    \n    return result;\n  }\n\n","sourceOld":"  /**\n   * Build lattice from input text\n   * @param text\n   */\n  public ViterbiNode[][][] build(char text[], int offset, int length) throws IOException {\n    ViterbiNode[][] startIndexArr = new ViterbiNode[length + 2][];  // text length + BOS and EOS\n    ViterbiNode[][] endIndexArr = new ViterbiNode[length + 2][];  // text length + BOS and EOS\n    int[] startSizeArr = new int[length + 2]; // array to keep ViterbiNode count in startIndexArr\n    int[] endSizeArr = new int[length + 2];   // array to keep ViterbiNode count in endIndexArr\n    FST.Arc<Long> arc = new FST.Arc<Long>();\n    ViterbiNode bosNode = new ViterbiNode(-1, BOS, 0, BOS.length, 0, 0, 0, -1, Type.KNOWN);\n    addToArrays(bosNode, 0, 1, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n    \n    // Process user dictionary;\n    if (useUserDictionary) {\n      processUserDictionary(text, offset, length, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n    }\n    \n    int unknownWordEndIndex = -1;\t// index of the last character of unknown word\n    \n    final IntsRef wordIdRef = new IntsRef();\n    \n    for (int startIndex = 0; startIndex < length; startIndex++) {\n      // If no token ends where current token starts, skip this index\n      if (endSizeArr[startIndex + 1] == 0) {\n        continue;\n      }\n      \n      int suffixStart = offset + startIndex;\n      int suffixLength = length - startIndex;\n      \n      boolean found = false;\n      arc = fst.getFirstArc(arc);\n      int output = 0;\n      for (int endIndex = 1; endIndex < suffixLength + 1; endIndex++) {\n        int ch = text[suffixStart + endIndex - 1];\n        \n        if (fst.findTargetArc(ch, arc, arc, endIndex == 1) == null) {\n          break; // continue to next position\n        }\n        output += arc.output.intValue();\n\n        if (arc.isFinal()) {\n          output += arc.nextFinalOutput.intValue();\n          found = true; // Don't produce unknown word starting from this index\n          dictionary.lookupWordIds(output, wordIdRef);\n          for (int ofs = 0; ofs < wordIdRef.length; ofs++) {\n            final int wordId = wordIdRef.ints[wordIdRef.offset + ofs];\n            ViterbiNode node = new ViterbiNode(wordId, text, suffixStart, endIndex, dictionary.getLeftId(wordId), dictionary.getRightId(wordId), dictionary.getWordCost(wordId), startIndex, Type.KNOWN);\n            addToArrays(node, startIndex + 1, startIndex + 1 + endIndex, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n          }\n        }\n      }\n      \n      // In the case of normal mode, it doesn't process unknown word greedily.\n      if(!searchMode && unknownWordEndIndex > startIndex){\n        continue;\n      }\n      \n      // Process Unknown Word: hmm what is this isInvoke logic (same no matter what)\n      int unknownWordLength = 0;\n      char firstCharacter = text[suffixStart];\n      boolean isInvoke = characterDefinition.isInvoke(firstCharacter);\n      if (isInvoke){\t// Process \"invoke\"\n        unknownWordLength = unkDictionary.lookup(text, suffixStart, suffixLength);\n      } else if (found == false){\t// Process not \"invoke\"\n        unknownWordLength = unkDictionary.lookup(text, suffixStart, suffixLength);\t\t\t\t\n      }\n      \n      if (unknownWordLength > 0) {      // found unknown word\n        final int characterId = characterDefinition.getCharacterClass(firstCharacter);\n        unkDictionary.lookupWordIds(characterId, wordIdRef); // characters in input text are supposed to be the same\n        for (int ofs = 0; ofs < wordIdRef.length; ofs++) {\n          final int wordId = wordIdRef.ints[wordIdRef.offset + ofs];\n          ViterbiNode node = new ViterbiNode(wordId, text, suffixStart, unknownWordLength, unkDictionary.getLeftId(wordId), unkDictionary.getRightId(wordId), unkDictionary.getWordCost(wordId), startIndex, Type.UNKNOWN);\n          addToArrays(node, startIndex + 1, startIndex + 1 + unknownWordLength, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n        }\n        unknownWordEndIndex = startIndex + unknownWordLength;\n      }\n    }\n    \n    ViterbiNode eosNode = new ViterbiNode(-1, EOS, 0, EOS.length, 0, 0, 0, length + 1, Type.KNOWN);\n    addToArrays(eosNode, length + 1, 0, startIndexArr, endIndexArr, startSizeArr, endSizeArr); //Add EOS node to endIndexArr at index 0\n    \n    ViterbiNode[][][] result = new ViterbiNode[][][]{startIndexArr, endIndexArr};\n    \n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b6fdfce35d0adb18836cf8711abe487a934df33","date":1327946200,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/kuromoji/viterbi/Viterbi#build(char[],int,int).mjava","pathOld":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/kuromoji/viterbi/Viterbi#build(char[],int,int).mjava","sourceNew":"  /**\n   * Build lattice from input text\n   * @param text\n   */\n  public ViterbiNode[][][] build(char text[], int offset, int length) throws IOException {\n    ViterbiNode[][] startIndexArr = new ViterbiNode[length + 2][];  // text length + BOS and EOS\n    ViterbiNode[][] endIndexArr = new ViterbiNode[length + 2][];  // text length + BOS and EOS\n    int[] startSizeArr = new int[length + 2]; // array to keep ViterbiNode count in startIndexArr\n    int[] endSizeArr = new int[length + 2];   // array to keep ViterbiNode count in endIndexArr\n    FST.Arc<Long> arc = new FST.Arc<Long>();\n    ViterbiNode bosNode = new ViterbiNode(-1, BOS, 0, BOS.length, 0, 0, 0, -1, Type.KNOWN);\n    addToArrays(bosNode, 0, 1, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n    \n    final FST.BytesReader fstReader = fst.getBytesReader(0);\n\n    // Process user dictionary;\n    if (useUserDictionary) {\n      processUserDictionary(text, offset, length, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n    }\n    \n    int unknownWordEndIndex = -1;\t// index of the last character of unknown word\n    \n    final IntsRef wordIdRef = new IntsRef();\n    \n    for (int startIndex = 0; startIndex < length; startIndex++) {\n      // If no token ends where current token starts, skip this index\n      if (endSizeArr[startIndex + 1] == 0) {\n        continue;\n      }\n      \n      int suffixStart = offset + startIndex;\n      int suffixLength = length - startIndex;\n      \n      boolean found = false;\n      arc = fst.getFirstArc(arc);\n      int output = 0;\n      for (int endIndex = 1; endIndex < suffixLength + 1; endIndex++) {\n        int ch = text[suffixStart + endIndex - 1];\n        \n        if (fst.findTargetArc(ch, arc, arc, endIndex == 1, fstReader) == null) {\n          break; // continue to next position\n        }\n        output += arc.output.intValue();\n\n        if (arc.isFinal()) {\n          output += arc.nextFinalOutput.intValue();\n          found = true; // Don't produce unknown word starting from this index\n          dictionary.lookupWordIds(output, wordIdRef);\n          for (int ofs = 0; ofs < wordIdRef.length; ofs++) {\n            final int wordId = wordIdRef.ints[wordIdRef.offset + ofs];\n            ViterbiNode node = new ViterbiNode(wordId, text, suffixStart, endIndex, dictionary.getLeftId(wordId), dictionary.getRightId(wordId), dictionary.getWordCost(wordId), startIndex, Type.KNOWN);\n            addToArrays(node, startIndex + 1, startIndex + 1 + endIndex, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n          }\n        }\n      }\n      \n      // In the case of normal mode, it doesn't process unknown word greedily.\n      if(!searchMode && unknownWordEndIndex > startIndex){\n        continue;\n      }\n      \n      // Process Unknown Word: hmm what is this isInvoke logic (same no matter what)\n      int unknownWordLength = 0;\n      char firstCharacter = text[suffixStart];\n      boolean isInvoke = characterDefinition.isInvoke(firstCharacter);\n      if (isInvoke){\t// Process \"invoke\"\n        unknownWordLength = unkDictionary.lookup(text, suffixStart, suffixLength);\n      } else if (found == false){\t// Process not \"invoke\"\n        unknownWordLength = unkDictionary.lookup(text, suffixStart, suffixLength);\t\t\t\t\n      }\n      \n      if (unknownWordLength > 0) {      // found unknown word\n        final int characterId = characterDefinition.getCharacterClass(firstCharacter);\n        unkDictionary.lookupWordIds(characterId, wordIdRef); // characters in input text are supposed to be the same\n        for (int ofs = 0; ofs < wordIdRef.length; ofs++) {\n          final int wordId = wordIdRef.ints[wordIdRef.offset + ofs];\n          ViterbiNode node = new ViterbiNode(wordId, text, suffixStart, unknownWordLength, unkDictionary.getLeftId(wordId), unkDictionary.getRightId(wordId), unkDictionary.getWordCost(wordId), startIndex, Type.UNKNOWN);\n          addToArrays(node, startIndex + 1, startIndex + 1 + unknownWordLength, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n        }\n        unknownWordEndIndex = startIndex + unknownWordLength;\n      }\n    }\n    \n    ViterbiNode eosNode = new ViterbiNode(-1, EOS, 0, EOS.length, 0, 0, 0, length + 1, Type.KNOWN);\n    addToArrays(eosNode, length + 1, 0, startIndexArr, endIndexArr, startSizeArr, endSizeArr); //Add EOS node to endIndexArr at index 0\n    \n    ViterbiNode[][][] result = new ViterbiNode[][][]{startIndexArr, endIndexArr};\n    \n    return result;\n  }\n\n","sourceOld":"  /**\n   * Build lattice from input text\n   * @param text\n   */\n  public ViterbiNode[][][] build(char text[], int offset, int length) throws IOException {\n    ViterbiNode[][] startIndexArr = new ViterbiNode[length + 2][];  // text length + BOS and EOS\n    ViterbiNode[][] endIndexArr = new ViterbiNode[length + 2][];  // text length + BOS and EOS\n    int[] startSizeArr = new int[length + 2]; // array to keep ViterbiNode count in startIndexArr\n    int[] endSizeArr = new int[length + 2];   // array to keep ViterbiNode count in endIndexArr\n    FST.Arc<Long> arc = new FST.Arc<Long>();\n    ViterbiNode bosNode = new ViterbiNode(-1, BOS, 0, BOS.length, 0, 0, 0, -1, Type.KNOWN);\n    addToArrays(bosNode, 0, 1, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n    \n    // Process user dictionary;\n    if (useUserDictionary) {\n      processUserDictionary(text, offset, length, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n    }\n    \n    int unknownWordEndIndex = -1;\t// index of the last character of unknown word\n    \n    final IntsRef wordIdRef = new IntsRef();\n    \n    for (int startIndex = 0; startIndex < length; startIndex++) {\n      // If no token ends where current token starts, skip this index\n      if (endSizeArr[startIndex + 1] == 0) {\n        continue;\n      }\n      \n      int suffixStart = offset + startIndex;\n      int suffixLength = length - startIndex;\n      \n      boolean found = false;\n      arc = fst.getFirstArc(arc);\n      int output = 0;\n      for (int endIndex = 1; endIndex < suffixLength + 1; endIndex++) {\n        int ch = text[suffixStart + endIndex - 1];\n        \n        if (fst.findTargetArc(ch, arc, arc, endIndex == 1) == null) {\n          break; // continue to next position\n        }\n        output += arc.output.intValue();\n\n        if (arc.isFinal()) {\n          output += arc.nextFinalOutput.intValue();\n          found = true; // Don't produce unknown word starting from this index\n          dictionary.lookupWordIds(output, wordIdRef);\n          for (int ofs = 0; ofs < wordIdRef.length; ofs++) {\n            final int wordId = wordIdRef.ints[wordIdRef.offset + ofs];\n            ViterbiNode node = new ViterbiNode(wordId, text, suffixStart, endIndex, dictionary.getLeftId(wordId), dictionary.getRightId(wordId), dictionary.getWordCost(wordId), startIndex, Type.KNOWN);\n            addToArrays(node, startIndex + 1, startIndex + 1 + endIndex, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n          }\n        }\n      }\n      \n      // In the case of normal mode, it doesn't process unknown word greedily.\n      if(!searchMode && unknownWordEndIndex > startIndex){\n        continue;\n      }\n      \n      // Process Unknown Word: hmm what is this isInvoke logic (same no matter what)\n      int unknownWordLength = 0;\n      char firstCharacter = text[suffixStart];\n      boolean isInvoke = characterDefinition.isInvoke(firstCharacter);\n      if (isInvoke){\t// Process \"invoke\"\n        unknownWordLength = unkDictionary.lookup(text, suffixStart, suffixLength);\n      } else if (found == false){\t// Process not \"invoke\"\n        unknownWordLength = unkDictionary.lookup(text, suffixStart, suffixLength);\t\t\t\t\n      }\n      \n      if (unknownWordLength > 0) {      // found unknown word\n        final int characterId = characterDefinition.getCharacterClass(firstCharacter);\n        unkDictionary.lookupWordIds(characterId, wordIdRef); // characters in input text are supposed to be the same\n        for (int ofs = 0; ofs < wordIdRef.length; ofs++) {\n          final int wordId = wordIdRef.ints[wordIdRef.offset + ofs];\n          ViterbiNode node = new ViterbiNode(wordId, text, suffixStart, unknownWordLength, unkDictionary.getLeftId(wordId), unkDictionary.getRightId(wordId), unkDictionary.getWordCost(wordId), startIndex, Type.UNKNOWN);\n          addToArrays(node, startIndex + 1, startIndex + 1 + unknownWordLength, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n        }\n        unknownWordEndIndex = startIndex + unknownWordLength;\n      }\n    }\n    \n    ViterbiNode eosNode = new ViterbiNode(-1, EOS, 0, EOS.length, 0, 0, 0, length + 1, Type.KNOWN);\n    addToArrays(eosNode, length + 1, 0, startIndexArr, endIndexArr, startSizeArr, endSizeArr); //Add EOS node to endIndexArr at index 0\n    \n    ViterbiNode[][][] result = new ViterbiNode[][][]{startIndexArr, endIndexArr};\n    \n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"13bedc217a57b03b17f22e563b0c4892fefe8ff2","date":1328194873,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/kuromoji/viterbi/Viterbi#build(char[],int,int).mjava","pathOld":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/kuromoji/viterbi/Viterbi#build(char[],int,int).mjava","sourceNew":"  /**\n   * Build lattice from input text\n   * @param text\n   */\n  public ViterbiNode[][][] build(char text[], int offset, int length) throws IOException {\n    ViterbiNode[][] startIndexArr = new ViterbiNode[length + 2][];  // text length + BOS and EOS\n    ViterbiNode[][] endIndexArr = new ViterbiNode[length + 2][];  // text length + BOS and EOS\n    int[] startSizeArr = new int[length + 2]; // array to keep ViterbiNode count in startIndexArr\n    int[] endSizeArr = new int[length + 2];   // array to keep ViterbiNode count in endIndexArr\n    FST.Arc<Long> arc = new FST.Arc<Long>();\n    ViterbiNode bosNode = new ViterbiNode(-1, BOS, 0, BOS.length, 0, 0, 0, -1, Type.KNOWN);\n    addToArrays(bosNode, 0, 1, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n    \n    final FST.BytesReader fstReader = fst.getBytesReader(0);\n\n    // Process user dictionary;\n    if (useUserDictionary) {\n      processUserDictionary(text, offset, length, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n    }\n    \n    int unknownWordEndIndex = -1;\t// index of the last character of unknown word\n    \n    final IntsRef wordIdRef = new IntsRef();\n    \n    for (int startIndex = 0; startIndex < length; startIndex++) {\n      // If no token ends where current token starts, skip this index\n      if (endSizeArr[startIndex + 1] == 0) {\n        continue;\n      }\n      \n      int suffixStart = offset + startIndex;\n      int suffixLength = length - startIndex;\n      \n      boolean found = false;\n      arc = fst.getFirstArc(arc);\n      int output = 0;\n      for (int endIndex = 1; endIndex < suffixLength + 1; endIndex++) {\n        int ch = text[suffixStart + endIndex - 1];\n        \n        if (fst.findTargetArc(ch, arc, arc, endIndex == 1, fstReader) == null) {\n          break; // continue to next position\n        }\n        output += arc.output.intValue();\n\n        if (arc.isFinal()) {\n          final int finalOutput = output + arc.nextFinalOutput.intValue();\n          found = true; // Don't produce unknown word starting from this index\n          dictionary.lookupWordIds(finalOutput, wordIdRef);\n          for (int ofs = 0; ofs < wordIdRef.length; ofs++) {\n            final int wordId = wordIdRef.ints[wordIdRef.offset + ofs];\n            ViterbiNode node = new ViterbiNode(wordId, text, suffixStart, endIndex, dictionary.getLeftId(wordId), dictionary.getRightId(wordId), dictionary.getWordCost(wordId), startIndex, Type.KNOWN);\n            addToArrays(node, startIndex + 1, startIndex + 1 + endIndex, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n          }\n        }\n      }\n      \n      // In the case of normal mode, it doesn't process unknown word greedily.\n      if(!searchMode && unknownWordEndIndex > startIndex){\n        continue;\n      }\n      \n      // Process Unknown Word: hmm what is this isInvoke logic (same no matter what)\n      int unknownWordLength = 0;\n      char firstCharacter = text[suffixStart];\n      boolean isInvoke = characterDefinition.isInvoke(firstCharacter);\n      if (isInvoke){\t// Process \"invoke\"\n        unknownWordLength = unkDictionary.lookup(text, suffixStart, suffixLength);\n      } else if (found == false){\t// Process not \"invoke\"\n        unknownWordLength = unkDictionary.lookup(text, suffixStart, suffixLength);\t\t\t\t\n      }\n      \n      if (unknownWordLength > 0) {      // found unknown word\n        final int characterId = characterDefinition.getCharacterClass(firstCharacter);\n        unkDictionary.lookupWordIds(characterId, wordIdRef); // characters in input text are supposed to be the same\n        for (int ofs = 0; ofs < wordIdRef.length; ofs++) {\n          final int wordId = wordIdRef.ints[wordIdRef.offset + ofs];\n          ViterbiNode node = new ViterbiNode(wordId, text, suffixStart, unknownWordLength, unkDictionary.getLeftId(wordId), unkDictionary.getRightId(wordId), unkDictionary.getWordCost(wordId), startIndex, Type.UNKNOWN);\n          addToArrays(node, startIndex + 1, startIndex + 1 + unknownWordLength, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n        }\n        unknownWordEndIndex = startIndex + unknownWordLength;\n      }\n    }\n    \n    ViterbiNode eosNode = new ViterbiNode(-1, EOS, 0, EOS.length, 0, 0, 0, length + 1, Type.KNOWN);\n    addToArrays(eosNode, length + 1, 0, startIndexArr, endIndexArr, startSizeArr, endSizeArr); //Add EOS node to endIndexArr at index 0\n    \n    ViterbiNode[][][] result = new ViterbiNode[][][]{startIndexArr, endIndexArr};\n    \n    return result;\n  }\n\n","sourceOld":"  /**\n   * Build lattice from input text\n   * @param text\n   */\n  public ViterbiNode[][][] build(char text[], int offset, int length) throws IOException {\n    ViterbiNode[][] startIndexArr = new ViterbiNode[length + 2][];  // text length + BOS and EOS\n    ViterbiNode[][] endIndexArr = new ViterbiNode[length + 2][];  // text length + BOS and EOS\n    int[] startSizeArr = new int[length + 2]; // array to keep ViterbiNode count in startIndexArr\n    int[] endSizeArr = new int[length + 2];   // array to keep ViterbiNode count in endIndexArr\n    FST.Arc<Long> arc = new FST.Arc<Long>();\n    ViterbiNode bosNode = new ViterbiNode(-1, BOS, 0, BOS.length, 0, 0, 0, -1, Type.KNOWN);\n    addToArrays(bosNode, 0, 1, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n    \n    final FST.BytesReader fstReader = fst.getBytesReader(0);\n\n    // Process user dictionary;\n    if (useUserDictionary) {\n      processUserDictionary(text, offset, length, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n    }\n    \n    int unknownWordEndIndex = -1;\t// index of the last character of unknown word\n    \n    final IntsRef wordIdRef = new IntsRef();\n    \n    for (int startIndex = 0; startIndex < length; startIndex++) {\n      // If no token ends where current token starts, skip this index\n      if (endSizeArr[startIndex + 1] == 0) {\n        continue;\n      }\n      \n      int suffixStart = offset + startIndex;\n      int suffixLength = length - startIndex;\n      \n      boolean found = false;\n      arc = fst.getFirstArc(arc);\n      int output = 0;\n      for (int endIndex = 1; endIndex < suffixLength + 1; endIndex++) {\n        int ch = text[suffixStart + endIndex - 1];\n        \n        if (fst.findTargetArc(ch, arc, arc, endIndex == 1, fstReader) == null) {\n          break; // continue to next position\n        }\n        output += arc.output.intValue();\n\n        if (arc.isFinal()) {\n          output += arc.nextFinalOutput.intValue();\n          found = true; // Don't produce unknown word starting from this index\n          dictionary.lookupWordIds(output, wordIdRef);\n          for (int ofs = 0; ofs < wordIdRef.length; ofs++) {\n            final int wordId = wordIdRef.ints[wordIdRef.offset + ofs];\n            ViterbiNode node = new ViterbiNode(wordId, text, suffixStart, endIndex, dictionary.getLeftId(wordId), dictionary.getRightId(wordId), dictionary.getWordCost(wordId), startIndex, Type.KNOWN);\n            addToArrays(node, startIndex + 1, startIndex + 1 + endIndex, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n          }\n        }\n      }\n      \n      // In the case of normal mode, it doesn't process unknown word greedily.\n      if(!searchMode && unknownWordEndIndex > startIndex){\n        continue;\n      }\n      \n      // Process Unknown Word: hmm what is this isInvoke logic (same no matter what)\n      int unknownWordLength = 0;\n      char firstCharacter = text[suffixStart];\n      boolean isInvoke = characterDefinition.isInvoke(firstCharacter);\n      if (isInvoke){\t// Process \"invoke\"\n        unknownWordLength = unkDictionary.lookup(text, suffixStart, suffixLength);\n      } else if (found == false){\t// Process not \"invoke\"\n        unknownWordLength = unkDictionary.lookup(text, suffixStart, suffixLength);\t\t\t\t\n      }\n      \n      if (unknownWordLength > 0) {      // found unknown word\n        final int characterId = characterDefinition.getCharacterClass(firstCharacter);\n        unkDictionary.lookupWordIds(characterId, wordIdRef); // characters in input text are supposed to be the same\n        for (int ofs = 0; ofs < wordIdRef.length; ofs++) {\n          final int wordId = wordIdRef.ints[wordIdRef.offset + ofs];\n          ViterbiNode node = new ViterbiNode(wordId, text, suffixStart, unknownWordLength, unkDictionary.getLeftId(wordId), unkDictionary.getRightId(wordId), unkDictionary.getWordCost(wordId), startIndex, Type.UNKNOWN);\n          addToArrays(node, startIndex + 1, startIndex + 1 + unknownWordLength, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n        }\n        unknownWordEndIndex = startIndex + unknownWordLength;\n      }\n    }\n    \n    ViterbiNode eosNode = new ViterbiNode(-1, EOS, 0, EOS.length, 0, 0, 0, length + 1, Type.KNOWN);\n    addToArrays(eosNode, length + 1, 0, startIndexArr, endIndexArr, startSizeArr, endSizeArr); //Add EOS node to endIndexArr at index 0\n    \n    ViterbiNode[][][] result = new ViterbiNode[][][]{startIndexArr, endIndexArr};\n    \n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0984ad47974c2d5d354519ddb2aa8358973a6271","date":1330868053,"type":4,"author":"Christian Moen","isMerge":false,"pathNew":"/dev/null","pathOld":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/kuromoji/viterbi/Viterbi#build(char[],int,int).mjava","sourceNew":null,"sourceOld":"  /**\n   * Build lattice from input text\n   * @param text\n   */\n  public ViterbiNode[][][] build(char text[], int offset, int length) throws IOException {\n    ViterbiNode[][] startIndexArr = new ViterbiNode[length + 2][];  // text length + BOS and EOS\n    ViterbiNode[][] endIndexArr = new ViterbiNode[length + 2][];  // text length + BOS and EOS\n    int[] startSizeArr = new int[length + 2]; // array to keep ViterbiNode count in startIndexArr\n    int[] endSizeArr = new int[length + 2];   // array to keep ViterbiNode count in endIndexArr\n    FST.Arc<Long> arc = new FST.Arc<Long>();\n    ViterbiNode bosNode = new ViterbiNode(-1, BOS, 0, BOS.length, 0, 0, 0, -1, Type.KNOWN);\n    addToArrays(bosNode, 0, 1, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n    \n    final FST.BytesReader fstReader = fst.getBytesReader(0);\n\n    // Process user dictionary;\n    if (useUserDictionary) {\n      processUserDictionary(text, offset, length, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n    }\n    \n    int unknownWordEndIndex = -1;\t// index of the last character of unknown word\n    \n    final IntsRef wordIdRef = new IntsRef();\n    \n    for (int startIndex = 0; startIndex < length; startIndex++) {\n      // If no token ends where current token starts, skip this index\n      if (endSizeArr[startIndex + 1] == 0) {\n        continue;\n      }\n      \n      int suffixStart = offset + startIndex;\n      int suffixLength = length - startIndex;\n      \n      boolean found = false;\n      arc = fst.getFirstArc(arc);\n      int output = 0;\n      for (int endIndex = 1; endIndex < suffixLength + 1; endIndex++) {\n        int ch = text[suffixStart + endIndex - 1];\n        \n        if (fst.findTargetArc(ch, arc, arc, endIndex == 1, fstReader) == null) {\n          break; // continue to next position\n        }\n        output += arc.output.intValue();\n\n        if (arc.isFinal()) {\n          final int finalOutput = output + arc.nextFinalOutput.intValue();\n          found = true; // Don't produce unknown word starting from this index\n          dictionary.lookupWordIds(finalOutput, wordIdRef);\n          for (int ofs = 0; ofs < wordIdRef.length; ofs++) {\n            final int wordId = wordIdRef.ints[wordIdRef.offset + ofs];\n            ViterbiNode node = new ViterbiNode(wordId, text, suffixStart, endIndex, dictionary.getLeftId(wordId), dictionary.getRightId(wordId), dictionary.getWordCost(wordId), startIndex, Type.KNOWN);\n            addToArrays(node, startIndex + 1, startIndex + 1 + endIndex, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n          }\n        }\n      }\n      \n      // In the case of normal mode, it doesn't process unknown word greedily.\n      if(!searchMode && unknownWordEndIndex > startIndex){\n        continue;\n      }\n      \n      // Process Unknown Word: hmm what is this isInvoke logic (same no matter what)\n      int unknownWordLength = 0;\n      char firstCharacter = text[suffixStart];\n      boolean isInvoke = characterDefinition.isInvoke(firstCharacter);\n      if (isInvoke){\t// Process \"invoke\"\n        unknownWordLength = unkDictionary.lookup(text, suffixStart, suffixLength);\n      } else if (found == false){\t// Process not \"invoke\"\n        unknownWordLength = unkDictionary.lookup(text, suffixStart, suffixLength);\t\t\t\t\n      }\n      \n      if (unknownWordLength > 0) {      // found unknown word\n        final int characterId = characterDefinition.getCharacterClass(firstCharacter);\n        unkDictionary.lookupWordIds(characterId, wordIdRef); // characters in input text are supposed to be the same\n        for (int ofs = 0; ofs < wordIdRef.length; ofs++) {\n          final int wordId = wordIdRef.ints[wordIdRef.offset + ofs];\n          ViterbiNode node = new ViterbiNode(wordId, text, suffixStart, unknownWordLength, unkDictionary.getLeftId(wordId), unkDictionary.getRightId(wordId), unkDictionary.getWordCost(wordId), startIndex, Type.UNKNOWN);\n          addToArrays(node, startIndex + 1, startIndex + 1 + unknownWordLength, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n        }\n        unknownWordEndIndex = startIndex + unknownWordLength;\n      }\n    }\n    \n    ViterbiNode eosNode = new ViterbiNode(-1, EOS, 0, EOS.length, 0, 0, 0, length + 1, Type.KNOWN);\n    addToArrays(eosNode, length + 1, 0, startIndexArr, endIndexArr, startSizeArr, endSizeArr); //Add EOS node to endIndexArr at index 0\n    \n    ViterbiNode[][][] result = new ViterbiNode[][][]{startIndexArr, endIndexArr};\n    \n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":4,"author":"Ryan McKinley","isMerge":true,"pathNew":"/dev/null","pathOld":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/kuromoji/viterbi/Viterbi#build(char[],int,int).mjava","sourceNew":null,"sourceOld":"  /**\n   * Build lattice from input text\n   * @param text\n   */\n  public ViterbiNode[][][] build(char text[], int offset, int length) throws IOException {\n    ViterbiNode[][] startIndexArr = new ViterbiNode[length + 2][];  // text length + BOS and EOS\n    ViterbiNode[][] endIndexArr = new ViterbiNode[length + 2][];  // text length + BOS and EOS\n    int[] startSizeArr = new int[length + 2]; // array to keep ViterbiNode count in startIndexArr\n    int[] endSizeArr = new int[length + 2];   // array to keep ViterbiNode count in endIndexArr\n    FST.Arc<Long> arc = new FST.Arc<Long>();\n    ViterbiNode bosNode = new ViterbiNode(-1, BOS, 0, BOS.length, 0, 0, 0, -1, Type.KNOWN);\n    addToArrays(bosNode, 0, 1, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n    \n    final FST.BytesReader fstReader = fst.getBytesReader(0);\n\n    // Process user dictionary;\n    if (useUserDictionary) {\n      processUserDictionary(text, offset, length, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n    }\n    \n    int unknownWordEndIndex = -1;\t// index of the last character of unknown word\n    \n    final IntsRef wordIdRef = new IntsRef();\n    \n    for (int startIndex = 0; startIndex < length; startIndex++) {\n      // If no token ends where current token starts, skip this index\n      if (endSizeArr[startIndex + 1] == 0) {\n        continue;\n      }\n      \n      int suffixStart = offset + startIndex;\n      int suffixLength = length - startIndex;\n      \n      boolean found = false;\n      arc = fst.getFirstArc(arc);\n      int output = 0;\n      for (int endIndex = 1; endIndex < suffixLength + 1; endIndex++) {\n        int ch = text[suffixStart + endIndex - 1];\n        \n        if (fst.findTargetArc(ch, arc, arc, endIndex == 1, fstReader) == null) {\n          break; // continue to next position\n        }\n        output += arc.output.intValue();\n\n        if (arc.isFinal()) {\n          final int finalOutput = output + arc.nextFinalOutput.intValue();\n          found = true; // Don't produce unknown word starting from this index\n          dictionary.lookupWordIds(finalOutput, wordIdRef);\n          for (int ofs = 0; ofs < wordIdRef.length; ofs++) {\n            final int wordId = wordIdRef.ints[wordIdRef.offset + ofs];\n            ViterbiNode node = new ViterbiNode(wordId, text, suffixStart, endIndex, dictionary.getLeftId(wordId), dictionary.getRightId(wordId), dictionary.getWordCost(wordId), startIndex, Type.KNOWN);\n            addToArrays(node, startIndex + 1, startIndex + 1 + endIndex, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n          }\n        }\n      }\n      \n      // In the case of normal mode, it doesn't process unknown word greedily.\n      if(!searchMode && unknownWordEndIndex > startIndex){\n        continue;\n      }\n      \n      // Process Unknown Word: hmm what is this isInvoke logic (same no matter what)\n      int unknownWordLength = 0;\n      char firstCharacter = text[suffixStart];\n      boolean isInvoke = characterDefinition.isInvoke(firstCharacter);\n      if (isInvoke){\t// Process \"invoke\"\n        unknownWordLength = unkDictionary.lookup(text, suffixStart, suffixLength);\n      } else if (found == false){\t// Process not \"invoke\"\n        unknownWordLength = unkDictionary.lookup(text, suffixStart, suffixLength);\t\t\t\t\n      }\n      \n      if (unknownWordLength > 0) {      // found unknown word\n        final int characterId = characterDefinition.getCharacterClass(firstCharacter);\n        unkDictionary.lookupWordIds(characterId, wordIdRef); // characters in input text are supposed to be the same\n        for (int ofs = 0; ofs < wordIdRef.length; ofs++) {\n          final int wordId = wordIdRef.ints[wordIdRef.offset + ofs];\n          ViterbiNode node = new ViterbiNode(wordId, text, suffixStart, unknownWordLength, unkDictionary.getLeftId(wordId), unkDictionary.getRightId(wordId), unkDictionary.getWordCost(wordId), startIndex, Type.UNKNOWN);\n          addToArrays(node, startIndex + 1, startIndex + 1 + unknownWordLength, startIndexArr, endIndexArr, startSizeArr, endSizeArr);\n        }\n        unknownWordEndIndex = startIndex + unknownWordLength;\n      }\n    }\n    \n    ViterbiNode eosNode = new ViterbiNode(-1, EOS, 0, EOS.length, 0, 0, 0, length + 1, Type.KNOWN);\n    addToArrays(eosNode, length + 1, 0, startIndexArr, endIndexArr, startSizeArr, endSizeArr); //Add EOS node to endIndexArr at index 0\n    \n    ViterbiNode[][][] result = new ViterbiNode[][][]{startIndexArr, endIndexArr};\n    \n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["13bedc217a57b03b17f22e563b0c4892fefe8ff2","0984ad47974c2d5d354519ddb2aa8358973a6271"],"0984ad47974c2d5d354519ddb2aa8358973a6271":["13bedc217a57b03b17f22e563b0c4892fefe8ff2"],"b3be20ca1091c0b7cdb2308b9023606a5e451cec":["6ae8b8ec55786d06eb9b03fc7bc86a907e1a3ae2"],"817882884229bace7dc5d1b75f6b0e4aa1e47122":["6ae8b8ec55786d06eb9b03fc7bc86a907e1a3ae2","b3be20ca1091c0b7cdb2308b9023606a5e451cec"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5b6fdfce35d0adb18836cf8711abe487a934df33":["6ae8b8ec55786d06eb9b03fc7bc86a907e1a3ae2","b3be20ca1091c0b7cdb2308b9023606a5e451cec"],"6ae8b8ec55786d06eb9b03fc7bc86a907e1a3ae2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"13bedc217a57b03b17f22e563b0c4892fefe8ff2":["b3be20ca1091c0b7cdb2308b9023606a5e451cec"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0984ad47974c2d5d354519ddb2aa8358973a6271"]},"commit2Childs":{"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"0984ad47974c2d5d354519ddb2aa8358973a6271":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b3be20ca1091c0b7cdb2308b9023606a5e451cec":["817882884229bace7dc5d1b75f6b0e4aa1e47122","5b6fdfce35d0adb18836cf8711abe487a934df33","13bedc217a57b03b17f22e563b0c4892fefe8ff2"],"817882884229bace7dc5d1b75f6b0e4aa1e47122":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6ae8b8ec55786d06eb9b03fc7bc86a907e1a3ae2"],"5b6fdfce35d0adb18836cf8711abe487a934df33":[],"6ae8b8ec55786d06eb9b03fc7bc86a907e1a3ae2":["b3be20ca1091c0b7cdb2308b9023606a5e451cec","817882884229bace7dc5d1b75f6b0e4aa1e47122","5b6fdfce35d0adb18836cf8711abe487a934df33"],"13bedc217a57b03b17f22e563b0c4892fefe8ff2":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","0984ad47974c2d5d354519ddb2aa8358973a6271"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","817882884229bace7dc5d1b75f6b0e4aa1e47122","5b6fdfce35d0adb18836cf8711abe487a934df33","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}