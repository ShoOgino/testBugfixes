{"path":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#waitForState(String,String,Replica.State,long).mjava","commits":[{"id":"84f20f331d8001864545c7021812d8c6509c7593","date":1517216128,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#waitForState(String,String,Replica.State,long).mjava","pathOld":"/dev/null","sourceNew":"  protected void waitForState(String collection, String replicaName, Replica.State state, long ms) throws KeeperException, InterruptedException {\n    TimeOut timeOut = new TimeOut(ms, TimeUnit.MILLISECONDS, TimeSource.CURRENT_TIME);\n    Replica.State replicaState = Replica.State.ACTIVE;\n    while (!timeOut.hasTimedOut()) {\n      ZkStateReader zkr = cloudClient.getZkStateReader();\n      zkr.forceUpdateCollection(collection);; // force the state to be fresh\n      ClusterState cs = zkr.getClusterState();\n      Collection<Slice> slices = cs.getCollection(collection).getActiveSlices();\n      Slice slice = slices.iterator().next();\n      Replica partitionedReplica = slice.getReplica(replicaName);\n      replicaState = partitionedReplica.getState();\n      if (replicaState == state) return;\n    }\n    assertEquals(\"Timeout waiting for state \"+ state +\" of replica \" + replicaName + \", current state \" + replicaState,\n        state, replicaState);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bc201e01d035a7370848d9d2451e0e27ee77df2e","date":1544724144,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#waitForState(String,String,Replica.State,long).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/HttpPartitionTest#waitForState(String,String,Replica.State,long).mjava","sourceNew":"  protected void waitForState(String collection, String replicaName, Replica.State state, long ms) throws KeeperException, InterruptedException {\n    TimeOut timeOut = new TimeOut(ms, TimeUnit.MILLISECONDS, TimeSource.NANO_TIME);\n    Replica.State replicaState = Replica.State.ACTIVE;\n    while (!timeOut.hasTimedOut()) {\n      ZkStateReader zkr = cloudClient.getZkStateReader();\n      zkr.forceUpdateCollection(collection);; // force the state to be fresh\n      ClusterState cs = zkr.getClusterState();\n      Collection<Slice> slices = cs.getCollection(collection).getActiveSlices();\n      Slice slice = slices.iterator().next();\n      Replica partitionedReplica = slice.getReplica(replicaName);\n      replicaState = partitionedReplica.getState();\n      if (replicaState == state) return;\n    }\n    assertEquals(\"Timeout waiting for state \"+ state +\" of replica \" + replicaName + \", current state \" + replicaState,\n        state, replicaState);\n  }\n\n","sourceOld":"  protected void waitForState(String collection, String replicaName, Replica.State state, long ms) throws KeeperException, InterruptedException {\n    TimeOut timeOut = new TimeOut(ms, TimeUnit.MILLISECONDS, TimeSource.CURRENT_TIME);\n    Replica.State replicaState = Replica.State.ACTIVE;\n    while (!timeOut.hasTimedOut()) {\n      ZkStateReader zkr = cloudClient.getZkStateReader();\n      zkr.forceUpdateCollection(collection);; // force the state to be fresh\n      ClusterState cs = zkr.getClusterState();\n      Collection<Slice> slices = cs.getCollection(collection).getActiveSlices();\n      Slice slice = slices.iterator().next();\n      Replica partitionedReplica = slice.getReplica(replicaName);\n      replicaState = partitionedReplica.getState();\n      if (replicaState == state) return;\n    }\n    assertEquals(\"Timeout waiting for state \"+ state +\" of replica \" + replicaName + \", current state \" + replicaState,\n        state, replicaState);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"84f20f331d8001864545c7021812d8c6509c7593":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"bc201e01d035a7370848d9d2451e0e27ee77df2e":["84f20f331d8001864545c7021812d8c6509c7593"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bc201e01d035a7370848d9d2451e0e27ee77df2e"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["84f20f331d8001864545c7021812d8c6509c7593"],"84f20f331d8001864545c7021812d8c6509c7593":["bc201e01d035a7370848d9d2451e0e27ee77df2e"],"bc201e01d035a7370848d9d2451e0e27ee77df2e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}