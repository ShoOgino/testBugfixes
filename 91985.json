{"path":"solr/core/src/test/org/apache/solr/update/TestNestedUpdateProcessor.RandomNestedDocModel#checkParentAndChildQueriesOfEachDocument().mjava","commits":[{"id":"0b5e0da3b576580fb2128e87467fa5f579ca2c33","date":1599081383,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestNestedUpdateProcessor.RandomNestedDocModel#checkParentAndChildQueriesOfEachDocument().mjava","pathOld":"/dev/null","sourceNew":"    /** \n     * Loops over the 'model' of every document we've indexed, asserting that\n     * parent/child queries wrapping an '<code>id:foo</code> using various paths\n     * match the expected ancestors/descendents\n     */\n    public void checkParentAndChildQueriesOfEachDocument() {\n      assertFalse(\"You didn't build any docs\", allDocs.isEmpty());\n      \n      for (String doc_id : allDocs.keySet()) {\n        final String doc_path = allDocs.get(doc_id).getFieldValue(\"test_path_s\").toString();\n        \n        if ( ! doc_path.equals(\"/\") ) {\n          \n          // doc_id -> descdentId must have at least one ancestor (since it's not a root level document)\n          final String descendentId = doc_id;\n          assert allDocs.get(descendentId).containsKey(\"ancestor_ids_ss\");\n          final List<Object> allAncestorIds = new ArrayList<>(allDocs.get(descendentId).getFieldValues(\"ancestor_ids_ss\"));\n          \n          // pick a random ancestor to use in our testing...\n          final String ancestorId = allAncestorIds.get(random().nextInt(allAncestorIds.size())).toString();\n          final String ancestor_path = allDocs.get(ancestorId).getFieldValue(\"test_path_s\").toString();\n          \n          final Collection<Object> allOfAncestorsDescendentIds\n            = allDocs.get(ancestorId).getFieldValues(\"descendent_ids_ss\");\n          \n          assertTrue(\"Sanity check \" + ancestorId + \" ancestor of \" + descendentId,\n                     allOfAncestorsDescendentIds.contains(descendentId));\n          \n          // now we should be able to assert that a 'parent' query wrapped around a query for the descendentId\n          // using the ancestor_path should match exactly one doc: our ancestorId...\n          assertQ(req(parentQueryMaker(ancestor_path, \"id:\" + descendentId),\n                      \"_trace_path_tested\", ancestor_path,\n                      \"fl\", \"id\",\n                      \"indent\", \"true\")\n                  , \"//result/@numFound=1\"\n                  , \"//doc/str[@name='id'][.='\"+ancestorId+\"']\"\n                  );\n          \n          // meanwhile, a 'child' query wrapped arround a query for the ancestorId, using the ancestor_path,\n          // should match all of it's descendents (for simplicity we'll check just the numFound and the\n          // 'descendentId' we started with)\n          assertQ(req(childQueryMaker(ancestor_path, \"id:\" + ancestorId),\n                      \"_trace_path_tested\", ancestor_path,\n                      \"rows\", \"9999\",\n                      \"fl\", \"id\",\n                      \"indent\", \"true\")\n                  , \"//result/@numFound=\"+allOfAncestorsDescendentIds.size()\n                  , \"//doc/str[@name='id'][.='\"+descendentId+\"']\"\n                  );\n          \n        }\n        \n        // regardless of wether doc_id has an ancestor or not, a 'parent' query with a path that isn't a\n        // prefix of the path of the (child) doc_id in the wrapped query should match 0 docs w/o failing\n        assertQ(req(parentQueryMaker(\"/xxx/yyy\", \"id:\" + doc_id),\n                    \"_trace_path_tested\", \"/xxx/yyy\",\n                    \"indent\", \"true\")\n                , \"//result/@numFound=0\");\n        \n        // likewise: a 'child' query wrapped around a query for our doc_id (regardless of wether if has\n        // any kids), using a path that doesn't start with the same prefix as doc_id, should match 0\n        // docs w/o failing\n        assertQ(req(childQueryMaker(\"/xxx/yyy\", \"id:\" + doc_id),\n                    \"_trace_path_tested\", \"/xxx/yyy\",\n                    \"indent\", \"true\")\n                , \"//result/@numFound=0\");\n        \n        // lastly: wrapping a child query around a query for our doc_id, using a path that \"extends\" \n        // the doc_id's path should always get 0 results if that path doesn't match any actual kids\n        // (regardless of wether doc_id has any children/descendents)\n        assertQ(req(childQueryMaker(doc_path + \"/xxx/yyy\", \"id:\" + doc_id),\n                    \"_trace_path_tested\", doc_path + \"/xxx/yyy\",\n                    \"indent\", \"true\")\n                , \"//result/@numFound=0\");\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0b5e0da3b576580fb2128e87467fa5f579ca2c33"],"0b5e0da3b576580fb2128e87467fa5f579ca2c33":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0b5e0da3b576580fb2128e87467fa5f579ca2c33"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"0b5e0da3b576580fb2128e87467fa5f579ca2c33":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}