{"path":"lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader#ParallelAtomicReader(boolean,AtomicReader[],AtomicReader[]).mjava","commits":[{"id":"6e09a3a223be07d75777515a717312813221fe58","date":1328908385,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader#ParallelAtomicReader(boolean,AtomicReader[],AtomicReader[]).mjava","pathOld":"/dev/null","sourceNew":"  /** Expert: create a ParallelAtomicReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelAtomicReader(boolean closeSubReaders, AtomicReader[] readers, AtomicReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    this.numDocs = (readers.length > 0) ? readers[0].numDocs() : 0;\n    this.maxDoc = (readers.length > 0) ? readers[0].maxDoc() : 0;\n    this.hasDeletions = (readers.length > 0) ? readers[0].hasDeletions() : false;\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(AtomicReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n      \n    for (final AtomicReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for(FieldInfo fieldInfo : readerFieldInfos) { // update fieldToReader map\n        // NOTE: first reader having a given field \"wins\":\n        if (fieldToReader.get(fieldInfo.name) == null) {\n          fieldInfos.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          this.fields.addField(fieldInfo.name, reader.terms(fieldInfo.name));\n        }\n      }\n    } \n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    if (!closeSubReaders) {\n      for (AtomicReader reader : completeReaderSet) {\n        reader.incRef();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["a2a81b3988dfbdfb187c425043b89868e359b238"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c9fa925e715e5bcc90af5416555a98a001309c1e","date":1329559042,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader#ParallelAtomicReader(boolean,AtomicReader[],AtomicReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader#ParallelAtomicReader(boolean,AtomicReader[],AtomicReader[]).mjava","sourceNew":"  /** Expert: create a ParallelAtomicReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelAtomicReader(boolean closeSubReaders, AtomicReader[] readers, AtomicReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final AtomicReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(AtomicReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n      \n    for (final AtomicReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for(FieldInfo fieldInfo : readerFieldInfos) { // update fieldToReader map\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          fieldInfos.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          this.fields.addField(fieldInfo.name, reader.terms(fieldInfo.name));\n        }\n      }\n    } \n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    if (!closeSubReaders) {\n      for (AtomicReader reader : completeReaderSet) {\n        reader.incRef();\n      }\n    }\n  }\n\n","sourceOld":"  /** Expert: create a ParallelAtomicReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelAtomicReader(boolean closeSubReaders, AtomicReader[] readers, AtomicReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    this.numDocs = (readers.length > 0) ? readers[0].numDocs() : 0;\n    this.maxDoc = (readers.length > 0) ? readers[0].maxDoc() : 0;\n    this.hasDeletions = (readers.length > 0) ? readers[0].hasDeletions() : false;\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(AtomicReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n      \n    for (final AtomicReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for(FieldInfo fieldInfo : readerFieldInfos) { // update fieldToReader map\n        // NOTE: first reader having a given field \"wins\":\n        if (fieldToReader.get(fieldInfo.name) == null) {\n          fieldInfos.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          this.fields.addField(fieldInfo.name, reader.terms(fieldInfo.name));\n        }\n      }\n    } \n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    if (!closeSubReaders) {\n      for (AtomicReader reader : completeReaderSet) {\n        reader.incRef();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54184c8fa13303a999acbb2f54de8b5d8d1b1bd7","date":1329818475,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader#ParallelAtomicReader(boolean,AtomicReader[],AtomicReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader#ParallelAtomicReader(boolean,AtomicReader[],AtomicReader[]).mjava","sourceNew":"  /** Expert: create a ParallelAtomicReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelAtomicReader(boolean closeSubReaders, AtomicReader[] readers, AtomicReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final AtomicReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(AtomicReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n      \n    for (final AtomicReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for(FieldInfo fieldInfo : readerFieldInfos) { // update fieldToReader map\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          fieldInfos.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.isIndexed) {\n            this.fields.addField(fieldInfo.name, reader.terms(fieldInfo.name));\n          }\n        }\n      }\n    } \n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    if (!closeSubReaders) {\n      for (AtomicReader reader : completeReaderSet) {\n        reader.incRef();\n      }\n    }\n  }\n\n","sourceOld":"  /** Expert: create a ParallelAtomicReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelAtomicReader(boolean closeSubReaders, AtomicReader[] readers, AtomicReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final AtomicReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(AtomicReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n      \n    for (final AtomicReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for(FieldInfo fieldInfo : readerFieldInfos) { // update fieldToReader map\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          fieldInfos.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          this.fields.addField(fieldInfo.name, reader.terms(fieldInfo.name));\n        }\n      }\n    } \n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    if (!closeSubReaders) {\n      for (AtomicReader reader : completeReaderSet) {\n        reader.incRef();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d85ecdb6c60e4c2edb5455f39169bb2c4550c99a","date":1329841033,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader#ParallelAtomicReader(boolean,AtomicReader[],AtomicReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader#ParallelAtomicReader(boolean,AtomicReader[],AtomicReader[]).mjava","sourceNew":"  /** Expert: create a ParallelAtomicReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelAtomicReader(boolean closeSubReaders, AtomicReader[] readers, AtomicReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final AtomicReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(AtomicReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // build FieldInfos and fieldToReader map:\n    for (final AtomicReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          fieldInfos.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.storeTermVector) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    \n    // build Fields instance\n    for (final AtomicReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      if (readerFields != null) {\n        final FieldsEnum it = readerFields.iterator();\n        String name;\n        while ((name = it.next()) != null) {\n          // only add if the reader responsible for that field name is the current:\n          if (fieldToReader.get(name) == reader) {\n            this.fields.addField(name, it.terms());\n          }\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    if (!closeSubReaders) {\n      for (AtomicReader reader : completeReaderSet) {\n        reader.incRef();\n      }\n    }\n  }\n\n","sourceOld":"  /** Expert: create a ParallelAtomicReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelAtomicReader(boolean closeSubReaders, AtomicReader[] readers, AtomicReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final AtomicReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(AtomicReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n      \n    for (final AtomicReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for(FieldInfo fieldInfo : readerFieldInfos) { // update fieldToReader map\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          fieldInfos.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.isIndexed) {\n            this.fields.addField(fieldInfo.name, reader.terms(fieldInfo.name));\n          }\n        }\n      }\n    } \n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    if (!closeSubReaders) {\n      for (AtomicReader reader : completeReaderSet) {\n        reader.incRef();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a2a81b3988dfbdfb187c425043b89868e359b238","date":1329919075,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader#ParallelAtomicReader(boolean,AtomicReader[],AtomicReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader#ParallelAtomicReader(boolean,AtomicReader[],AtomicReader[]).mjava","sourceNew":"  /** Expert: create a ParallelAtomicReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelAtomicReader(boolean closeSubReaders, AtomicReader[] readers, AtomicReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final AtomicReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(AtomicReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // build FieldInfos and fieldToReader map:\n    for (final AtomicReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          fieldInfos.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.storeTermVector) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    \n    // build Fields instance\n    for (final AtomicReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      if (readerFields != null) {\n        final FieldsEnum it = readerFields.iterator();\n        String name;\n        while ((name = it.next()) != null) {\n          // only add if the reader responsible for that field name is the current:\n          if (fieldToReader.get(name) == reader) {\n            this.fields.addField(name, it.terms());\n          }\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (AtomicReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","sourceOld":"  /** Expert: create a ParallelAtomicReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelAtomicReader(boolean closeSubReaders, AtomicReader[] readers, AtomicReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final AtomicReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(AtomicReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // build FieldInfos and fieldToReader map:\n    for (final AtomicReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          fieldInfos.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.storeTermVector) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    \n    // build Fields instance\n    for (final AtomicReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      if (readerFields != null) {\n        final FieldsEnum it = readerFields.iterator();\n        String name;\n        while ((name = it.next()) != null) {\n          // only add if the reader responsible for that field name is the current:\n          if (fieldToReader.get(name) == reader) {\n            this.fields.addField(name, it.terms());\n          }\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    if (!closeSubReaders) {\n      for (AtomicReader reader : completeReaderSet) {\n        reader.incRef();\n      }\n    }\n  }\n\n","bugFix":["6e09a3a223be07d75777515a717312813221fe58"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader#ParallelAtomicReader(boolean,AtomicReader[],AtomicReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader#ParallelAtomicReader(boolean,AtomicReader[],AtomicReader[]).mjava","sourceNew":"  /** Expert: create a ParallelAtomicReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelAtomicReader(boolean closeSubReaders, AtomicReader[] readers, AtomicReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final AtomicReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(AtomicReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // build FieldInfos and fieldToReader map:\n    for (final AtomicReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          fieldInfos.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.storeTermVector) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    \n    // build Fields instance\n    for (final AtomicReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      if (readerFields != null) {\n        final FieldsEnum it = readerFields.iterator();\n        String name;\n        while ((name = it.next()) != null) {\n          // only add if the reader responsible for that field name is the current:\n          if (fieldToReader.get(name) == reader) {\n            this.fields.addField(name, it.terms());\n          }\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (AtomicReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","sourceOld":"  /** Expert: create a ParallelAtomicReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelAtomicReader(boolean closeSubReaders, AtomicReader[] readers, AtomicReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final AtomicReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(AtomicReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n      \n    for (final AtomicReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for(FieldInfo fieldInfo : readerFieldInfos) { // update fieldToReader map\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          fieldInfos.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          this.fields.addField(fieldInfo.name, reader.terms(fieldInfo.name));\n        }\n      }\n    } \n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    if (!closeSubReaders) {\n      for (AtomicReader reader : completeReaderSet) {\n        reader.incRef();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d08eba3d52b63561ebf936481ce73e6b6a14aa03","date":1333879759,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader#ParallelAtomicReader(boolean,AtomicReader[],AtomicReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader#ParallelAtomicReader(boolean,AtomicReader[],AtomicReader[]).mjava","sourceNew":"  /** Expert: create a ParallelAtomicReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelAtomicReader(boolean closeSubReaders, AtomicReader[] readers, AtomicReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final AtomicReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(AtomicReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // build FieldInfos and fieldToReader map:\n    for (final AtomicReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          fieldInfos.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.storeTermVector) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    \n    // build InvertedFields instance\n    for (final AtomicReader reader : this.parallelReaders) {\n      final InvertedFields readerFields = reader.fields();\n      if (readerFields != null) {\n        final FieldsEnum it = readerFields.iterator();\n        String name;\n        while ((name = it.next()) != null) {\n          // only add if the reader responsible for that field name is the current:\n          if (fieldToReader.get(name) == reader) {\n            this.fields.addField(name, it.terms());\n          }\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (AtomicReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","sourceOld":"  /** Expert: create a ParallelAtomicReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelAtomicReader(boolean closeSubReaders, AtomicReader[] readers, AtomicReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final AtomicReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(AtomicReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // build FieldInfos and fieldToReader map:\n    for (final AtomicReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          fieldInfos.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.storeTermVector) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    \n    // build Fields instance\n    for (final AtomicReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      if (readerFields != null) {\n        final FieldsEnum it = readerFields.iterator();\n        String name;\n        while ((name = it.next()) != null) {\n          // only add if the reader responsible for that field name is the current:\n          if (fieldToReader.get(name) == reader) {\n            this.fields.addField(name, it.terms());\n          }\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (AtomicReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf","date":1333892281,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader#ParallelAtomicReader(boolean,AtomicReader[],AtomicReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader#ParallelAtomicReader(boolean,AtomicReader[],AtomicReader[]).mjava","sourceNew":"  /** Expert: create a ParallelAtomicReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelAtomicReader(boolean closeSubReaders, AtomicReader[] readers, AtomicReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final AtomicReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(AtomicReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // build FieldInfos and fieldToReader map:\n    for (final AtomicReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          fieldInfos.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.storeTermVector) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    \n    // build Fields instance\n    for (final AtomicReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      if (readerFields != null) {\n        final FieldsEnum it = readerFields.iterator();\n        String name;\n        while ((name = it.next()) != null) {\n          // only add if the reader responsible for that field name is the current:\n          if (fieldToReader.get(name) == reader) {\n            this.fields.addField(name, it.terms());\n          }\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (AtomicReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","sourceOld":"  /** Expert: create a ParallelAtomicReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelAtomicReader(boolean closeSubReaders, AtomicReader[] readers, AtomicReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final AtomicReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(AtomicReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // build FieldInfos and fieldToReader map:\n    for (final AtomicReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          fieldInfos.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.storeTermVector) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    \n    // build InvertedFields instance\n    for (final AtomicReader reader : this.parallelReaders) {\n      final InvertedFields readerFields = reader.fields();\n      if (readerFields != null) {\n        final FieldsEnum it = readerFields.iterator();\n        String name;\n        while ((name = it.next()) != null) {\n          // only add if the reader responsible for that field name is the current:\n          if (fieldToReader.get(name) == reader) {\n            this.fields.addField(name, it.terms());\n          }\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (AtomicReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"76923f6a33f2c4bec7f584e3f251261afe7ea276","date":1337149711,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader#ParallelAtomicReader(boolean,AtomicReader[],AtomicReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader#ParallelAtomicReader(boolean,AtomicReader[],AtomicReader[]).mjava","sourceNew":"  /** Expert: create a ParallelAtomicReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelAtomicReader(boolean closeSubReaders, AtomicReader[] readers, AtomicReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final AtomicReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(AtomicReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    MutableFieldInfos builder = new MutableFieldInfos();\n    // build FieldInfos and fieldToReader map:\n    for (final AtomicReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    fieldInfos = builder.asReadOnly();\n    \n    // build Fields instance\n    for (final AtomicReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      if (readerFields != null) {\n        final FieldsEnum it = readerFields.iterator();\n        String name;\n        while ((name = it.next()) != null) {\n          // only add if the reader responsible for that field name is the current:\n          if (fieldToReader.get(name) == reader) {\n            this.fields.addField(name, it.terms());\n          }\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (AtomicReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","sourceOld":"  /** Expert: create a ParallelAtomicReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelAtomicReader(boolean closeSubReaders, AtomicReader[] readers, AtomicReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final AtomicReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(AtomicReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // build FieldInfos and fieldToReader map:\n    for (final AtomicReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          fieldInfos.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.storeTermVector) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    \n    // build Fields instance\n    for (final AtomicReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      if (readerFields != null) {\n        final FieldsEnum it = readerFields.iterator();\n        String name;\n        while ((name = it.next()) != null) {\n          // only add if the reader responsible for that field name is the current:\n          if (fieldToReader.get(name) == reader) {\n            this.fields.addField(name, it.terms());\n          }\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (AtomicReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"030c3c949a4d9470b22d6b1aa20e836d96c72cb7","date":1337350881,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader#ParallelAtomicReader(boolean,AtomicReader[],AtomicReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader#ParallelAtomicReader(boolean,AtomicReader[],AtomicReader[]).mjava","sourceNew":"  /** Expert: create a ParallelAtomicReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelAtomicReader(boolean closeSubReaders, AtomicReader[] readers, AtomicReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final AtomicReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(AtomicReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    MutableFieldInfos builder = new MutableFieldInfos();\n    // build FieldInfos and fieldToReader map:\n    for (final AtomicReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    fieldInfos = builder.finish();\n    \n    // build Fields instance\n    for (final AtomicReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      if (readerFields != null) {\n        final FieldsEnum it = readerFields.iterator();\n        String name;\n        while ((name = it.next()) != null) {\n          // only add if the reader responsible for that field name is the current:\n          if (fieldToReader.get(name) == reader) {\n            this.fields.addField(name, it.terms());\n          }\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (AtomicReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","sourceOld":"  /** Expert: create a ParallelAtomicReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelAtomicReader(boolean closeSubReaders, AtomicReader[] readers, AtomicReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final AtomicReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(AtomicReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    MutableFieldInfos builder = new MutableFieldInfos();\n    // build FieldInfos and fieldToReader map:\n    for (final AtomicReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    fieldInfos = builder.asReadOnly();\n    \n    // build Fields instance\n    for (final AtomicReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      if (readerFields != null) {\n        final FieldsEnum it = readerFields.iterator();\n        String name;\n        while ((name = it.next()) != null) {\n          // only add if the reader responsible for that field name is the current:\n          if (fieldToReader.get(name) == reader) {\n            this.fields.addField(name, it.terms());\n          }\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (AtomicReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a851824c09818632c94eba41e60ef5e72e323c8e","date":1337355760,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader#ParallelAtomicReader(boolean,AtomicReader[],AtomicReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader#ParallelAtomicReader(boolean,AtomicReader[],AtomicReader[]).mjava","sourceNew":"  /** Expert: create a ParallelAtomicReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelAtomicReader(boolean closeSubReaders, AtomicReader[] readers, AtomicReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final AtomicReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(AtomicReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n    // build FieldInfos and fieldToReader map:\n    for (final AtomicReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    fieldInfos = builder.finish();\n    \n    // build Fields instance\n    for (final AtomicReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      if (readerFields != null) {\n        final FieldsEnum it = readerFields.iterator();\n        String name;\n        while ((name = it.next()) != null) {\n          // only add if the reader responsible for that field name is the current:\n          if (fieldToReader.get(name) == reader) {\n            this.fields.addField(name, it.terms());\n          }\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (AtomicReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","sourceOld":"  /** Expert: create a ParallelAtomicReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelAtomicReader(boolean closeSubReaders, AtomicReader[] readers, AtomicReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final AtomicReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(AtomicReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    MutableFieldInfos builder = new MutableFieldInfos();\n    // build FieldInfos and fieldToReader map:\n    for (final AtomicReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    fieldInfos = builder.finish();\n    \n    // build Fields instance\n    for (final AtomicReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      if (readerFields != null) {\n        final FieldsEnum it = readerFields.iterator();\n        String name;\n        while ((name = it.next()) != null) {\n          // only add if the reader responsible for that field name is the current:\n          if (fieldToReader.get(name) == reader) {\n            this.fields.addField(name, it.terms());\n          }\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (AtomicReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader#ParallelAtomicReader(boolean,AtomicReader[],AtomicReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader#ParallelAtomicReader(boolean,AtomicReader[],AtomicReader[]).mjava","sourceNew":"  /** Expert: create a ParallelAtomicReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelAtomicReader(boolean closeSubReaders, AtomicReader[] readers, AtomicReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final AtomicReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(AtomicReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n    // build FieldInfos and fieldToReader map:\n    for (final AtomicReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    fieldInfos = builder.finish();\n    \n    // build Fields instance\n    for (final AtomicReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      if (readerFields != null) {\n        final FieldsEnum it = readerFields.iterator();\n        String name;\n        while ((name = it.next()) != null) {\n          // only add if the reader responsible for that field name is the current:\n          if (fieldToReader.get(name) == reader) {\n            this.fields.addField(name, it.terms());\n          }\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (AtomicReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","sourceOld":"  /** Expert: create a ParallelAtomicReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelAtomicReader(boolean closeSubReaders, AtomicReader[] readers, AtomicReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final AtomicReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(AtomicReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // build FieldInfos and fieldToReader map:\n    for (final AtomicReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          fieldInfos.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.storeTermVector) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    \n    // build Fields instance\n    for (final AtomicReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      if (readerFields != null) {\n        final FieldsEnum it = readerFields.iterator();\n        String name;\n        while ((name = it.next()) != null) {\n          // only add if the reader responsible for that field name is the current:\n          if (fieldToReader.get(name) == reader) {\n            this.fields.addField(name, it.terms());\n          }\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (AtomicReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb07ab105350b80ed9d63ca64b117084ed7391bc","date":1344824719,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader#ParallelAtomicReader(boolean,AtomicReader[],AtomicReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader#ParallelAtomicReader(boolean,AtomicReader[],AtomicReader[]).mjava","sourceNew":"  /** Expert: create a ParallelAtomicReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelAtomicReader(boolean closeSubReaders, AtomicReader[] readers, AtomicReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final AtomicReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(AtomicReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n    // build FieldInfos and fieldToReader map:\n    for (final AtomicReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    fieldInfos = builder.finish();\n    \n    // build Fields instance\n    for (final AtomicReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      if (readerFields != null) {\n        for (String field : readerFields) {\n          // only add if the reader responsible for that field name is the current:\n          if (fieldToReader.get(field) == reader) {\n            this.fields.addField(field, readerFields.terms(field));\n          }\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (AtomicReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","sourceOld":"  /** Expert: create a ParallelAtomicReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelAtomicReader(boolean closeSubReaders, AtomicReader[] readers, AtomicReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final AtomicReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(AtomicReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n    // build FieldInfos and fieldToReader map:\n    for (final AtomicReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    fieldInfos = builder.finish();\n    \n    // build Fields instance\n    for (final AtomicReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      if (readerFields != null) {\n        final FieldsEnum it = readerFields.iterator();\n        String name;\n        while ((name = it.next()) != null) {\n          // only add if the reader responsible for that field name is the current:\n          if (fieldToReader.get(name) == reader) {\n            this.fields.addField(name, it.terms());\n          }\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (AtomicReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader#ParallelAtomicReader(boolean,AtomicReader[],AtomicReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader#ParallelAtomicReader(boolean,AtomicReader[],AtomicReader[]).mjava","sourceNew":"  /** Expert: create a ParallelAtomicReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelAtomicReader(boolean closeSubReaders, AtomicReader[] readers, AtomicReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final AtomicReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(AtomicReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n    // build FieldInfos and fieldToReader map:\n    for (final AtomicReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    fieldInfos = builder.finish();\n    \n    // build Fields instance\n    for (final AtomicReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      if (readerFields != null) {\n        for (String field : readerFields) {\n          // only add if the reader responsible for that field name is the current:\n          if (fieldToReader.get(field) == reader) {\n            this.fields.addField(field, readerFields.terms(field));\n          }\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (AtomicReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","sourceOld":"  /** Expert: create a ParallelAtomicReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelAtomicReader(boolean closeSubReaders, AtomicReader[] readers, AtomicReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final AtomicReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(AtomicReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n    // build FieldInfos and fieldToReader map:\n    for (final AtomicReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    fieldInfos = builder.finish();\n    \n    // build Fields instance\n    for (final AtomicReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      if (readerFields != null) {\n        final FieldsEnum it = readerFields.iterator();\n        String name;\n        while ((name = it.next()) != null) {\n          // only add if the reader responsible for that field name is the current:\n          if (fieldToReader.get(name) == reader) {\n            this.fields.addField(name, it.terms());\n          }\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (AtomicReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","date":1344867506,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader#ParallelAtomicReader(boolean,AtomicReader[],AtomicReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader#ParallelAtomicReader(boolean,AtomicReader[],AtomicReader[]).mjava","sourceNew":"  /** Expert: create a ParallelAtomicReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelAtomicReader(boolean closeSubReaders, AtomicReader[] readers, AtomicReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final AtomicReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(AtomicReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n    // build FieldInfos and fieldToReader map:\n    for (final AtomicReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    fieldInfos = builder.finish();\n    \n    // build Fields instance\n    for (final AtomicReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      if (readerFields != null) {\n        for (String field : readerFields) {\n          // only add if the reader responsible for that field name is the current:\n          if (fieldToReader.get(field) == reader) {\n            this.fields.addField(field, readerFields.terms(field));\n          }\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (AtomicReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","sourceOld":"  /** Expert: create a ParallelAtomicReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelAtomicReader(boolean closeSubReaders, AtomicReader[] readers, AtomicReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final AtomicReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(AtomicReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n    // build FieldInfos and fieldToReader map:\n    for (final AtomicReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    fieldInfos = builder.finish();\n    \n    // build Fields instance\n    for (final AtomicReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      if (readerFields != null) {\n        final FieldsEnum it = readerFields.iterator();\n        String name;\n        while ((name = it.next()) != null) {\n          // only add if the reader responsible for that field name is the current:\n          if (fieldToReader.get(name) == reader) {\n            this.fields.addField(name, it.terms());\n          }\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (AtomicReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":4,"author":"Ryan Ernst","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader#ParallelAtomicReader(boolean,AtomicReader[],AtomicReader[]).mjava","sourceNew":null,"sourceOld":"  /** Expert: create a ParallelAtomicReader based on the provided\n   *  readers and storedFieldReaders; when a document is\n   *  loaded, only storedFieldsReaders will be used. */\n  public ParallelAtomicReader(boolean closeSubReaders, AtomicReader[] readers, AtomicReader[] storedFieldsReaders) throws IOException {\n    this.closeSubReaders = closeSubReaders;\n    if (readers.length == 0 && storedFieldsReaders.length > 0)\n      throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n    this.parallelReaders = readers.clone();\n    this.storedFieldsReaders = storedFieldsReaders.clone();\n    if (parallelReaders.length > 0) {\n      final AtomicReader first = parallelReaders[0];\n      this.maxDoc = first.maxDoc();\n      this.numDocs = first.numDocs();\n      this.hasDeletions = first.hasDeletions();\n    } else {\n      this.maxDoc = this.numDocs = 0;\n      this.hasDeletions = false;\n    }\n    Collections.addAll(completeReaderSet, this.parallelReaders);\n    Collections.addAll(completeReaderSet, this.storedFieldsReaders);\n    \n    // check compatibility:\n    for(AtomicReader reader : completeReaderSet) {\n      if (reader.maxDoc() != maxDoc) {\n        throw new IllegalArgumentException(\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n      }\n    }\n    \n    // TODO: make this read-only in a cleaner way?\n    FieldInfos.Builder builder = new FieldInfos.Builder();\n    // build FieldInfos and fieldToReader map:\n    for (final AtomicReader reader : this.parallelReaders) {\n      final FieldInfos readerFieldInfos = reader.getFieldInfos();\n      for (FieldInfo fieldInfo : readerFieldInfos) {\n        // NOTE: first reader having a given field \"wins\":\n        if (!fieldToReader.containsKey(fieldInfo.name)) {\n          builder.add(fieldInfo);\n          fieldToReader.put(fieldInfo.name, reader);\n          if (fieldInfo.hasVectors()) {\n            tvFieldToReader.put(fieldInfo.name, reader);\n          }\n        }\n      }\n    }\n    fieldInfos = builder.finish();\n    \n    // build Fields instance\n    for (final AtomicReader reader : this.parallelReaders) {\n      final Fields readerFields = reader.fields();\n      if (readerFields != null) {\n        for (String field : readerFields) {\n          // only add if the reader responsible for that field name is the current:\n          if (fieldToReader.get(field) == reader) {\n            this.fields.addField(field, readerFields.terms(field));\n          }\n        }\n      }\n    }\n\n    // do this finally so any Exceptions occurred before don't affect refcounts:\n    for (AtomicReader reader : completeReaderSet) {\n      if (!closeSubReaders) {\n        reader.incRef();\n      }\n      reader.registerParentReader(this);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["c9fa925e715e5bcc90af5416555a98a001309c1e","a2a81b3988dfbdfb187c425043b89868e359b238"],"fb07ab105350b80ed9d63ca64b117084ed7391bc":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"030c3c949a4d9470b22d6b1aa20e836d96c72cb7":["76923f6a33f2c4bec7f584e3f251261afe7ea276"],"d08eba3d52b63561ebf936481ce73e6b6a14aa03":["a2a81b3988dfbdfb187c425043b89868e359b238"],"a851824c09818632c94eba41e60ef5e72e323c8e":["030c3c949a4d9470b22d6b1aa20e836d96c72cb7"],"6e09a3a223be07d75777515a717312813221fe58":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["fb07ab105350b80ed9d63ca64b117084ed7391bc"],"a2a81b3988dfbdfb187c425043b89868e359b238":["d85ecdb6c60e4c2edb5455f39169bb2c4550c99a"],"76923f6a33f2c4bec7f584e3f251261afe7ea276":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf","a851824c09818632c94eba41e60ef5e72e323c8e"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","fb07ab105350b80ed9d63ca64b117084ed7391bc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf":["d08eba3d52b63561ebf936481ce73e6b6a14aa03"],"c9fa925e715e5bcc90af5416555a98a001309c1e":["6e09a3a223be07d75777515a717312813221fe58"],"d85ecdb6c60e4c2edb5455f39169bb2c4550c99a":["54184c8fa13303a999acbb2f54de8b5d8d1b1bd7"],"54184c8fa13303a999acbb2f54de8b5d8d1b1bd7":["c9fa925e715e5bcc90af5416555a98a001309c1e"],"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","fb07ab105350b80ed9d63ca64b117084ed7391bc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c9fb5f46e264daf5ba3860defe623a89d202dd87"]},"commit2Childs":{"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"fb07ab105350b80ed9d63ca64b117084ed7391bc":["c9fb5f46e264daf5ba3860defe623a89d202dd87","c7869f64c874ebf7f317d22c00baf2b6857797a6","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9"],"030c3c949a4d9470b22d6b1aa20e836d96c72cb7":["a851824c09818632c94eba41e60ef5e72e323c8e"],"d08eba3d52b63561ebf936481ce73e6b6a14aa03":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf"],"a851824c09818632c94eba41e60ef5e72e323c8e":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"6e09a3a223be07d75777515a717312813221fe58":["c9fa925e715e5bcc90af5416555a98a001309c1e"],"a2a81b3988dfbdfb187c425043b89868e359b238":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","d08eba3d52b63561ebf936481ce73e6b6a14aa03"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"76923f6a33f2c4bec7f584e3f251261afe7ea276":["030c3c949a4d9470b22d6b1aa20e836d96c72cb7"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["fb07ab105350b80ed9d63ca64b117084ed7391bc","c7869f64c874ebf7f317d22c00baf2b6857797a6","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6e09a3a223be07d75777515a717312813221fe58"],"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf":["76923f6a33f2c4bec7f584e3f251261afe7ea276","615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"c9fa925e715e5bcc90af5416555a98a001309c1e":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","54184c8fa13303a999acbb2f54de8b5d8d1b1bd7"],"d85ecdb6c60e4c2edb5455f39169bb2c4550c99a":["a2a81b3988dfbdfb187c425043b89868e359b238"],"54184c8fa13303a999acbb2f54de8b5d8d1b1bd7":["d85ecdb6c60e4c2edb5455f39169bb2c4550c99a"],"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","c7869f64c874ebf7f317d22c00baf2b6857797a6","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}