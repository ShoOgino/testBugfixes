{"path":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","pathOld":"solr/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","sourceNew":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of DateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n  }\n\n","sourceOld":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of DateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","pathOld":"solr/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","sourceNew":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of DateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n  }\n\n","sourceOld":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of DateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","pathOld":"solr/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","sourceNew":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of DateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n  }\n\n","sourceOld":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of DateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"461fea4b90072bede0ef2dc0dba66a8c5dbf1356","date":1316194960,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","pathOld":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","sourceNew":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n    clearIndex();\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of DateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n  }\n\n","sourceOld":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of DateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b3c7501e15f71c01b69ba22749b192827fa2019b","date":1335285341,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","pathOld":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","sourceNew":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n    clearIndex();\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of DateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n    assertQ(\"check counts using fixed NOW\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=1]\");\n                \n    assertQ(\"check counts using fixed NOW and TZ rounding\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"TZ\", \"GMT-23\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=0]\");\n\n  }\n\n","sourceOld":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n    clearIndex();\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of DateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n  }\n\n","bugFix":null,"bugIntro":["ba0bb1c61dbf71a82da9a3ea8cda3d481f703d29"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0fad4c5c26f8a062d31d59ceb5ea2dc3ca38aef","date":1363025664,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","pathOld":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","sourceNew":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n    clearIndex();\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of DateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n    \n    // a ridiculoulsy long date math expression that's still equivilent to july4\n    final StringBuilder july4Long = new StringBuilder(july4);\n    final int iters = atLeast(10);\n    for (int i = 0; i < iters; i++) {\n      final String val = String.valueOf(atLeast(1));\n      july4Long.append(\"+\" + val + \"SECONDS-\" + val + \"SECONDS\");\n    }\n\n    // term queries using date math (all of these should match doc#1)\n    for (String q : \n           new String[] {\n             \"bday:1976-07-04T12\\\\:08\\\\:56.45Z/SECOND+235MILLIS\",\n             \"bday:1976-07-04T12\\\\:08\\\\:56.123Z/MINUTE+56SECONDS+235MILLIS\",\n             \"bday:\\\"1976-07-04T12:08:56.45Z/SECOND+235MILLIS\\\"\",\n             \"bday:\\\"1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\\\"\",\n             \"{!term f=bday}1976-07-04T12:08:56.45Z/SECOND+235MILLIS\",\n             \"{!term f=bday}1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\",             \n             \"{!term f=bday}\"+july4,\n             \"{!term f=bday}\"+july4Long,\n             \"bday:\\\"\" + july4Long + \"\\\"\"\n           }) {\n      assertQ(\"check math on field query: \" + q,\n              req(\"q\", q),\n              \"*[count(//doc)=1]\",\n              \"//int[@name='id'][.='1']\");\n    }\n\n    // range queries using date math\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n    assertQ(\"check counts using fixed NOW\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=1]\");\n                \n    assertQ(\"check counts using fixed NOW and TZ rounding\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"TZ\", \"GMT-23\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=0]\");\n\n  }\n\n","sourceOld":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n    clearIndex();\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of DateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n    assertQ(\"check counts using fixed NOW\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=1]\");\n                \n    assertQ(\"check counts using fixed NOW and TZ rounding\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"TZ\", \"GMT-23\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=0]\");\n\n  }\n\n","bugFix":null,"bugIntro":["9f4251f14d2db68330fc1e6f0495c053a905d560"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2106271e380c198349e0f6eac0395bb462913fab","date":1397072894,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","pathOld":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","sourceNew":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n    clearIndex();\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of TrieDateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n    \n    // a ridiculoulsy long date math expression that's still equivilent to july4\n    final StringBuilder july4Long = new StringBuilder(july4);\n    final int iters = atLeast(10);\n    for (int i = 0; i < iters; i++) {\n      final String val = String.valueOf(atLeast(1));\n      july4Long.append(\"+\" + val + \"SECONDS-\" + val + \"SECONDS\");\n    }\n\n    // term queries using date math (all of these should match doc#1)\n    for (String q : \n           new String[] {\n             \"bday:1976-07-04T12\\\\:08\\\\:56.45Z/SECOND+235MILLIS\",\n             \"bday:1976-07-04T12\\\\:08\\\\:56.123Z/MINUTE+56SECONDS+235MILLIS\",\n             \"bday:\\\"1976-07-04T12:08:56.45Z/SECOND+235MILLIS\\\"\",\n             \"bday:\\\"1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\\\"\",\n             \"{!term f=bday}1976-07-04T12:08:56.45Z/SECOND+235MILLIS\",\n             \"{!term f=bday}1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\",             \n             \"{!term f=bday}\"+july4,\n             \"{!term f=bday}\"+july4Long,\n             \"bday:\\\"\" + july4Long + \"\\\"\"\n           }) {\n      assertQ(\"check math on field query: \" + q,\n              req(\"q\", q),\n              \"*[count(//doc)=1]\",\n              \"//int[@name='id'][.='1']\");\n    }\n\n    // range queries using date math\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n    assertQ(\"check counts using fixed NOW\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=1]\");\n                \n    assertQ(\"check counts using fixed NOW and TZ rounding\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"TZ\", \"GMT-23\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=0]\");\n\n  }\n\n","sourceOld":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n    clearIndex();\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of DateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n    \n    // a ridiculoulsy long date math expression that's still equivilent to july4\n    final StringBuilder july4Long = new StringBuilder(july4);\n    final int iters = atLeast(10);\n    for (int i = 0; i < iters; i++) {\n      final String val = String.valueOf(atLeast(1));\n      july4Long.append(\"+\" + val + \"SECONDS-\" + val + \"SECONDS\");\n    }\n\n    // term queries using date math (all of these should match doc#1)\n    for (String q : \n           new String[] {\n             \"bday:1976-07-04T12\\\\:08\\\\:56.45Z/SECOND+235MILLIS\",\n             \"bday:1976-07-04T12\\\\:08\\\\:56.123Z/MINUTE+56SECONDS+235MILLIS\",\n             \"bday:\\\"1976-07-04T12:08:56.45Z/SECOND+235MILLIS\\\"\",\n             \"bday:\\\"1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\\\"\",\n             \"{!term f=bday}1976-07-04T12:08:56.45Z/SECOND+235MILLIS\",\n             \"{!term f=bday}1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\",             \n             \"{!term f=bday}\"+july4,\n             \"{!term f=bday}\"+july4Long,\n             \"bday:\\\"\" + july4Long + \"\\\"\"\n           }) {\n      assertQ(\"check math on field query: \" + q,\n              req(\"q\", q),\n              \"*[count(//doc)=1]\",\n              \"//int[@name='id'][.='1']\");\n    }\n\n    // range queries using date math\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n    assertQ(\"check counts using fixed NOW\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=1]\");\n                \n    assertQ(\"check counts using fixed NOW and TZ rounding\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"TZ\", \"GMT-23\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=0]\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba0bb1c61dbf71a82da9a3ea8cda3d481f703d29","date":1463148204,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","pathOld":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","sourceNew":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n    clearIndex();\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of TrieDateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n    \n    // a ridiculoulsy long date math expression that's still equivilent to july4\n    final StringBuilder july4Long = new StringBuilder(july4);\n    final int iters = atLeast(10);\n    for (int i = 0; i < iters; i++) {\n      final String val = String.valueOf(atLeast(1));\n      july4Long.append(\"+\" + val + \"SECONDS-\" + val + \"SECONDS\");\n    }\n\n    // term queries using date math (all of these should match doc#1)\n    for (String q : \n           new String[] {\n             \"bday:1976-07-04T12\\\\:08\\\\:56.45Z/SECOND+235MILLIS\",\n             \"bday:1976-07-04T12\\\\:08\\\\:56.123Z/MINUTE+56SECONDS+235MILLIS\",\n             \"bday:\\\"1976-07-04T12:08:56.45Z/SECOND+235MILLIS\\\"\",\n             \"bday:\\\"1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\\\"\",\n             \"{!term f=bday}1976-07-04T12:08:56.45Z/SECOND+235MILLIS\",\n             \"{!term f=bday}1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\",             \n             \"{!term f=bday}\"+july4,\n             \"{!term f=bday}\"+july4Long,\n             \"bday:\\\"\" + july4Long + \"\\\"\"\n           }) {\n      assertQ(\"check math on field query: \" + q,\n              req(\"q\", q),\n              \"*[count(//doc)=1]\",\n              \"//int[@name='id'][.='1']\");\n    }\n\n    // range queries using date math\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n    assertQ(\"check counts using fixed NOW\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=1]\");\n                \n    assertQ(\"check counts using fixed NOW and TZ rounding\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"TZ\", \"GMT+01\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=0]\");\n\n  }\n\n","sourceOld":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n    clearIndex();\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of TrieDateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n    \n    // a ridiculoulsy long date math expression that's still equivilent to july4\n    final StringBuilder july4Long = new StringBuilder(july4);\n    final int iters = atLeast(10);\n    for (int i = 0; i < iters; i++) {\n      final String val = String.valueOf(atLeast(1));\n      july4Long.append(\"+\" + val + \"SECONDS-\" + val + \"SECONDS\");\n    }\n\n    // term queries using date math (all of these should match doc#1)\n    for (String q : \n           new String[] {\n             \"bday:1976-07-04T12\\\\:08\\\\:56.45Z/SECOND+235MILLIS\",\n             \"bday:1976-07-04T12\\\\:08\\\\:56.123Z/MINUTE+56SECONDS+235MILLIS\",\n             \"bday:\\\"1976-07-04T12:08:56.45Z/SECOND+235MILLIS\\\"\",\n             \"bday:\\\"1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\\\"\",\n             \"{!term f=bday}1976-07-04T12:08:56.45Z/SECOND+235MILLIS\",\n             \"{!term f=bday}1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\",             \n             \"{!term f=bday}\"+july4,\n             \"{!term f=bday}\"+july4Long,\n             \"bday:\\\"\" + july4Long + \"\\\"\"\n           }) {\n      assertQ(\"check math on field query: \" + q,\n              req(\"q\", q),\n              \"*[count(//doc)=1]\",\n              \"//int[@name='id'][.='1']\");\n    }\n\n    // range queries using date math\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n    assertQ(\"check counts using fixed NOW\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=1]\");\n                \n    assertQ(\"check counts using fixed NOW and TZ rounding\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"TZ\", \"GMT-23\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=0]\");\n\n  }\n\n","bugFix":["b3c7501e15f71c01b69ba22749b192827fa2019b"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ad30c6a479e764150a3316e57263319775f1df2","date":1463395403,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","pathOld":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","sourceNew":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n    clearIndex();\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of TrieDateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n    \n    // a ridiculoulsy long date math expression that's still equivilent to july4\n    final StringBuilder july4Long = new StringBuilder(july4);\n    final int iters = atLeast(10);\n    for (int i = 0; i < iters; i++) {\n      final String val = String.valueOf(atLeast(1));\n      july4Long.append(\"+\" + val + \"SECONDS-\" + val + \"SECONDS\");\n    }\n\n    // term queries using date math (all of these should match doc#1)\n    for (String q : \n           new String[] {\n             \"bday:1976-07-04T12\\\\:08\\\\:56.45Z/SECOND+235MILLIS\",\n             \"bday:1976-07-04T12\\\\:08\\\\:56.123Z/MINUTE+56SECONDS+235MILLIS\",\n             \"bday:\\\"1976-07-04T12:08:56.45Z/SECOND+235MILLIS\\\"\",\n             \"bday:\\\"1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\\\"\",\n             \"{!term f=bday}1976-07-04T12:08:56.45Z/SECOND+235MILLIS\",\n             \"{!term f=bday}1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\",             \n             \"{!term f=bday}\"+july4,\n             \"{!term f=bday}\"+july4Long,\n             \"bday:\\\"\" + july4Long + \"\\\"\"\n           }) {\n      assertQ(\"check math on field query: \" + q,\n              req(\"q\", q),\n              \"*[count(//doc)=1]\",\n              \"//int[@name='id'][.='1']\");\n    }\n\n    // range queries using date math\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n    assertQ(\"check counts using fixed NOW\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=1]\");\n                \n    assertQ(\"check counts using fixed NOW and TZ rounding\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"TZ\", \"GMT+01\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=0]\");\n\n  }\n\n","sourceOld":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n    clearIndex();\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of TrieDateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n    \n    // a ridiculoulsy long date math expression that's still equivilent to july4\n    final StringBuilder july4Long = new StringBuilder(july4);\n    final int iters = atLeast(10);\n    for (int i = 0; i < iters; i++) {\n      final String val = String.valueOf(atLeast(1));\n      july4Long.append(\"+\" + val + \"SECONDS-\" + val + \"SECONDS\");\n    }\n\n    // term queries using date math (all of these should match doc#1)\n    for (String q : \n           new String[] {\n             \"bday:1976-07-04T12\\\\:08\\\\:56.45Z/SECOND+235MILLIS\",\n             \"bday:1976-07-04T12\\\\:08\\\\:56.123Z/MINUTE+56SECONDS+235MILLIS\",\n             \"bday:\\\"1976-07-04T12:08:56.45Z/SECOND+235MILLIS\\\"\",\n             \"bday:\\\"1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\\\"\",\n             \"{!term f=bday}1976-07-04T12:08:56.45Z/SECOND+235MILLIS\",\n             \"{!term f=bday}1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\",             \n             \"{!term f=bday}\"+july4,\n             \"{!term f=bday}\"+july4Long,\n             \"bday:\\\"\" + july4Long + \"\\\"\"\n           }) {\n      assertQ(\"check math on field query: \" + q,\n              req(\"q\", q),\n              \"*[count(//doc)=1]\",\n              \"//int[@name='id'][.='1']\");\n    }\n\n    // range queries using date math\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n    assertQ(\"check counts using fixed NOW\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=1]\");\n                \n    assertQ(\"check counts using fixed NOW and TZ rounding\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"TZ\", \"GMT-23\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=0]\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","pathOld":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","sourceNew":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n    clearIndex();\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of TrieDateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n    \n    // a ridiculoulsy long date math expression that's still equivilent to july4\n    final StringBuilder july4Long = new StringBuilder(july4);\n    final int iters = atLeast(10);\n    for (int i = 0; i < iters; i++) {\n      final String val = String.valueOf(atLeast(1));\n      july4Long.append(\"+\" + val + \"SECONDS-\" + val + \"SECONDS\");\n    }\n\n    // term queries using date math (all of these should match doc#1)\n    for (String q : \n           new String[] {\n             \"bday:1976-07-04T12\\\\:08\\\\:56.45Z/SECOND+235MILLIS\",\n             \"bday:1976-07-04T12\\\\:08\\\\:56.123Z/MINUTE+56SECONDS+235MILLIS\",\n             \"bday:\\\"1976-07-04T12:08:56.45Z/SECOND+235MILLIS\\\"\",\n             \"bday:\\\"1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\\\"\",\n             \"{!term f=bday}1976-07-04T12:08:56.45Z/SECOND+235MILLIS\",\n             \"{!term f=bday}1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\",             \n             \"{!term f=bday}\"+july4,\n             \"{!term f=bday}\"+july4Long,\n             \"bday:\\\"\" + july4Long + \"\\\"\"\n           }) {\n      assertQ(\"check math on field query: \" + q,\n              req(\"q\", q),\n              \"*[count(//doc)=1]\",\n              \"//int[@name='id'][.='1']\");\n    }\n\n    // range queries using date math\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n    assertQ(\"check counts using fixed NOW\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=1]\");\n                \n    assertQ(\"check counts using fixed NOW and TZ rounding\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"TZ\", \"GMT+01\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=0]\");\n\n  }\n\n","sourceOld":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n    clearIndex();\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of TrieDateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n    \n    // a ridiculoulsy long date math expression that's still equivilent to july4\n    final StringBuilder july4Long = new StringBuilder(july4);\n    final int iters = atLeast(10);\n    for (int i = 0; i < iters; i++) {\n      final String val = String.valueOf(atLeast(1));\n      july4Long.append(\"+\" + val + \"SECONDS-\" + val + \"SECONDS\");\n    }\n\n    // term queries using date math (all of these should match doc#1)\n    for (String q : \n           new String[] {\n             \"bday:1976-07-04T12\\\\:08\\\\:56.45Z/SECOND+235MILLIS\",\n             \"bday:1976-07-04T12\\\\:08\\\\:56.123Z/MINUTE+56SECONDS+235MILLIS\",\n             \"bday:\\\"1976-07-04T12:08:56.45Z/SECOND+235MILLIS\\\"\",\n             \"bday:\\\"1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\\\"\",\n             \"{!term f=bday}1976-07-04T12:08:56.45Z/SECOND+235MILLIS\",\n             \"{!term f=bday}1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\",             \n             \"{!term f=bday}\"+july4,\n             \"{!term f=bday}\"+july4Long,\n             \"bday:\\\"\" + july4Long + \"\\\"\"\n           }) {\n      assertQ(\"check math on field query: \" + q,\n              req(\"q\", q),\n              \"*[count(//doc)=1]\",\n              \"//int[@name='id'][.='1']\");\n    }\n\n    // range queries using date math\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n    assertQ(\"check counts using fixed NOW\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=1]\");\n                \n    assertQ(\"check counts using fixed NOW and TZ rounding\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"TZ\", \"GMT-23\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=0]\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","pathOld":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","sourceNew":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n    clearIndex();\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of TrieDateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n    \n    // a ridiculoulsy long date math expression that's still equivilent to july4\n    final StringBuilder july4Long = new StringBuilder(july4);\n    final int iters = atLeast(10);\n    for (int i = 0; i < iters; i++) {\n      final String val = String.valueOf(atLeast(1));\n      july4Long.append(\"+\" + val + \"SECONDS-\" + val + \"SECONDS\");\n    }\n\n    // term queries using date math (all of these should match doc#1)\n    for (String q : \n           new String[] {\n             \"bday:1976-07-04T12\\\\:08\\\\:56.45Z/SECOND+235MILLIS\",\n             \"bday:1976-07-04T12\\\\:08\\\\:56.123Z/MINUTE+56SECONDS+235MILLIS\",\n             \"bday:\\\"1976-07-04T12:08:56.45Z/SECOND+235MILLIS\\\"\",\n             \"bday:\\\"1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\\\"\",\n             \"{!term f=bday}1976-07-04T12:08:56.45Z/SECOND+235MILLIS\",\n             \"{!term f=bday}1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\",             \n             \"{!term f=bday}\"+july4,\n             \"{!term f=bday}\"+july4Long,\n             \"bday:\\\"\" + july4Long + \"\\\"\"\n           }) {\n      assertQ(\"check math on field query: \" + q,\n              req(\"q\", q),\n              \"*[count(//doc)=1]\",\n              \"//int[@name='id'][.='1']\");\n    }\n\n    // range queries using date math\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n    assertQ(\"check counts using fixed NOW\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=1]\");\n                \n    assertQ(\"check counts using fixed NOW and TZ rounding\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"TZ\", \"GMT+01\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=0]\");\n\n  }\n\n","sourceOld":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n    clearIndex();\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of TrieDateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n    \n    // a ridiculoulsy long date math expression that's still equivilent to july4\n    final StringBuilder july4Long = new StringBuilder(july4);\n    final int iters = atLeast(10);\n    for (int i = 0; i < iters; i++) {\n      final String val = String.valueOf(atLeast(1));\n      july4Long.append(\"+\" + val + \"SECONDS-\" + val + \"SECONDS\");\n    }\n\n    // term queries using date math (all of these should match doc#1)\n    for (String q : \n           new String[] {\n             \"bday:1976-07-04T12\\\\:08\\\\:56.45Z/SECOND+235MILLIS\",\n             \"bday:1976-07-04T12\\\\:08\\\\:56.123Z/MINUTE+56SECONDS+235MILLIS\",\n             \"bday:\\\"1976-07-04T12:08:56.45Z/SECOND+235MILLIS\\\"\",\n             \"bday:\\\"1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\\\"\",\n             \"{!term f=bday}1976-07-04T12:08:56.45Z/SECOND+235MILLIS\",\n             \"{!term f=bday}1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\",             \n             \"{!term f=bday}\"+july4,\n             \"{!term f=bday}\"+july4Long,\n             \"bday:\\\"\" + july4Long + \"\\\"\"\n           }) {\n      assertQ(\"check math on field query: \" + q,\n              req(\"q\", q),\n              \"*[count(//doc)=1]\",\n              \"//int[@name='id'][.='1']\");\n    }\n\n    // range queries using date math\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n    assertQ(\"check counts using fixed NOW\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=1]\");\n                \n    assertQ(\"check counts using fixed NOW and TZ rounding\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"TZ\", \"GMT-23\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=0]\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a71f63026529f3c1f03cfdd664910873ab2369ae","date":1497543264,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","pathOld":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","sourceNew":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n    clearIndex();\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of TrieDateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n    \n    // a ridiculoulsy long date math expression that's still equivilent to july4\n    final StringBuilder july4Long = new StringBuilder(july4);\n    final int iters = atLeast(10);\n    for (int i = 0; i < iters; i++) {\n      final String val = String.valueOf(atLeast(1));\n      july4Long.append(\"+\" + val + \"SECONDS-\" + val + \"SECONDS\");\n    }\n\n    // term queries using date math (all of these should match doc#1)\n    for (String q : \n           new String[] {\n             \"bday:1976-07-04T12\\\\:08\\\\:56.45Z/SECOND+235MILLIS\",\n             \"bday:1976-07-04T12\\\\:08\\\\:56.123Z/MINUTE+56SECONDS+235MILLIS\",\n             \"bday:\\\"1976-07-04T12:08:56.45Z/SECOND+235MILLIS\\\"\",\n             \"bday:\\\"1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\\\"\",\n             \"{!term f=bday}1976-07-04T12:08:56.45Z/SECOND+235MILLIS\",\n             \"{!term f=bday}1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\",             \n             \"{!term f=bday}\"+july4,\n             \"{!term f=bday}\"+july4Long,\n             \"bday:\\\"\" + july4Long + \"\\\"\"\n           }) {\n      assertQ(\"check math on field query: \" + q,\n              req(\"q\", q),\n              \"*[count(//doc)=1]\",\n              \"//str[@name='id'][.='1']\");\n    }\n\n    // range queries using date math\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n    assertQ(\"check counts using fixed NOW\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=1]\");\n                \n    assertQ(\"check counts using fixed NOW and TZ rounding\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"TZ\", \"GMT+01\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=0]\");\n\n  }\n\n","sourceOld":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n    clearIndex();\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of TrieDateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n    \n    // a ridiculoulsy long date math expression that's still equivilent to july4\n    final StringBuilder july4Long = new StringBuilder(july4);\n    final int iters = atLeast(10);\n    for (int i = 0; i < iters; i++) {\n      final String val = String.valueOf(atLeast(1));\n      july4Long.append(\"+\" + val + \"SECONDS-\" + val + \"SECONDS\");\n    }\n\n    // term queries using date math (all of these should match doc#1)\n    for (String q : \n           new String[] {\n             \"bday:1976-07-04T12\\\\:08\\\\:56.45Z/SECOND+235MILLIS\",\n             \"bday:1976-07-04T12\\\\:08\\\\:56.123Z/MINUTE+56SECONDS+235MILLIS\",\n             \"bday:\\\"1976-07-04T12:08:56.45Z/SECOND+235MILLIS\\\"\",\n             \"bday:\\\"1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\\\"\",\n             \"{!term f=bday}1976-07-04T12:08:56.45Z/SECOND+235MILLIS\",\n             \"{!term f=bday}1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\",             \n             \"{!term f=bday}\"+july4,\n             \"{!term f=bday}\"+july4Long,\n             \"bday:\\\"\" + july4Long + \"\\\"\"\n           }) {\n      assertQ(\"check math on field query: \" + q,\n              req(\"q\", q),\n              \"*[count(//doc)=1]\",\n              \"//int[@name='id'][.='1']\");\n    }\n\n    // range queries using date math\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n    assertQ(\"check counts using fixed NOW\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=1]\");\n                \n    assertQ(\"check counts using fixed NOW and TZ rounding\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"TZ\", \"GMT+01\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=0]\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","pathOld":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","sourceNew":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n    clearIndex();\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of TrieDateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n    \n    // a ridiculoulsy long date math expression that's still equivilent to july4\n    final StringBuilder july4Long = new StringBuilder(july4);\n    final int iters = atLeast(10);\n    for (int i = 0; i < iters; i++) {\n      final String val = String.valueOf(atLeast(1));\n      july4Long.append(\"+\" + val + \"SECONDS-\" + val + \"SECONDS\");\n    }\n\n    // term queries using date math (all of these should match doc#1)\n    for (String q : \n           new String[] {\n             \"bday:1976-07-04T12\\\\:08\\\\:56.45Z/SECOND+235MILLIS\",\n             \"bday:1976-07-04T12\\\\:08\\\\:56.123Z/MINUTE+56SECONDS+235MILLIS\",\n             \"bday:\\\"1976-07-04T12:08:56.45Z/SECOND+235MILLIS\\\"\",\n             \"bday:\\\"1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\\\"\",\n             \"{!term f=bday}1976-07-04T12:08:56.45Z/SECOND+235MILLIS\",\n             \"{!term f=bday}1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\",             \n             \"{!term f=bday}\"+july4,\n             \"{!term f=bday}\"+july4Long,\n             \"bday:\\\"\" + july4Long + \"\\\"\"\n           }) {\n      assertQ(\"check math on field query: \" + q,\n              req(\"q\", q),\n              \"*[count(//doc)=1]\",\n              \"//str[@name='id'][.='1']\");\n    }\n\n    // range queries using date math\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n    assertQ(\"check counts using fixed NOW\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=1]\");\n                \n    assertQ(\"check counts using fixed NOW and TZ rounding\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"TZ\", \"GMT+01\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=0]\");\n\n  }\n\n","sourceOld":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n    clearIndex();\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of TrieDateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n    \n    // a ridiculoulsy long date math expression that's still equivilent to july4\n    final StringBuilder july4Long = new StringBuilder(july4);\n    final int iters = atLeast(10);\n    for (int i = 0; i < iters; i++) {\n      final String val = String.valueOf(atLeast(1));\n      july4Long.append(\"+\" + val + \"SECONDS-\" + val + \"SECONDS\");\n    }\n\n    // term queries using date math (all of these should match doc#1)\n    for (String q : \n           new String[] {\n             \"bday:1976-07-04T12\\\\:08\\\\:56.45Z/SECOND+235MILLIS\",\n             \"bday:1976-07-04T12\\\\:08\\\\:56.123Z/MINUTE+56SECONDS+235MILLIS\",\n             \"bday:\\\"1976-07-04T12:08:56.45Z/SECOND+235MILLIS\\\"\",\n             \"bday:\\\"1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\\\"\",\n             \"{!term f=bday}1976-07-04T12:08:56.45Z/SECOND+235MILLIS\",\n             \"{!term f=bday}1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\",             \n             \"{!term f=bday}\"+july4,\n             \"{!term f=bday}\"+july4Long,\n             \"bday:\\\"\" + july4Long + \"\\\"\"\n           }) {\n      assertQ(\"check math on field query: \" + q,\n              req(\"q\", q),\n              \"*[count(//doc)=1]\",\n              \"//int[@name='id'][.='1']\");\n    }\n\n    // range queries using date math\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n    assertQ(\"check counts using fixed NOW\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=1]\");\n                \n    assertQ(\"check counts using fixed NOW and TZ rounding\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"TZ\", \"GMT+01\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=0]\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","pathOld":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","sourceNew":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n    clearIndex();\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of TrieDateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n    \n    // a ridiculoulsy long date math expression that's still equivilent to july4\n    final StringBuilder july4Long = new StringBuilder(july4);\n    final int iters = atLeast(10);\n    for (int i = 0; i < iters; i++) {\n      final String val = String.valueOf(atLeast(1));\n      july4Long.append(\"+\" + val + \"SECONDS-\" + val + \"SECONDS\");\n    }\n\n    // term queries using date math (all of these should match doc#1)\n    for (String q : \n           new String[] {\n             \"bday:1976-07-04T12\\\\:08\\\\:56.45Z/SECOND+235MILLIS\",\n             \"bday:1976-07-04T12\\\\:08\\\\:56.123Z/MINUTE+56SECONDS+235MILLIS\",\n             \"bday:\\\"1976-07-04T12:08:56.45Z/SECOND+235MILLIS\\\"\",\n             \"bday:\\\"1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\\\"\",\n             \"{!term f=bday}1976-07-04T12:08:56.45Z/SECOND+235MILLIS\",\n             \"{!term f=bday}1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\",             \n             \"{!term f=bday}\"+july4,\n             \"{!term f=bday}\"+july4Long,\n             \"bday:\\\"\" + july4Long + \"\\\"\"\n           }) {\n      assertQ(\"check math on field query: \" + q,\n              req(\"q\", q),\n              \"*[count(//doc)=1]\",\n              \"//str[@name='id'][.='1']\");\n    }\n\n    // range queries using date math\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n    assertQ(\"check counts using fixed NOW\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=1]\");\n                \n    assertQ(\"check counts using fixed NOW and TZ rounding\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"TZ\", \"GMT+01\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=0]\");\n\n  }\n\n","sourceOld":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n    clearIndex();\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of TrieDateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n    \n    // a ridiculoulsy long date math expression that's still equivilent to july4\n    final StringBuilder july4Long = new StringBuilder(july4);\n    final int iters = atLeast(10);\n    for (int i = 0; i < iters; i++) {\n      final String val = String.valueOf(atLeast(1));\n      july4Long.append(\"+\" + val + \"SECONDS-\" + val + \"SECONDS\");\n    }\n\n    // term queries using date math (all of these should match doc#1)\n    for (String q : \n           new String[] {\n             \"bday:1976-07-04T12\\\\:08\\\\:56.45Z/SECOND+235MILLIS\",\n             \"bday:1976-07-04T12\\\\:08\\\\:56.123Z/MINUTE+56SECONDS+235MILLIS\",\n             \"bday:\\\"1976-07-04T12:08:56.45Z/SECOND+235MILLIS\\\"\",\n             \"bday:\\\"1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\\\"\",\n             \"{!term f=bday}1976-07-04T12:08:56.45Z/SECOND+235MILLIS\",\n             \"{!term f=bday}1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\",             \n             \"{!term f=bday}\"+july4,\n             \"{!term f=bday}\"+july4Long,\n             \"bday:\\\"\" + july4Long + \"\\\"\"\n           }) {\n      assertQ(\"check math on field query: \" + q,\n              req(\"q\", q),\n              \"*[count(//doc)=1]\",\n              \"//int[@name='id'][.='1']\");\n    }\n\n    // range queries using date math\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n    assertQ(\"check counts using fixed NOW\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=1]\");\n                \n    assertQ(\"check counts using fixed NOW and TZ rounding\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"TZ\", \"GMT+01\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=0]\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aa31759957c90bbd07c2fa553208a76b0e8dc518","date":1504624674,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","pathOld":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","sourceNew":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n    clearIndex();\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of DatePointField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n    \n    // a ridiculoulsy long date math expression that's still equivilent to july4\n    final StringBuilder july4Long = new StringBuilder(july4);\n    final int iters = atLeast(10);\n    for (int i = 0; i < iters; i++) {\n      final String val = String.valueOf(atLeast(1));\n      july4Long.append(\"+\" + val + \"SECONDS-\" + val + \"SECONDS\");\n    }\n\n    // term queries using date math (all of these should match doc#1)\n    for (String q : \n           new String[] {\n             \"bday:1976-07-04T12\\\\:08\\\\:56.45Z/SECOND+235MILLIS\",\n             \"bday:1976-07-04T12\\\\:08\\\\:56.123Z/MINUTE+56SECONDS+235MILLIS\",\n             \"bday:\\\"1976-07-04T12:08:56.45Z/SECOND+235MILLIS\\\"\",\n             \"bday:\\\"1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\\\"\",\n             \"{!term f=bday}1976-07-04T12:08:56.45Z/SECOND+235MILLIS\",\n             \"{!term f=bday}1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\",             \n             \"{!term f=bday}\"+july4,\n             \"{!term f=bday}\"+july4Long,\n             \"bday:\\\"\" + july4Long + \"\\\"\"\n           }) {\n      assertQ(\"check math on field query: \" + q,\n              req(\"q\", q),\n              \"*[count(//doc)=1]\",\n              \"//str[@name='id'][.='1']\");\n    }\n\n    // range queries using date math\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n    assertQ(\"check counts using fixed NOW\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=1]\");\n                \n    assertQ(\"check counts using fixed NOW and TZ rounding\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"TZ\", \"GMT+01\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=0]\");\n\n  }\n\n","sourceOld":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n    clearIndex();\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of TrieDateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n    \n    // a ridiculoulsy long date math expression that's still equivilent to july4\n    final StringBuilder july4Long = new StringBuilder(july4);\n    final int iters = atLeast(10);\n    for (int i = 0; i < iters; i++) {\n      final String val = String.valueOf(atLeast(1));\n      july4Long.append(\"+\" + val + \"SECONDS-\" + val + \"SECONDS\");\n    }\n\n    // term queries using date math (all of these should match doc#1)\n    for (String q : \n           new String[] {\n             \"bday:1976-07-04T12\\\\:08\\\\:56.45Z/SECOND+235MILLIS\",\n             \"bday:1976-07-04T12\\\\:08\\\\:56.123Z/MINUTE+56SECONDS+235MILLIS\",\n             \"bday:\\\"1976-07-04T12:08:56.45Z/SECOND+235MILLIS\\\"\",\n             \"bday:\\\"1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\\\"\",\n             \"{!term f=bday}1976-07-04T12:08:56.45Z/SECOND+235MILLIS\",\n             \"{!term f=bday}1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\",             \n             \"{!term f=bday}\"+july4,\n             \"{!term f=bday}\"+july4Long,\n             \"bday:\\\"\" + july4Long + \"\\\"\"\n           }) {\n      assertQ(\"check math on field query: \" + q,\n              req(\"q\", q),\n              \"*[count(//doc)=1]\",\n              \"//str[@name='id'][.='1']\");\n    }\n\n    // range queries using date math\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n    assertQ(\"check counts using fixed NOW\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=1]\");\n                \n    assertQ(\"check counts using fixed NOW and TZ rounding\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"TZ\", \"GMT+01\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=0]\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b21283ed01203901a7257aa4b7f0a0899c86e56e","date":1504689720,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","pathOld":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","sourceNew":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n    clearIndex();\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of DatePointField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n    \n    // a ridiculoulsy long date math expression that's still equivilent to july4\n    final StringBuilder july4Long = new StringBuilder(july4);\n    final int iters = atLeast(10);\n    for (int i = 0; i < iters; i++) {\n      final String val = String.valueOf(atLeast(1));\n      july4Long.append(\"+\" + val + \"SECONDS-\" + val + \"SECONDS\");\n    }\n\n    // term queries using date math (all of these should match doc#1)\n    for (String q : \n           new String[] {\n             \"bday:1976-07-04T12\\\\:08\\\\:56.45Z/SECOND+235MILLIS\",\n             \"bday:1976-07-04T12\\\\:08\\\\:56.123Z/MINUTE+56SECONDS+235MILLIS\",\n             \"bday:\\\"1976-07-04T12:08:56.45Z/SECOND+235MILLIS\\\"\",\n             \"bday:\\\"1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\\\"\",\n             \"{!term f=bday}1976-07-04T12:08:56.45Z/SECOND+235MILLIS\",\n             \"{!term f=bday}1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\",             \n             \"{!term f=bday}\"+july4,\n             \"{!term f=bday}\"+july4Long,\n             \"bday:\\\"\" + july4Long + \"\\\"\"\n           }) {\n      assertQ(\"check math on field query: \" + q,\n              req(\"q\", q),\n              \"*[count(//doc)=1]\",\n              \"//str[@name='id'][.='1']\");\n    }\n\n    // range queries using date math\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n    assertQ(\"check counts using fixed NOW\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=1]\");\n                \n    assertQ(\"check counts using fixed NOW and TZ rounding\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"TZ\", \"GMT+01\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=0]\");\n\n  }\n\n","sourceOld":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n    clearIndex();\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of TrieDateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n    \n    // a ridiculoulsy long date math expression that's still equivilent to july4\n    final StringBuilder july4Long = new StringBuilder(july4);\n    final int iters = atLeast(10);\n    for (int i = 0; i < iters; i++) {\n      final String val = String.valueOf(atLeast(1));\n      july4Long.append(\"+\" + val + \"SECONDS-\" + val + \"SECONDS\");\n    }\n\n    // term queries using date math (all of these should match doc#1)\n    for (String q : \n           new String[] {\n             \"bday:1976-07-04T12\\\\:08\\\\:56.45Z/SECOND+235MILLIS\",\n             \"bday:1976-07-04T12\\\\:08\\\\:56.123Z/MINUTE+56SECONDS+235MILLIS\",\n             \"bday:\\\"1976-07-04T12:08:56.45Z/SECOND+235MILLIS\\\"\",\n             \"bday:\\\"1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\\\"\",\n             \"{!term f=bday}1976-07-04T12:08:56.45Z/SECOND+235MILLIS\",\n             \"{!term f=bday}1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\",             \n             \"{!term f=bday}\"+july4,\n             \"{!term f=bday}\"+july4Long,\n             \"bday:\\\"\" + july4Long + \"\\\"\"\n           }) {\n      assertQ(\"check math on field query: \" + q,\n              req(\"q\", q),\n              \"*[count(//doc)=1]\",\n              \"//str[@name='id'][.='1']\");\n    }\n\n    // range queries using date math\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n    assertQ(\"check counts using fixed NOW\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=1]\");\n                \n    assertQ(\"check counts using fixed NOW and TZ rounding\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"TZ\", \"GMT+01\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=0]\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7","date":1504848000,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","pathOld":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","sourceNew":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n    clearIndex();\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of DatePointField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n    \n    // a ridiculoulsy long date math expression that's still equivilent to july4\n    final StringBuilder july4Long = new StringBuilder(july4);\n    final int iters = atLeast(10);\n    for (int i = 0; i < iters; i++) {\n      final String val = String.valueOf(atLeast(1));\n      july4Long.append(\"+\" + val + \"SECONDS-\" + val + \"SECONDS\");\n    }\n\n    // term queries using date math (all of these should match doc#1)\n    for (String q : \n           new String[] {\n             \"bday:1976-07-04T12\\\\:08\\\\:56.45Z/SECOND+235MILLIS\",\n             \"bday:1976-07-04T12\\\\:08\\\\:56.123Z/MINUTE+56SECONDS+235MILLIS\",\n             \"bday:\\\"1976-07-04T12:08:56.45Z/SECOND+235MILLIS\\\"\",\n             \"bday:\\\"1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\\\"\",\n             \"{!term f=bday}1976-07-04T12:08:56.45Z/SECOND+235MILLIS\",\n             \"{!term f=bday}1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\",             \n             \"{!term f=bday}\"+july4,\n             \"{!term f=bday}\"+july4Long,\n             \"bday:\\\"\" + july4Long + \"\\\"\"\n           }) {\n      assertQ(\"check math on field query: \" + q,\n              req(\"q\", q),\n              \"*[count(//doc)=1]\",\n              \"//str[@name='id'][.='1']\");\n    }\n\n    // range queries using date math\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n    assertQ(\"check counts using fixed NOW\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=1]\");\n                \n    assertQ(\"check counts using fixed NOW and TZ rounding\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"TZ\", \"GMT+01\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=0]\");\n\n  }\n\n","sourceOld":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n    clearIndex();\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of TrieDateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n    \n    // a ridiculoulsy long date math expression that's still equivilent to july4\n    final StringBuilder july4Long = new StringBuilder(july4);\n    final int iters = atLeast(10);\n    for (int i = 0; i < iters; i++) {\n      final String val = String.valueOf(atLeast(1));\n      july4Long.append(\"+\" + val + \"SECONDS-\" + val + \"SECONDS\");\n    }\n\n    // term queries using date math (all of these should match doc#1)\n    for (String q : \n           new String[] {\n             \"bday:1976-07-04T12\\\\:08\\\\:56.45Z/SECOND+235MILLIS\",\n             \"bday:1976-07-04T12\\\\:08\\\\:56.123Z/MINUTE+56SECONDS+235MILLIS\",\n             \"bday:\\\"1976-07-04T12:08:56.45Z/SECOND+235MILLIS\\\"\",\n             \"bday:\\\"1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\\\"\",\n             \"{!term f=bday}1976-07-04T12:08:56.45Z/SECOND+235MILLIS\",\n             \"{!term f=bday}1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\",             \n             \"{!term f=bday}\"+july4,\n             \"{!term f=bday}\"+july4Long,\n             \"bday:\\\"\" + july4Long + \"\\\"\"\n           }) {\n      assertQ(\"check math on field query: \" + q,\n              req(\"q\", q),\n              \"*[count(//doc)=1]\",\n              \"//str[@name='id'][.='1']\");\n    }\n\n    // range queries using date math\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n    assertQ(\"check counts using fixed NOW\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=1]\");\n                \n    assertQ(\"check counts using fixed NOW and TZ rounding\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"TZ\", \"GMT+01\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=0]\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"685bd38810c206c93e9058f3c2cfa9827c086c27","date":1505751821,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","pathOld":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","sourceNew":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n    clearIndex();\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of DatePointField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n    \n    // a ridiculoulsy long date math expression that's still equivilent to july4\n    final StringBuilder july4Long = new StringBuilder(july4);\n    final int iters = atLeast(10);\n    for (int i = 0; i < iters; i++) {\n      final String val = String.valueOf(atLeast(1));\n      july4Long.append(\"+\" + val + \"SECONDS-\" + val + \"SECONDS\");\n    }\n\n    // term queries using date math (all of these should match doc#1)\n    for (String q : \n           new String[] {\n             \"bday:1976-07-04T12\\\\:08\\\\:56.45Z/SECOND+235MILLIS\",\n             \"bday:1976-07-04T12\\\\:08\\\\:56.123Z/MINUTE+56SECONDS+235MILLIS\",\n             \"bday:\\\"1976-07-04T12:08:56.45Z/SECOND+235MILLIS\\\"\",\n             \"bday:\\\"1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\\\"\",\n             \"{!term f=bday}1976-07-04T12:08:56.45Z/SECOND+235MILLIS\",\n             \"{!term f=bday}1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\",             \n             \"{!term f=bday}\"+july4,\n             \"{!term f=bday}\"+july4Long,\n             \"bday:\\\"\" + july4Long + \"\\\"\"\n           }) {\n      assertQ(\"check math on field query: \" + q,\n              req(\"q\", q),\n              \"*[count(//doc)=1]\",\n              \"//str[@name='id'][.='1']\");\n    }\n\n    // range queries using date math\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n    assertQ(\"check counts using fixed NOW\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=1]\");\n                \n    assertQ(\"check counts using fixed NOW and TZ rounding\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"TZ\", \"GMT+01\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=0]\");\n\n  }\n\n","sourceOld":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n    clearIndex();\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of TrieDateField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n    \n    // a ridiculoulsy long date math expression that's still equivilent to july4\n    final StringBuilder july4Long = new StringBuilder(july4);\n    final int iters = atLeast(10);\n    for (int i = 0; i < iters; i++) {\n      final String val = String.valueOf(atLeast(1));\n      july4Long.append(\"+\" + val + \"SECONDS-\" + val + \"SECONDS\");\n    }\n\n    // term queries using date math (all of these should match doc#1)\n    for (String q : \n           new String[] {\n             \"bday:1976-07-04T12\\\\:08\\\\:56.45Z/SECOND+235MILLIS\",\n             \"bday:1976-07-04T12\\\\:08\\\\:56.123Z/MINUTE+56SECONDS+235MILLIS\",\n             \"bday:\\\"1976-07-04T12:08:56.45Z/SECOND+235MILLIS\\\"\",\n             \"bday:\\\"1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\\\"\",\n             \"{!term f=bday}1976-07-04T12:08:56.45Z/SECOND+235MILLIS\",\n             \"{!term f=bday}1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\",             \n             \"{!term f=bday}\"+july4,\n             \"{!term f=bday}\"+july4Long,\n             \"bday:\\\"\" + july4Long + \"\\\"\"\n           }) {\n      assertQ(\"check math on field query: \" + q,\n              req(\"q\", q),\n              \"*[count(//doc)=1]\",\n              \"//str[@name='id'][.='1']\");\n    }\n\n    // range queries using date math\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n    assertQ(\"check counts using fixed NOW\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=1]\");\n                \n    assertQ(\"check counts using fixed NOW and TZ rounding\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"TZ\", \"GMT+01\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=0]\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9f4251f14d2db68330fc1e6f0495c053a905d560","date":1537116380,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","pathOld":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testDateMath().mjava","sourceNew":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n    clearIndex();\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of DatePointField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n    \n    // a ridiculoulsy long date math expression that's still equivalent to july4\n    final StringBuilder july4Long = new StringBuilder(july4);\n    final int iters = atLeast(10);\n    for (int i = 0; i < iters; i++) {\n      final String val = String.valueOf(atLeast(1));\n      july4Long.append(\"+\" + val + \"SECONDS-\" + val + \"SECONDS\");\n    }\n\n    // term queries using date math (all of these should match doc#1)\n    for (String q : \n           new String[] {\n             \"bday:1976-07-04T12\\\\:08\\\\:56.45Z/SECOND+235MILLIS\",\n             \"bday:1976-07-04T12\\\\:08\\\\:56.123Z/MINUTE+56SECONDS+235MILLIS\",\n             \"bday:\\\"1976-07-04T12:08:56.45Z/SECOND+235MILLIS\\\"\",\n             \"bday:\\\"1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\\\"\",\n             \"{!term f=bday}1976-07-04T12:08:56.45Z/SECOND+235MILLIS\",\n             \"{!term f=bday}1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\",             \n             \"{!term f=bday}\"+july4,\n             \"{!term f=bday}\"+july4Long,\n             \"bday:\\\"\" + july4Long + \"\\\"\"\n           }) {\n      assertQ(\"check math on field query: \" + q,\n              req(\"q\", q),\n              \"*[count(//doc)=1]\",\n              \"//str[@name='id'][.='1']\");\n    }\n\n    // range queries using date math\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n    assertQ(\"check counts using fixed NOW\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=1]\");\n                \n    assertQ(\"check counts using fixed NOW and TZ rounding\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"TZ\", \"GMT+01\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=0]\");\n\n  }\n\n","sourceOld":"  /** @see org.apache.solr.util.DateMathParserTest */\n  @Test\n  public void testDateMath() {\n    clearIndex();\n\n    // testing everything from query level is hard because\n    // time marches on ... and there is no easy way to reach into the\n    // bowels of DatePointField and muck with the definition of \"now\"\n    //    ...\n    // BUT: we can test that crazy combinations of \"NOW\" all work correctly,\n    // assuming the test doesn't take too long to run...\n\n    final String july4 = \"1976-07-04T12:08:56.235Z\";\n    assertU(adoc(\"id\", \"1\",  \"bday\", july4));\n    assertU(adoc(\"id\", \"2\",  \"bday\", \"NOW\"));\n    assertU(adoc(\"id\", \"3\",  \"bday\", \"NOW/HOUR\"));\n    assertU(adoc(\"id\", \"4\",  \"bday\", \"NOW-30MINUTES\"));\n    assertU(adoc(\"id\", \"5\",  \"bday\", \"NOW+30MINUTES\"));\n    assertU(adoc(\"id\", \"6\",  \"bday\", \"NOW+2YEARS\"));\n    assertU(commit());\n    \n    // a ridiculoulsy long date math expression that's still equivilent to july4\n    final StringBuilder july4Long = new StringBuilder(july4);\n    final int iters = atLeast(10);\n    for (int i = 0; i < iters; i++) {\n      final String val = String.valueOf(atLeast(1));\n      july4Long.append(\"+\" + val + \"SECONDS-\" + val + \"SECONDS\");\n    }\n\n    // term queries using date math (all of these should match doc#1)\n    for (String q : \n           new String[] {\n             \"bday:1976-07-04T12\\\\:08\\\\:56.45Z/SECOND+235MILLIS\",\n             \"bday:1976-07-04T12\\\\:08\\\\:56.123Z/MINUTE+56SECONDS+235MILLIS\",\n             \"bday:\\\"1976-07-04T12:08:56.45Z/SECOND+235MILLIS\\\"\",\n             \"bday:\\\"1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\\\"\",\n             \"{!term f=bday}1976-07-04T12:08:56.45Z/SECOND+235MILLIS\",\n             \"{!term f=bday}1976-07-04T12:08:56.123Z/MINUTE+56SECONDS+235MILLIS\",             \n             \"{!term f=bday}\"+july4,\n             \"{!term f=bday}\"+july4Long,\n             \"bday:\\\"\" + july4Long + \"\\\"\"\n           }) {\n      assertQ(\"check math on field query: \" + q,\n              req(\"q\", q),\n              \"*[count(//doc)=1]\",\n              \"//str[@name='id'][.='1']\");\n    }\n\n    // range queries using date math\n    assertQ(\"check math on absolute date#1\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND]\"),\n            \"*[count(//doc)=0]\");\n    assertQ(\"check math on absolute date#2\",\n            req(\"q\", \"bday:[* TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#3\",\n            req(\"q\", \"bday:[\"+july4+\"/SECOND TO \"+july4+\"/SECOND+1SECOND]\"),\n            \"*[count(//doc)=1]\");\n    assertQ(\"check math on absolute date#4\",\n            req(\"q\", \"bday:[\"+july4+\"/MINUTE+1MINUTE TO *]\"),\n            \"*[count(//doc)=5]\");\n    \n    assertQ(\"check count for before now\",\n            req(\"q\", \"bday:[* TO NOW]\"), \"*[count(//doc)=4]\");\n\n    assertQ(\"check count for after now\",\n            req(\"q\", \"bday:[NOW TO *]\"), \"*[count(//doc)=2]\");\n\n    assertQ(\"check count for old stuff\",\n            req(\"q\", \"bday:[* TO NOW-2YEARS]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for future stuff\",\n            req(\"q\", \"bday:[NOW+1MONTH TO *]\"), \"*[count(//doc)=1]\");\n\n    assertQ(\"check count for near stuff\",\n            req(\"q\", \"bday:[NOW-1MONTH TO NOW+2HOURS]\"), \"*[count(//doc)=4]\");\n    \n    assertQ(\"check counts using fixed NOW\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=1]\");\n                \n    assertQ(\"check counts using fixed NOW and TZ rounding\",\n            req(\"q\", \"bday:[NOW/DAY TO NOW/DAY+1DAY]\",\n                \"TZ\", \"GMT+01\",\n                \"NOW\", \"205369736000\" // 1976-07-04T23:08:56.235Z\n                ),\n            \"*[count(//doc)=0]\");\n\n  }\n\n","bugFix":["d0fad4c5c26f8a062d31d59ceb5ea2dc3ca38aef"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b21283ed01203901a7257aa4b7f0a0899c86e56e":["28288370235ed02234a64753cdbf0c6ec096304a","aa31759957c90bbd07c2fa553208a76b0e8dc518"],"9f4251f14d2db68330fc1e6f0495c053a905d560":["104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"],"aa31759957c90bbd07c2fa553208a76b0e8dc518":["28288370235ed02234a64753cdbf0c6ec096304a"],"b3c7501e15f71c01b69ba22749b192827fa2019b":["461fea4b90072bede0ef2dc0dba66a8c5dbf1356"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"a71f63026529f3c1f03cfdd664910873ab2369ae":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"461fea4b90072bede0ef2dc0dba66a8c5dbf1356":["c26f00b574427b55127e869b935845554afde1fa"],"0ad30c6a479e764150a3316e57263319775f1df2":["2106271e380c198349e0f6eac0395bb462913fab","ba0bb1c61dbf71a82da9a3ea8cda3d481f703d29"],"28288370235ed02234a64753cdbf0c6ec096304a":["d470c8182e92b264680e34081b75e70a9f2b3c89","a71f63026529f3c1f03cfdd664910873ab2369ae"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["2106271e380c198349e0f6eac0395bb462913fab","d470c8182e92b264680e34081b75e70a9f2b3c89"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["2106271e380c198349e0f6eac0395bb462913fab","0ad30c6a479e764150a3316e57263319775f1df2"],"ba0bb1c61dbf71a82da9a3ea8cda3d481f703d29":["2106271e380c198349e0f6eac0395bb462913fab"],"685bd38810c206c93e9058f3c2cfa9827c086c27":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"],"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7":["28288370235ed02234a64753cdbf0c6ec096304a","b21283ed01203901a7257aa4b7f0a0899c86e56e"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2106271e380c198349e0f6eac0395bb462913fab":["d0fad4c5c26f8a062d31d59ceb5ea2dc3ca38aef"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d0fad4c5c26f8a062d31d59ceb5ea2dc3ca38aef":["b3c7501e15f71c01b69ba22749b192827fa2019b"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["d470c8182e92b264680e34081b75e70a9f2b3c89","a71f63026529f3c1f03cfdd664910873ab2369ae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9f4251f14d2db68330fc1e6f0495c053a905d560"]},"commit2Childs":{"b21283ed01203901a7257aa4b7f0a0899c86e56e":["104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"],"9f4251f14d2db68330fc1e6f0495c053a905d560":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"aa31759957c90bbd07c2fa553208a76b0e8dc518":["b21283ed01203901a7257aa4b7f0a0899c86e56e"],"b3c7501e15f71c01b69ba22749b192827fa2019b":["d0fad4c5c26f8a062d31d59ceb5ea2dc3ca38aef"],"c26f00b574427b55127e869b935845554afde1fa":["461fea4b90072bede0ef2dc0dba66a8c5dbf1356"],"a71f63026529f3c1f03cfdd664910873ab2369ae":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"461fea4b90072bede0ef2dc0dba66a8c5dbf1356":["b3c7501e15f71c01b69ba22749b192827fa2019b"],"0ad30c6a479e764150a3316e57263319775f1df2":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"28288370235ed02234a64753cdbf0c6ec096304a":["b21283ed01203901a7257aa4b7f0a0899c86e56e","aa31759957c90bbd07c2fa553208a76b0e8dc518","104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["a71f63026529f3c1f03cfdd664910873ab2369ae","28288370235ed02234a64753cdbf0c6ec096304a","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"ba0bb1c61dbf71a82da9a3ea8cda3d481f703d29":["0ad30c6a479e764150a3316e57263319775f1df2"],"685bd38810c206c93e9058f3c2cfa9827c086c27":[],"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7":["9f4251f14d2db68330fc1e6f0495c053a905d560","685bd38810c206c93e9058f3c2cfa9827c086c27"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"2106271e380c198349e0f6eac0395bb462913fab":["0ad30c6a479e764150a3316e57263319775f1df2","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","ba0bb1c61dbf71a82da9a3ea8cda3d481f703d29"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"d0fad4c5c26f8a062d31d59ceb5ea2dc3ca38aef":["2106271e380c198349e0f6eac0395bb462913fab"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["685bd38810c206c93e9058f3c2cfa9827c086c27"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","685bd38810c206c93e9058f3c2cfa9827c086c27","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}