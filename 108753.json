{"path":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","sourceNew":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final DocValues docValues = reader.docValues(fieldInfo.name);\n          if (docValues == null) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" omits docvalues but should have them!\");\n          }\n          DocValues.Type type = docValues.type();\n          if (type != fieldInfo.getDocValuesType()) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" has type: \" + type + \" but fieldInfos says:\" + fieldInfo.getDocValuesType());\n          }\n          final Source values = docValues.getDirectSource();\n          final int maxDoc = reader.maxDoc();\n          int size = docValues.getValueSize();\n          for (int i = 0; i < maxDoc; i++) {\n            switch (fieldInfo.getDocValuesType()) {\n            case BYTES_FIXED_SORTED:\n            case BYTES_VAR_SORTED:\n            case BYTES_FIXED_DEREF:\n            case BYTES_FIXED_STRAIGHT:\n            case BYTES_VAR_DEREF:\n            case BYTES_VAR_STRAIGHT:\n              BytesRef bytes = new BytesRef();\n              values.getBytes(i, bytes);\n              if (size != -1 && size != bytes.length) {\n                throw new RuntimeException(\"field: \" + fieldInfo.name + \" returned wrongly sized bytes, was: \" + bytes.length + \" should be: \" + size);\n              }\n              break;\n            case FLOAT_32:\n              assert size == 4;\n              values.getFloat(i);\n              break;\n            case FLOAT_64:\n              assert size == 8;\n              values.getFloat(i);\n              break;\n            case VAR_INTS:\n              assert size == -1;\n              values.getInt(i);\n              break;\n            case FIXED_INTS_16:\n              assert size == 2;\n              values.getInt(i);\n              break;\n            case FIXED_INTS_32:\n              assert size == 4;\n              values.getInt(i);\n              break;\n            case FIXED_INTS_64:\n              assert size == 8;\n              values.getInt(i);\n              break;\n            case FIXED_INTS_8:\n              assert size == 1;\n              values.getInt(i);\n              break;\n            default:\n              throw new IllegalArgumentException(\"Field: \" + fieldInfo.name\n                          + \" - no such DocValues type: \" + fieldInfo.getDocValuesType());\n            }\n          }\n          if (type == DocValues.Type.BYTES_FIXED_SORTED || type == DocValues.Type.BYTES_VAR_SORTED) {\n            // check sorted bytes\n            SortedSource sortedValues = values.asSortedSource();\n            Comparator<BytesRef> comparator = sortedValues.getComparator();\n            int lastOrd = -1;\n            BytesRef lastBytes = new BytesRef();\n            for (int i = 0; i < maxDoc; i++) {\n              int ord = sortedValues.ord(i);\n              if (ord < 0 || ord > maxDoc) {\n                throw new RuntimeException(\"field: \" + fieldInfo.name + \" ord is out of bounds: \" + ord);\n              }\n              BytesRef bytes = new BytesRef();\n              sortedValues.getByOrd(ord, bytes);\n              if (lastOrd != -1) {\n                int ordComp = Integer.signum(new Integer(ord).compareTo(new Integer(lastOrd)));\n                int bytesComp = Integer.signum(comparator.compare(bytes, lastBytes));\n                if (ordComp != bytesComp) {\n                  throw new RuntimeException(\"field: \" + fieldInfo.name + \" ord comparison is wrong: \" + ordComp + \" comparator claims: \" + bytesComp);\n                }\n              }\n              lastOrd = ord;\n              lastBytes = bytes;\n            }\n          }\n        } else {\n          if (reader.docValues(fieldInfo.name) != null) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" has docvalues but should omit them!\");\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","sourceOld":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final DocValues docValues = reader.docValues(fieldInfo.name);\n          if (docValues == null) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" omits docvalues but should have them!\");\n          }\n          DocValues.Type type = docValues.type();\n          if (type != fieldInfo.getDocValuesType()) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" has type: \" + type + \" but fieldInfos says:\" + fieldInfo.getDocValuesType());\n          }\n          final Source values = docValues.getDirectSource();\n          final int maxDoc = reader.maxDoc();\n          int size = docValues.getValueSize();\n          for (int i = 0; i < maxDoc; i++) {\n            switch (fieldInfo.getDocValuesType()) {\n            case BYTES_FIXED_SORTED:\n            case BYTES_VAR_SORTED:\n            case BYTES_FIXED_DEREF:\n            case BYTES_FIXED_STRAIGHT:\n            case BYTES_VAR_DEREF:\n            case BYTES_VAR_STRAIGHT:\n              BytesRef bytes = new BytesRef();\n              values.getBytes(i, bytes);\n              if (size != -1 && size != bytes.length) {\n                throw new RuntimeException(\"field: \" + fieldInfo.name + \" returned wrongly sized bytes, was: \" + bytes.length + \" should be: \" + size);\n              }\n              break;\n            case FLOAT_32:\n              assert size == 4;\n              values.getFloat(i);\n              break;\n            case FLOAT_64:\n              assert size == 8;\n              values.getFloat(i);\n              break;\n            case VAR_INTS:\n              assert size == -1;\n              values.getInt(i);\n              break;\n            case FIXED_INTS_16:\n              assert size == 2;\n              values.getInt(i);\n              break;\n            case FIXED_INTS_32:\n              assert size == 4;\n              values.getInt(i);\n              break;\n            case FIXED_INTS_64:\n              assert size == 8;\n              values.getInt(i);\n              break;\n            case FIXED_INTS_8:\n              assert size == 1;\n              values.getInt(i);\n              break;\n            default:\n              throw new IllegalArgumentException(\"Field: \" + fieldInfo.name\n                          + \" - no such DocValues type: \" + fieldInfo.getDocValuesType());\n            }\n          }\n          if (type == DocValues.Type.BYTES_FIXED_SORTED || type == DocValues.Type.BYTES_VAR_SORTED) {\n            // check sorted bytes\n            SortedSource sortedValues = values.asSortedSource();\n            Comparator<BytesRef> comparator = sortedValues.getComparator();\n            int lastOrd = -1;\n            BytesRef lastBytes = new BytesRef();\n            for (int i = 0; i < maxDoc; i++) {\n              int ord = sortedValues.ord(i);\n              if (ord < 0 || ord > maxDoc) {\n                throw new RuntimeException(\"field: \" + fieldInfo.name + \" ord is out of bounds: \" + ord);\n              }\n              BytesRef bytes = new BytesRef();\n              sortedValues.getByOrd(ord, bytes);\n              if (lastOrd != -1) {\n                int ordComp = Integer.signum(new Integer(ord).compareTo(new Integer(lastOrd)));\n                int bytesComp = Integer.signum(comparator.compare(bytes, lastBytes));\n                if (ordComp != bytesComp) {\n                  throw new RuntimeException(\"field: \" + fieldInfo.name + \" ord comparison is wrong: \" + ordComp + \" comparator claims: \" + bytesComp);\n                }\n              }\n              lastOrd = ord;\n              lastBytes = bytes;\n            }\n          }\n        } else {\n          if (reader.docValues(fieldInfo.name) != null) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" has docvalues but should omit them!\");\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"381d580ec52adb3c6976ebe95b15943af3af7dcb","date":1331480752,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","sourceNew":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final DocValues docValues = reader.docValues(fieldInfo.name);\n          checkDocValues(docValues, fieldInfo.name, fieldInfo.getDocValuesType(), reader.maxDoc());\n        } else {\n          if (reader.docValues(fieldInfo.name) != null) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" has docvalues but should omit them!\");\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","sourceOld":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final DocValues docValues = reader.docValues(fieldInfo.name);\n          if (docValues == null) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" omits docvalues but should have them!\");\n          }\n          DocValues.Type type = docValues.type();\n          if (type != fieldInfo.getDocValuesType()) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" has type: \" + type + \" but fieldInfos says:\" + fieldInfo.getDocValuesType());\n          }\n          final Source values = docValues.getDirectSource();\n          final int maxDoc = reader.maxDoc();\n          int size = docValues.getValueSize();\n          for (int i = 0; i < maxDoc; i++) {\n            switch (fieldInfo.getDocValuesType()) {\n            case BYTES_FIXED_SORTED:\n            case BYTES_VAR_SORTED:\n            case BYTES_FIXED_DEREF:\n            case BYTES_FIXED_STRAIGHT:\n            case BYTES_VAR_DEREF:\n            case BYTES_VAR_STRAIGHT:\n              BytesRef bytes = new BytesRef();\n              values.getBytes(i, bytes);\n              if (size != -1 && size != bytes.length) {\n                throw new RuntimeException(\"field: \" + fieldInfo.name + \" returned wrongly sized bytes, was: \" + bytes.length + \" should be: \" + size);\n              }\n              break;\n            case FLOAT_32:\n              assert size == 4;\n              values.getFloat(i);\n              break;\n            case FLOAT_64:\n              assert size == 8;\n              values.getFloat(i);\n              break;\n            case VAR_INTS:\n              assert size == -1;\n              values.getInt(i);\n              break;\n            case FIXED_INTS_16:\n              assert size == 2;\n              values.getInt(i);\n              break;\n            case FIXED_INTS_32:\n              assert size == 4;\n              values.getInt(i);\n              break;\n            case FIXED_INTS_64:\n              assert size == 8;\n              values.getInt(i);\n              break;\n            case FIXED_INTS_8:\n              assert size == 1;\n              values.getInt(i);\n              break;\n            default:\n              throw new IllegalArgumentException(\"Field: \" + fieldInfo.name\n                          + \" - no such DocValues type: \" + fieldInfo.getDocValuesType());\n            }\n          }\n          if (type == DocValues.Type.BYTES_FIXED_SORTED || type == DocValues.Type.BYTES_VAR_SORTED) {\n            // check sorted bytes\n            SortedSource sortedValues = values.asSortedSource();\n            Comparator<BytesRef> comparator = sortedValues.getComparator();\n            int lastOrd = -1;\n            BytesRef lastBytes = new BytesRef();\n            for (int i = 0; i < maxDoc; i++) {\n              int ord = sortedValues.ord(i);\n              if (ord < 0 || ord > maxDoc) {\n                throw new RuntimeException(\"field: \" + fieldInfo.name + \" ord is out of bounds: \" + ord);\n              }\n              BytesRef bytes = new BytesRef();\n              sortedValues.getByOrd(ord, bytes);\n              if (lastOrd != -1) {\n                int ordComp = Integer.signum(new Integer(ord).compareTo(new Integer(lastOrd)));\n                int bytesComp = Integer.signum(comparator.compare(bytes, lastBytes));\n                if (ordComp != bytesComp) {\n                  throw new RuntimeException(\"field: \" + fieldInfo.name + \" ord comparison is wrong: \" + ordComp + \" comparator claims: \" + bytesComp);\n                }\n              }\n              lastOrd = ord;\n              lastBytes = bytes;\n            }\n          }\n        } else {\n          if (reader.docValues(fieldInfo.name) != null) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" has docvalues but should omit them!\");\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","bugFix":["e128967bca58657bc0039d4bfe631e63e81f1977","a1c385b88a2532c3fbcb9082d04be2a1433f2762","93c59ad5034eecd863f267bd75e1df7b8a51e427","5ebb742ffd3fae76a577a68de595d711f43e6944","ecd41ba3cdd1b4d825aa53d1987e4360cf45cb05"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","sourceNew":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final DocValues docValues = reader.docValues(fieldInfo.name);\n          checkDocValues(docValues, fieldInfo.name, fieldInfo.getDocValuesType(), reader.maxDoc());\n        } else {\n          if (reader.docValues(fieldInfo.name) != null) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" has docvalues but should omit them!\");\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","sourceOld":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final DocValues docValues = reader.docValues(fieldInfo.name);\n          if (docValues == null) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" omits docvalues but should have them!\");\n          }\n          DocValues.Type type = docValues.type();\n          if (type != fieldInfo.getDocValuesType()) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" has type: \" + type + \" but fieldInfos says:\" + fieldInfo.getDocValuesType());\n          }\n          final Source values = docValues.getDirectSource();\n          final int maxDoc = reader.maxDoc();\n          int size = docValues.getValueSize();\n          for (int i = 0; i < maxDoc; i++) {\n            switch (fieldInfo.getDocValuesType()) {\n            case BYTES_FIXED_SORTED:\n            case BYTES_VAR_SORTED:\n            case BYTES_FIXED_DEREF:\n            case BYTES_FIXED_STRAIGHT:\n            case BYTES_VAR_DEREF:\n            case BYTES_VAR_STRAIGHT:\n              BytesRef bytes = new BytesRef();\n              values.getBytes(i, bytes);\n              if (size != -1 && size != bytes.length) {\n                throw new RuntimeException(\"field: \" + fieldInfo.name + \" returned wrongly sized bytes, was: \" + bytes.length + \" should be: \" + size);\n              }\n              break;\n            case FLOAT_32:\n              assert size == 4;\n              values.getFloat(i);\n              break;\n            case FLOAT_64:\n              assert size == 8;\n              values.getFloat(i);\n              break;\n            case VAR_INTS:\n              assert size == -1;\n              values.getInt(i);\n              break;\n            case FIXED_INTS_16:\n              assert size == 2;\n              values.getInt(i);\n              break;\n            case FIXED_INTS_32:\n              assert size == 4;\n              values.getInt(i);\n              break;\n            case FIXED_INTS_64:\n              assert size == 8;\n              values.getInt(i);\n              break;\n            case FIXED_INTS_8:\n              assert size == 1;\n              values.getInt(i);\n              break;\n            default:\n              throw new IllegalArgumentException(\"Field: \" + fieldInfo.name\n                          + \" - no such DocValues type: \" + fieldInfo.getDocValuesType());\n            }\n          }\n          if (type == DocValues.Type.BYTES_FIXED_SORTED || type == DocValues.Type.BYTES_VAR_SORTED) {\n            // check sorted bytes\n            SortedSource sortedValues = values.asSortedSource();\n            Comparator<BytesRef> comparator = sortedValues.getComparator();\n            int lastOrd = -1;\n            BytesRef lastBytes = new BytesRef();\n            for (int i = 0; i < maxDoc; i++) {\n              int ord = sortedValues.ord(i);\n              if (ord < 0 || ord > maxDoc) {\n                throw new RuntimeException(\"field: \" + fieldInfo.name + \" ord is out of bounds: \" + ord);\n              }\n              BytesRef bytes = new BytesRef();\n              sortedValues.getByOrd(ord, bytes);\n              if (lastOrd != -1) {\n                int ordComp = Integer.signum(new Integer(ord).compareTo(new Integer(lastOrd)));\n                int bytesComp = Integer.signum(comparator.compare(bytes, lastBytes));\n                if (ordComp != bytesComp) {\n                  throw new RuntimeException(\"field: \" + fieldInfo.name + \" ord comparison is wrong: \" + ordComp + \" comparator claims: \" + bytesComp);\n                }\n              }\n              lastOrd = ord;\n              lastBytes = bytes;\n            }\n          }\n        } else {\n          if (reader.docValues(fieldInfo.name) != null) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" has docvalues but should omit them!\");\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d08eba3d52b63561ebf936481ce73e6b6a14aa03","date":1333879759,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","sourceNew":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final DocValues docValues = reader.docValues(fieldInfo.name);\n          checkDocValues(docValues, fieldInfo.name, fieldInfo.getDocValuesType(), reader.maxDoc());\n        } else {\n          if (reader.docValues(fieldInfo.name) != null) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" has docvalues but should omit them!\");\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues InvertedFields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","sourceOld":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final DocValues docValues = reader.docValues(fieldInfo.name);\n          checkDocValues(docValues, fieldInfo.name, fieldInfo.getDocValuesType(), reader.maxDoc());\n        } else {\n          if (reader.docValues(fieldInfo.name) != null) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" has docvalues but should omit them!\");\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf","date":1333892281,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","sourceNew":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final DocValues docValues = reader.docValues(fieldInfo.name);\n          checkDocValues(docValues, fieldInfo.name, fieldInfo.getDocValuesType(), reader.maxDoc());\n        } else {\n          if (reader.docValues(fieldInfo.name) != null) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" has docvalues but should omit them!\");\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","sourceOld":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final DocValues docValues = reader.docValues(fieldInfo.name);\n          checkDocValues(docValues, fieldInfo.name, fieldInfo.getDocValuesType(), reader.maxDoc());\n        } else {\n          if (reader.docValues(fieldInfo.name) != null) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" has docvalues but should omit them!\");\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues InvertedFields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2dee33619431ada2a7a07f5fe2dbd94bac6a460","date":1337274029,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,FieldInfos,SegmentReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","sourceNew":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n                                               FieldInfos fieldInfos,\n                                               SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final DocValues docValues = reader.docValues(fieldInfo.name);\n          checkDocValues(docValues, fieldInfo.name, fieldInfo.getDocValuesType(), reader.maxDoc());\n        } else {\n          if (reader.docValues(fieldInfo.name) != null) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" has docvalues but should omit them!\");\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","sourceOld":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final DocValues docValues = reader.docValues(fieldInfo.name);\n          checkDocValues(docValues, fieldInfo.name, fieldInfo.getDocValuesType(), reader.maxDoc());\n        } else {\n          if (reader.docValues(fieldInfo.name) != null) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" has docvalues but should omit them!\");\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":5,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfoPerCommit,FieldInfos,SegmentReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","sourceNew":"  private Status.DocValuesStatus testDocValues(SegmentInfoPerCommit info,\n                                               FieldInfos fieldInfos,\n                                               SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final DocValues docValues = reader.docValues(fieldInfo.name);\n          checkDocValues(docValues, fieldInfo.name, fieldInfo.getDocValuesType(), reader.maxDoc());\n        } else {\n          if (reader.docValues(fieldInfo.name) != null) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" has docvalues but should omit them!\");\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","sourceOld":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final DocValues docValues = reader.docValues(fieldInfo.name);\n          checkDocValues(docValues, fieldInfo.name, fieldInfo.getDocValuesType(), reader.maxDoc());\n        } else {\n          if (reader.docValues(fieldInfo.name) != null) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" has docvalues but should omit them!\");\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d2dee33619431ada2a7a07f5fe2dbd94bac6a460":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf"],"38e3b736c7ca086d61b7dbb841c905ee115490da":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","381d580ec52adb3c6976ebe95b15943af3af7dcb"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf","d2dee33619431ada2a7a07f5fe2dbd94bac6a460"],"381d580ec52adb3c6976ebe95b15943af3af7dcb":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf":["d08eba3d52b63561ebf936481ce73e6b6a14aa03"],"d08eba3d52b63561ebf936481ce73e6b6a14aa03":["381d580ec52adb3c6976ebe95b15943af3af7dcb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"]},"commit2Childs":{"d2dee33619431ada2a7a07f5fe2dbd94bac6a460":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["38e3b736c7ca086d61b7dbb841c905ee115490da","381d580ec52adb3c6976ebe95b15943af3af7dcb"],"381d580ec52adb3c6976ebe95b15943af3af7dcb":["38e3b736c7ca086d61b7dbb841c905ee115490da","d08eba3d52b63561ebf936481ce73e6b6a14aa03"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf":["d2dee33619431ada2a7a07f5fe2dbd94bac6a460","615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"d08eba3d52b63561ebf936481ce73e6b6a14aa03":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["38e3b736c7ca086d61b7dbb841c905ee115490da","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}