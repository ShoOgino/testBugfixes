{"path":"solr/core/src/java/org/apache/solr/cloud/ZkController#publishAndWaitForDownStates(boolean).mjava","commits":[{"id":"b550b9fe8a5610e9a206849fa6e2bde1e8a2cf02","date":1360357765,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publishAndWaitForDownStates(boolean).mjava","pathOld":"/dev/null","sourceNew":"  private boolean publishAndWaitForDownStates(boolean alreadyCreatedZkReader)\n      throws KeeperException, InterruptedException {\n    if (zkClient.exists(ZkStateReader.LIVE_NODES_ZKNODE, true)) {\n      alreadyCreatedZkReader = true;\n      // try and publish anyone from our node as down\n      zkStateReader.createClusterStateWatchersAndUpdate();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> collections = clusterState.getCollections();\n      List<String> updatedNodes = new ArrayList<String>();\n      for (String collectionName : collections) {\n        DocCollection collection = clusterState.getCollection(collectionName);\n        Collection<Slice> slices = collection.getSlices();\n        for (Slice slice : slices) {\n          Collection<Replica> replicas = slice.getReplicas();\n          for (Replica replica : replicas) {\n            if (replica.getNodeName().equals(getNodeName())\n                && !(replica.getStr(ZkStateReader.STATE_PROP)\n                    .equals(ZkStateReader.DOWN))) {\n              ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n                  \"state\", ZkStateReader.STATE_PROP, ZkStateReader.DOWN,\n                  ZkStateReader.BASE_URL_PROP, getBaseUrl(),\n                  ZkStateReader.CORE_NAME_PROP, replica.getStr(ZkStateReader.CORE_NAME_PROP),\n                  ZkStateReader.ROLES_PROP,\n                  replica.getStr(ZkStateReader.ROLES_PROP),\n                  ZkStateReader.NODE_NAME_PROP, getNodeName(),\n                  ZkStateReader.SHARD_ID_PROP,\n                  replica.getStr(ZkStateReader.SHARD_ID_PROP),\n                  ZkStateReader.COLLECTION_PROP,\n                  replica.getStr(ZkStateReader.COLLECTION_PROP));\n              updatedNodes.add(replica.getStr(ZkStateReader.CORE_NAME_PROP));\n              overseerJobQueue.offer(ZkStateReader.toJSON(m));\n            }\n          }\n        }\n      }\n      \n      // now wait till the updates are in our state\n      long now = System.currentTimeMillis();\n      long timeout = now + 1000 * 300;\n      boolean foundStates = false;\n      while (System.currentTimeMillis() < timeout) {\n        clusterState = zkStateReader.getClusterState();\n        collections = clusterState.getCollections();\n        for (String collectionName : collections) {\n          DocCollection collection = clusterState\n              .getCollection(collectionName);\n          Collection<Slice> slices = collection.getSlices();\n          for (Slice slice : slices) {\n            Collection<Replica> replicas = slice.getReplicas();\n            for (Replica replica : replicas) {\n              if (replica.getStr(ZkStateReader.STATE_PROP).equals(\n                  ZkStateReader.DOWN)) {\n                updatedNodes.remove(replica\n                    .getStr(ZkStateReader.CORE_NAME_PROP));\n                \n              }\n            }\n          }\n        }\n        \n        if (updatedNodes.size() == 0) {\n          foundStates = true;\n          break;\n        }\n      }\n      if (!foundStates) {\n        log.warn(\"Timed out waiting to see all nodes published as DOWN in our cluster state.\");\n      }\n    }\n    return alreadyCreatedZkReader;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"474a065e1bf22f3551c2fd2c9e18bde479e5c3c5","date":1361033993,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publishAndWaitForDownStates(boolean).mjava","sourceNew":null,"sourceOld":"  private boolean publishAndWaitForDownStates(boolean alreadyCreatedZkReader)\n      throws KeeperException, InterruptedException {\n    if (zkClient.exists(ZkStateReader.LIVE_NODES_ZKNODE, true)) {\n      alreadyCreatedZkReader = true;\n      // try and publish anyone from our node as down\n      zkStateReader.createClusterStateWatchersAndUpdate();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> collections = clusterState.getCollections();\n      List<String> updatedNodes = new ArrayList<String>();\n      for (String collectionName : collections) {\n        DocCollection collection = clusterState.getCollection(collectionName);\n        Collection<Slice> slices = collection.getSlices();\n        for (Slice slice : slices) {\n          Collection<Replica> replicas = slice.getReplicas();\n          for (Replica replica : replicas) {\n            if (replica.getNodeName().equals(getNodeName())\n                && !(replica.getStr(ZkStateReader.STATE_PROP)\n                    .equals(ZkStateReader.DOWN))) {\n              ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n                  \"state\", ZkStateReader.STATE_PROP, ZkStateReader.DOWN,\n                  ZkStateReader.BASE_URL_PROP, getBaseUrl(),\n                  ZkStateReader.CORE_NAME_PROP, replica.getStr(ZkStateReader.CORE_NAME_PROP),\n                  ZkStateReader.ROLES_PROP,\n                  replica.getStr(ZkStateReader.ROLES_PROP),\n                  ZkStateReader.NODE_NAME_PROP, getNodeName(),\n                  ZkStateReader.SHARD_ID_PROP,\n                  replica.getStr(ZkStateReader.SHARD_ID_PROP),\n                  ZkStateReader.COLLECTION_PROP,\n                  replica.getStr(ZkStateReader.COLLECTION_PROP));\n              updatedNodes.add(replica.getStr(ZkStateReader.CORE_NAME_PROP));\n              overseerJobQueue.offer(ZkStateReader.toJSON(m));\n            }\n          }\n        }\n      }\n      \n      // now wait till the updates are in our state\n      long now = System.currentTimeMillis();\n      long timeout = now + 1000 * 300;\n      boolean foundStates = false;\n      while (System.currentTimeMillis() < timeout) {\n        clusterState = zkStateReader.getClusterState();\n        collections = clusterState.getCollections();\n        for (String collectionName : collections) {\n          DocCollection collection = clusterState\n              .getCollection(collectionName);\n          Collection<Slice> slices = collection.getSlices();\n          for (Slice slice : slices) {\n            Collection<Replica> replicas = slice.getReplicas();\n            for (Replica replica : replicas) {\n              if (replica.getStr(ZkStateReader.STATE_PROP).equals(\n                  ZkStateReader.DOWN)) {\n                updatedNodes.remove(replica\n                    .getStr(ZkStateReader.CORE_NAME_PROP));\n                \n              }\n            }\n          }\n        }\n        \n        if (updatedNodes.size() == 0) {\n          foundStates = true;\n          break;\n        }\n      }\n      if (!foundStates) {\n        log.warn(\"Timed out waiting to see all nodes published as DOWN in our cluster state.\");\n      }\n    }\n    return alreadyCreatedZkReader;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"95303ff3749680c743b9425f9cf99e6e4065e8a8","date":1361061922,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publishAndWaitForDownStates(boolean).mjava","sourceNew":null,"sourceOld":"  private boolean publishAndWaitForDownStates(boolean alreadyCreatedZkReader)\n      throws KeeperException, InterruptedException {\n    if (zkClient.exists(ZkStateReader.LIVE_NODES_ZKNODE, true)) {\n      alreadyCreatedZkReader = true;\n      // try and publish anyone from our node as down\n      zkStateReader.createClusterStateWatchersAndUpdate();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> collections = clusterState.getCollections();\n      List<String> updatedNodes = new ArrayList<String>();\n      for (String collectionName : collections) {\n        DocCollection collection = clusterState.getCollection(collectionName);\n        Collection<Slice> slices = collection.getSlices();\n        for (Slice slice : slices) {\n          Collection<Replica> replicas = slice.getReplicas();\n          for (Replica replica : replicas) {\n            if (replica.getNodeName().equals(getNodeName())\n                && !(replica.getStr(ZkStateReader.STATE_PROP)\n                    .equals(ZkStateReader.DOWN))) {\n              ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n                  \"state\", ZkStateReader.STATE_PROP, ZkStateReader.DOWN,\n                  ZkStateReader.BASE_URL_PROP, getBaseUrl(),\n                  ZkStateReader.CORE_NAME_PROP, replica.getStr(ZkStateReader.CORE_NAME_PROP),\n                  ZkStateReader.ROLES_PROP,\n                  replica.getStr(ZkStateReader.ROLES_PROP),\n                  ZkStateReader.NODE_NAME_PROP, getNodeName(),\n                  ZkStateReader.SHARD_ID_PROP,\n                  replica.getStr(ZkStateReader.SHARD_ID_PROP),\n                  ZkStateReader.COLLECTION_PROP,\n                  replica.getStr(ZkStateReader.COLLECTION_PROP));\n              updatedNodes.add(replica.getStr(ZkStateReader.CORE_NAME_PROP));\n              overseerJobQueue.offer(ZkStateReader.toJSON(m));\n            }\n          }\n        }\n      }\n      \n      // now wait till the updates are in our state\n      long now = System.currentTimeMillis();\n      long timeout = now + 1000 * 300;\n      boolean foundStates = false;\n      while (System.currentTimeMillis() < timeout) {\n        clusterState = zkStateReader.getClusterState();\n        collections = clusterState.getCollections();\n        for (String collectionName : collections) {\n          DocCollection collection = clusterState\n              .getCollection(collectionName);\n          Collection<Slice> slices = collection.getSlices();\n          for (Slice slice : slices) {\n            Collection<Replica> replicas = slice.getReplicas();\n            for (Replica replica : replicas) {\n              if (replica.getStr(ZkStateReader.STATE_PROP).equals(\n                  ZkStateReader.DOWN)) {\n                updatedNodes.remove(replica\n                    .getStr(ZkStateReader.CORE_NAME_PROP));\n                \n              }\n            }\n          }\n        }\n        \n        if (updatedNodes.size() == 0) {\n          foundStates = true;\n          break;\n        }\n      }\n      if (!foundStates) {\n        log.warn(\"Timed out waiting to see all nodes published as DOWN in our cluster state.\");\n      }\n    }\n    return alreadyCreatedZkReader;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b550b9fe8a5610e9a206849fa6e2bde1e8a2cf02":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"95303ff3749680c743b9425f9cf99e6e4065e8a8":["b550b9fe8a5610e9a206849fa6e2bde1e8a2cf02","474a065e1bf22f3551c2fd2c9e18bde479e5c3c5"],"474a065e1bf22f3551c2fd2c9e18bde479e5c3c5":["b550b9fe8a5610e9a206849fa6e2bde1e8a2cf02"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["474a065e1bf22f3551c2fd2c9e18bde479e5c3c5"]},"commit2Childs":{"b550b9fe8a5610e9a206849fa6e2bde1e8a2cf02":["95303ff3749680c743b9425f9cf99e6e4065e8a8","474a065e1bf22f3551c2fd2c9e18bde479e5c3c5"],"95303ff3749680c743b9425f9cf99e6e4065e8a8":[],"474a065e1bf22f3551c2fd2c9e18bde479e5c3c5":["95303ff3749680c743b9425f9cf99e6e4065e8a8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b550b9fe8a5610e9a206849fa6e2bde1e8a2cf02"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["95303ff3749680c743b9425f9cf99e6e4065e8a8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}