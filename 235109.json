{"path":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","sourceNew":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (cachingEnabled) {\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"Closing \").append(name);\n      for (SolrCache cache : cacheList) {\n        sb.append(\"\\n\\t\");\n        sb.append(cache);\n      }\n      log.info(sb.toString());\n    } else {\n      log.debug(\"Closing \" + name);\n    }\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    if (closeReader) reader.decRef();\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","sourceOld":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (cachingEnabled) {\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"Closing \").append(name);\n      for (SolrCache cache : cacheList) {\n        sb.append(\"\\n\\t\");\n        sb.append(cache);\n      }\n      log.info(sb.toString());\n    } else {\n      log.debug(\"Closing \" + name);\n    }\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    if (closeReader) reader.decRef();\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","sourceNew":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (cachingEnabled) {\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"Closing \").append(name);\n      for (SolrCache cache : cacheList) {\n        sb.append(\"\\n\\t\");\n        sb.append(cache);\n      }\n      log.info(sb.toString());\n    } else {\n      log.debug(\"Closing \" + name);\n    }\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    if (closeReader) reader.decRef();\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","sourceOld":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (cachingEnabled) {\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"Closing \").append(name);\n      for (SolrCache cache : cacheList) {\n        sb.append(\"\\n\\t\");\n        sb.append(cache);\n      }\n      log.info(sb.toString());\n    } else {\n      log.debug(\"Closing \" + name);\n    }\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    if (closeReader) reader.decRef();\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","sourceNew":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (cachingEnabled) {\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"Closing \").append(name);\n      for (SolrCache cache : cacheList) {\n        sb.append(\"\\n\\t\");\n        sb.append(cache);\n      }\n      log.info(sb.toString());\n    } else {\n      log.debug(\"Closing \" + name);\n    }\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    if (closeReader) reader.decRef();\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","sourceOld":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (cachingEnabled) {\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"Closing \").append(name);\n      for (SolrCache cache : cacheList) {\n        sb.append(\"\\n\\t\");\n        sb.append(cache);\n      }\n      log.info(sb.toString());\n    } else {\n      log.debug(\"Closing \" + name);\n    }\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    if (closeReader) reader.decRef();\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e22ffe8cc51a892ae103df018822d7873e901c2a","date":1313696790,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","sourceNew":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (cachingEnabled) {\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"Closing \").append(name);\n      for (SolrCache cache : cacheList) {\n        sb.append(\"\\n\\t\");\n        sb.append(cache);\n      }\n      log.info(sb.toString());\n    } else {\n      log.debug(\"Closing \" + name);\n    }\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    if (closeReader) reader.decRef();\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n\n    directoryFactory.release(getIndexReader().directory());\n   \n    \n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","sourceOld":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (cachingEnabled) {\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"Closing \").append(name);\n      for (SolrCache cache : cacheList) {\n        sb.append(\"\\n\\t\");\n        sb.append(cache);\n      }\n      log.info(sb.toString());\n    } else {\n      log.debug(\"Closing \" + name);\n    }\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    if (closeReader) reader.decRef();\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":["058801f8673d53a5abac8088204860ec29a40f0d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0e7c2454a6a8237bfd0e953f5b940838408c9055","date":1323649300,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","sourceNew":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  public void close() throws IOException {\n    if (cachingEnabled) {\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"Closing \").append(name);\n      for (SolrCache cache : cacheList) {\n        sb.append(\"\\n\\t\");\n        sb.append(cache);\n      }\n      log.info(sb.toString());\n    } else {\n      log.debug(\"Closing \" + name);\n    }\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    if (closeReader) reader.decRef();\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n\n    directoryFactory.release(getIndexReader().directory());\n   \n    \n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","sourceOld":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (cachingEnabled) {\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"Closing \").append(name);\n      for (SolrCache cache : cacheList) {\n        sb.append(\"\\n\\t\");\n        sb.append(cache);\n      }\n      log.info(sb.toString());\n    } else {\n      log.debug(\"Closing \" + name);\n    }\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    if (closeReader) reader.decRef();\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n\n    directoryFactory.release(getIndexReader().directory());\n   \n    \n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","date":1323720782,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","sourceNew":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  public void close() throws IOException {\n    if (cachingEnabled) {\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"Closing \").append(name);\n      for (SolrCache cache : cacheList) {\n        sb.append(\"\\n\\t\");\n        sb.append(cache);\n      }\n      log.info(sb.toString());\n    } else {\n      log.debug(\"Closing \" + name);\n    }\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    if (closeReader) reader.decRef();\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n\n    directoryFactory.release(getIndexReader().directory());\n   \n    \n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","sourceOld":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (cachingEnabled) {\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"Closing \").append(name);\n      for (SolrCache cache : cacheList) {\n        sb.append(\"\\n\\t\");\n        sb.append(cache);\n      }\n      log.info(sb.toString());\n    } else {\n      log.debug(\"Closing \" + name);\n    }\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    if (closeReader) reader.decRef();\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n\n    directoryFactory.release(getIndexReader().directory());\n   \n    \n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8f7907798e0c730e9ab37681c6e8dfbde0e4173","date":1330361299,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","sourceNew":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  public void close() throws IOException {\n    if (debug) {\n      if (cachingEnabled) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        if (debug) log.debug(\"Closing \" + name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    if (closeReader) reader.decRef();\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n\n    directoryFactory.release(getIndexReader().directory());\n   \n    \n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","sourceOld":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  public void close() throws IOException {\n    if (cachingEnabled) {\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"Closing \").append(name);\n      for (SolrCache cache : cacheList) {\n        sb.append(\"\\n\\t\");\n        sb.append(cache);\n      }\n      log.info(sb.toString());\n    } else {\n      log.debug(\"Closing \" + name);\n    }\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    if (closeReader) reader.decRef();\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n\n    directoryFactory.release(getIndexReader().directory());\n   \n    \n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","sourceNew":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  public void close() throws IOException {\n    if (debug) {\n      if (cachingEnabled) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        if (debug) log.debug(\"Closing \" + name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    if (closeReader) reader.decRef();\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n\n    directoryFactory.release(getIndexReader().directory());\n   \n    \n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","sourceOld":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  public void close() throws IOException {\n    if (cachingEnabled) {\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"Closing \").append(name);\n      for (SolrCache cache : cacheList) {\n        sb.append(\"\\n\\t\");\n        sb.append(cache);\n      }\n      log.info(sb.toString());\n    } else {\n      log.debug(\"Closing \" + name);\n    }\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    if (closeReader) reader.decRef();\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n\n    directoryFactory.release(getIndexReader().directory());\n   \n    \n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9405f486872f1e416304dfe389741f4ee2f8a4d","date":1351276739,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","sourceNew":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  public void close() throws IOException {\n    if (debug) {\n      if (cachingEnabled) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        if (debug) log.debug(\"Closing \" + name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    try {\n      if (closeReader) reader.decRef();\n    } catch (Throwable t) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", t);\n    }\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n\n    directoryFactory.release(getIndexReader().directory());\n   \n    \n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","sourceOld":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  public void close() throws IOException {\n    if (debug) {\n      if (cachingEnabled) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        if (debug) log.debug(\"Closing \" + name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    if (closeReader) reader.decRef();\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n\n    directoryFactory.release(getIndexReader().directory());\n   \n    \n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f2126b84bd093fa3d921582a109a0ee578c28126","date":1351522501,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","sourceNew":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  public void close() throws IOException {\n    if (debug) {\n      if (cachingEnabled) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        if (debug) log.debug(\"Closing \" + name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    try {\n      if (closeReader) reader.decRef();\n    } catch (Throwable t) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", t);\n    }\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n\n    directoryFactory.release(getIndexReader().directory());\n   \n    \n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","sourceOld":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  public void close() throws IOException {\n    if (debug) {\n      if (cachingEnabled) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        if (debug) log.debug(\"Closing \" + name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    if (closeReader) reader.decRef();\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n\n    directoryFactory.release(getIndexReader().directory());\n   \n    \n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","sourceNew":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (debug) {\n      if (cachingEnabled) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        if (debug) log.debug(\"Closing \" + name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    try {\n      if (closeReader) reader.decRef();\n    } catch (Throwable t) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", t);\n    }\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n\n    directoryFactory.release(getIndexReader().directory());\n   \n    \n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","sourceOld":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  public void close() throws IOException {\n    if (debug) {\n      if (cachingEnabled) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        if (debug) log.debug(\"Closing \" + name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    try {\n      if (closeReader) reader.decRef();\n    } catch (Throwable t) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", t);\n    }\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n\n    directoryFactory.release(getIndexReader().directory());\n   \n    \n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","sourceNew":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (debug) {\n      if (cachingEnabled) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        if (debug) log.debug(\"Closing \" + name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    try {\n      if (closeReader) reader.decRef();\n    } catch (Throwable t) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", t);\n    }\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n\n    directoryFactory.release(getIndexReader().directory());\n   \n    \n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","sourceOld":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  public void close() throws IOException {\n    if (debug) {\n      if (cachingEnabled) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        if (debug) log.debug(\"Closing \" + name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    try {\n      if (closeReader) reader.decRef();\n    } catch (Throwable t) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", t);\n    }\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n\n    directoryFactory.release(getIndexReader().directory());\n   \n    \n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"058801f8673d53a5abac8088204860ec29a40f0d","date":1364178882,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","sourceNew":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (debug) {\n      if (cachingEnabled) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        if (debug) log.debug(\"Closing \" + name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    try {\n      if (closeReader) reader.decRef();\n    } catch (Throwable t) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", t);\n    }\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n    if (reserveDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n    if (createdDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n   \n    \n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","sourceOld":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (debug) {\n      if (cachingEnabled) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        if (debug) log.debug(\"Closing \" + name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    try {\n      if (closeReader) reader.decRef();\n    } catch (Throwable t) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", t);\n    }\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n\n    directoryFactory.release(getIndexReader().directory());\n   \n    \n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","bugFix":["e22ffe8cc51a892ae103df018822d7873e901c2a"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"849494cf2f3a96af5c8c84995108ddd8456fcd04","date":1372277913,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","sourceNew":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (debug) {\n      if (cachingEnabled) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        if (debug) log.debug(\"Closing \" + name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    \n    long cpg = reader.getIndexCommit().getGeneration();\n    try {\n      if (closeReader) reader.decRef();\n    } catch (Throwable t) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", t);\n    }\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      core.getDeletionPolicy().releaseCommitPoint(cpg);\n    }\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n    if (reserveDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n    if (createdDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n   \n    \n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","sourceOld":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (debug) {\n      if (cachingEnabled) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        if (debug) log.debug(\"Closing \" + name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    try {\n      if (closeReader) reader.decRef();\n    } catch (Throwable t) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", t);\n    }\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n    if (reserveDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n    if (createdDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n   \n    \n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","sourceNew":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (debug) {\n      if (cachingEnabled) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        if (debug) log.debug(\"Closing \" + name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    \n    long cpg = reader.getIndexCommit().getGeneration();\n    try {\n      if (closeReader) reader.decRef();\n    } catch (Throwable t) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", t);\n    }\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      core.getDeletionPolicy().releaseCommitPoint(cpg);\n    }\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n    if (reserveDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n    if (createdDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n   \n    \n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","sourceOld":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (debug) {\n      if (cachingEnabled) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        if (debug) log.debug(\"Closing \" + name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    try {\n      if (closeReader) reader.decRef();\n    } catch (Throwable t) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", t);\n    }\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n    if (reserveDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n    if (createdDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n   \n    \n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","date":1389633998,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","sourceNew":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (debug) {\n      if (cachingEnabled) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        if (debug) log.debug(\"Closing \" + name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    \n    long cpg = reader.getIndexCommit().getGeneration();\n    try {\n      if (closeReader) reader.decRef();\n    } catch (Exception e) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", e);\n    }\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      core.getDeletionPolicy().releaseCommitPoint(cpg);\n    }\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n    if (reserveDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n    if (createdDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n   \n    \n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","sourceOld":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (debug) {\n      if (cachingEnabled) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        if (debug) log.debug(\"Closing \" + name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    \n    long cpg = reader.getIndexCommit().getGeneration();\n    try {\n      if (closeReader) reader.decRef();\n    } catch (Throwable t) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", t);\n    }\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      core.getDeletionPolicy().releaseCommitPoint(cpg);\n    }\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n    if (reserveDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n    if (createdDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n   \n    \n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","bugFix":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5275a994b4fc707fafce0408625bd3456edc28a4","date":1400004510,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","sourceNew":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (debug) {\n      if (cachingEnabled) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        if (debug) log.debug(\"Closing \" + name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    \n    long cpg = reader.getIndexCommit().getGeneration();\n    try {\n      if (closeReader) rawReader.decRef();\n    } catch (Exception e) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", e);\n    }\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      core.getDeletionPolicy().releaseCommitPoint(cpg);\n    }\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n    if (reserveDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n    if (createdDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n   \n    \n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","sourceOld":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (debug) {\n      if (cachingEnabled) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        if (debug) log.debug(\"Closing \" + name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    \n    long cpg = reader.getIndexCommit().getGeneration();\n    try {\n      if (closeReader) reader.decRef();\n    } catch (Exception e) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", e);\n    }\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      core.getDeletionPolicy().releaseCommitPoint(cpg);\n    }\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n    if (reserveDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n    if (createdDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n   \n    \n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93dd449115a9247533e44bab47e8429e5dccbc6d","date":1400258396,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","sourceNew":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (debug) {\n      if (cachingEnabled) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        if (debug) log.debug(\"Closing \" + name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    \n    long cpg = reader.getIndexCommit().getGeneration();\n    try {\n      if (closeReader) rawReader.decRef();\n    } catch (Exception e) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", e);\n    }\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      core.getDeletionPolicy().releaseCommitPoint(cpg);\n    }\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n    if (reserveDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n    if (createdDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n   \n    \n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","sourceOld":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (debug) {\n      if (cachingEnabled) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        if (debug) log.debug(\"Closing \" + name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    \n    long cpg = reader.getIndexCommit().getGeneration();\n    try {\n      if (closeReader) reader.decRef();\n    } catch (Exception e) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", e);\n    }\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      core.getDeletionPolicy().releaseCommitPoint(cpg);\n    }\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n    if (reserveDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n    if (createdDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n   \n    \n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","sourceNew":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (debug) {\n      if (cachingEnabled) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        if (debug) log.debug(\"Closing \" + name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    \n    long cpg = reader.getIndexCommit().getGeneration();\n    try {\n      if (closeReader) rawReader.decRef();\n    } catch (Exception e) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", e);\n    }\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      core.getDeletionPolicy().releaseCommitPoint(cpg);\n    }\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n    if (reserveDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n    if (createdDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n   \n    \n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","sourceOld":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (debug) {\n      if (cachingEnabled) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        if (debug) log.debug(\"Closing \" + name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    \n    long cpg = reader.getIndexCommit().getGeneration();\n    try {\n      if (closeReader) reader.decRef();\n    } catch (Exception e) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", e);\n    }\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      core.getDeletionPolicy().releaseCommitPoint(cpg);\n    }\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n    if (reserveDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n    if (createdDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n   \n    \n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ac9de183adbc9483681f275ac1e2d92ed19f52e1","date":1452414626,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","sourceNew":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (log.isDebugEnabled()) {\n      if (cachingEnabled) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        log.debug(\"Closing [{}]\", name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n\n    long cpg = reader.getIndexCommit().getGeneration();\n    try {\n      if (closeReader) rawReader.decRef();\n    } catch (Exception e) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", e);\n    }\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      core.getDeletionPolicy().releaseCommitPoint(cpg);\n    }\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n    if (releaseDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n\n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","sourceOld":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (debug) {\n      if (cachingEnabled) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        if (debug) log.debug(\"Closing \" + name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n    \n    long cpg = reader.getIndexCommit().getGeneration();\n    try {\n      if (closeReader) rawReader.decRef();\n    } catch (Exception e) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", e);\n    }\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      core.getDeletionPolicy().releaseCommitPoint(cpg);\n    }\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n    if (reserveDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n    if (createdDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n   \n    \n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ed2d3cbea990a1cd6c54a591a294f629964b01be","date":1488991463,"type":3,"author":"Mark Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","sourceNew":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (log.isDebugEnabled()) {\n      if (cachingEnabled) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        log.debug(\"Closing [{}]\", name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n\n    long cpg = reader.getIndexCommit().getGeneration();\n    try {\n      if (closeReader) rawReader.decRef();\n    } catch (Exception e) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", e);\n    }\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      core.getDeletionPolicy().releaseCommitPoint(cpg);\n    }\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n    if (releaseDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n\n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n    assert ObjectReleaseTracker.release(this);\n  }\n\n","sourceOld":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (log.isDebugEnabled()) {\n      if (cachingEnabled) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        log.debug(\"Closing [{}]\", name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n\n    long cpg = reader.getIndexCommit().getGeneration();\n    try {\n      if (closeReader) rawReader.decRef();\n    } catch (Exception e) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", e);\n    }\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      core.getDeletionPolicy().releaseCommitPoint(cpg);\n    }\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n    if (releaseDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n\n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c959a64c5b52cc12eb8daa17f4f0ed9cf2dfcaaa","date":1571411704,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","sourceNew":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (log.isDebugEnabled()) {\n      if (cachingEnabled) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        log.debug(\"Closing [{}]\", name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n\n    long cpg = reader.getIndexCommit().getGeneration();\n    try {\n      if (closeReader) rawReader.decRef();\n    } catch (Exception e) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", e);\n    }\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      core.getDeletionPolicy().releaseCommitPoint(cpg);\n    }\n\n    for (SolrCache cache : cacheList) {\n      try {\n        cache.close();\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception closing cache \" + cache.name(), e);\n      }\n    }\n\n    if (releaseDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n\n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n    assert ObjectReleaseTracker.release(this);\n  }\n\n","sourceOld":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (log.isDebugEnabled()) {\n      if (cachingEnabled) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        log.debug(\"Closing [{}]\", name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n\n    long cpg = reader.getIndexCommit().getGeneration();\n    try {\n      if (closeReader) rawReader.decRef();\n    } catch (Exception e) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", e);\n    }\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      core.getDeletionPolicy().releaseCommitPoint(cpg);\n    }\n\n    for (SolrCache cache : cacheList) {\n      cache.close();\n    }\n\n    if (releaseDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n\n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n    assert ObjectReleaseTracker.release(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e9e5eaf280a6aa21423126b8232aa157a9b7366","date":1571772228,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","sourceNew":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (log.isDebugEnabled()) {\n      if (cachingEnabled) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        log.debug(\"Closing [{}]\", name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n\n    long cpg = reader.getIndexCommit().getGeneration();\n    try {\n      if (closeReader) rawReader.decRef();\n    } catch (Exception e) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", e);\n    }\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      core.getDeletionPolicy().releaseCommitPoint(cpg);\n    }\n\n    for (SolrCache cache : cacheList) {\n      try {\n        cache.close();\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception closing cache \" + cache.name(), e);\n      }\n    }\n\n    if (releaseDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n\n    try {\n      SolrMetricProducer.super.close();\n    } catch (Exception e) {\n      log.warn(\"Exception closing\", e);\n    }\n\n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n    assert ObjectReleaseTracker.release(this);\n  }\n\n","sourceOld":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (log.isDebugEnabled()) {\n      if (cachingEnabled) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        log.debug(\"Closing [{}]\", name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n\n    long cpg = reader.getIndexCommit().getGeneration();\n    try {\n      if (closeReader) rawReader.decRef();\n    } catch (Exception e) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", e);\n    }\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      core.getDeletionPolicy().releaseCommitPoint(cpg);\n    }\n\n    for (SolrCache cache : cacheList) {\n      try {\n        cache.close();\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception closing cache \" + cache.name(), e);\n      }\n    }\n\n    if (releaseDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n\n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n    assert ObjectReleaseTracker.release(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c2af5a711bd6e2d33e0221ced0f47ac596ed275","date":1572877903,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","sourceNew":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (log.isDebugEnabled()) {\n      if (cachingEnabled) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        log.debug(\"Closing [{}]\", name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n\n    long cpg = reader.getIndexCommit().getGeneration();\n    try {\n      if (closeReader) rawReader.decRef();\n    } catch (Exception e) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", e);\n    }\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      core.getDeletionPolicy().releaseCommitPoint(cpg);\n    }\n\n    for (SolrCache cache : cacheList) {\n      try {\n        cache.close();\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception closing cache \" + cache.name(), e);\n      }\n    }\n\n    if (releaseDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n\n    try {\n      SolrInfoBean.super.close();\n    } catch (Exception e) {\n      log.warn(\"Exception closing\", e);\n    }\n\n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n    assert ObjectReleaseTracker.release(this);\n  }\n\n","sourceOld":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (log.isDebugEnabled()) {\n      if (cachingEnabled) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        log.debug(\"Closing [{}]\", name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n\n    long cpg = reader.getIndexCommit().getGeneration();\n    try {\n      if (closeReader) rawReader.decRef();\n    } catch (Exception e) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", e);\n    }\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      core.getDeletionPolicy().releaseCommitPoint(cpg);\n    }\n\n    for (SolrCache cache : cacheList) {\n      try {\n        cache.close();\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception closing cache \" + cache.name(), e);\n      }\n    }\n\n    if (releaseDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n\n    try {\n      SolrMetricProducer.super.close();\n    } catch (Exception e) {\n      log.warn(\"Exception closing\", e);\n    }\n\n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n    assert ObjectReleaseTracker.release(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54faedfb0e03479a38f5ee82f2dfaeea536e9404","date":1587251295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","sourceNew":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (log.isDebugEnabled()) {\n      if (cachingEnabled) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(\"{}\", sb);\n      } else {\n        log.debug(\"Closing [{}]\", name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n\n    long cpg = reader.getIndexCommit().getGeneration();\n    try {\n      if (closeReader) rawReader.decRef();\n    } catch (Exception e) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", e);\n    }\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      core.getDeletionPolicy().releaseCommitPoint(cpg);\n    }\n\n    for (SolrCache cache : cacheList) {\n      try {\n        cache.close();\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception closing cache \" + cache.name(), e);\n      }\n    }\n\n    if (releaseDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n\n    try {\n      SolrInfoBean.super.close();\n    } catch (Exception e) {\n      log.warn(\"Exception closing\", e);\n    }\n\n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n    assert ObjectReleaseTracker.release(this);\n  }\n\n","sourceOld":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (log.isDebugEnabled()) {\n      if (cachingEnabled) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(sb.toString());\n      } else {\n        log.debug(\"Closing [{}]\", name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n\n    long cpg = reader.getIndexCommit().getGeneration();\n    try {\n      if (closeReader) rawReader.decRef();\n    } catch (Exception e) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", e);\n    }\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      core.getDeletionPolicy().releaseCommitPoint(cpg);\n    }\n\n    for (SolrCache cache : cacheList) {\n      try {\n        cache.close();\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception closing cache \" + cache.name(), e);\n      }\n    }\n\n    if (releaseDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n\n    try {\n      SolrInfoBean.super.close();\n    } catch (Exception e) {\n      log.warn(\"Exception closing\", e);\n    }\n\n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n    assert ObjectReleaseTracker.release(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"50dfd19525c8d73e856dca6edb64b7aea074037f","date":1591579225,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#close().mjava","sourceNew":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (log.isDebugEnabled()) {\n      if (cachingEnabled) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (@SuppressWarnings({\"rawtypes\"})SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(\"{}\", sb);\n      } else {\n        log.debug(\"Closing [{}]\", name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n\n    long cpg = reader.getIndexCommit().getGeneration();\n    try {\n      if (closeReader) rawReader.decRef();\n    } catch (Exception e) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", e);\n    }\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      core.getDeletionPolicy().releaseCommitPoint(cpg);\n    }\n\n    for (@SuppressWarnings({\"rawtypes\"})SolrCache cache : cacheList) {\n      try {\n        cache.close();\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception closing cache \" + cache.name(), e);\n      }\n    }\n\n    if (releaseDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n\n    try {\n      SolrInfoBean.super.close();\n    } catch (Exception e) {\n      log.warn(\"Exception closing\", e);\n    }\n\n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n    assert ObjectReleaseTracker.release(this);\n  }\n\n","sourceOld":"  /**\n   * Free's resources associated with this searcher.\n   *\n   * In particular, the underlying reader and any cache's in use are closed.\n   */\n  @Override\n  public void close() throws IOException {\n    if (log.isDebugEnabled()) {\n      if (cachingEnabled) {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Closing \").append(name);\n        for (SolrCache cache : cacheList) {\n          sb.append(\"\\n\\t\");\n          sb.append(cache);\n        }\n        log.debug(\"{}\", sb);\n      } else {\n        log.debug(\"Closing [{}]\", name);\n      }\n    }\n\n    core.getInfoRegistry().remove(name);\n\n    // super.close();\n    // can't use super.close() since it just calls reader.close() and that may only be called once\n    // per reader (even if incRef() was previously called).\n\n    long cpg = reader.getIndexCommit().getGeneration();\n    try {\n      if (closeReader) rawReader.decRef();\n    } catch (Exception e) {\n      SolrException.log(log, \"Problem dec ref'ing reader\", e);\n    }\n\n    if (directoryFactory.searchersReserveCommitPoints()) {\n      core.getDeletionPolicy().releaseCommitPoint(cpg);\n    }\n\n    for (SolrCache cache : cacheList) {\n      try {\n        cache.close();\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception closing cache \" + cache.name(), e);\n      }\n    }\n\n    if (releaseDirectory) {\n      directoryFactory.release(getIndexReader().directory());\n    }\n\n    try {\n      SolrInfoBean.super.close();\n    } catch (Exception e) {\n      log.warn(\"Exception closing\", e);\n    }\n\n    // do this at the end so it only gets done if there are no exceptions\n    numCloses.incrementAndGet();\n    assert ObjectReleaseTracker.release(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["d9405f486872f1e416304dfe389741f4ee2f8a4d","7530de27b87b961b51f01bd1299b7004d46e8823"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["058801f8673d53a5abac8088204860ec29a40f0d","849494cf2f3a96af5c8c84995108ddd8456fcd04"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["0e7c2454a6a8237bfd0e953f5b940838408c9055","f8f7907798e0c730e9ab37681c6e8dfbde0e4173"],"5275a994b4fc707fafce0408625bd3456edc28a4":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":["e22ffe8cc51a892ae103df018822d7873e901c2a","0e7c2454a6a8237bfd0e953f5b940838408c9055"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["f8f7907798e0c730e9ab37681c6e8dfbde0e4173"],"56572ec06f1407c066d6b7399413178b33176cd8":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","93dd449115a9247533e44bab47e8429e5dccbc6d"],"54faedfb0e03479a38f5ee82f2dfaeea536e9404":["7c2af5a711bd6e2d33e0221ced0f47ac596ed275"],"0e7c2454a6a8237bfd0e953f5b940838408c9055":["e22ffe8cc51a892ae103df018822d7873e901c2a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f2126b84bd093fa3d921582a109a0ee578c28126":["f8f7907798e0c730e9ab37681c6e8dfbde0e4173","d9405f486872f1e416304dfe389741f4ee2f8a4d"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["849494cf2f3a96af5c8c84995108ddd8456fcd04"],"e22ffe8cc51a892ae103df018822d7873e901c2a":["c26f00b574427b55127e869b935845554afde1fa"],"f8f7907798e0c730e9ab37681c6e8dfbde0e4173":["0e7c2454a6a8237bfd0e953f5b940838408c9055"],"c959a64c5b52cc12eb8daa17f4f0ed9cf2dfcaaa":["ed2d3cbea990a1cd6c54a591a294f629964b01be"],"2e9e5eaf280a6aa21423126b8232aa157a9b7366":["c959a64c5b52cc12eb8daa17f4f0ed9cf2dfcaaa"],"ac9de183adbc9483681f275ac1e2d92ed19f52e1":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["058801f8673d53a5abac8088204860ec29a40f0d"],"058801f8673d53a5abac8088204860ec29a40f0d":["7530de27b87b961b51f01bd1299b7004d46e8823"],"ed2d3cbea990a1cd6c54a591a294f629964b01be":["ac9de183adbc9483681f275ac1e2d92ed19f52e1"],"7c2af5a711bd6e2d33e0221ced0f47ac596ed275":["2e9e5eaf280a6aa21423126b8232aa157a9b7366"],"50dfd19525c8d73e856dca6edb64b7aea074037f":["54faedfb0e03479a38f5ee82f2dfaeea536e9404"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","5275a994b4fc707fafce0408625bd3456edc28a4"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7530de27b87b961b51f01bd1299b7004d46e8823":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["50dfd19525c8d73e856dca6edb64b7aea074037f"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"5275a994b4fc707fafce0408625bd3456edc28a4":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"c26f00b574427b55127e869b935845554afde1fa":["e22ffe8cc51a892ae103df018822d7873e901c2a"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":[],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","f2126b84bd093fa3d921582a109a0ee578c28126","7530de27b87b961b51f01bd1299b7004d46e8823"],"56572ec06f1407c066d6b7399413178b33176cd8":[],"54faedfb0e03479a38f5ee82f2dfaeea536e9404":["50dfd19525c8d73e856dca6edb64b7aea074037f"],"0e7c2454a6a8237bfd0e953f5b940838408c9055":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","f8f7907798e0c730e9ab37681c6e8dfbde0e4173"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"f2126b84bd093fa3d921582a109a0ee578c28126":[],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["5275a994b4fc707fafce0408625bd3456edc28a4","56572ec06f1407c066d6b7399413178b33176cd8","93dd449115a9247533e44bab47e8429e5dccbc6d"],"e22ffe8cc51a892ae103df018822d7873e901c2a":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","0e7c2454a6a8237bfd0e953f5b940838408c9055"],"f8f7907798e0c730e9ab37681c6e8dfbde0e4173":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","d9405f486872f1e416304dfe389741f4ee2f8a4d","f2126b84bd093fa3d921582a109a0ee578c28126"],"c959a64c5b52cc12eb8daa17f4f0ed9cf2dfcaaa":["2e9e5eaf280a6aa21423126b8232aa157a9b7366"],"2e9e5eaf280a6aa21423126b8232aa157a9b7366":["7c2af5a711bd6e2d33e0221ced0f47ac596ed275"],"ac9de183adbc9483681f275ac1e2d92ed19f52e1":["ed2d3cbea990a1cd6c54a591a294f629964b01be"],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["37a0f60745e53927c4c876cfe5b5a58170f0646c","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"058801f8673d53a5abac8088204860ec29a40f0d":["37a0f60745e53927c4c876cfe5b5a58170f0646c","849494cf2f3a96af5c8c84995108ddd8456fcd04"],"ed2d3cbea990a1cd6c54a591a294f629964b01be":["c959a64c5b52cc12eb8daa17f4f0ed9cf2dfcaaa"],"7c2af5a711bd6e2d33e0221ced0f47ac596ed275":["54faedfb0e03479a38f5ee82f2dfaeea536e9404"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["56572ec06f1407c066d6b7399413178b33176cd8","ac9de183adbc9483681f275ac1e2d92ed19f52e1"],"50dfd19525c8d73e856dca6edb64b7aea074037f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","058801f8673d53a5abac8088204860ec29a40f0d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","37a0f60745e53927c4c876cfe5b5a58170f0646c","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","56572ec06f1407c066d6b7399413178b33176cd8","f2126b84bd093fa3d921582a109a0ee578c28126","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}