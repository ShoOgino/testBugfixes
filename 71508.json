{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/LZ4#decompress(DataInput,int,byte[],int).mjava","commits":[{"id":"9ee663728a95682ffb5dee37517ac9e863cd0820","date":1352758633,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/LZ4#decompress(DataInput,int,byte[],int).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/LZ4#decompress(DataInput,int,BytesRef).mjava","sourceNew":"  /**\n   * Decompress at least <code>decompressedLen</code> bytes into\n   * <code>dest[dOff:]</code>. Please note that <code>dest</code> must be large\n   * enough to be able to hold <b>all</b> decompressed data (meaning that you\n   * need to know the total decompressed length).\n   */\n  public static int decompress(DataInput compressed, int decompressedLen, byte[] dest, int dOff) throws IOException {\n    final int destEnd = dest.length;\n\n    do {\n      // literals\n      final int token = compressed.readByte() & 0xFF;\n      int literalLen = token >>> 4;\n\n      if (literalLen != 0) {\n        if (literalLen == 0x0F) {\n          byte len;\n          while ((len = compressed.readByte()) == (byte) 0xFF) {\n            literalLen += 0xFF;\n          }\n          literalLen += len & 0xFF;\n        }\n        compressed.readBytes(dest, dOff, literalLen);\n        dOff += literalLen;\n      }\n\n      if (dOff >= decompressedLen) {\n        break;\n      }\n\n      // matchs\n      final int matchDec = (compressed.readByte() & 0xFF) | ((compressed.readByte() & 0xFF) << 8);\n      assert matchDec > 0;\n\n      int matchLen = token & 0x0F;\n      if (matchLen == 0x0F) {\n        int len;\n        while ((len = compressed.readByte()) == (byte) 0xFF) {\n          matchLen += 0xFF;\n        }\n        matchLen += len & 0xFF;\n      }\n      matchLen += MIN_MATCH;\n\n      // copying a multiple of 8 bytes can make decompression from 5% to 10% faster\n      final int fastLen = ((matchLen - 1) & 0xFFFFFFF8) + 8;\n      if (matchDec < matchLen || dOff + fastLen > destEnd) {\n        // overlap -> naive incremental copy\n        for (int ref = dOff - matchDec, end = dOff + matchLen; dOff < end; ++ref, ++dOff) {\n          dest[dOff] = dest[ref];\n        }\n      } else {\n        // no overlap -> arraycopy\n        System.arraycopy(dest, dOff - matchDec, dest, dOff, fastLen);\n        dOff += matchLen;\n      }\n    } while (dOff < decompressedLen);\n\n    return dOff;\n  }\n\n","sourceOld":"  /**\n   * Decompress at least <code>decompressedLen</code> bytes into <code>destBytes</code>.\n   * Please note that <code>destBytes</code> must be large enough to be able to hold\n   * <b>all</b> decompressed data plus 8 bytes (meaning that you need to know the total\n   * decompressed length).\n   */\n  public static void decompress(DataInput compressed, int decompressedLen, BytesRef destBytes) throws IOException {\n    final byte[] dest = destBytes.bytes;\n    final int destEnd = dest.length;\n    int dOff = 0;\n\n    while (dOff < decompressedLen) {\n      // literals\n      final int token = compressed.readByte() & 0xFF;\n      int literalLen = token >>> 4;\n\n      if (literalLen != 0) {\n        if (literalLen == 0x0F) {\n          byte len;\n          while ((len = compressed.readByte()) == (byte) 0xFF) {\n            literalLen += 0xFF;\n          }\n          literalLen += len & 0xFF;\n        }\n        compressed.readBytes(dest, dOff, literalLen);\n        dOff += literalLen;\n      }\n\n      if (dOff >= decompressedLen) {\n        break;\n      }\n\n      // matchs\n      final int matchDec = (compressed.readByte() & 0xFF) | ((compressed.readByte() & 0xFF) << 8);\n      assert matchDec > 0;\n\n      int matchLen = token & 0x0F;\n      if (matchLen == 0x0F) {\n        int len;\n        while ((len = compressed.readByte()) == (byte) 0xFF) {\n          matchLen += 0xFF;\n        }\n        matchLen += len & 0xFF;\n      }\n      matchLen += MIN_MATCH;\n\n      // copying a multiple of 8 bytes can make decompression from 5% to 10% faster\n      final int fastLen = ((matchLen - 1) & 0xFFFFFFF8) + 8;\n      if (matchDec < matchLen || dOff + fastLen > destEnd) {\n        // overlap -> naive incremental copy\n        for (int ref = dOff - matchDec, end = dOff + matchLen; dOff < end; ++ref, ++dOff) {\n          dest[dOff] = dest[ref];\n        }\n      } else {\n        // no overlap -> arraycopy\n        System.arraycopy(dest, dOff - matchDec, dest, dOff, fastLen);\n        dOff += matchLen;\n      }\n    }\n    destBytes.offset = 0;\n    destBytes.length = dOff;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5e04b732c631a77cbbd25b6ce43c2a8abb1e9e69","date":1352818449,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/LZ4#decompress(DataInput,int,byte[],int).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/LZ4#decompress(DataInput,int,byte[],int).mjava","sourceNew":"  /**\n   * Decompress at least <code>decompressedLen</code> bytes into\n   * <code>dest[dOff:]</code>. Please note that <code>dest</code> must be large\n   * enough to be able to hold <b>all</b> decompressed data (meaning that you\n   * need to know the total decompressed length).\n   */\n  public static int decompress(DataInput compressed, int decompressedLen, byte[] dest, int dOff) throws IOException {\n    final int destEnd = dest.length;\n\n    do {\n      // literals\n      final int token = compressed.readByte() & 0xFF;\n      int literalLen = token >>> 4;\n\n      if (literalLen != 0) {\n        if (literalLen == 0x0F) {\n          byte len;\n          while ((len = compressed.readByte()) == (byte) 0xFF) {\n            literalLen += 0xFF;\n          }\n          literalLen += len & 0xFF;\n        }\n        compressed.readBytes(dest, dOff, literalLen);\n        dOff += literalLen;\n      }\n\n      if (dOff >= decompressedLen) {\n        break;\n      }\n\n      // matchs\n      final int matchDec = (compressed.readByte() & 0xFF) | ((compressed.readByte() & 0xFF) << 8);\n      assert matchDec > 0;\n\n      int matchLen = token & 0x0F;\n      if (matchLen == 0x0F) {\n        int len;\n        while ((len = compressed.readByte()) == (byte) 0xFF) {\n          matchLen += 0xFF;\n        }\n        matchLen += len & 0xFF;\n      }\n      matchLen += MIN_MATCH;\n\n      // copying a multiple of 8 bytes can make decompression from 5% to 10% faster\n      final int fastLen = ((matchLen - 1) & 0xFFFFFFF8) + 8;\n      if (matchDec < matchLen || dOff + fastLen > destEnd) {\n        // overlap -> naive incremental copy\n        for (int ref = dOff - matchDec, end = dOff + matchLen; dOff < end; ++ref, ++dOff) {\n          dest[dOff] = dest[ref];\n        }\n      } else {\n        // no overlap -> arraycopy\n        System.arraycopy(dest, dOff - matchDec, dest, dOff, fastLen);\n        dOff += matchLen;\n      }\n    } while (dOff < decompressedLen);\n\n    return dOff;\n  }\n\n","sourceOld":"  /**\n   * Decompress at least <code>decompressedLen</code> bytes into\n   * <code>dest[dOff:]</code>. Please note that <code>dest</code> must be large\n   * enough to be able to hold <b>all</b> decompressed data (meaning that you\n   * need to know the total decompressed length).\n   */\n  public static int decompress(DataInput compressed, int decompressedLen, byte[] dest, int dOff) throws IOException {\n    final int destEnd = dest.length;\n\n    do {\n      // literals\n      final int token = compressed.readByte() & 0xFF;\n      int literalLen = token >>> 4;\n\n      if (literalLen != 0) {\n        if (literalLen == 0x0F) {\n          byte len;\n          while ((len = compressed.readByte()) == (byte) 0xFF) {\n            literalLen += 0xFF;\n          }\n          literalLen += len & 0xFF;\n        }\n        compressed.readBytes(dest, dOff, literalLen);\n        dOff += literalLen;\n      }\n\n      if (dOff >= decompressedLen) {\n        break;\n      }\n\n      // matchs\n      final int matchDec = (compressed.readByte() & 0xFF) | ((compressed.readByte() & 0xFF) << 8);\n      assert matchDec > 0;\n\n      int matchLen = token & 0x0F;\n      if (matchLen == 0x0F) {\n        int len;\n        while ((len = compressed.readByte()) == (byte) 0xFF) {\n          matchLen += 0xFF;\n        }\n        matchLen += len & 0xFF;\n      }\n      matchLen += MIN_MATCH;\n\n      // copying a multiple of 8 bytes can make decompression from 5% to 10% faster\n      final int fastLen = ((matchLen - 1) & 0xFFFFFFF8) + 8;\n      if (matchDec < matchLen || dOff + fastLen > destEnd) {\n        // overlap -> naive incremental copy\n        for (int ref = dOff - matchDec, end = dOff + matchLen; dOff < end; ++ref, ++dOff) {\n          dest[dOff] = dest[ref];\n        }\n      } else {\n        // no overlap -> arraycopy\n        System.arraycopy(dest, dOff - matchDec, dest, dOff, fastLen);\n        dOff += matchLen;\n      }\n    } while (dOff < decompressedLen);\n\n    return dOff;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9ee663728a95682ffb5dee37517ac9e863cd0820":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5e04b732c631a77cbbd25b6ce43c2a8abb1e9e69":["9ee663728a95682ffb5dee37517ac9e863cd0820"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5e04b732c631a77cbbd25b6ce43c2a8abb1e9e69"]},"commit2Childs":{"9ee663728a95682ffb5dee37517ac9e863cd0820":["5e04b732c631a77cbbd25b6ce43c2a8abb1e9e69"],"5e04b732c631a77cbbd25b6ce43c2a8abb1e9e69":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9ee663728a95682ffb5dee37517ac9e863cd0820"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}