{"path":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","commits":[{"id":"c1a89fbf5a750bffb59fe3bf0779dd9fb5ee0c4d","date":1382570352,"type":0,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"/dev/null","sourceNew":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) throws IOException {\n      this.cacheId = new Object();\n      this.field = localParams.get(\"field\");\n      this.solrParams = params;\n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      }\n      this.searcher = request.getSearcher();\n      this.leafCount = searcher.getTopReaderContext().leaves().size();\n      this.maxDoc = searcher.maxDoc();\n      this.schema = searcher.getSchema();\n      SchemaField schemaField = schema.getField(this.field);\n      if(schemaField.hasDocValues()) {\n        this.docValues = searcher.getAtomicReader().getSortedDocValues(this.field);\n      } else {\n        this.docValues = FieldCache.DEFAULT.getTermsIndex(searcher.getAtomicReader(), this.field);\n      }\n\n      this.max = localParams.get(\"max\");\n      if(this.max != null) {\n        this.fieldType = searcher.getSchema().getField(this.max).getType();\n      }\n\n      this.min = localParams.get(\"min\");\n      if(this.min != null) {\n        this.fieldType = searcher.getSchema().getField(this.min).getType();\n      }\n\n      this.context = request.getContext();\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["ceae51e37bbff02dcdeaa12303fec10d3eaaa004"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f028e66c4e5145ca2811ba1ca70570ec10a1e723","date":1382669434,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","sourceNew":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) throws IOException {\n      this.cacheId = new Object();\n      this.field = localParams.get(\"field\");\n      this.solrParams = params;\n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      } else {\n        throw new IOException(\"Invalid nullPolicy:\"+nPolicy);\n      }\n      this.searcher = request.getSearcher();\n      this.leafCount = searcher.getTopReaderContext().leaves().size();\n      this.maxDoc = searcher.maxDoc();\n      this.schema = searcher.getSchema();\n      SchemaField schemaField = schema.getField(this.field);\n      if(schemaField.hasDocValues()) {\n        this.docValues = searcher.getAtomicReader().getSortedDocValues(this.field);\n      } else {\n        this.docValues = FieldCache.DEFAULT.getTermsIndex(searcher.getAtomicReader(), this.field);\n      }\n\n      this.max = localParams.get(\"max\");\n      if(this.max != null) {\n        this.fieldType = searcher.getSchema().getField(this.max).getType();\n      }\n\n      this.min = localParams.get(\"min\");\n      if(this.min != null) {\n        this.fieldType = searcher.getSchema().getField(this.min).getType();\n      }\n\n      this.context = request.getContext();\n    }\n\n","sourceOld":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) throws IOException {\n      this.cacheId = new Object();\n      this.field = localParams.get(\"field\");\n      this.solrParams = params;\n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      }\n      this.searcher = request.getSearcher();\n      this.leafCount = searcher.getTopReaderContext().leaves().size();\n      this.maxDoc = searcher.maxDoc();\n      this.schema = searcher.getSchema();\n      SchemaField schemaField = schema.getField(this.field);\n      if(schemaField.hasDocValues()) {\n        this.docValues = searcher.getAtomicReader().getSortedDocValues(this.field);\n      } else {\n        this.docValues = FieldCache.DEFAULT.getTermsIndex(searcher.getAtomicReader(), this.field);\n      }\n\n      this.max = localParams.get(\"max\");\n      if(this.max != null) {\n        this.fieldType = searcher.getSchema().getField(this.max).getType();\n      }\n\n      this.min = localParams.get(\"min\");\n      if(this.min != null) {\n        this.fieldType = searcher.getSchema().getField(this.min).getType();\n      }\n\n      this.context = request.getContext();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ceae51e37bbff02dcdeaa12303fec10d3eaaa004","date":1387382773,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","sourceNew":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) throws IOException {\n      this.cacheId = new Object();\n      this.field = localParams.get(\"field\");\n      this.max = localParams.get(\"max\");\n      this.min = localParams.get(\"min\");\n      this.context = request.getContext();\n      if(this.min != null || this.max != null) {\n        this.needsScores = needsScores(params);\n      }\n\n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      } else {\n        throw new IOException(\"Invalid nullPolicy:\"+nPolicy);\n      }\n    }\n\n","sourceOld":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) throws IOException {\n      this.cacheId = new Object();\n      this.field = localParams.get(\"field\");\n      this.solrParams = params;\n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      } else {\n        throw new IOException(\"Invalid nullPolicy:\"+nPolicy);\n      }\n      this.searcher = request.getSearcher();\n      this.leafCount = searcher.getTopReaderContext().leaves().size();\n      this.maxDoc = searcher.maxDoc();\n      this.schema = searcher.getSchema();\n      SchemaField schemaField = schema.getField(this.field);\n      if(schemaField.hasDocValues()) {\n        this.docValues = searcher.getAtomicReader().getSortedDocValues(this.field);\n      } else {\n        this.docValues = FieldCache.DEFAULT.getTermsIndex(searcher.getAtomicReader(), this.field);\n      }\n\n      this.max = localParams.get(\"max\");\n      if(this.max != null) {\n        this.fieldType = searcher.getSchema().getField(this.max).getType();\n      }\n\n      this.min = localParams.get(\"min\");\n      if(this.min != null) {\n        this.fieldType = searcher.getSchema().getField(this.min).getType();\n      }\n\n      this.context = request.getContext();\n    }\n\n","bugFix":["c1a89fbf5a750bffb59fe3bf0779dd9fb5ee0c4d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","sourceNew":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) throws IOException {\n      this.cacheId = new Object();\n      this.field = localParams.get(\"field\");\n      this.max = localParams.get(\"max\");\n      this.min = localParams.get(\"min\");\n      this.context = request.getContext();\n      if(this.min != null || this.max != null) {\n        this.needsScores = needsScores(params);\n      }\n\n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      } else {\n        throw new IOException(\"Invalid nullPolicy:\"+nPolicy);\n      }\n    }\n\n","sourceOld":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) throws IOException {\n      this.cacheId = new Object();\n      this.field = localParams.get(\"field\");\n      this.solrParams = params;\n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      } else {\n        throw new IOException(\"Invalid nullPolicy:\"+nPolicy);\n      }\n      this.searcher = request.getSearcher();\n      this.leafCount = searcher.getTopReaderContext().leaves().size();\n      this.maxDoc = searcher.maxDoc();\n      this.schema = searcher.getSchema();\n      SchemaField schemaField = schema.getField(this.field);\n      if(schemaField.hasDocValues()) {\n        this.docValues = searcher.getAtomicReader().getSortedDocValues(this.field);\n      } else {\n        this.docValues = FieldCache.DEFAULT.getTermsIndex(searcher.getAtomicReader(), this.field);\n      }\n\n      this.max = localParams.get(\"max\");\n      if(this.max != null) {\n        this.fieldType = searcher.getSchema().getField(this.max).getType();\n      }\n\n      this.min = localParams.get(\"min\");\n      if(this.min != null) {\n        this.fieldType = searcher.getSchema().getField(this.min).getType();\n      }\n\n      this.context = request.getContext();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6f9eac2f0b568b3694682edb863185a273fbbc6f","date":1391883217,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","sourceNew":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) throws IOException {\n      this.field = localParams.get(\"field\");\n      this.max = localParams.get(\"max\");\n      this.min = localParams.get(\"min\");\n      if(this.min != null || this.max != null) {\n        this.needsScores = needsScores(params);\n      }\n\n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      } else {\n        throw new IOException(\"Invalid nullPolicy:\"+nPolicy);\n      }\n    }\n\n","sourceOld":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) throws IOException {\n      this.cacheId = new Object();\n      this.field = localParams.get(\"field\");\n      this.max = localParams.get(\"max\");\n      this.min = localParams.get(\"min\");\n      this.context = request.getContext();\n      if(this.min != null || this.max != null) {\n        this.needsScores = needsScores(params);\n      }\n\n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      } else {\n        throw new IOException(\"Invalid nullPolicy:\"+nPolicy);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b3c00dc1009b09cee556b71f8383d9fc259a87ea","date":1395723902,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","sourceNew":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) throws IOException {\n      this.field = localParams.get(\"field\");\n      if (this.field == null) {\n        throw new IllegalStateException(\"Required 'field' param is missing.\");\n      }\n      this.max = localParams.get(\"max\");\n      this.min = localParams.get(\"min\");\n      if(this.min != null || this.max != null) {\n        this.needsScores = needsScores(params);\n      }\n\n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      } else {\n        throw new IOException(\"Invalid nullPolicy:\"+nPolicy);\n      }\n    }\n\n","sourceOld":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) throws IOException {\n      this.field = localParams.get(\"field\");\n      this.max = localParams.get(\"max\");\n      this.min = localParams.get(\"min\");\n      if(this.min != null || this.max != null) {\n        this.needsScores = needsScores(params);\n      }\n\n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      } else {\n        throw new IOException(\"Invalid nullPolicy:\"+nPolicy);\n      }\n    }\n\n","bugFix":null,"bugIntro":["d140695fc024caefb4dc32ea6b3f6f4a649727b0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d140695fc024caefb4dc32ea6b3f6f4a649727b0","date":1395724151,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","sourceNew":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) throws IOException {\n      this.field = localParams.get(\"field\");\n      if (this.field == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Required 'field' param is missing.\");\n      }\n      this.max = localParams.get(\"max\");\n      this.min = localParams.get(\"min\");\n      if(this.min != null || this.max != null) {\n        this.needsScores = needsScores(params);\n      }\n\n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      } else {\n        throw new IOException(\"Invalid nullPolicy:\"+nPolicy);\n      }\n    }\n\n","sourceOld":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) throws IOException {\n      this.field = localParams.get(\"field\");\n      if (this.field == null) {\n        throw new IllegalStateException(\"Required 'field' param is missing.\");\n      }\n      this.max = localParams.get(\"max\");\n      this.min = localParams.get(\"min\");\n      if(this.min != null || this.max != null) {\n        this.needsScores = needsScores(params);\n      }\n\n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      } else {\n        throw new IOException(\"Invalid nullPolicy:\"+nPolicy);\n      }\n    }\n\n","bugFix":["b3c00dc1009b09cee556b71f8383d9fc259a87ea"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a667f95e8b4d25c8e45a6bb9ba8ce9654e7858d7","date":1401992910,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","sourceNew":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) throws IOException {\n      this.field = localParams.get(\"field\");\n      if (this.field == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Required 'field' param is missing.\");\n      }\n      this.max = localParams.get(\"max\");\n      this.min = localParams.get(\"min\");\n      if(this.min != null || this.max != null) {\n        this.needsScores = needsScores(params);\n      }\n\n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      } else {\n        throw new IOException(\"Invalid nullPolicy:\"+nPolicy);\n      }\n\n    }\n\n","sourceOld":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) throws IOException {\n      this.field = localParams.get(\"field\");\n      if (this.field == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Required 'field' param is missing.\");\n      }\n      this.max = localParams.get(\"max\");\n      this.min = localParams.get(\"min\");\n      if(this.min != null || this.max != null) {\n        this.needsScores = needsScores(params);\n      }\n\n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      } else {\n        throw new IOException(\"Invalid nullPolicy:\"+nPolicy);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8ced52befdc8d88d90766aadbaac496f3fd0e4ee","date":1421070034,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","sourceNew":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) throws IOException {\n      this.collapseField = localParams.get(\"field\");\n      if (this.collapseField == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Required 'field' param is missing.\");\n      }\n      this.max = localParams.get(\"max\");\n      this.min = localParams.get(\"min\");\n      this.hint = localParams.get(\"hint\");\n      this.size = localParams.getInt(\"size\", 100000); //Only used for collapsing on int fields.\n\n      if(this.min != null || this.max != null) {\n        this.needsScores = needsScores(params);\n      }\n\n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      } else {\n        throw new IOException(\"Invalid nullPolicy:\"+nPolicy);\n      }\n    }\n\n","sourceOld":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) throws IOException {\n      this.field = localParams.get(\"field\");\n      if (this.field == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Required 'field' param is missing.\");\n      }\n      this.max = localParams.get(\"max\");\n      this.min = localParams.get(\"min\");\n      if(this.min != null || this.max != null) {\n        this.needsScores = needsScores(params);\n      }\n\n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      } else {\n        throw new IOException(\"Invalid nullPolicy:\"+nPolicy);\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0325de99180d346d61d36938843a5c8451fe26ae","date":1447368726,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","sourceNew":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) throws IOException {\n      this.collapseField = localParams.get(\"field\");\n      if (this.collapseField == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Required 'field' param is missing.\");\n      }\n\n      this.groupHeadSelector = GroupHeadSelector.build(localParams);\n      \n      if (groupHeadSelector.type.equals(GroupHeadSelectorType.SORT) &&\n          CollapseScore.wantsCScore(groupHeadSelector.selectorText)) {\n        // we can't support Sorts that wrap functions that include \"cscore()\" because\n        // the abstraction layer for Sort/SortField rewriting gives each clause it's own\n        // context Map which we don't have access to -- so for now, give a useful error\n        // (as early as possible) if attempted\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                                \"Using cscore() as a function in the 'sort' local \"+\n                                \"param of the collapse parser is not supported\");\n      }\n\n        \n      \n      this.sortSpec = GroupHeadSelectorType.SORT.equals(groupHeadSelector.type) \n        ? QueryParsing.parseSortSpec(groupHeadSelector.selectorText, request)\n        : null;\n\n      this.hint = localParams.get(\"hint\");\n      this.size = localParams.getInt(\"size\", 100000); //Only used for collapsing on int fields.\n\n      {\n        final SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        assert null != info;\n        \n        // may be null in some esoteric corner usages\n        final ResponseBuilder rb = info.getResponseBuilder();\n        final SortSpec topSort = null == rb ? null : rb.getSortSpec();\n        \n        this.needsScores =\n          (info.getRsp().getReturnFields().wantsScore() ||\n           (null != topSort && topSort.includesScore()) ||\n           GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type) ||\n           (GroupHeadSelectorType.SORT.equals(groupHeadSelector.type)\n            && this.sortSpec.includesScore()) ||\n           (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)\n            && CollapseScore.wantsCScore(groupHeadSelector.selectorText)) ||\n           (this.boosted != null));\n\n        if (this.needsScores && null != rb) {\n          // regardless of why we need scores ensure the IndexSearcher will compute them\n          // for the \"real\" docs.  (ie: maybe we need them because we were\n          // asked to compute them for the collapsed docs, maybe we need them because in\n          // order to find the groupHead we need them computed for us.\n          \n          rb.setFieldFlags( rb.getFieldFlags() | SolrIndexSearcher.GET_SCORES);\n        }\n      }\n      \n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      } else {\n        throw new IOException(\"Invalid nullPolicy:\"+nPolicy);\n      }\n    }\n\n","sourceOld":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) throws IOException {\n      this.collapseField = localParams.get(\"field\");\n      if (this.collapseField == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Required 'field' param is missing.\");\n      }\n      this.max = localParams.get(\"max\");\n      this.min = localParams.get(\"min\");\n      this.hint = localParams.get(\"hint\");\n      this.size = localParams.getInt(\"size\", 100000); //Only used for collapsing on int fields.\n\n      if(this.min != null || this.max != null) {\n        this.needsScores = needsScores(params);\n      }\n\n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      } else {\n        throw new IOException(\"Invalid nullPolicy:\"+nPolicy);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c8dc56dbae186505066de8a78986cba31525ef0","date":1447876120,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","sourceNew":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) throws IOException {\n      this.collapseField = localParams.get(\"field\");\n      if (this.collapseField == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Required 'field' param is missing.\");\n      }\n\n      this.groupHeadSelector = GroupHeadSelector.build(localParams);\n      \n      if (groupHeadSelector.type.equals(GroupHeadSelectorType.SORT) &&\n          CollapseScore.wantsCScore(groupHeadSelector.selectorText)) {\n        // we can't support Sorts that wrap functions that include \"cscore()\" because\n        // the abstraction layer for Sort/SortField rewriting gives each clause it's own\n        // context Map which we don't have access to -- so for now, give a useful error\n        // (as early as possible) if attempted\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                                \"Using cscore() as a function in the 'sort' local \"+\n                                \"param of the collapse parser is not supported\");\n      }\n\n        \n      \n      this.sortSpec = GroupHeadSelectorType.SORT.equals(groupHeadSelector.type) \n        ? SortSpecParsing.parseSortSpec(groupHeadSelector.selectorText, request)\n        : null;\n\n      this.hint = localParams.get(\"hint\");\n      this.size = localParams.getInt(\"size\", 100000); //Only used for collapsing on int fields.\n\n      {\n        final SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        assert null != info;\n        \n        // may be null in some esoteric corner usages\n        final ResponseBuilder rb = info.getResponseBuilder();\n        final SortSpec topSort = null == rb ? null : rb.getSortSpec();\n        \n        this.needsScores =\n          (info.getRsp().getReturnFields().wantsScore() ||\n           (null != topSort && topSort.includesScore()) ||\n           GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type) ||\n           (GroupHeadSelectorType.SORT.equals(groupHeadSelector.type)\n            && this.sortSpec.includesScore()) ||\n           (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)\n            && CollapseScore.wantsCScore(groupHeadSelector.selectorText)) ||\n           (this.boosted != null));\n\n        if (this.needsScores && null != rb) {\n          // regardless of why we need scores ensure the IndexSearcher will compute them\n          // for the \"real\" docs.  (ie: maybe we need them because we were\n          // asked to compute them for the collapsed docs, maybe we need them because in\n          // order to find the groupHead we need them computed for us.\n          \n          rb.setFieldFlags( rb.getFieldFlags() | SolrIndexSearcher.GET_SCORES);\n        }\n      }\n      \n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      } else {\n        throw new IOException(\"Invalid nullPolicy:\"+nPolicy);\n      }\n    }\n\n","sourceOld":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) throws IOException {\n      this.collapseField = localParams.get(\"field\");\n      if (this.collapseField == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Required 'field' param is missing.\");\n      }\n\n      this.groupHeadSelector = GroupHeadSelector.build(localParams);\n      \n      if (groupHeadSelector.type.equals(GroupHeadSelectorType.SORT) &&\n          CollapseScore.wantsCScore(groupHeadSelector.selectorText)) {\n        // we can't support Sorts that wrap functions that include \"cscore()\" because\n        // the abstraction layer for Sort/SortField rewriting gives each clause it's own\n        // context Map which we don't have access to -- so for now, give a useful error\n        // (as early as possible) if attempted\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                                \"Using cscore() as a function in the 'sort' local \"+\n                                \"param of the collapse parser is not supported\");\n      }\n\n        \n      \n      this.sortSpec = GroupHeadSelectorType.SORT.equals(groupHeadSelector.type) \n        ? QueryParsing.parseSortSpec(groupHeadSelector.selectorText, request)\n        : null;\n\n      this.hint = localParams.get(\"hint\");\n      this.size = localParams.getInt(\"size\", 100000); //Only used for collapsing on int fields.\n\n      {\n        final SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        assert null != info;\n        \n        // may be null in some esoteric corner usages\n        final ResponseBuilder rb = info.getResponseBuilder();\n        final SortSpec topSort = null == rb ? null : rb.getSortSpec();\n        \n        this.needsScores =\n          (info.getRsp().getReturnFields().wantsScore() ||\n           (null != topSort && topSort.includesScore()) ||\n           GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type) ||\n           (GroupHeadSelectorType.SORT.equals(groupHeadSelector.type)\n            && this.sortSpec.includesScore()) ||\n           (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)\n            && CollapseScore.wantsCScore(groupHeadSelector.selectorText)) ||\n           (this.boosted != null));\n\n        if (this.needsScores && null != rb) {\n          // regardless of why we need scores ensure the IndexSearcher will compute them\n          // for the \"real\" docs.  (ie: maybe we need them because we were\n          // asked to compute them for the collapsed docs, maybe we need them because in\n          // order to find the groupHead we need them computed for us.\n          \n          rb.setFieldFlags( rb.getFieldFlags() | SolrIndexSearcher.GET_SCORES);\n        }\n      }\n      \n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      } else {\n        throw new IOException(\"Invalid nullPolicy:\"+nPolicy);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89261f2e2f1daac6de850bf45b31f5b8d3573f29","date":1537189734,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","sourceNew":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) {\n      this.collapseField = localParams.get(\"field\");\n      if (this.collapseField == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Required 'field' param is missing.\");\n      }\n\n      // if unknown field, this would fail fast\n      SchemaField collapseFieldSf = request.getSchema().getField(this.collapseField);\n      // collapseFieldSf won't be null\n      if (collapseFieldSf.multiValued()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collapsing not supported on multivalued fields\");\n      }\n\n      this.groupHeadSelector = GroupHeadSelector.build(localParams);\n      \n      if (groupHeadSelector.type.equals(GroupHeadSelectorType.SORT) &&\n          CollapseScore.wantsCScore(groupHeadSelector.selectorText)) {\n        // we can't support Sorts that wrap functions that include \"cscore()\" because\n        // the abstraction layer for Sort/SortField rewriting gives each clause it's own\n        // context Map which we don't have access to -- so for now, give a useful error\n        // (as early as possible) if attempted\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                                \"Using cscore() as a function in the 'sort' local \"+\n                                \"param of the collapse parser is not supported\");\n      }\n\n        \n      \n      this.sortSpec = GroupHeadSelectorType.SORT.equals(groupHeadSelector.type) \n        ? SortSpecParsing.parseSortSpec(groupHeadSelector.selectorText, request)\n        : null;\n\n      this.hint = localParams.get(\"hint\");\n      this.size = localParams.getInt(\"size\", 100000); //Only used for collapsing on int fields.\n\n      {\n        final SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        assert null != info;\n        \n        // may be null in some esoteric corner usages\n        final ResponseBuilder rb = info.getResponseBuilder();\n        final SortSpec topSort = null == rb ? null : rb.getSortSpec();\n        \n        this.needsScores =\n          (info.getRsp().getReturnFields().wantsScore() ||\n           (null != topSort && topSort.includesScore()) ||\n           GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type) ||\n           (GroupHeadSelectorType.SORT.equals(groupHeadSelector.type)\n            && this.sortSpec.includesScore()) ||\n           (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)\n            && CollapseScore.wantsCScore(groupHeadSelector.selectorText)) ||\n           (this.boosted != null));\n\n        if (this.needsScores && null != rb) {\n          // regardless of why we need scores ensure the IndexSearcher will compute them\n          // for the \"real\" docs.  (ie: maybe we need them because we were\n          // asked to compute them for the collapsed docs, maybe we need them because in\n          // order to find the groupHead we need them computed for us.\n          \n          rb.setFieldFlags( rb.getFieldFlags() | SolrIndexSearcher.GET_SCORES);\n        }\n      }\n      \n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid nullPolicy:\"+nPolicy);\n      }\n    }\n\n","sourceOld":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) throws IOException {\n      this.collapseField = localParams.get(\"field\");\n      if (this.collapseField == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Required 'field' param is missing.\");\n      }\n\n      this.groupHeadSelector = GroupHeadSelector.build(localParams);\n      \n      if (groupHeadSelector.type.equals(GroupHeadSelectorType.SORT) &&\n          CollapseScore.wantsCScore(groupHeadSelector.selectorText)) {\n        // we can't support Sorts that wrap functions that include \"cscore()\" because\n        // the abstraction layer for Sort/SortField rewriting gives each clause it's own\n        // context Map which we don't have access to -- so for now, give a useful error\n        // (as early as possible) if attempted\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                                \"Using cscore() as a function in the 'sort' local \"+\n                                \"param of the collapse parser is not supported\");\n      }\n\n        \n      \n      this.sortSpec = GroupHeadSelectorType.SORT.equals(groupHeadSelector.type) \n        ? SortSpecParsing.parseSortSpec(groupHeadSelector.selectorText, request)\n        : null;\n\n      this.hint = localParams.get(\"hint\");\n      this.size = localParams.getInt(\"size\", 100000); //Only used for collapsing on int fields.\n\n      {\n        final SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        assert null != info;\n        \n        // may be null in some esoteric corner usages\n        final ResponseBuilder rb = info.getResponseBuilder();\n        final SortSpec topSort = null == rb ? null : rb.getSortSpec();\n        \n        this.needsScores =\n          (info.getRsp().getReturnFields().wantsScore() ||\n           (null != topSort && topSort.includesScore()) ||\n           GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type) ||\n           (GroupHeadSelectorType.SORT.equals(groupHeadSelector.type)\n            && this.sortSpec.includesScore()) ||\n           (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)\n            && CollapseScore.wantsCScore(groupHeadSelector.selectorText)) ||\n           (this.boosted != null));\n\n        if (this.needsScores && null != rb) {\n          // regardless of why we need scores ensure the IndexSearcher will compute them\n          // for the \"real\" docs.  (ie: maybe we need them because we were\n          // asked to compute them for the collapsed docs, maybe we need them because in\n          // order to find the groupHead we need them computed for us.\n          \n          rb.setFieldFlags( rb.getFieldFlags() | SolrIndexSearcher.GET_SCORES);\n        }\n      }\n      \n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      } else {\n        throw new IOException(\"Invalid nullPolicy:\"+nPolicy);\n      }\n    }\n\n","bugFix":null,"bugIntro":["f91f5834f35d94627a0568326e442dce3d92764c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"446ec69a32a7e8cb8bf6eb8be693e96ab5f5a0d3","date":1556831715,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","sourceNew":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) {\n      this.collapseField = localParams.get(\"field\");\n      if (this.collapseField == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Required 'field' param is missing.\");\n      }\n\n      // if unknown field, this would fail fast\n      SchemaField collapseFieldSf = request.getSchema().getField(this.collapseField);\n      // collapseFieldSf won't be null\n      if (collapseFieldSf.multiValued()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collapsing not supported on multivalued fields\");\n      }\n\n      this.groupHeadSelector = GroupHeadSelector.build(localParams);\n      \n      if (groupHeadSelector.type.equals(GroupHeadSelectorType.SORT) &&\n          CollapseScore.wantsCScore(groupHeadSelector.selectorText)) {\n        // we can't support Sorts that wrap functions that include \"cscore()\" because\n        // the abstraction layer for Sort/SortField rewriting gives each clause it's own\n        // context Map which we don't have access to -- so for now, give a useful error\n        // (as early as possible) if attempted\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                                \"Using cscore() as a function in the 'sort' local \"+\n                                \"param of the collapse parser is not supported\");\n      }\n\n        \n      \n      this.sortSpec = GroupHeadSelectorType.SORT.equals(groupHeadSelector.type) \n        ? SortSpecParsing.parseSortSpec(groupHeadSelector.selectorText, request)\n        : null;\n\n      this.hint = localParams.get(\"hint\");\n      this.size = localParams.getInt(\"size\", 100000); //Only used for collapsing on int fields.\n\n      {\n        final SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        assert null != info;\n        \n        // may be null in some esoteric corner usages\n        final ResponseBuilder rb = info.getResponseBuilder();\n        final SortSpec topSort = null == rb ? null : rb.getSortSpec();\n\n        this.needsScores4Collapsing = GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type) ||\n            (GroupHeadSelectorType.SORT.equals(groupHeadSelector.type)\n                && this.sortSpec.includesScore()) ||\n            (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)\n                && CollapseScore.wantsCScore(groupHeadSelector.selectorText));\n        this.needsScores = needsScores4Collapsing ||\n          (info.getRsp().getReturnFields().wantsScore() ||\n           (null != topSort && topSort.includesScore()) ||\n           (this.boosted != null));\n\n        if (this.needsScores && null != rb) {\n          // regardless of why we need scores ensure the IndexSearcher will compute them\n          // for the \"real\" docs.  (ie: maybe we need them because we were\n          // asked to compute them for the collapsed docs, maybe we need them because in\n          // order to find the groupHead we need them computed for us.\n          \n          rb.setFieldFlags( rb.getFieldFlags() | SolrIndexSearcher.GET_SCORES);\n        }\n      }\n      \n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid nullPolicy:\"+nPolicy);\n      }\n    }\n\n","sourceOld":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) {\n      this.collapseField = localParams.get(\"field\");\n      if (this.collapseField == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Required 'field' param is missing.\");\n      }\n\n      // if unknown field, this would fail fast\n      SchemaField collapseFieldSf = request.getSchema().getField(this.collapseField);\n      // collapseFieldSf won't be null\n      if (collapseFieldSf.multiValued()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collapsing not supported on multivalued fields\");\n      }\n\n      this.groupHeadSelector = GroupHeadSelector.build(localParams);\n      \n      if (groupHeadSelector.type.equals(GroupHeadSelectorType.SORT) &&\n          CollapseScore.wantsCScore(groupHeadSelector.selectorText)) {\n        // we can't support Sorts that wrap functions that include \"cscore()\" because\n        // the abstraction layer for Sort/SortField rewriting gives each clause it's own\n        // context Map which we don't have access to -- so for now, give a useful error\n        // (as early as possible) if attempted\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                                \"Using cscore() as a function in the 'sort' local \"+\n                                \"param of the collapse parser is not supported\");\n      }\n\n        \n      \n      this.sortSpec = GroupHeadSelectorType.SORT.equals(groupHeadSelector.type) \n        ? SortSpecParsing.parseSortSpec(groupHeadSelector.selectorText, request)\n        : null;\n\n      this.hint = localParams.get(\"hint\");\n      this.size = localParams.getInt(\"size\", 100000); //Only used for collapsing on int fields.\n\n      {\n        final SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        assert null != info;\n        \n        // may be null in some esoteric corner usages\n        final ResponseBuilder rb = info.getResponseBuilder();\n        final SortSpec topSort = null == rb ? null : rb.getSortSpec();\n        \n        this.needsScores =\n          (info.getRsp().getReturnFields().wantsScore() ||\n           (null != topSort && topSort.includesScore()) ||\n           GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type) ||\n           (GroupHeadSelectorType.SORT.equals(groupHeadSelector.type)\n            && this.sortSpec.includesScore()) ||\n           (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)\n            && CollapseScore.wantsCScore(groupHeadSelector.selectorText)) ||\n           (this.boosted != null));\n\n        if (this.needsScores && null != rb) {\n          // regardless of why we need scores ensure the IndexSearcher will compute them\n          // for the \"real\" docs.  (ie: maybe we need them because we were\n          // asked to compute them for the collapsed docs, maybe we need them because in\n          // order to find the groupHead we need them computed for us.\n          \n          rb.setFieldFlags( rb.getFieldFlags() | SolrIndexSearcher.GET_SCORES);\n        }\n      }\n      \n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid nullPolicy:\"+nPolicy);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f91f5834f35d94627a0568326e442dce3d92764c","date":1561436441,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","sourceNew":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) {\n      this.collapseField = localParams.get(\"field\");\n      if (this.collapseField == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Required 'field' param is missing.\");\n      }\n\n      // if unknown field, this would fail fast\n      SchemaField collapseFieldSf = request.getSchema().getField(this.collapseField);\n      if (!(collapseFieldSf.isUninvertible() || collapseFieldSf.hasDocValues())) {\n        // uninvertible=false and docvalues=false\n        // field can't be indexed=false and uninvertible=true\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collapsing field '\" + collapseField +\n            \"' should be either docValues enabled or indexed with uninvertible enabled\");\n      } else if (collapseFieldSf.multiValued()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collapsing not supported on multivalued fields\");\n      }\n\n      this.groupHeadSelector = GroupHeadSelector.build(localParams);\n      \n      if (groupHeadSelector.type.equals(GroupHeadSelectorType.SORT) &&\n          CollapseScore.wantsCScore(groupHeadSelector.selectorText)) {\n        // we can't support Sorts that wrap functions that include \"cscore()\" because\n        // the abstraction layer for Sort/SortField rewriting gives each clause it's own\n        // context Map which we don't have access to -- so for now, give a useful error\n        // (as early as possible) if attempted\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                                \"Using cscore() as a function in the 'sort' local \"+\n                                \"param of the collapse parser is not supported\");\n      }\n\n        \n      \n      this.sortSpec = GroupHeadSelectorType.SORT.equals(groupHeadSelector.type) \n        ? SortSpecParsing.parseSortSpec(groupHeadSelector.selectorText, request)\n        : null;\n\n      this.hint = localParams.get(\"hint\");\n      this.size = localParams.getInt(\"size\", 100000); //Only used for collapsing on int fields.\n\n      {\n        final SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        assert null != info;\n        \n        // may be null in some esoteric corner usages\n        final ResponseBuilder rb = info.getResponseBuilder();\n        final SortSpec topSort = null == rb ? null : rb.getSortSpec();\n\n        this.needsScores4Collapsing = GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type) ||\n            (GroupHeadSelectorType.SORT.equals(groupHeadSelector.type)\n                && this.sortSpec.includesScore()) ||\n            (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)\n                && CollapseScore.wantsCScore(groupHeadSelector.selectorText));\n        this.needsScores = needsScores4Collapsing ||\n          (info.getRsp().getReturnFields().wantsScore() ||\n           (null != topSort && topSort.includesScore()) ||\n           (this.boosted != null));\n\n        if (this.needsScores && null != rb) {\n          // regardless of why we need scores ensure the IndexSearcher will compute them\n          // for the \"real\" docs.  (ie: maybe we need them because we were\n          // asked to compute them for the collapsed docs, maybe we need them because in\n          // order to find the groupHead we need them computed for us.\n          \n          rb.setFieldFlags( rb.getFieldFlags() | SolrIndexSearcher.GET_SCORES);\n        }\n      }\n      \n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid nullPolicy:\"+nPolicy);\n      }\n    }\n\n","sourceOld":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) {\n      this.collapseField = localParams.get(\"field\");\n      if (this.collapseField == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Required 'field' param is missing.\");\n      }\n\n      // if unknown field, this would fail fast\n      SchemaField collapseFieldSf = request.getSchema().getField(this.collapseField);\n      // collapseFieldSf won't be null\n      if (collapseFieldSf.multiValued()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collapsing not supported on multivalued fields\");\n      }\n\n      this.groupHeadSelector = GroupHeadSelector.build(localParams);\n      \n      if (groupHeadSelector.type.equals(GroupHeadSelectorType.SORT) &&\n          CollapseScore.wantsCScore(groupHeadSelector.selectorText)) {\n        // we can't support Sorts that wrap functions that include \"cscore()\" because\n        // the abstraction layer for Sort/SortField rewriting gives each clause it's own\n        // context Map which we don't have access to -- so for now, give a useful error\n        // (as early as possible) if attempted\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                                \"Using cscore() as a function in the 'sort' local \"+\n                                \"param of the collapse parser is not supported\");\n      }\n\n        \n      \n      this.sortSpec = GroupHeadSelectorType.SORT.equals(groupHeadSelector.type) \n        ? SortSpecParsing.parseSortSpec(groupHeadSelector.selectorText, request)\n        : null;\n\n      this.hint = localParams.get(\"hint\");\n      this.size = localParams.getInt(\"size\", 100000); //Only used for collapsing on int fields.\n\n      {\n        final SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        assert null != info;\n        \n        // may be null in some esoteric corner usages\n        final ResponseBuilder rb = info.getResponseBuilder();\n        final SortSpec topSort = null == rb ? null : rb.getSortSpec();\n\n        this.needsScores4Collapsing = GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type) ||\n            (GroupHeadSelectorType.SORT.equals(groupHeadSelector.type)\n                && this.sortSpec.includesScore()) ||\n            (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)\n                && CollapseScore.wantsCScore(groupHeadSelector.selectorText));\n        this.needsScores = needsScores4Collapsing ||\n          (info.getRsp().getReturnFields().wantsScore() ||\n           (null != topSort && topSort.includesScore()) ||\n           (this.boosted != null));\n\n        if (this.needsScores && null != rb) {\n          // regardless of why we need scores ensure the IndexSearcher will compute them\n          // for the \"real\" docs.  (ie: maybe we need them because we were\n          // asked to compute them for the collapsed docs, maybe we need them because in\n          // order to find the groupHead we need them computed for us.\n          \n          rb.setFieldFlags( rb.getFieldFlags() | SolrIndexSearcher.GET_SCORES);\n        }\n      }\n      \n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid nullPolicy:\"+nPolicy);\n      }\n    }\n\n","bugFix":["89261f2e2f1daac6de850bf45b31f5b8d3573f29"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6457ab2a0e58432fae0f4816844575d9fdf4fc00","date":1576126280,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","sourceNew":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) {\n      // Don't allow collapsing if grouping is being used.\n      if (request.getParams().getBool(GroupParams.GROUP, false)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Can not use collapse with Grouping enabled\");\n      }\n\n      this.collapseField = localParams.get(\"field\");\n      if (this.collapseField == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Required 'field' param is missing.\");\n      }\n\n      // if unknown field, this would fail fast\n      SchemaField collapseFieldSf = request.getSchema().getField(this.collapseField);\n      if (!(collapseFieldSf.isUninvertible() || collapseFieldSf.hasDocValues())) {\n        // uninvertible=false and docvalues=false\n        // field can't be indexed=false and uninvertible=true\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collapsing field '\" + collapseField +\n            \"' should be either docValues enabled or indexed with uninvertible enabled\");\n      } else if (collapseFieldSf.multiValued()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collapsing not supported on multivalued fields\");\n      }\n\n      this.groupHeadSelector = GroupHeadSelector.build(localParams);\n      \n      if (groupHeadSelector.type.equals(GroupHeadSelectorType.SORT) &&\n          CollapseScore.wantsCScore(groupHeadSelector.selectorText)) {\n        // we can't support Sorts that wrap functions that include \"cscore()\" because\n        // the abstraction layer for Sort/SortField rewriting gives each clause it's own\n        // context Map which we don't have access to -- so for now, give a useful error\n        // (as early as possible) if attempted\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                                \"Using cscore() as a function in the 'sort' local \"+\n                                \"param of the collapse parser is not supported\");\n      }\n\n        \n      \n      this.sortSpec = GroupHeadSelectorType.SORT.equals(groupHeadSelector.type) \n        ? SortSpecParsing.parseSortSpec(groupHeadSelector.selectorText, request)\n        : null;\n\n      this.hint = localParams.get(\"hint\");\n      this.size = localParams.getInt(\"size\", 100000); //Only used for collapsing on int fields.\n\n      {\n        final SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        assert null != info;\n        \n        // may be null in some esoteric corner usages\n        final ResponseBuilder rb = info.getResponseBuilder();\n        final SortSpec topSort = null == rb ? null : rb.getSortSpec();\n\n        this.needsScores4Collapsing = GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type) ||\n            (GroupHeadSelectorType.SORT.equals(groupHeadSelector.type)\n                && this.sortSpec.includesScore()) ||\n            (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)\n                && CollapseScore.wantsCScore(groupHeadSelector.selectorText));\n        this.needsScores = needsScores4Collapsing ||\n          (info.getRsp().getReturnFields().wantsScore() ||\n           (null != topSort && topSort.includesScore()) ||\n           (this.boosted != null));\n\n        if (this.needsScores && null != rb) {\n          // regardless of why we need scores ensure the IndexSearcher will compute them\n          // for the \"real\" docs.  (ie: maybe we need them because we were\n          // asked to compute them for the collapsed docs, maybe we need them because in\n          // order to find the groupHead we need them computed for us.\n          \n          rb.setFieldFlags( rb.getFieldFlags() | SolrIndexSearcher.GET_SCORES);\n        }\n      }\n      \n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid nullPolicy:\"+nPolicy);\n      }\n    }\n\n","sourceOld":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) {\n      this.collapseField = localParams.get(\"field\");\n      if (this.collapseField == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Required 'field' param is missing.\");\n      }\n\n      // if unknown field, this would fail fast\n      SchemaField collapseFieldSf = request.getSchema().getField(this.collapseField);\n      if (!(collapseFieldSf.isUninvertible() || collapseFieldSf.hasDocValues())) {\n        // uninvertible=false and docvalues=false\n        // field can't be indexed=false and uninvertible=true\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collapsing field '\" + collapseField +\n            \"' should be either docValues enabled or indexed with uninvertible enabled\");\n      } else if (collapseFieldSf.multiValued()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collapsing not supported on multivalued fields\");\n      }\n\n      this.groupHeadSelector = GroupHeadSelector.build(localParams);\n      \n      if (groupHeadSelector.type.equals(GroupHeadSelectorType.SORT) &&\n          CollapseScore.wantsCScore(groupHeadSelector.selectorText)) {\n        // we can't support Sorts that wrap functions that include \"cscore()\" because\n        // the abstraction layer for Sort/SortField rewriting gives each clause it's own\n        // context Map which we don't have access to -- so for now, give a useful error\n        // (as early as possible) if attempted\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                                \"Using cscore() as a function in the 'sort' local \"+\n                                \"param of the collapse parser is not supported\");\n      }\n\n        \n      \n      this.sortSpec = GroupHeadSelectorType.SORT.equals(groupHeadSelector.type) \n        ? SortSpecParsing.parseSortSpec(groupHeadSelector.selectorText, request)\n        : null;\n\n      this.hint = localParams.get(\"hint\");\n      this.size = localParams.getInt(\"size\", 100000); //Only used for collapsing on int fields.\n\n      {\n        final SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        assert null != info;\n        \n        // may be null in some esoteric corner usages\n        final ResponseBuilder rb = info.getResponseBuilder();\n        final SortSpec topSort = null == rb ? null : rb.getSortSpec();\n\n        this.needsScores4Collapsing = GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type) ||\n            (GroupHeadSelectorType.SORT.equals(groupHeadSelector.type)\n                && this.sortSpec.includesScore()) ||\n            (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)\n                && CollapseScore.wantsCScore(groupHeadSelector.selectorText));\n        this.needsScores = needsScores4Collapsing ||\n          (info.getRsp().getReturnFields().wantsScore() ||\n           (null != topSort && topSort.includesScore()) ||\n           (this.boosted != null));\n\n        if (this.needsScores && null != rb) {\n          // regardless of why we need scores ensure the IndexSearcher will compute them\n          // for the \"real\" docs.  (ie: maybe we need them because we were\n          // asked to compute them for the collapsed docs, maybe we need them because in\n          // order to find the groupHead we need them computed for us.\n          \n          rb.setFieldFlags( rb.getFieldFlags() | SolrIndexSearcher.GET_SCORES);\n        }\n      }\n      \n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid nullPolicy:\"+nPolicy);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df724d84dab24a0cc54bec95a8680867adc7f171","date":1576156608,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","sourceNew":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) {\n      // Don't allow collapsing if grouping is being used.\n      if (request.getParams().getBool(GroupParams.GROUP, false)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Can not use collapse with Grouping enabled\");\n      }\n\n      this.collapseField = localParams.get(\"field\");\n      if (this.collapseField == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Required 'field' param is missing.\");\n      }\n\n      // if unknown field, this would fail fast\n      SchemaField collapseFieldSf = request.getSchema().getField(this.collapseField);\n      if (!(collapseFieldSf.isUninvertible() || collapseFieldSf.hasDocValues())) {\n        // uninvertible=false and docvalues=false\n        // field can't be indexed=false and uninvertible=true\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collapsing field '\" + collapseField +\n            \"' should be either docValues enabled or indexed with uninvertible enabled\");\n      } else if (collapseFieldSf.multiValued()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collapsing not supported on multivalued fields\");\n      }\n\n      this.groupHeadSelector = GroupHeadSelector.build(localParams);\n      \n      if (groupHeadSelector.type.equals(GroupHeadSelectorType.SORT) &&\n          CollapseScore.wantsCScore(groupHeadSelector.selectorText)) {\n        // we can't support Sorts that wrap functions that include \"cscore()\" because\n        // the abstraction layer for Sort/SortField rewriting gives each clause it's own\n        // context Map which we don't have access to -- so for now, give a useful error\n        // (as early as possible) if attempted\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                                \"Using cscore() as a function in the 'sort' local \"+\n                                \"param of the collapse parser is not supported\");\n      }\n\n        \n      \n      this.sortSpec = GroupHeadSelectorType.SORT.equals(groupHeadSelector.type) \n        ? SortSpecParsing.parseSortSpec(groupHeadSelector.selectorText, request)\n        : null;\n\n      this.hint = localParams.get(\"hint\");\n      this.size = localParams.getInt(\"size\", 100000); //Only used for collapsing on int fields.\n\n      {\n        final SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        assert null != info;\n        \n        // may be null in some esoteric corner usages\n        final ResponseBuilder rb = info.getResponseBuilder();\n        final SortSpec topSort = null == rb ? null : rb.getSortSpec();\n\n        this.needsScores4Collapsing = GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type) ||\n            (GroupHeadSelectorType.SORT.equals(groupHeadSelector.type)\n                && this.sortSpec.includesScore()) ||\n            (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)\n                && CollapseScore.wantsCScore(groupHeadSelector.selectorText));\n        this.needsScores = needsScores4Collapsing ||\n          (info.getRsp().getReturnFields().wantsScore() ||\n           (null != topSort && topSort.includesScore()) ||\n           (this.boosted != null));\n\n        if (this.needsScores && null != rb) {\n          // regardless of why we need scores ensure the IndexSearcher will compute them\n          // for the \"real\" docs.  (ie: maybe we need them because we were\n          // asked to compute them for the collapsed docs, maybe we need them because in\n          // order to find the groupHead we need them computed for us.\n          \n          rb.setFieldFlags( rb.getFieldFlags() | SolrIndexSearcher.GET_SCORES);\n        }\n      }\n      \n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid nullPolicy:\"+nPolicy);\n      }\n    }\n\n","sourceOld":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) {\n      this.collapseField = localParams.get(\"field\");\n      if (this.collapseField == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Required 'field' param is missing.\");\n      }\n\n      // if unknown field, this would fail fast\n      SchemaField collapseFieldSf = request.getSchema().getField(this.collapseField);\n      if (!(collapseFieldSf.isUninvertible() || collapseFieldSf.hasDocValues())) {\n        // uninvertible=false and docvalues=false\n        // field can't be indexed=false and uninvertible=true\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collapsing field '\" + collapseField +\n            \"' should be either docValues enabled or indexed with uninvertible enabled\");\n      } else if (collapseFieldSf.multiValued()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collapsing not supported on multivalued fields\");\n      }\n\n      this.groupHeadSelector = GroupHeadSelector.build(localParams);\n      \n      if (groupHeadSelector.type.equals(GroupHeadSelectorType.SORT) &&\n          CollapseScore.wantsCScore(groupHeadSelector.selectorText)) {\n        // we can't support Sorts that wrap functions that include \"cscore()\" because\n        // the abstraction layer for Sort/SortField rewriting gives each clause it's own\n        // context Map which we don't have access to -- so for now, give a useful error\n        // (as early as possible) if attempted\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                                \"Using cscore() as a function in the 'sort' local \"+\n                                \"param of the collapse parser is not supported\");\n      }\n\n        \n      \n      this.sortSpec = GroupHeadSelectorType.SORT.equals(groupHeadSelector.type) \n        ? SortSpecParsing.parseSortSpec(groupHeadSelector.selectorText, request)\n        : null;\n\n      this.hint = localParams.get(\"hint\");\n      this.size = localParams.getInt(\"size\", 100000); //Only used for collapsing on int fields.\n\n      {\n        final SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        assert null != info;\n        \n        // may be null in some esoteric corner usages\n        final ResponseBuilder rb = info.getResponseBuilder();\n        final SortSpec topSort = null == rb ? null : rb.getSortSpec();\n\n        this.needsScores4Collapsing = GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type) ||\n            (GroupHeadSelectorType.SORT.equals(groupHeadSelector.type)\n                && this.sortSpec.includesScore()) ||\n            (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)\n                && CollapseScore.wantsCScore(groupHeadSelector.selectorText));\n        this.needsScores = needsScores4Collapsing ||\n          (info.getRsp().getReturnFields().wantsScore() ||\n           (null != topSort && topSort.includesScore()) ||\n           (this.boosted != null));\n\n        if (this.needsScores && null != rb) {\n          // regardless of why we need scores ensure the IndexSearcher will compute them\n          // for the \"real\" docs.  (ie: maybe we need them because we were\n          // asked to compute them for the collapsed docs, maybe we need them because in\n          // order to find the groupHead we need them computed for us.\n          \n          rb.setFieldFlags( rb.getFieldFlags() | SolrIndexSearcher.GET_SCORES);\n        }\n      }\n      \n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid nullPolicy:\"+nPolicy);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3575e61fd7df2bbcce8b977a23d3d67aa423ce62","date":1586507050,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","sourceNew":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) {\n      // Don't allow collapsing if grouping is being used.\n      if (request.getParams().getBool(GroupParams.GROUP, false)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Can not use collapse with Grouping enabled\");\n      }\n\n      this.collapseField = localParams.get(\"field\");\n      if (this.collapseField == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Required 'field' param is missing.\");\n      }\n\n      // if unknown field, this would fail fast\n      SchemaField collapseFieldSf = request.getSchema().getField(this.collapseField);\n      if (!(collapseFieldSf.isUninvertible() || collapseFieldSf.hasDocValues())) {\n        // uninvertible=false and docvalues=false\n        // field can't be indexed=false and uninvertible=true\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collapsing field '\" + collapseField +\n            \"' should be either docValues enabled or indexed with uninvertible enabled\");\n      } else if (collapseFieldSf.multiValued()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collapsing not supported on multivalued fields\");\n      }\n\n      this.groupHeadSelector = GroupHeadSelector.build(localParams);\n\n      if (groupHeadSelector.type.equals(GroupHeadSelectorType.SORT) &&\n          CollapseScore.wantsCScore(groupHeadSelector.selectorText)) {\n        // we can't support Sorts that wrap functions that include \"cscore()\" because\n        // the abstraction layer for Sort/SortField rewriting gives each clause it's own\n        // context Map which we don't have access to -- so for now, give a useful error\n        // (as early as possible) if attempted\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                                \"Using cscore() as a function in the 'sort' local \"+\n                                \"param of the collapse parser is not supported\");\n      }\n\n\n\n      this.sortSpec = GroupHeadSelectorType.SORT.equals(groupHeadSelector.type)\n        ? SortSpecParsing.parseSortSpec(groupHeadSelector.selectorText, request)\n        : null;\n\n      this.hint = localParams.get(\"hint\");\n      this.size = localParams.getInt(\"size\", 100000); //Only used for collapsing on int fields.\n\n      {\n        final SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        assert null != info;\n\n        // may be null in some esoteric corner usages\n        final ResponseBuilder rb = info.getResponseBuilder();\n        final SortSpec topSort = null == rb ? null : rb.getSortSpec();\n\n        this.needsScores4Collapsing = GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type) ||\n            (GroupHeadSelectorType.SORT.equals(groupHeadSelector.type)\n                && this.sortSpec.includesScore()) ||\n            (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)\n                && CollapseScore.wantsCScore(groupHeadSelector.selectorText));\n        this.needsScores = needsScores4Collapsing ||\n          (info.getRsp().getReturnFields().wantsScore() ||\n           (null != topSort && topSort.includesScore()) ||\n           (this.boosted != null));\n\n        if (this.needsScores && null != rb) {\n          // regardless of why we need scores ensure the IndexSearcher will compute them\n          // for the \"real\" docs.  (ie: maybe we need them because we were\n          // asked to compute them for the collapsed docs, maybe we need them because in\n          // order to find the groupHead we need them computed for us.\n\n          rb.setFieldFlags( rb.getFieldFlags() | SolrIndexSearcher.GET_SCORES);\n        }\n      }\n\n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid nullPolicy:\"+nPolicy);\n      }\n    }\n\n","sourceOld":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) {\n      // Don't allow collapsing if grouping is being used.\n      if (request.getParams().getBool(GroupParams.GROUP, false)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Can not use collapse with Grouping enabled\");\n      }\n\n      this.collapseField = localParams.get(\"field\");\n      if (this.collapseField == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Required 'field' param is missing.\");\n      }\n\n      // if unknown field, this would fail fast\n      SchemaField collapseFieldSf = request.getSchema().getField(this.collapseField);\n      if (!(collapseFieldSf.isUninvertible() || collapseFieldSf.hasDocValues())) {\n        // uninvertible=false and docvalues=false\n        // field can't be indexed=false and uninvertible=true\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collapsing field '\" + collapseField +\n            \"' should be either docValues enabled or indexed with uninvertible enabled\");\n      } else if (collapseFieldSf.multiValued()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collapsing not supported on multivalued fields\");\n      }\n\n      this.groupHeadSelector = GroupHeadSelector.build(localParams);\n      \n      if (groupHeadSelector.type.equals(GroupHeadSelectorType.SORT) &&\n          CollapseScore.wantsCScore(groupHeadSelector.selectorText)) {\n        // we can't support Sorts that wrap functions that include \"cscore()\" because\n        // the abstraction layer for Sort/SortField rewriting gives each clause it's own\n        // context Map which we don't have access to -- so for now, give a useful error\n        // (as early as possible) if attempted\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                                \"Using cscore() as a function in the 'sort' local \"+\n                                \"param of the collapse parser is not supported\");\n      }\n\n        \n      \n      this.sortSpec = GroupHeadSelectorType.SORT.equals(groupHeadSelector.type) \n        ? SortSpecParsing.parseSortSpec(groupHeadSelector.selectorText, request)\n        : null;\n\n      this.hint = localParams.get(\"hint\");\n      this.size = localParams.getInt(\"size\", 100000); //Only used for collapsing on int fields.\n\n      {\n        final SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        assert null != info;\n        \n        // may be null in some esoteric corner usages\n        final ResponseBuilder rb = info.getResponseBuilder();\n        final SortSpec topSort = null == rb ? null : rb.getSortSpec();\n\n        this.needsScores4Collapsing = GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type) ||\n            (GroupHeadSelectorType.SORT.equals(groupHeadSelector.type)\n                && this.sortSpec.includesScore()) ||\n            (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)\n                && CollapseScore.wantsCScore(groupHeadSelector.selectorText));\n        this.needsScores = needsScores4Collapsing ||\n          (info.getRsp().getReturnFields().wantsScore() ||\n           (null != topSort && topSort.includesScore()) ||\n           (this.boosted != null));\n\n        if (this.needsScores && null != rb) {\n          // regardless of why we need scores ensure the IndexSearcher will compute them\n          // for the \"real\" docs.  (ie: maybe we need them because we were\n          // asked to compute them for the collapsed docs, maybe we need them because in\n          // order to find the groupHead we need them computed for us.\n          \n          rb.setFieldFlags( rb.getFieldFlags() | SolrIndexSearcher.GET_SCORES);\n        }\n      }\n      \n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid nullPolicy:\"+nPolicy);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a813b523bf76aa0a68013d636b6eb53cedb142a4","date":1601387389,"type":3,"author":"Guna Sekhar Dora Kovvuru","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#CollapsingPostFilter(SolrParams,SolrParams,SolrQueryRequest).mjava","sourceNew":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) {\n      // Don't allow collapsing if grouping is being used.\n      if (request.getParams().getBool(GroupParams.GROUP, false)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Can not use collapse with Grouping enabled\");\n      }\n\n      this.collapseField = localParams.get(\"field\");\n      if (this.collapseField == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Required 'field' param is missing.\");\n      }\n\n      // if unknown field, this would fail fast\n      SchemaField collapseFieldSf = request.getSchema().getField(this.collapseField);\n      if (!(collapseFieldSf.isUninvertible() || collapseFieldSf.hasDocValues())) {\n        // uninvertible=false and docvalues=false\n        // field can't be indexed=false and uninvertible=true\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collapsing field '\" + collapseField +\n            \"' should be either docValues enabled or indexed with uninvertible enabled\");\n      } else if (collapseFieldSf.multiValued()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collapsing not supported on multivalued fields\");\n      }\n\n      this.groupHeadSelector = GroupHeadSelector.build(localParams);\n\n      if (groupHeadSelector.type.equals(GroupHeadSelectorType.SORT) &&\n          CollapseScore.wantsCScore(groupHeadSelector.selectorText)) {\n        // we can't support Sorts that wrap functions that include \"cscore()\" because\n        // the abstraction layer for Sort/SortField rewriting gives each clause it's own\n        // context Map which we don't have access to -- so for now, give a useful error\n        // (as early as possible) if attempted\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                                \"Using cscore() as a function in the 'sort' local \"+\n                                \"param of the collapse parser is not supported\");\n      }\n\n\n\n      this.sortSpec = GroupHeadSelectorType.SORT.equals(groupHeadSelector.type)\n        ? SortSpecParsing.parseSortSpec(groupHeadSelector.selectorText, request)\n        : null;\n\n      this.hint = localParams.get(\"hint\");\n      this.size = localParams.getInt(\"size\", 100000); //Only used for collapsing on int fields.\n\n      {\n        final SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        assert null != info;\n\n        // may be null in some esoteric corner usages\n        final ResponseBuilder rb = info.getResponseBuilder();\n        final SortSpec topSort = null == rb ? null : rb.getSortSpec();\n\n        this.needsScores4Collapsing = GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type) ||\n            (GroupHeadSelectorType.SORT.equals(groupHeadSelector.type)\n                && this.sortSpec.includesScore()) ||\n            (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)\n                && CollapseScore.wantsCScore(groupHeadSelector.selectorText));\n        this.needsScores = needsScores4Collapsing ||\n          (info.getRsp().getReturnFields().wantsScore() ||\n           (null != topSort && topSort.includesScore()) ||\n           (this.boosted != null));\n\n        if (this.needsScores && null != rb) {\n          // regardless of why we need scores ensure the IndexSearcher will compute them\n          // for the \"real\" docs.  (ie: maybe we need them because we were\n          // asked to compute them for the collapsed docs, maybe we need them because in\n          // order to find the groupHead we need them computed for us.\n\n          rb.setFieldFlags( rb.getFieldFlags() | SolrIndexSearcher.GET_SCORES);\n        }\n      }\n\n      this.nullPolicy = NullPolicy.fromString(localParams.get(\"nullPolicy\"));\n    }\n\n","sourceOld":"    public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) {\n      // Don't allow collapsing if grouping is being used.\n      if (request.getParams().getBool(GroupParams.GROUP, false)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Can not use collapse with Grouping enabled\");\n      }\n\n      this.collapseField = localParams.get(\"field\");\n      if (this.collapseField == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Required 'field' param is missing.\");\n      }\n\n      // if unknown field, this would fail fast\n      SchemaField collapseFieldSf = request.getSchema().getField(this.collapseField);\n      if (!(collapseFieldSf.isUninvertible() || collapseFieldSf.hasDocValues())) {\n        // uninvertible=false and docvalues=false\n        // field can't be indexed=false and uninvertible=true\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collapsing field '\" + collapseField +\n            \"' should be either docValues enabled or indexed with uninvertible enabled\");\n      } else if (collapseFieldSf.multiValued()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collapsing not supported on multivalued fields\");\n      }\n\n      this.groupHeadSelector = GroupHeadSelector.build(localParams);\n\n      if (groupHeadSelector.type.equals(GroupHeadSelectorType.SORT) &&\n          CollapseScore.wantsCScore(groupHeadSelector.selectorText)) {\n        // we can't support Sorts that wrap functions that include \"cscore()\" because\n        // the abstraction layer for Sort/SortField rewriting gives each clause it's own\n        // context Map which we don't have access to -- so for now, give a useful error\n        // (as early as possible) if attempted\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                                \"Using cscore() as a function in the 'sort' local \"+\n                                \"param of the collapse parser is not supported\");\n      }\n\n\n\n      this.sortSpec = GroupHeadSelectorType.SORT.equals(groupHeadSelector.type)\n        ? SortSpecParsing.parseSortSpec(groupHeadSelector.selectorText, request)\n        : null;\n\n      this.hint = localParams.get(\"hint\");\n      this.size = localParams.getInt(\"size\", 100000); //Only used for collapsing on int fields.\n\n      {\n        final SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        assert null != info;\n\n        // may be null in some esoteric corner usages\n        final ResponseBuilder rb = info.getResponseBuilder();\n        final SortSpec topSort = null == rb ? null : rb.getSortSpec();\n\n        this.needsScores4Collapsing = GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type) ||\n            (GroupHeadSelectorType.SORT.equals(groupHeadSelector.type)\n                && this.sortSpec.includesScore()) ||\n            (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)\n                && CollapseScore.wantsCScore(groupHeadSelector.selectorText));\n        this.needsScores = needsScores4Collapsing ||\n          (info.getRsp().getReturnFields().wantsScore() ||\n           (null != topSort && topSort.includesScore()) ||\n           (this.boosted != null));\n\n        if (this.needsScores && null != rb) {\n          // regardless of why we need scores ensure the IndexSearcher will compute them\n          // for the \"real\" docs.  (ie: maybe we need them because we were\n          // asked to compute them for the collapsed docs, maybe we need them because in\n          // order to find the groupHead we need them computed for us.\n\n          rb.setFieldFlags( rb.getFieldFlags() | SolrIndexSearcher.GET_SCORES);\n        }\n      }\n\n      String nPolicy = localParams.get(\"nullPolicy\", NULL_IGNORE);\n      if(nPolicy.equals(NULL_IGNORE)) {\n        this.nullPolicy = NULL_POLICY_IGNORE;\n      } else if (nPolicy.equals(NULL_COLLAPSE)) {\n        this.nullPolicy = NULL_POLICY_COLLAPSE;\n      } else if(nPolicy.equals((NULL_EXPAND))) {\n        this.nullPolicy = NULL_POLICY_EXPAND;\n      } else {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid nullPolicy:\"+nPolicy);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b3c00dc1009b09cee556b71f8383d9fc259a87ea":["6f9eac2f0b568b3694682edb863185a273fbbc6f"],"89261f2e2f1daac6de850bf45b31f5b8d3573f29":["6c8dc56dbae186505066de8a78986cba31525ef0"],"3575e61fd7df2bbcce8b977a23d3d67aa423ce62":["6457ab2a0e58432fae0f4816844575d9fdf4fc00"],"f91f5834f35d94627a0568326e442dce3d92764c":["446ec69a32a7e8cb8bf6eb8be693e96ab5f5a0d3"],"446ec69a32a7e8cb8bf6eb8be693e96ab5f5a0d3":["89261f2e2f1daac6de850bf45b31f5b8d3573f29"],"a667f95e8b4d25c8e45a6bb9ba8ce9654e7858d7":["d140695fc024caefb4dc32ea6b3f6f4a649727b0"],"d140695fc024caefb4dc32ea6b3f6f4a649727b0":["b3c00dc1009b09cee556b71f8383d9fc259a87ea"],"a813b523bf76aa0a68013d636b6eb53cedb142a4":["3575e61fd7df2bbcce8b977a23d3d67aa423ce62"],"df724d84dab24a0cc54bec95a8680867adc7f171":["f91f5834f35d94627a0568326e442dce3d92764c","6457ab2a0e58432fae0f4816844575d9fdf4fc00"],"6c8dc56dbae186505066de8a78986cba31525ef0":["0325de99180d346d61d36938843a5c8451fe26ae"],"8ced52befdc8d88d90766aadbaac496f3fd0e4ee":["a667f95e8b4d25c8e45a6bb9ba8ce9654e7858d7"],"6457ab2a0e58432fae0f4816844575d9fdf4fc00":["f91f5834f35d94627a0568326e442dce3d92764c"],"f028e66c4e5145ca2811ba1ca70570ec10a1e723":["c1a89fbf5a750bffb59fe3bf0779dd9fb5ee0c4d"],"c1a89fbf5a750bffb59fe3bf0779dd9fb5ee0c4d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["f028e66c4e5145ca2811ba1ca70570ec10a1e723","ceae51e37bbff02dcdeaa12303fec10d3eaaa004"],"6f9eac2f0b568b3694682edb863185a273fbbc6f":["ceae51e37bbff02dcdeaa12303fec10d3eaaa004"],"0325de99180d346d61d36938843a5c8451fe26ae":["8ced52befdc8d88d90766aadbaac496f3fd0e4ee"],"ceae51e37bbff02dcdeaa12303fec10d3eaaa004":["f028e66c4e5145ca2811ba1ca70570ec10a1e723"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a813b523bf76aa0a68013d636b6eb53cedb142a4"]},"commit2Childs":{"b3c00dc1009b09cee556b71f8383d9fc259a87ea":["d140695fc024caefb4dc32ea6b3f6f4a649727b0"],"89261f2e2f1daac6de850bf45b31f5b8d3573f29":["446ec69a32a7e8cb8bf6eb8be693e96ab5f5a0d3"],"3575e61fd7df2bbcce8b977a23d3d67aa423ce62":["a813b523bf76aa0a68013d636b6eb53cedb142a4"],"f91f5834f35d94627a0568326e442dce3d92764c":["df724d84dab24a0cc54bec95a8680867adc7f171","6457ab2a0e58432fae0f4816844575d9fdf4fc00"],"446ec69a32a7e8cb8bf6eb8be693e96ab5f5a0d3":["f91f5834f35d94627a0568326e442dce3d92764c"],"a667f95e8b4d25c8e45a6bb9ba8ce9654e7858d7":["8ced52befdc8d88d90766aadbaac496f3fd0e4ee"],"d140695fc024caefb4dc32ea6b3f6f4a649727b0":["a667f95e8b4d25c8e45a6bb9ba8ce9654e7858d7"],"a813b523bf76aa0a68013d636b6eb53cedb142a4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"df724d84dab24a0cc54bec95a8680867adc7f171":[],"6c8dc56dbae186505066de8a78986cba31525ef0":["89261f2e2f1daac6de850bf45b31f5b8d3573f29"],"8ced52befdc8d88d90766aadbaac496f3fd0e4ee":["0325de99180d346d61d36938843a5c8451fe26ae"],"6457ab2a0e58432fae0f4816844575d9fdf4fc00":["3575e61fd7df2bbcce8b977a23d3d67aa423ce62","df724d84dab24a0cc54bec95a8680867adc7f171"],"f028e66c4e5145ca2811ba1ca70570ec10a1e723":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","ceae51e37bbff02dcdeaa12303fec10d3eaaa004"],"c1a89fbf5a750bffb59fe3bf0779dd9fb5ee0c4d":["f028e66c4e5145ca2811ba1ca70570ec10a1e723"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c1a89fbf5a750bffb59fe3bf0779dd9fb5ee0c4d"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"6f9eac2f0b568b3694682edb863185a273fbbc6f":["b3c00dc1009b09cee556b71f8383d9fc259a87ea"],"0325de99180d346d61d36938843a5c8451fe26ae":["6c8dc56dbae186505066de8a78986cba31525ef0"],"ceae51e37bbff02dcdeaa12303fec10d3eaaa004":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","6f9eac2f0b568b3694682edb863185a273fbbc6f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["df724d84dab24a0cc54bec95a8680867adc7f171","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}