{"path":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","commits":[{"id":"c5a558d54519c651068ddb202f03befefb1514a7","date":1354382006,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","pathOld":"/dev/null","sourceNew":"  // use old code for now\n  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n//     return setupRequest2(DocRouter.DEFAULT.shardHash(id, null, null), id, doc);\n    return setupRequest(DocRouter.DEFAULT.shardHash(id, null, null));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89f828d954597b98a28942874636f35c719b8a5d","date":1354471211,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","sourceNew":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      String coreName = req.getCore().getName();\n      String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetShard(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n\n        String leaderNodeName = leaderProps.getCoreNodeName();\n        isLeader = coreNodeName.equals(leaderNodeName);\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(shardId, phase);\n\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                if (!skipListSet.contains(props.getCoreUrl())) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  // use old code for now\n  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n//     return setupRequest2(DocRouter.DEFAULT.shardHash(id, null, null), id, doc);\n    return setupRequest(DocRouter.DEFAULT.shardHash(id, null, null));\n  }\n\n","bugFix":null,"bugIntro":["6c228eadc8ab12c4b442521f5890283801a6cab5","7b4c4001c33d7e459f31c8810ea8fd129c7b6ea7","91e069c492cf4895697ef7b81df0ffb9a8bd4b48","747dd71fefcbc7142661c25334b74c518fef4d81","28327f97250ba0a97287ec9875c89161fe4e4611"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e7754464847b06ced605515bd48219280ede29e9","date":1354586462,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","sourceNew":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      String coreName = req.getCore().getName();\n      String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n\n        String leaderNodeName = leaderProps.getCoreNodeName();\n        isLeader = coreNodeName.equals(leaderNodeName);\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(shardId, phase);\n\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                if (!skipListSet.contains(props.getCoreUrl())) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      String coreName = req.getCore().getName();\n      String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetShard(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n\n        String leaderNodeName = leaderProps.getCoreNodeName();\n        isLeader = coreNodeName.equals(leaderNodeName);\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(shardId, phase);\n\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                if (!skipListSet.contains(props.getCoreUrl())) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":["747dd71fefcbc7142661c25334b74c518fef4d81"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","pathOld":"/dev/null","sourceNew":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      String coreName = req.getCore().getName();\n      String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n\n        String leaderNodeName = leaderProps.getCoreNodeName();\n        isLeader = coreNodeName.equals(leaderNodeName);\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(shardId, phase);\n\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                if (!skipListSet.contains(props.getCoreUrl())) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"56a558aa5aadd60ae850d1ab090098bc63bdfaf9","date":1355245333,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","sourceNew":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      String coreName = req.getCore().getName();\n      String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId));\n\n        String leaderNodeName = leaderProps.getCoreNodeName();\n        isLeader = coreNodeName.equals(leaderNodeName);\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(shardId, phase);\n\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                if (!skipListSet.contains(props.getCoreUrl())) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      String coreName = req.getCore().getName();\n      String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n\n        String leaderNodeName = leaderProps.getCoreNodeName();\n        isLeader = coreNodeName.equals(leaderNodeName);\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(shardId, phase);\n\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                if (!skipListSet.contains(props.getCoreUrl())) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3d7c0c8a97beb56d2e168604f9928de17981eabe","date":1357257676,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","sourceNew":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n\n      String coreName = req.getCore().getName();\n      String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId));\n\n        String leaderNodeName = leaderProps.getCoreNodeName();\n        isLeader = coreNodeName.equals(leaderNodeName);\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(shardId, phase);\n\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                if (!skipListSet.contains(props.getCoreUrl())) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      String coreName = req.getCore().getName();\n      String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId));\n\n        String leaderNodeName = leaderProps.getCoreNodeName();\n        isLeader = coreNodeName.equals(leaderNodeName);\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(shardId, phase);\n\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                if (!skipListSet.contains(props.getCoreUrl())) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":["747dd71fefcbc7142661c25334b74c518fef4d81"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","sourceNew":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n\n      String coreName = req.getCore().getName();\n      String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId));\n\n        String leaderNodeName = leaderProps.getCoreNodeName();\n        isLeader = coreNodeName.equals(leaderNodeName);\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(shardId, phase);\n\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                if (!skipListSet.contains(props.getCoreUrl())) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      String coreName = req.getCore().getName();\n      String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderProps(\n            collection, shardId));\n\n        String leaderNodeName = leaderProps.getCoreNodeName();\n        isLeader = coreNodeName.equals(leaderNodeName);\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(shardId, phase);\n\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                if (!skipListSet.contains(props.getCoreUrl())) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6c228eadc8ab12c4b442521f5890283801a6cab5","date":1358509063,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","sourceNew":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n\n      String coreName = req.getCore().getName();\n      String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId));\n\n        String leaderNodeName = leaderProps.getCoreNodeName();\n        isLeader = coreNodeName.equals(leaderNodeName);\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                if (!skipListSet.contains(props.getCoreUrl())) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n\n      String coreName = req.getCore().getName();\n      String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId));\n\n        String leaderNodeName = leaderProps.getCoreNodeName();\n        isLeader = coreNodeName.equals(leaderNodeName);\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(shardId, phase);\n\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                if (!skipListSet.contains(props.getCoreUrl())) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":["89f828d954597b98a28942874636f35c719b8a5d"],"bugIntro":["747dd71fefcbc7142661c25334b74c518fef4d81"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c4015cd39dff8d4dec562d909f9766debac53aa6","date":1358548736,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","sourceNew":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n\n      String coreName = req.getCore().getName();\n      String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId));\n\n        String leaderNodeName = leaderProps.getCoreNodeName();\n        isLeader = coreNodeName.equals(leaderNodeName);\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                if (!skipListSet.contains(props.getCoreUrl())) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n\n      String coreName = req.getCore().getName();\n      String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId));\n\n        String leaderNodeName = leaderProps.getCoreNodeName();\n        isLeader = coreNodeName.equals(leaderNodeName);\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(shardId, phase);\n\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                if (!skipListSet.contains(props.getCoreUrl())) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb4a195b8dc1808cd01748bd2e0fba26ca915d4d","date":1361851792,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","sourceNew":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(leaderReplica);\n        String coreNodeName = zkController.getCoreNodeName(req.getCore().getCoreDescriptor());\n        isLeader = coreNodeName.equals(leaderReplica.getName());\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, coreNodeName,\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                if (!skipListSet.contains(props.getCoreUrl())) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n\n      String coreName = req.getCore().getName();\n      String coreNodeName = zkController.getNodeName() + \"_\" + coreName;\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId));\n\n        String leaderNodeName = leaderProps.getCoreNodeName();\n        isLeader = coreNodeName.equals(leaderNodeName);\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, zkController.getNodeName(),\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                if (!skipListSet.contains(props.getCoreUrl())) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":["747dd71fefcbc7142661c25334b74c518fef4d81"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"76530c83bab98ecf28c61c2b68a7151a946298f2","date":1363923567,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","sourceNew":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(leaderReplica);\n        String coreNodeName = zkController.getCoreNodeName(req.getCore().getCoreDescriptor());\n        isLeader = coreNodeName.equals(leaderReplica.getName());\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, coreNodeName,\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(leaderReplica);\n        String coreNodeName = zkController.getCoreNodeName(req.getCore().getCoreDescriptor());\n        isLeader = coreNodeName.equals(leaderReplica.getName());\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, coreNodeName,\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                if (!skipListSet.contains(props.getCoreUrl())) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":["747dd71fefcbc7142661c25334b74c518fef4d81"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"618dcc9a4785445b3a9c5cf1cdcd6604a856d3b3","date":1364230557,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","sourceNew":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(leaderReplica);\n        String coreNodeName = zkController.getCoreNodeName(req.getCore().getCoreDescriptor());\n        isLeader = coreNodeName.equals(leaderReplica.getName());\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, coreNodeName,\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(leaderReplica);\n        String coreNodeName = zkController.getCoreNodeName(req.getCore().getCoreDescriptor());\n        isLeader = coreNodeName.equals(leaderReplica.getName());\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, coreNodeName,\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":["747dd71fefcbc7142661c25334b74c518fef4d81"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"28327f97250ba0a97287ec9875c89161fe4e4611","date":1364277704,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","sourceNew":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(leaderReplica);\n        String coreNodeName = zkController.getCoreNodeName(req.getCore().getCoreDescriptor());\n        isLeader = coreNodeName.equals(leaderReplica.getName());\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, coreNodeName,\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(leaderReplica);\n        String coreNodeName = zkController.getCoreNodeName(req.getCore().getCoreDescriptor());\n        isLeader = coreNodeName.equals(leaderReplica.getName());\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, coreNodeName,\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(\"test.distrib.skip.servers\");\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":["89f828d954597b98a28942874636f35c719b8a5d"],"bugIntro":["747dd71fefcbc7142661c25334b74c518fef4d81"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0beaed456aa3358e5e4a99ea2aea994ef6c81de3","date":1365434191,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","sourceNew":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(leaderReplica);\n        String coreNodeName = zkController.getCoreNodeName(req.getCore().getCoreDescriptor());\n        isLeader = coreNodeName.equals(leaderReplica.getName());\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, coreNodeName,\n                  coreName, null, ZkStateReader.DOWN);\n\n          nodes = addSubShardLeaders(coll, shardId, id, doc, nodes);\n          if (replicaProps != null) {\n            if (nodes == null)  {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            }\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(leaderReplica);\n        String coreNodeName = zkController.getCoreNodeName(req.getCore().getCoreDescriptor());\n        isLeader = coreNodeName.equals(leaderReplica.getName());\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, coreNodeName,\n                  coreName, null, ZkStateReader.DOWN);\n          if (replicaProps != null) {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":["747dd71fefcbc7142661c25334b74c518fef4d81"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8f1ea787bab5bdb5e72685e55424898da05509b6","date":1370289750,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","sourceNew":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(leaderReplica);\n        String coreNodeName = zkController.getCoreNodeName(req.getCore().getCoreDescriptor());\n        isLeader = coreNodeName.equals(leaderReplica.getName());\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, coreNodeName,\n                  coreName, null, ZkStateReader.DOWN);\n\n          if (replicaProps != null) {\n            if (nodes == null)  {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            }\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(leaderReplica);\n        String coreNodeName = zkController.getCoreNodeName(req.getCore().getCoreDescriptor());\n        isLeader = coreNodeName.equals(leaderReplica.getName());\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, coreNodeName,\n                  coreName, null, ZkStateReader.DOWN);\n\n          nodes = addSubShardLeaders(coll, shardId, id, doc, nodes);\n          if (replicaProps != null) {\n            if (nodes == null)  {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            }\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"849494cf2f3a96af5c8c84995108ddd8456fcd04","date":1372277913,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","sourceNew":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        isLeader = leaderReplica.getName().equals(\n            req.getCore().getCoreDescriptor().getCloudDescriptor()\n                .getCoreNodeName());\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, leaderReplica.getName(),\n                  coreName, null, ZkStateReader.DOWN);\n\n          if (replicaProps != null) {\n            if (nodes == null)  {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            }\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(new ZkCoreNodeProps(leaderReplica), zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(leaderReplica);\n        String coreNodeName = zkController.getCoreNodeName(req.getCore().getCoreDescriptor());\n        isLeader = coreNodeName.equals(leaderReplica.getName());\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, coreNodeName,\n                  coreName, null, ZkStateReader.DOWN);\n\n          if (replicaProps != null) {\n            if (nodes == null)  {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            }\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":["747dd71fefcbc7142661c25334b74c518fef4d81"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"96adbab674ae121f8b6b3e10474070b4bd97a219","date":1373614333,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","sourceNew":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        isLeader = leaderReplica.getName().equals(\n            req.getCore().getCoreDescriptor().getCloudDescriptor()\n                .getCoreNodeName());\n\n        if (!isLeader) {\n          isSubShardLeader = amISubShardLeader(coll, slice, id, doc);\n          if (isSubShardLeader) {\n            String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n            slice = coll.getSlice(myShardId);\n            shardId = myShardId;\n            leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, myShardId);\n            List<ZkCoreNodeProps> myReplicas = zkController.getZkStateReader().getReplicaProps(collection, shardId, leaderReplica.getName(), coreName, null, ZkStateReader.DOWN);\n          }\n        }\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n\n        if (DistribPhase.FROMLEADER == phase && !isSubShardLeader) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader || isSubShardLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, leaderReplica.getName(),\n                  coreName, null, ZkStateReader.DOWN);\n\n          if (replicaProps != null) {\n            if (nodes == null)  {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            }\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(new ZkCoreNodeProps(leaderReplica), zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        isLeader = leaderReplica.getName().equals(\n            req.getCore().getCoreDescriptor().getCloudDescriptor()\n                .getCoreNodeName());\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, leaderReplica.getName(),\n                  coreName, null, ZkStateReader.DOWN);\n\n          if (replicaProps != null) {\n            if (nodes == null)  {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            }\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(new ZkCoreNodeProps(leaderReplica), zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":["747dd71fefcbc7142661c25334b74c518fef4d81"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","sourceNew":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        isLeader = leaderReplica.getName().equals(\n            req.getCore().getCoreDescriptor().getCloudDescriptor()\n                .getCoreNodeName());\n\n        if (!isLeader) {\n          isSubShardLeader = amISubShardLeader(coll, slice, id, doc);\n          if (isSubShardLeader) {\n            String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n            slice = coll.getSlice(myShardId);\n            shardId = myShardId;\n            leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, myShardId);\n            List<ZkCoreNodeProps> myReplicas = zkController.getZkStateReader().getReplicaProps(collection, shardId, leaderReplica.getName(), coreName, null, ZkStateReader.DOWN);\n          }\n        }\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n\n        if (DistribPhase.FROMLEADER == phase && !isSubShardLeader) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader || isSubShardLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, leaderReplica.getName(),\n                  coreName, null, ZkStateReader.DOWN);\n\n          if (replicaProps != null) {\n            if (nodes == null)  {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            }\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(new ZkCoreNodeProps(leaderReplica), zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(leaderReplica);\n        String coreNodeName = zkController.getCoreNodeName(req.getCore().getCoreDescriptor());\n        isLeader = coreNodeName.equals(leaderReplica.getName());\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n\n        if (DistribPhase.FROMLEADER == phase) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, coreNodeName,\n                  coreName, null, ZkStateReader.DOWN);\n\n          if (replicaProps != null) {\n            if (nodes == null)  {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            }\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(leaderProps, zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"91e069c492cf4895697ef7b81df0ffb9a8bd4b48","date":1382134253,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","sourceNew":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        isLeader = leaderReplica.getName().equals(\n            req.getCore().getCoreDescriptor().getCloudDescriptor()\n                .getCoreNodeName());\n\n        if (!isLeader) {\n          isSubShardLeader = amISubShardLeader(coll, slice, id, doc);\n          if (isSubShardLeader) {\n            String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n            slice = coll.getSlice(myShardId);\n            shardId = myShardId;\n            leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, myShardId);\n            List<ZkCoreNodeProps> myReplicas = zkController.getZkStateReader().getReplicaProps(collection, shardId, leaderReplica.getName(), coreName, null, ZkStateReader.DOWN);\n          }\n        }\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n\n        if (DistribPhase.FROMLEADER == phase && !isSubShardLeader) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader || isSubShardLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, leaderReplica.getName(),\n                  coreName, null, ZkStateReader.DOWN);\n\n          if (replicaProps != null) {\n            if (nodes == null)  {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            }\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(new ZkCoreNodeProps(leaderReplica), zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      numNodes = cstate.getLiveNodes().size();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        isLeader = leaderReplica.getName().equals(\n            req.getCore().getCoreDescriptor().getCloudDescriptor()\n                .getCoreNodeName());\n\n        if (!isLeader) {\n          isSubShardLeader = amISubShardLeader(coll, slice, id, doc);\n          if (isSubShardLeader) {\n            String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n            slice = coll.getSlice(myShardId);\n            shardId = myShardId;\n            leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, myShardId);\n            List<ZkCoreNodeProps> myReplicas = zkController.getZkStateReader().getReplicaProps(collection, shardId, leaderReplica.getName(), coreName, null, ZkStateReader.DOWN);\n          }\n        }\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n\n        if (DistribPhase.FROMLEADER == phase && !isSubShardLeader) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader || isSubShardLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, leaderReplica.getName(),\n                  coreName, null, ZkStateReader.DOWN);\n\n          if (replicaProps != null) {\n            if (nodes == null)  {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            }\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(new ZkCoreNodeProps(leaderReplica), zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":["89f828d954597b98a28942874636f35c719b8a5d"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"da888af1ab894358122a22229051215f58cf4d54","date":1384408702,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","sourceNew":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        isLeader = leaderReplica.getName().equals(\n            req.getCore().getCoreDescriptor().getCloudDescriptor()\n                .getCoreNodeName());\n\n        if (!isLeader) {\n          isSubShardLeader = amISubShardLeader(coll, slice, id, doc);\n          if (isSubShardLeader) {\n            String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n            slice = coll.getSlice(myShardId);\n            shardId = myShardId;\n            leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, myShardId);\n            List<ZkCoreNodeProps> myReplicas = zkController.getZkStateReader().getReplicaProps(collection, shardId, leaderReplica.getName(), coreName, null, ZkStateReader.DOWN);\n          }\n        }\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n        // if request is coming from another collection then we want it to be sent to all replicas\n        // even if it's phase is FROMLEADER\n        String fromCollection = updateCommand.getReq().getParams().get(\"distrib.from.collection\");\n\n        if (DistribPhase.FROMLEADER == phase && !isSubShardLeader && fromCollection == null) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader || isSubShardLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, leaderReplica.getName(),\n                  coreName, null, ZkStateReader.DOWN);\n\n          if (replicaProps != null) {\n            if (nodes == null)  {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            }\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(new ZkCoreNodeProps(leaderReplica), zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        isLeader = leaderReplica.getName().equals(\n            req.getCore().getCoreDescriptor().getCloudDescriptor()\n                .getCoreNodeName());\n\n        if (!isLeader) {\n          isSubShardLeader = amISubShardLeader(coll, slice, id, doc);\n          if (isSubShardLeader) {\n            String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n            slice = coll.getSlice(myShardId);\n            shardId = myShardId;\n            leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, myShardId);\n            List<ZkCoreNodeProps> myReplicas = zkController.getZkStateReader().getReplicaProps(collection, shardId, leaderReplica.getName(), coreName, null, ZkStateReader.DOWN);\n          }\n        }\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n\n        if (DistribPhase.FROMLEADER == phase && !isSubShardLeader) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader || isSubShardLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, leaderReplica.getName(),\n                  coreName, null, ZkStateReader.DOWN);\n\n          if (replicaProps != null) {\n            if (nodes == null)  {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            }\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(new ZkCoreNodeProps(leaderReplica), zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":["747dd71fefcbc7142661c25334b74c518fef4d81"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3333dd7044501b4f20231ea55ab64e688285d153","date":1384785078,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","sourceNew":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        isLeader = leaderReplica.getName().equals(\n            req.getCore().getCoreDescriptor().getCloudDescriptor()\n                .getCoreNodeName());\n\n        if (!isLeader) {\n          isSubShardLeader = amISubShardLeader(coll, slice, id, doc);\n          if (isSubShardLeader) {\n            String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n            slice = coll.getSlice(myShardId);\n            shardId = myShardId;\n            leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, myShardId);\n            List<ZkCoreNodeProps> myReplicas = zkController.getZkStateReader().getReplicaProps(collection, shardId, leaderReplica.getName(), coreName, null, ZkStateReader.DOWN);\n          }\n        }\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n        // if request is coming from another collection then we want it to be sent to all replicas\n        // even if it's phase is FROMLEADER\n        String fromCollection = updateCommand.getReq().getParams().get(DISTRIB_FROM_COLLECTION);\n\n        if (DistribPhase.FROMLEADER == phase && !isSubShardLeader && fromCollection == null) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader || isSubShardLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, leaderReplica.getName(),\n                  coreName, null, ZkStateReader.DOWN);\n\n          if (replicaProps != null) {\n            if (nodes == null)  {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            }\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(new ZkCoreNodeProps(leaderReplica), zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        isLeader = leaderReplica.getName().equals(\n            req.getCore().getCoreDescriptor().getCloudDescriptor()\n                .getCoreNodeName());\n\n        if (!isLeader) {\n          isSubShardLeader = amISubShardLeader(coll, slice, id, doc);\n          if (isSubShardLeader) {\n            String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n            slice = coll.getSlice(myShardId);\n            shardId = myShardId;\n            leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, myShardId);\n            List<ZkCoreNodeProps> myReplicas = zkController.getZkStateReader().getReplicaProps(collection, shardId, leaderReplica.getName(), coreName, null, ZkStateReader.DOWN);\n          }\n        }\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n        // if request is coming from another collection then we want it to be sent to all replicas\n        // even if it's phase is FROMLEADER\n        String fromCollection = updateCommand.getReq().getParams().get(\"distrib.from.collection\");\n\n        if (DistribPhase.FROMLEADER == phase && !isSubShardLeader && fromCollection == null) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader || isSubShardLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, leaderReplica.getName(),\n                  coreName, null, ZkStateReader.DOWN);\n\n          if (replicaProps != null) {\n            if (nodes == null)  {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            }\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(new ZkCoreNodeProps(leaderReplica), zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":["747dd71fefcbc7142661c25334b74c518fef4d81"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c1dd6595120fba7e99fcec70759c6cdea9a071b3","date":1385615716,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","sourceNew":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        isLeader = leaderReplica.getName().equals(\n            req.getCore().getCoreDescriptor().getCloudDescriptor()\n                .getCoreNodeName());\n\n        if (!isLeader) {\n          isSubShardLeader = amISubShardLeader(coll, slice, id, doc);\n          if (isSubShardLeader) {\n            String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n            slice = coll.getSlice(myShardId);\n            shardId = myShardId;\n            leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, myShardId);\n            List<ZkCoreNodeProps> myReplicas = zkController.getZkStateReader().getReplicaProps(collection, shardId, leaderReplica.getName(), coreName, null, ZkStateReader.DOWN);\n          }\n        }\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n        // if request is coming from another collection then we want it to be sent to all replicas\n        // even if it's phase is FROMLEADER\n        String fromCollection = updateCommand.getReq().getParams().get(DISTRIB_FROM_COLLECTION);\n\n        if (DistribPhase.FROMLEADER == phase && !isSubShardLeader && fromCollection == null) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader || isSubShardLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, leaderReplica.getName(),\n                  coreName, null, ZkStateReader.DOWN);\n\n          if (replicaProps != null) {\n            if (nodes == null)  {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            }\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(new ZkCoreNodeProps(leaderReplica), zkController.getZkStateReader(), collection, shardId, ZkCoreNodeProps.getCoreUrl(\n              zkController.getBaseUrl(), req.getCore().getName())));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        isLeader = leaderReplica.getName().equals(\n            req.getCore().getCoreDescriptor().getCloudDescriptor()\n                .getCoreNodeName());\n\n        if (!isLeader) {\n          isSubShardLeader = amISubShardLeader(coll, slice, id, doc);\n          if (isSubShardLeader) {\n            String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n            slice = coll.getSlice(myShardId);\n            shardId = myShardId;\n            leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, myShardId);\n            List<ZkCoreNodeProps> myReplicas = zkController.getZkStateReader().getReplicaProps(collection, shardId, leaderReplica.getName(), coreName, null, ZkStateReader.DOWN);\n          }\n        }\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n        // if request is coming from another collection then we want it to be sent to all replicas\n        // even if it's phase is FROMLEADER\n        String fromCollection = updateCommand.getReq().getParams().get(DISTRIB_FROM_COLLECTION);\n\n        if (DistribPhase.FROMLEADER == phase && !isSubShardLeader && fromCollection == null) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader || isSubShardLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, leaderReplica.getName(),\n                  coreName, null, ZkStateReader.DOWN);\n\n          if (replicaProps != null) {\n            if (nodes == null)  {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            }\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(new ZkCoreNodeProps(leaderReplica), zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9ce545e833f5334e245fb71d83c3460ef83c2d5e","date":1385773467,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","sourceNew":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        isLeader = leaderReplica.getName().equals(\n            req.getCore().getCoreDescriptor().getCloudDescriptor()\n                .getCoreNodeName());\n\n        if (!isLeader) {\n          isSubShardLeader = amISubShardLeader(coll, slice, id, doc);\n          if (isSubShardLeader) {\n            String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n            slice = coll.getSlice(myShardId);\n            shardId = myShardId;\n            leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, myShardId);\n            List<ZkCoreNodeProps> myReplicas = zkController.getZkStateReader().getReplicaProps(collection, shardId, leaderReplica.getName(), coreName, null, ZkStateReader.DOWN);\n          }\n        }\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n        // if request is coming from another collection then we want it to be sent to all replicas\n        // even if it's phase is FROMLEADER\n        String fromCollection = updateCommand.getReq().getParams().get(DISTRIB_FROM_COLLECTION);\n\n        if (DistribPhase.FROMLEADER == phase && !isSubShardLeader && fromCollection == null) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader || isSubShardLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, leaderReplica.getName(),\n                  coreName, null, ZkStateReader.DOWN);\n\n          if (replicaProps != null) {\n            if (nodes == null)  {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            }\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(new ZkCoreNodeProps(leaderReplica), zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        isLeader = leaderReplica.getName().equals(\n            req.getCore().getCoreDescriptor().getCloudDescriptor()\n                .getCoreNodeName());\n\n        if (!isLeader) {\n          isSubShardLeader = amISubShardLeader(coll, slice, id, doc);\n          if (isSubShardLeader) {\n            String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n            slice = coll.getSlice(myShardId);\n            shardId = myShardId;\n            leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, myShardId);\n            List<ZkCoreNodeProps> myReplicas = zkController.getZkStateReader().getReplicaProps(collection, shardId, leaderReplica.getName(), coreName, null, ZkStateReader.DOWN);\n          }\n        }\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n        // if request is coming from another collection then we want it to be sent to all replicas\n        // even if it's phase is FROMLEADER\n        String fromCollection = updateCommand.getReq().getParams().get(DISTRIB_FROM_COLLECTION);\n\n        if (DistribPhase.FROMLEADER == phase && !isSubShardLeader && fromCollection == null) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader || isSubShardLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, leaderReplica.getName(),\n                  coreName, null, ZkStateReader.DOWN);\n\n          if (replicaProps != null) {\n            if (nodes == null)  {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            }\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(new ZkCoreNodeProps(leaderReplica), zkController.getZkStateReader(), collection, shardId, ZkCoreNodeProps.getCoreUrl(\n              zkController.getBaseUrl(), req.getCore().getName())));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":["747dd71fefcbc7142661c25334b74c518fef4d81"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","sourceNew":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        isLeader = leaderReplica.getName().equals(\n            req.getCore().getCoreDescriptor().getCloudDescriptor()\n                .getCoreNodeName());\n\n        if (!isLeader) {\n          isSubShardLeader = amISubShardLeader(coll, slice, id, doc);\n          if (isSubShardLeader) {\n            String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n            slice = coll.getSlice(myShardId);\n            shardId = myShardId;\n            leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, myShardId);\n            List<ZkCoreNodeProps> myReplicas = zkController.getZkStateReader().getReplicaProps(collection, shardId, leaderReplica.getName(), coreName, null, ZkStateReader.DOWN);\n          }\n        }\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n        // if request is coming from another collection then we want it to be sent to all replicas\n        // even if it's phase is FROMLEADER\n        String fromCollection = updateCommand.getReq().getParams().get(DISTRIB_FROM_COLLECTION);\n\n        if (DistribPhase.FROMLEADER == phase && !isSubShardLeader && fromCollection == null) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader || isSubShardLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, leaderReplica.getName(),\n                  coreName, null, ZkStateReader.DOWN);\n\n          if (replicaProps != null) {\n            if (nodes == null)  {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            }\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(new ZkCoreNodeProps(leaderReplica), zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        isLeader = leaderReplica.getName().equals(\n            req.getCore().getCoreDescriptor().getCloudDescriptor()\n                .getCoreNodeName());\n\n        if (!isLeader) {\n          isSubShardLeader = amISubShardLeader(coll, slice, id, doc);\n          if (isSubShardLeader) {\n            String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n            slice = coll.getSlice(myShardId);\n            shardId = myShardId;\n            leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, myShardId);\n            List<ZkCoreNodeProps> myReplicas = zkController.getZkStateReader().getReplicaProps(collection, shardId, leaderReplica.getName(), coreName, null, ZkStateReader.DOWN);\n          }\n        }\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n        // if request is coming from another collection then we want it to be sent to all replicas\n        // even if it's phase is FROMLEADER\n        String fromCollection = updateCommand.getReq().getParams().get(\"distrib.from.collection\");\n\n        if (DistribPhase.FROMLEADER == phase && !isSubShardLeader && fromCollection == null) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader || isSubShardLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, leaderReplica.getName(),\n                  coreName, null, ZkStateReader.DOWN);\n\n          if (replicaProps != null) {\n            if (nodes == null)  {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            }\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(new ZkCoreNodeProps(leaderReplica), zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b4c4001c33d7e459f31c8810ea8fd129c7b6ea7","date":1391654280,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","sourceNew":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n      DistribPhase phase =\n          DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n      if (DistribPhase.FROMLEADER == phase && !couldIbeSubShardLeader(coll)) {\n        if (req.getCore().getCoreDescriptor().getCloudDescriptor().isLeader()) {\n          // locally we think we are leader but the request says it came FROMLEADER\n          // that could indicate a problem, let the full logic below figure it out\n        } else {\n          isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n          forwardToLeader = false;\n          return nodes;\n        }\n      }\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        isLeader = leaderReplica.getName().equals(\n            req.getCore().getCoreDescriptor().getCloudDescriptor()\n                .getCoreNodeName());\n\n        if (!isLeader) {\n          isSubShardLeader = amISubShardLeader(coll, slice, id, doc);\n          if (isSubShardLeader) {\n            String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n            slice = coll.getSlice(myShardId);\n            shardId = myShardId;\n            leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, myShardId);\n            List<ZkCoreNodeProps> myReplicas = zkController.getZkStateReader().getReplicaProps(collection, shardId, leaderReplica.getName(), coreName, null, ZkStateReader.DOWN);\n          }\n        }\n\n        doDefensiveChecks(phase);\n\n        // if request is coming from another collection then we want it to be sent to all replicas\n        // even if it's phase is FROMLEADER\n        String fromCollection = updateCommand.getReq().getParams().get(DISTRIB_FROM_COLLECTION);\n\n        if (DistribPhase.FROMLEADER == phase && !isSubShardLeader && fromCollection == null) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader || isSubShardLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, leaderReplica.getName(),\n                  coreName, null, ZkStateReader.DOWN);\n\n          if (replicaProps != null) {\n            if (nodes == null)  {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            }\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(new ZkCoreNodeProps(leaderReplica), zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        isLeader = leaderReplica.getName().equals(\n            req.getCore().getCoreDescriptor().getCloudDescriptor()\n                .getCoreNodeName());\n\n        if (!isLeader) {\n          isSubShardLeader = amISubShardLeader(coll, slice, id, doc);\n          if (isSubShardLeader) {\n            String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n            slice = coll.getSlice(myShardId);\n            shardId = myShardId;\n            leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, myShardId);\n            List<ZkCoreNodeProps> myReplicas = zkController.getZkStateReader().getReplicaProps(collection, shardId, leaderReplica.getName(), coreName, null, ZkStateReader.DOWN);\n          }\n        }\n\n        DistribPhase phase =\n            DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n        doDefensiveChecks(phase);\n\n        // if request is coming from another collection then we want it to be sent to all replicas\n        // even if it's phase is FROMLEADER\n        String fromCollection = updateCommand.getReq().getParams().get(DISTRIB_FROM_COLLECTION);\n\n        if (DistribPhase.FROMLEADER == phase && !isSubShardLeader && fromCollection == null) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader || isSubShardLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, leaderReplica.getName(),\n                  coreName, null, ZkStateReader.DOWN);\n\n          if (replicaProps != null) {\n            if (nodes == null)  {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            }\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(new ZkCoreNodeProps(leaderReplica), zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":["89f828d954597b98a28942874636f35c719b8a5d"],"bugIntro":["747dd71fefcbc7142661c25334b74c518fef4d81"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","sourceNew":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n      DistribPhase phase =\n          DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n      if (DistribPhase.FROMLEADER == phase && !couldIbeSubShardLeader(coll)) {\n        if (req.getCore().getCoreDescriptor().getCloudDescriptor().isLeader()) {\n          // locally we think we are leader but the request says it came FROMLEADER\n          // that could indicate a problem, let the full logic below figure it out\n        } else {\n          isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n          forwardToLeader = false;\n          return nodes;\n        }\n      }\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        isLeader = leaderReplica.getName().equals(\n            req.getCore().getCoreDescriptor().getCloudDescriptor()\n                .getCoreNodeName());\n\n        if (!isLeader) {\n          isSubShardLeader = amISubShardLeader(coll, slice, id, doc);\n          if (isSubShardLeader) {\n            String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n            slice = coll.getSlice(myShardId);\n            shardId = myShardId;\n            leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, myShardId);\n            List<ZkCoreNodeProps> myReplicas = zkController.getZkStateReader().getReplicaProps(collection, shardId, leaderReplica.getName(), coreName, null, ZkStateReader.DOWN);\n          }\n        }\n\n        doDefensiveChecks(phase);\n\n        // if request is coming from another collection then we want it to be sent to all replicas\n        // even if it's phase is FROMLEADER\n        String fromCollection = updateCommand.getReq().getParams().get(DISTRIB_FROM_COLLECTION);\n\n        if (DistribPhase.FROMLEADER == phase && !isSubShardLeader && fromCollection == null) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader || isSubShardLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, leaderReplica.getName(),\n                  coreName, null, ZkStateReader.DOWN);\n\n          if (replicaProps != null) {\n            if (nodes == null)  {\n            nodes = new ArrayList<>(replicaProps.size());\n            }\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<>(1);\n          nodes.add(new RetryNode(new ZkCoreNodeProps(leaderReplica), zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n      DistribPhase phase =\n          DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n      if (DistribPhase.FROMLEADER == phase && !couldIbeSubShardLeader(coll)) {\n        if (req.getCore().getCoreDescriptor().getCloudDescriptor().isLeader()) {\n          // locally we think we are leader but the request says it came FROMLEADER\n          // that could indicate a problem, let the full logic below figure it out\n        } else {\n          isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n          forwardToLeader = false;\n          return nodes;\n        }\n      }\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        isLeader = leaderReplica.getName().equals(\n            req.getCore().getCoreDescriptor().getCloudDescriptor()\n                .getCoreNodeName());\n\n        if (!isLeader) {\n          isSubShardLeader = amISubShardLeader(coll, slice, id, doc);\n          if (isSubShardLeader) {\n            String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n            slice = coll.getSlice(myShardId);\n            shardId = myShardId;\n            leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, myShardId);\n            List<ZkCoreNodeProps> myReplicas = zkController.getZkStateReader().getReplicaProps(collection, shardId, leaderReplica.getName(), coreName, null, ZkStateReader.DOWN);\n          }\n        }\n\n        doDefensiveChecks(phase);\n\n        // if request is coming from another collection then we want it to be sent to all replicas\n        // even if it's phase is FROMLEADER\n        String fromCollection = updateCommand.getReq().getParams().get(DISTRIB_FROM_COLLECTION);\n\n        if (DistribPhase.FROMLEADER == phase && !isSubShardLeader && fromCollection == null) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader || isSubShardLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, leaderReplica.getName(),\n                  coreName, null, ZkStateReader.DOWN);\n\n          if (replicaProps != null) {\n            if (nodes == null)  {\n            nodes = new ArrayList<Node>(replicaProps.size());\n            }\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<String>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<Node>(1);\n          nodes.add(new RetryNode(new ZkCoreNodeProps(leaderReplica), zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":["747dd71fefcbc7142661c25334b74c518fef4d81"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"14d5815ecbef89580f5c48990bcd433f04f8563a","date":1399564106,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","sourceNew":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();      \n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n      DistribPhase phase =\n          DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n      if (DistribPhase.FROMLEADER == phase && !couldIbeSubShardLeader(coll)) {\n        if (req.getCore().getCoreDescriptor().getCloudDescriptor().isLeader()) {\n          // locally we think we are leader but the request says it came FROMLEADER\n          // that could indicate a problem, let the full logic below figure it out\n        } else {\n          isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n          forwardToLeader = false;\n          return nodes;\n        }\n      }\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        isLeader = leaderReplica.getName().equals(\n            req.getCore().getCoreDescriptor().getCloudDescriptor()\n                .getCoreNodeName());\n\n        if (!isLeader) {\n          isSubShardLeader = amISubShardLeader(coll, slice, id, doc);\n          if (isSubShardLeader) {\n            String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n            slice = coll.getSlice(myShardId);\n            shardId = myShardId;\n            leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, myShardId);\n            List<ZkCoreNodeProps> myReplicas = zkController.getZkStateReader().getReplicaProps(collection, shardId, leaderReplica.getName(), coreName, null, ZkStateReader.DOWN);\n          }\n        }\n\n        doDefensiveChecks(phase);\n\n        // if request is coming from another collection then we want it to be sent to all replicas\n        // even if it's phase is FROMLEADER\n        String fromCollection = updateCommand.getReq().getParams().get(DISTRIB_FROM_COLLECTION);\n\n        if (DistribPhase.FROMLEADER == phase && !isSubShardLeader && fromCollection == null) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader || isSubShardLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, leaderReplica.getName(),\n                  coreName, null, ZkStateReader.DOWN);\n\n          if (replicaProps != null) {\n            if (nodes == null)  {\n            nodes = new ArrayList<>(replicaProps.size());\n            }\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                    nodes.add(new StdNode(props, collection, shardId));\n                }\n              } else {\n                  nodes.add(new StdNode(props, collection, shardId));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<>(1);\n          nodes.add(new RetryNode(new ZkCoreNodeProps(leaderReplica), zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();\n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n      DistribPhase phase =\n          DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n      if (DistribPhase.FROMLEADER == phase && !couldIbeSubShardLeader(coll)) {\n        if (req.getCore().getCoreDescriptor().getCloudDescriptor().isLeader()) {\n          // locally we think we are leader but the request says it came FROMLEADER\n          // that could indicate a problem, let the full logic below figure it out\n        } else {\n          isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n          forwardToLeader = false;\n          return nodes;\n        }\n      }\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        isLeader = leaderReplica.getName().equals(\n            req.getCore().getCoreDescriptor().getCloudDescriptor()\n                .getCoreNodeName());\n\n        if (!isLeader) {\n          isSubShardLeader = amISubShardLeader(coll, slice, id, doc);\n          if (isSubShardLeader) {\n            String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n            slice = coll.getSlice(myShardId);\n            shardId = myShardId;\n            leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, myShardId);\n            List<ZkCoreNodeProps> myReplicas = zkController.getZkStateReader().getReplicaProps(collection, shardId, leaderReplica.getName(), coreName, null, ZkStateReader.DOWN);\n          }\n        }\n\n        doDefensiveChecks(phase);\n\n        // if request is coming from another collection then we want it to be sent to all replicas\n        // even if it's phase is FROMLEADER\n        String fromCollection = updateCommand.getReq().getParams().get(DISTRIB_FROM_COLLECTION);\n\n        if (DistribPhase.FROMLEADER == phase && !isSubShardLeader && fromCollection == null) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader || isSubShardLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, leaderReplica.getName(),\n                  coreName, null, ZkStateReader.DOWN);\n\n          if (replicaProps != null) {\n            if (nodes == null)  {\n            nodes = new ArrayList<>(replicaProps.size());\n            }\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                  nodes.add(new StdNode(props));\n                }\n              } else {\n                nodes.add(new StdNode(props));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<>(1);\n          nodes.add(new RetryNode(new ZkCoreNodeProps(leaderReplica), zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":["747dd71fefcbc7142661c25334b74c518fef4d81"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"be2d2facad861c539d42173b0e4538d64b7fda80","date":1405194900,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","sourceNew":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n\n      ClusterState cstate = zkController.getClusterState();      \n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n      DistribPhase phase =\n          DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n      if (DistribPhase.FROMLEADER == phase && !couldIbeSubShardLeader(coll)) {\n        if (req.getCore().getCoreDescriptor().getCloudDescriptor().isLeader()) {\n          // locally we think we are leader but the request says it came FROMLEADER\n          // that could indicate a problem, let the full logic below figure it out\n        } else {\n          isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n          forwardToLeader = false;\n          return nodes;\n        }\n      }\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        isLeader = leaderReplica.getName().equals(\n            req.getCore().getCoreDescriptor().getCloudDescriptor()\n                .getCoreNodeName());\n\n        if (!isLeader) {\n          isSubShardLeader = amISubShardLeader(coll, slice, id, doc);\n          if (isSubShardLeader) {\n            String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n            slice = coll.getSlice(myShardId);\n            shardId = myShardId;\n            leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, myShardId);\n            List<ZkCoreNodeProps> myReplicas = zkController.getZkStateReader().getReplicaProps(collection, shardId, leaderReplica.getName(), null, ZkStateReader.DOWN);\n          }\n        }\n\n        doDefensiveChecks(phase);\n\n        // if request is coming from another collection then we want it to be sent to all replicas\n        // even if it's phase is FROMLEADER\n        String fromCollection = updateCommand.getReq().getParams().get(DISTRIB_FROM_COLLECTION);\n\n        if (DistribPhase.FROMLEADER == phase && !isSubShardLeader && fromCollection == null) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader || isSubShardLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, leaderReplica.getName(), null, ZkStateReader.DOWN);\n\n          if (replicaProps != null) {\n            if (nodes == null)  {\n            nodes = new ArrayList<>(replicaProps.size());\n            }\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                    nodes.add(new StdNode(props, collection, shardId));\n                }\n              } else {\n                  nodes.add(new StdNode(props, collection, shardId));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<>(1);\n          nodes.add(new RetryNode(new ZkCoreNodeProps(leaderReplica), zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n      String coreName = req.getCore().getName();\n\n      ClusterState cstate = zkController.getClusterState();      \n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n      DistribPhase phase =\n          DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n      if (DistribPhase.FROMLEADER == phase && !couldIbeSubShardLeader(coll)) {\n        if (req.getCore().getCoreDescriptor().getCloudDescriptor().isLeader()) {\n          // locally we think we are leader but the request says it came FROMLEADER\n          // that could indicate a problem, let the full logic below figure it out\n        } else {\n          isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n          forwardToLeader = false;\n          return nodes;\n        }\n      }\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        isLeader = leaderReplica.getName().equals(\n            req.getCore().getCoreDescriptor().getCloudDescriptor()\n                .getCoreNodeName());\n\n        if (!isLeader) {\n          isSubShardLeader = amISubShardLeader(coll, slice, id, doc);\n          if (isSubShardLeader) {\n            String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n            slice = coll.getSlice(myShardId);\n            shardId = myShardId;\n            leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, myShardId);\n            List<ZkCoreNodeProps> myReplicas = zkController.getZkStateReader().getReplicaProps(collection, shardId, leaderReplica.getName(), coreName, null, ZkStateReader.DOWN);\n          }\n        }\n\n        doDefensiveChecks(phase);\n\n        // if request is coming from another collection then we want it to be sent to all replicas\n        // even if it's phase is FROMLEADER\n        String fromCollection = updateCommand.getReq().getParams().get(DISTRIB_FROM_COLLECTION);\n\n        if (DistribPhase.FROMLEADER == phase && !isSubShardLeader && fromCollection == null) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader || isSubShardLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, leaderReplica.getName(),\n                  coreName, null, ZkStateReader.DOWN);\n\n          if (replicaProps != null) {\n            if (nodes == null)  {\n            nodes = new ArrayList<>(replicaProps.size());\n            }\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                    nodes.add(new StdNode(props, collection, shardId));\n                }\n              } else {\n                  nodes.add(new StdNode(props, collection, shardId));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<>(1);\n          nodes.add(new RetryNode(new ZkCoreNodeProps(leaderReplica), zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":["747dd71fefcbc7142661c25334b74c518fef4d81"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1","date":1419400138,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","sourceNew":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n\n      ClusterState cstate = zkController.getClusterState();      \n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n      DistribPhase phase =\n          DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n      if (DistribPhase.FROMLEADER == phase && !couldIbeSubShardLeader(coll)) {\n        if (req.getCore().getCoreDescriptor().getCloudDescriptor().isLeader()) {\n          // locally we think we are leader but the request says it came FROMLEADER\n          // that could indicate a problem, let the full logic below figure it out\n        } else {\n          isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n          forwardToLeader = false;\n          return nodes;\n        }\n      }\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        isLeader = leaderReplica.getName().equals(\n            req.getCore().getCoreDescriptor().getCloudDescriptor()\n                .getCoreNodeName());\n\n        if (!isLeader) {\n          isSubShardLeader = amISubShardLeader(coll, slice, id, doc);\n          if (isSubShardLeader) {\n            String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n            slice = coll.getSlice(myShardId);\n            shardId = myShardId;\n            leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, myShardId);\n            List<ZkCoreNodeProps> myReplicas = zkController.getZkStateReader().getReplicaProps(collection, shardId, leaderReplica.getName(), null, ZkStateReader.DOWN);\n          }\n        }\n\n        doDefensiveChecks(phase);\n\n        // if request is coming from another collection then we want it to be sent to all replicas\n        // even if its phase is FROMLEADER\n        String fromCollection = updateCommand.getReq().getParams().get(DISTRIB_FROM_COLLECTION);\n\n        if (DistribPhase.FROMLEADER == phase && !isSubShardLeader && fromCollection == null) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader || isSubShardLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, leaderReplica.getName(), null, ZkStateReader.DOWN);\n\n          if (replicaProps != null) {\n            if (nodes == null)  {\n            nodes = new ArrayList<>(replicaProps.size());\n            }\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                    nodes.add(new StdNode(props, collection, shardId));\n                }\n              } else {\n                  nodes.add(new StdNode(props, collection, shardId));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<>(1);\n          nodes.add(new RetryNode(new ZkCoreNodeProps(leaderReplica), zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n\n      ClusterState cstate = zkController.getClusterState();      \n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n      DistribPhase phase =\n          DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n      if (DistribPhase.FROMLEADER == phase && !couldIbeSubShardLeader(coll)) {\n        if (req.getCore().getCoreDescriptor().getCloudDescriptor().isLeader()) {\n          // locally we think we are leader but the request says it came FROMLEADER\n          // that could indicate a problem, let the full logic below figure it out\n        } else {\n          isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n          forwardToLeader = false;\n          return nodes;\n        }\n      }\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        isLeader = leaderReplica.getName().equals(\n            req.getCore().getCoreDescriptor().getCloudDescriptor()\n                .getCoreNodeName());\n\n        if (!isLeader) {\n          isSubShardLeader = amISubShardLeader(coll, slice, id, doc);\n          if (isSubShardLeader) {\n            String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n            slice = coll.getSlice(myShardId);\n            shardId = myShardId;\n            leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, myShardId);\n            List<ZkCoreNodeProps> myReplicas = zkController.getZkStateReader().getReplicaProps(collection, shardId, leaderReplica.getName(), null, ZkStateReader.DOWN);\n          }\n        }\n\n        doDefensiveChecks(phase);\n\n        // if request is coming from another collection then we want it to be sent to all replicas\n        // even if it's phase is FROMLEADER\n        String fromCollection = updateCommand.getReq().getParams().get(DISTRIB_FROM_COLLECTION);\n\n        if (DistribPhase.FROMLEADER == phase && !isSubShardLeader && fromCollection == null) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader || isSubShardLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, leaderReplica.getName(), null, ZkStateReader.DOWN);\n\n          if (replicaProps != null) {\n            if (nodes == null)  {\n            nodes = new ArrayList<>(replicaProps.size());\n            }\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                    nodes.add(new StdNode(props, collection, shardId));\n                }\n              } else {\n                  nodes.add(new StdNode(props, collection, shardId));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<>(1);\n          nodes.add(new RetryNode(new ZkCoreNodeProps(leaderReplica), zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":["747dd71fefcbc7142661c25334b74c518fef4d81"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"747dd71fefcbc7142661c25334b74c518fef4d81","date":1423504825,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","sourceNew":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    return setupRequest(id, doc, null);\n  }\n\n","sourceOld":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    List<Node> nodes = null;\n\n    // if we are in zk mode...\n    if (zkEnabled) {\n\n      if ((updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0) {\n        isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n        forwardToLeader = false;\n        return nodes;\n      }\n\n      ClusterState cstate = zkController.getClusterState();      \n      DocCollection coll = cstate.getCollection(collection);\n      Slice slice = coll.getRouter().getTargetSlice(id, doc, req.getParams(), coll);\n\n      if (slice == null) {\n        // No slice found.  Most strict routers will have already thrown an exception, so a null return is\n        // a signal to use the slice of this core.\n        // TODO: what if this core is not in the targeted collection?\n        String shardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        slice = coll.getSlice(shardId);\n        if (slice == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"No shard \" + shardId + \" in \" + coll);\n        }\n      }\n\n      DistribPhase phase =\n          DistribPhase.parseParam(req.getParams().get(DISTRIB_UPDATE_PARAM));\n\n      if (DistribPhase.FROMLEADER == phase && !couldIbeSubShardLeader(coll)) {\n        if (req.getCore().getCoreDescriptor().getCloudDescriptor().isLeader()) {\n          // locally we think we are leader but the request says it came FROMLEADER\n          // that could indicate a problem, let the full logic below figure it out\n        } else {\n          isLeader = false;     // we actually might be the leader, but we don't want leader-logic for these types of updates anyway.\n          forwardToLeader = false;\n          return nodes;\n        }\n      }\n\n      String shardId = slice.getName();\n\n      try {\n        // Not equivalent to getLeaderProps, which does retries to find a leader.\n        // Replica leader = slice.getLeader();\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        isLeader = leaderReplica.getName().equals(\n            req.getCore().getCoreDescriptor().getCloudDescriptor()\n                .getCoreNodeName());\n\n        if (!isLeader) {\n          isSubShardLeader = amISubShardLeader(coll, slice, id, doc);\n          if (isSubShardLeader) {\n            String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n            slice = coll.getSlice(myShardId);\n            shardId = myShardId;\n            leaderReplica = zkController.getZkStateReader().getLeaderRetry(collection, myShardId);\n            List<ZkCoreNodeProps> myReplicas = zkController.getZkStateReader().getReplicaProps(collection, shardId, leaderReplica.getName(), null, ZkStateReader.DOWN);\n          }\n        }\n\n        doDefensiveChecks(phase);\n\n        // if request is coming from another collection then we want it to be sent to all replicas\n        // even if its phase is FROMLEADER\n        String fromCollection = updateCommand.getReq().getParams().get(DISTRIB_FROM_COLLECTION);\n\n        if (DistribPhase.FROMLEADER == phase && !isSubShardLeader && fromCollection == null) {\n          // we are coming from the leader, just go local - add no urls\n          forwardToLeader = false;\n        } else if (isLeader || isSubShardLeader) {\n          // that means I want to forward onto my replicas...\n          // so get the replicas...\n          forwardToLeader = false;\n          List<ZkCoreNodeProps> replicaProps = zkController.getZkStateReader()\n              .getReplicaProps(collection, shardId, leaderReplica.getName(), null, ZkStateReader.DOWN);\n\n          if (replicaProps != null) {\n            if (nodes == null)  {\n            nodes = new ArrayList<>(replicaProps.size());\n            }\n            // check for test param that lets us miss replicas\n            String[] skipList = req.getParams().getParams(TEST_DISTRIB_SKIP_SERVERS);\n            Set<String> skipListSet = null;\n            if (skipList != null) {\n              skipListSet = new HashSet<>(skipList.length);\n              skipListSet.addAll(Arrays.asList(skipList));\n              log.info(\"test.distrib.skip.servers was found and contains:\" + skipListSet);\n            }\n\n            for (ZkCoreNodeProps props : replicaProps) {\n              if (skipList != null) {\n                boolean skip = skipListSet.contains(props.getCoreUrl());\n                log.info(\"check url:\" + props.getCoreUrl() + \" against:\" + skipListSet + \" result:\" + skip);\n                if (!skip) {\n                    nodes.add(new StdNode(props, collection, shardId));\n                }\n              } else {\n                  nodes.add(new StdNode(props, collection, shardId));\n              }\n            }\n          }\n\n        } else {\n          // I need to forward onto the leader...\n          nodes = new ArrayList<>(1);\n          nodes.add(new RetryNode(new ZkCoreNodeProps(leaderReplica), zkController.getZkStateReader(), collection, shardId));\n          forwardToLeader = true;\n        }\n\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"\",\n            e);\n      }\n    }\n\n    return nodes;\n  }\n\n","bugFix":["89f828d954597b98a28942874636f35c719b8a5d","634f330c54fd3f9f491d52036dc3f40b4f4d8934","28327f97250ba0a97287ec9875c89161fe4e4611","cb4a195b8dc1808cd01748bd2e0fba26ca915d4d","0beaed456aa3358e5e4a99ea2aea994ef6c81de3","6c228eadc8ab12c4b442521f5890283801a6cab5","96adbab674ae121f8b6b3e10474070b4bd97a219","da888af1ab894358122a22229051215f58cf4d54","3d7c0c8a97beb56d2e168604f9928de17981eabe","e7754464847b06ced605515bd48219280ede29e9","849494cf2f3a96af5c8c84995108ddd8456fcd04","be2d2facad861c539d42173b0e4538d64b7fda80","76530c83bab98ecf28c61c2b68a7151a946298f2","14d5815ecbef89580f5c48990bcd433f04f8563a","7b4c4001c33d7e459f31c8810ea8fd129c7b6ea7","9ce545e833f5334e245fb71d83c3460ef83c2d5e","618dcc9a4785445b3a9c5cf1cdcd6604a856d3b3","8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1","3333dd7044501b4f20231ea55ab64e688285d153"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9d70e774cb25c8a8d2c3e5e84200f235f9168d87","date":1553016391,"type":5,"author":"Bar Rotstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedZkUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#setupRequest(String,SolrInputDocument).mjava","sourceNew":"  protected List<SolrCmdDistributor.Node> setupRequest(String id, SolrInputDocument doc) {\n    return setupRequest(id, doc, null);\n  }\n\n","sourceOld":"  private List<Node> setupRequest(String id, SolrInputDocument doc) {\n    return setupRequest(id, doc, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"618dcc9a4785445b3a9c5cf1cdcd6604a856d3b3":["76530c83bab98ecf28c61c2b68a7151a946298f2"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","3d7c0c8a97beb56d2e168604f9928de17981eabe"],"89f828d954597b98a28942874636f35c719b8a5d":["c5a558d54519c651068ddb202f03befefb1514a7"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["8f1ea787bab5bdb5e72685e55424898da05509b6","96adbab674ae121f8b6b3e10474070b4bd97a219"],"c4015cd39dff8d4dec562d909f9766debac53aa6":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","6c228eadc8ab12c4b442521f5890283801a6cab5"],"7b4c4001c33d7e459f31c8810ea8fd129c7b6ea7":["9ce545e833f5334e245fb71d83c3460ef83c2d5e"],"8f1ea787bab5bdb5e72685e55424898da05509b6":["0beaed456aa3358e5e4a99ea2aea994ef6c81de3"],"91e069c492cf4895697ef7b81df0ffb9a8bd4b48":["96adbab674ae121f8b6b3e10474070b4bd97a219"],"3d7c0c8a97beb56d2e168604f9928de17981eabe":["56a558aa5aadd60ae850d1ab090098bc63bdfaf9"],"e7754464847b06ced605515bd48219280ede29e9":["89f828d954597b98a28942874636f35c719b8a5d"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["be2d2facad861c539d42173b0e4538d64b7fda80"],"96adbab674ae121f8b6b3e10474070b4bd97a219":["849494cf2f3a96af5c8c84995108ddd8456fcd04"],"9ce545e833f5334e245fb71d83c3460ef83c2d5e":["c1dd6595120fba7e99fcec70759c6cdea9a071b3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"14d5815ecbef89580f5c48990bcd433f04f8563a":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"c1dd6595120fba7e99fcec70759c6cdea9a071b3":["3333dd7044501b4f20231ea55ab64e688285d153"],"56a558aa5aadd60ae850d1ab090098bc63bdfaf9":["e7754464847b06ced605515bd48219280ede29e9"],"6c228eadc8ab12c4b442521f5890283801a6cab5":["3d7c0c8a97beb56d2e168604f9928de17981eabe"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["7b4c4001c33d7e459f31c8810ea8fd129c7b6ea7"],"be2d2facad861c539d42173b0e4538d64b7fda80":["14d5815ecbef89580f5c48990bcd433f04f8563a"],"407687e67faf6e1f02a211ca078d8e3eed631027":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e7754464847b06ced605515bd48219280ede29e9"],"747dd71fefcbc7142661c25334b74c518fef4d81":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"0beaed456aa3358e5e4a99ea2aea994ef6c81de3":["28327f97250ba0a97287ec9875c89161fe4e4611"],"28327f97250ba0a97287ec9875c89161fe4e4611":["618dcc9a4785445b3a9c5cf1cdcd6604a856d3b3"],"da888af1ab894358122a22229051215f58cf4d54":["91e069c492cf4895697ef7b81df0ffb9a8bd4b48"],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["8f1ea787bab5bdb5e72685e55424898da05509b6"],"76530c83bab98ecf28c61c2b68a7151a946298f2":["cb4a195b8dc1808cd01748bd2e0fba26ca915d4d"],"c5a558d54519c651068ddb202f03befefb1514a7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["da888af1ab894358122a22229051215f58cf4d54","9ce545e833f5334e245fb71d83c3460ef83c2d5e"],"cb4a195b8dc1808cd01748bd2e0fba26ca915d4d":["6c228eadc8ab12c4b442521f5890283801a6cab5"],"9d70e774cb25c8a8d2c3e5e84200f235f9168d87":["747dd71fefcbc7142661c25334b74c518fef4d81"],"3333dd7044501b4f20231ea55ab64e688285d153":["da888af1ab894358122a22229051215f58cf4d54"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9d70e774cb25c8a8d2c3e5e84200f235f9168d87"]},"commit2Childs":{"618dcc9a4785445b3a9c5cf1cdcd6604a856d3b3":["28327f97250ba0a97287ec9875c89161fe4e4611"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["c4015cd39dff8d4dec562d909f9766debac53aa6"],"89f828d954597b98a28942874636f35c719b8a5d":["e7754464847b06ced605515bd48219280ede29e9"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"c4015cd39dff8d4dec562d909f9766debac53aa6":[],"7b4c4001c33d7e459f31c8810ea8fd129c7b6ea7":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"8f1ea787bab5bdb5e72685e55424898da05509b6":["37a0f60745e53927c4c876cfe5b5a58170f0646c","849494cf2f3a96af5c8c84995108ddd8456fcd04"],"91e069c492cf4895697ef7b81df0ffb9a8bd4b48":["da888af1ab894358122a22229051215f58cf4d54"],"3d7c0c8a97beb56d2e168604f9928de17981eabe":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","6c228eadc8ab12c4b442521f5890283801a6cab5"],"e7754464847b06ced605515bd48219280ede29e9":["56a558aa5aadd60ae850d1ab090098bc63bdfaf9","407687e67faf6e1f02a211ca078d8e3eed631027"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["747dd71fefcbc7142661c25334b74c518fef4d81"],"96adbab674ae121f8b6b3e10474070b4bd97a219":["37a0f60745e53927c4c876cfe5b5a58170f0646c","91e069c492cf4895697ef7b81df0ffb9a8bd4b48"],"9ce545e833f5334e245fb71d83c3460ef83c2d5e":["7b4c4001c33d7e459f31c8810ea8fd129c7b6ea7","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["407687e67faf6e1f02a211ca078d8e3eed631027","c5a558d54519c651068ddb202f03befefb1514a7"],"c1dd6595120fba7e99fcec70759c6cdea9a071b3":["9ce545e833f5334e245fb71d83c3460ef83c2d5e"],"14d5815ecbef89580f5c48990bcd433f04f8563a":["be2d2facad861c539d42173b0e4538d64b7fda80"],"56a558aa5aadd60ae850d1ab090098bc63bdfaf9":["3d7c0c8a97beb56d2e168604f9928de17981eabe"],"6c228eadc8ab12c4b442521f5890283801a6cab5":["c4015cd39dff8d4dec562d909f9766debac53aa6","cb4a195b8dc1808cd01748bd2e0fba26ca915d4d"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["14d5815ecbef89580f5c48990bcd433f04f8563a"],"be2d2facad861c539d42173b0e4538d64b7fda80":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"0beaed456aa3358e5e4a99ea2aea994ef6c81de3":["8f1ea787bab5bdb5e72685e55424898da05509b6"],"747dd71fefcbc7142661c25334b74c518fef4d81":["9d70e774cb25c8a8d2c3e5e84200f235f9168d87"],"28327f97250ba0a97287ec9875c89161fe4e4611":["0beaed456aa3358e5e4a99ea2aea994ef6c81de3"],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["96adbab674ae121f8b6b3e10474070b4bd97a219"],"da888af1ab894358122a22229051215f58cf4d54":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","3333dd7044501b4f20231ea55ab64e688285d153"],"76530c83bab98ecf28c61c2b68a7151a946298f2":["618dcc9a4785445b3a9c5cf1cdcd6604a856d3b3"],"c5a558d54519c651068ddb202f03befefb1514a7":["89f828d954597b98a28942874636f35c719b8a5d"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"cb4a195b8dc1808cd01748bd2e0fba26ca915d4d":["76530c83bab98ecf28c61c2b68a7151a946298f2"],"3333dd7044501b4f20231ea55ab64e688285d153":["c1dd6595120fba7e99fcec70759c6cdea9a071b3"],"9d70e774cb25c8a8d2c3e5e84200f235f9168d87":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","c4015cd39dff8d4dec562d909f9766debac53aa6","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}