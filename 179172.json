{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Suggester#getOperation().mjava","commits":[{"id":"eaca6a0674512222004d9a2b0ca95d86bda20f1c","date":1508160449,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Suggester#getOperation().mjava","pathOld":"/dev/null","sourceNew":"  public SolrRequest getOperation() {\n    if (!isInitialized) {\n      Set<String> collections = (Set<String>) hints.getOrDefault(Hint.COLL, Collections.emptySet());\n      Set<Pair<String, String>> s = (Set<Pair<String, String>>) hints.getOrDefault(Hint.COLL_SHARD, Collections.emptySet());\n      if (!collections.isEmpty() || !s.isEmpty()) {\n        HashSet<Pair<String, String>> shards = new HashSet<>(s);\n        collections.stream().forEach(c -> shards.add(new Pair<>(c, null)));\n        ClusterStateProvider stateProvider = session.cloudManager.getClusterStateProvider();\n        for (Pair<String, String> shard : shards) {\n          // if this is not a known collection from the existing clusterstate,\n          // then add it\n          if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(shard.first()))) {\n            session.addClausesForCollection(stateProvider, shard.first());\n          }\n          for (Row row : session.matrix) {\n            Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.computeIfAbsent(shard.first(), it -> new HashMap<>());\n            if (shard.second() != null) shardInfo.computeIfAbsent(shard.second(), it -> new ArrayList<>());\n          }\n        }\n        Collections.sort(session.expandedClauses);\n      }\n      Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n      if (srcNodes != null && !srcNodes.isEmpty()) {\n        // the source node is dead so live nodes may not have it\n        for (String srcNode : srcNodes) {\n          if(session.matrix.stream().noneMatch(row -> row.node.equals(srcNode)))\n          session.matrix.add(new Row(srcNode, session.getPolicy().params, session.cloudManager));\n        }\n      }\n      session.applyRules();\n      originalViolations.addAll(session.getViolations());\n      this.operation = init();\n      isInitialized = true;\n    }\n    return operation;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1bbcda32e5cd37ef61ea1190bacd080308e22070","date":1508850553,"type":5,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Suggester#getSuggestion().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Suggester#getOperation().mjava","sourceNew":"  public SolrRequest getSuggestion() {\n    if (!isInitialized) {\n      Set<String> collections = (Set<String>) hints.getOrDefault(Hint.COLL, Collections.emptySet());\n      Set<Pair<String, String>> s = (Set<Pair<String, String>>) hints.getOrDefault(Hint.COLL_SHARD, Collections.emptySet());\n      if (!collections.isEmpty() || !s.isEmpty()) {\n        HashSet<Pair<String, String>> shards = new HashSet<>(s);\n        collections.stream().forEach(c -> shards.add(new Pair<>(c, null)));\n        ClusterStateProvider stateProvider = session.cloudManager.getClusterStateProvider();\n        for (Pair<String, String> shard : shards) {\n          // if this is not a known collection from the existing clusterstate,\n          // then add it\n          if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(shard.first()))) {\n            session.addClausesForCollection(stateProvider, shard.first());\n          }\n          for (Row row : session.matrix) {\n            Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.computeIfAbsent(shard.first(), it -> new HashMap<>());\n            if (shard.second() != null) shardInfo.computeIfAbsent(shard.second(), it -> new ArrayList<>());\n          }\n        }\n        Collections.sort(session.expandedClauses);\n      }\n      Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n      if (srcNodes != null && !srcNodes.isEmpty()) {\n        // the source node is dead so live nodes may not have it\n        for (String srcNode : srcNodes) {\n          if(session.matrix.stream().noneMatch(row -> row.node.equals(srcNode)))\n            session.matrix.add(new Row(srcNode, session.getPolicy().params, session.getPolicy().perReplicaAttributes, session.cloudManager));\n        }\n      }\n      session.applyRules();\n      originalViolations.addAll(session.getViolations());\n      this.operation = init();\n      isInitialized = true;\n    }\n    return operation;\n  }\n\n","sourceOld":"  public SolrRequest getOperation() {\n    if (!isInitialized) {\n      Set<String> collections = (Set<String>) hints.getOrDefault(Hint.COLL, Collections.emptySet());\n      Set<Pair<String, String>> s = (Set<Pair<String, String>>) hints.getOrDefault(Hint.COLL_SHARD, Collections.emptySet());\n      if (!collections.isEmpty() || !s.isEmpty()) {\n        HashSet<Pair<String, String>> shards = new HashSet<>(s);\n        collections.stream().forEach(c -> shards.add(new Pair<>(c, null)));\n        ClusterStateProvider stateProvider = session.cloudManager.getClusterStateProvider();\n        for (Pair<String, String> shard : shards) {\n          // if this is not a known collection from the existing clusterstate,\n          // then add it\n          if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(shard.first()))) {\n            session.addClausesForCollection(stateProvider, shard.first());\n          }\n          for (Row row : session.matrix) {\n            Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.computeIfAbsent(shard.first(), it -> new HashMap<>());\n            if (shard.second() != null) shardInfo.computeIfAbsent(shard.second(), it -> new ArrayList<>());\n          }\n        }\n        Collections.sort(session.expandedClauses);\n      }\n      Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n      if (srcNodes != null && !srcNodes.isEmpty()) {\n        // the source node is dead so live nodes may not have it\n        for (String srcNode : srcNodes) {\n          if(session.matrix.stream().noneMatch(row -> row.node.equals(srcNode)))\n          session.matrix.add(new Row(srcNode, session.getPolicy().params, session.cloudManager));\n        }\n      }\n      session.applyRules();\n      originalViolations.addAll(session.getViolations());\n      this.operation = init();\n      isInitialized = true;\n    }\n    return operation;\n  }\n\n","bugFix":null,"bugIntro":["ef7c0ae2232b955007fc003318142c3bdb0e5e8c"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1bbcda32e5cd37ef61ea1190bacd080308e22070":["eaca6a0674512222004d9a2b0ca95d86bda20f1c"],"eaca6a0674512222004d9a2b0ca95d86bda20f1c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1bbcda32e5cd37ef61ea1190bacd080308e22070"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["eaca6a0674512222004d9a2b0ca95d86bda20f1c"],"1bbcda32e5cd37ef61ea1190bacd080308e22070":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"eaca6a0674512222004d9a2b0ca95d86bda20f1c":["1bbcda32e5cd37ef61ea1190bacd080308e22070"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}