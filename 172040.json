{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,long,long).mjava","commits":[{"id":"70a62ed2170ac1ef14886df1c66b89c9e4a68567","date":1352474176,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,long,long).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public NumericDocValuesConsumer addNumericField(FieldInfo field, final long minValue, long maxValue) throws IOException {\n      writeFieldEntry(field);\n      \n      // write our minimum value to the .dat, all entries are deltas from that\n      SimpleTextUtil.write(data, MINVALUE);\n      SimpleTextUtil.write(data, Long.toString(minValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      // build up our fixed-width \"simple text packed ints\" format\n      int maxBytesPerValue = Long.toString(maxValue - minValue).length();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < maxBytesPerValue; i++) {\n        sb.append('0');\n      }\n      \n      // write our pattern to the .dat\n      SimpleTextUtil.write(data, PATTERN);\n      SimpleTextUtil.write(data, sb.toString(), scratch);\n      SimpleTextUtil.writeNewline(data);\n      \n      final DecimalFormat encoder = new DecimalFormat(sb.toString(), new DecimalFormatSymbols(Locale.ROOT));\n      return new NumericDocValuesConsumer() {\n        int numDocsWritten = 0;\n\n        @Override\n        public void add(long value) throws IOException {\n          long delta = value - minValue;\n          SimpleTextUtil.write(data, encoder.format(delta), scratch);\n          SimpleTextUtil.writeNewline(data);\n          numDocsWritten++;\n        }\n\n        @Override\n        public void finish(FieldInfos fieldInfos, int numDocs) throws IOException {\n          assert numDocs == numDocsWritten;\n          // nocommit: hopefully indexwriter is responsible for \"filling\" like it does stored fields!\n        }\n      };\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"13b40d7b5a40b306d198a2c868823813753fc679","date":1352958277,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,long,long).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,long,long).mjava","sourceNew":"    @Override\n    public NumericDocValuesConsumer addNumericField(FieldInfo field, final long minValue, long maxValue) throws IOException {\n      writeFieldEntry(field);\n      \n      // write our minimum value to the .dat, all entries are deltas from that\n      SimpleTextUtil.write(data, MINVALUE);\n      SimpleTextUtil.write(data, Long.toString(minValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      // build up our fixed-width \"simple text packed ints\" format\n      int maxBytesPerValue = BigInteger.valueOf(maxValue).subtract(BigInteger.valueOf(minValue)).toString().length();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < maxBytesPerValue; i++) {\n        sb.append('0');\n      }\n      \n      // write our pattern to the .dat\n      SimpleTextUtil.write(data, PATTERN);\n      SimpleTextUtil.write(data, sb.toString(), scratch);\n      SimpleTextUtil.writeNewline(data);\n      \n      final DecimalFormat encoder = new DecimalFormat(sb.toString(), new DecimalFormatSymbols(Locale.ROOT));\n      return new NumericDocValuesConsumer() {\n        int numDocsWritten = 0;\n\n        @Override\n        public void add(long value) throws IOException {\n          Number delta = BigInteger.valueOf(value).subtract(BigInteger.valueOf(minValue));\n          SimpleTextUtil.write(data, encoder.format(delta), scratch);\n          SimpleTextUtil.writeNewline(data);\n          numDocsWritten++;\n        }\n\n        @Override\n        public void finish(FieldInfos fieldInfos, int numDocs) throws IOException {\n          assert numDocs == numDocsWritten;\n          // nocommit: hopefully indexwriter is responsible for \"filling\" like it does stored fields!\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public NumericDocValuesConsumer addNumericField(FieldInfo field, final long minValue, long maxValue) throws IOException {\n      writeFieldEntry(field);\n      \n      // write our minimum value to the .dat, all entries are deltas from that\n      SimpleTextUtil.write(data, MINVALUE);\n      SimpleTextUtil.write(data, Long.toString(minValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      // build up our fixed-width \"simple text packed ints\" format\n      int maxBytesPerValue = Long.toString(maxValue - minValue).length();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < maxBytesPerValue; i++) {\n        sb.append('0');\n      }\n      \n      // write our pattern to the .dat\n      SimpleTextUtil.write(data, PATTERN);\n      SimpleTextUtil.write(data, sb.toString(), scratch);\n      SimpleTextUtil.writeNewline(data);\n      \n      final DecimalFormat encoder = new DecimalFormat(sb.toString(), new DecimalFormatSymbols(Locale.ROOT));\n      return new NumericDocValuesConsumer() {\n        int numDocsWritten = 0;\n\n        @Override\n        public void add(long value) throws IOException {\n          long delta = value - minValue;\n          SimpleTextUtil.write(data, encoder.format(delta), scratch);\n          SimpleTextUtil.writeNewline(data);\n          numDocsWritten++;\n        }\n\n        @Override\n        public void finish(FieldInfos fieldInfos, int numDocs) throws IOException {\n          assert numDocs == numDocsWritten;\n          // nocommit: hopefully indexwriter is responsible for \"filling\" like it does stored fields!\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ce73f585d17f53055185a19beb46db23d76e0ad9","date":1353077110,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,long,long,int).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,long,long).mjava","sourceNew":"    @Override\n    public NumericDocValuesConsumer addNumericField(FieldInfo field, final long minValue, long maxValue, final int numDocs) throws IOException {\n      writeFieldEntry(field);\n      \n      // write our minimum value to the .dat, all entries are deltas from that\n      SimpleTextUtil.write(data, MINVALUE);\n      SimpleTextUtil.write(data, Long.toString(minValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      // build up our fixed-width \"simple text packed ints\" format\n      int maxBytesPerValue = BigInteger.valueOf(maxValue).subtract(BigInteger.valueOf(minValue)).toString().length();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < maxBytesPerValue; i++) {\n        sb.append('0');\n      }\n      \n      // write our pattern to the .dat\n      SimpleTextUtil.write(data, PATTERN);\n      SimpleTextUtil.write(data, sb.toString(), scratch);\n      SimpleTextUtil.writeNewline(data);\n      \n      final DecimalFormat encoder = new DecimalFormat(sb.toString(), new DecimalFormatSymbols(Locale.ROOT));\n      return new NumericDocValuesConsumer() {\n        int numDocsWritten = 0;\n\n        @Override\n        public void add(long value) throws IOException {\n          Number delta = BigInteger.valueOf(value).subtract(BigInteger.valueOf(minValue));\n          SimpleTextUtil.write(data, encoder.format(delta), scratch);\n          SimpleTextUtil.writeNewline(data);\n          numDocsWritten++;\n        }\n\n        @Override\n        public void finish() throws IOException {\n          assert numDocs == numDocsWritten;\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public NumericDocValuesConsumer addNumericField(FieldInfo field, final long minValue, long maxValue) throws IOException {\n      writeFieldEntry(field);\n      \n      // write our minimum value to the .dat, all entries are deltas from that\n      SimpleTextUtil.write(data, MINVALUE);\n      SimpleTextUtil.write(data, Long.toString(minValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      // build up our fixed-width \"simple text packed ints\" format\n      int maxBytesPerValue = BigInteger.valueOf(maxValue).subtract(BigInteger.valueOf(minValue)).toString().length();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < maxBytesPerValue; i++) {\n        sb.append('0');\n      }\n      \n      // write our pattern to the .dat\n      SimpleTextUtil.write(data, PATTERN);\n      SimpleTextUtil.write(data, sb.toString(), scratch);\n      SimpleTextUtil.writeNewline(data);\n      \n      final DecimalFormat encoder = new DecimalFormat(sb.toString(), new DecimalFormatSymbols(Locale.ROOT));\n      return new NumericDocValuesConsumer() {\n        int numDocsWritten = 0;\n\n        @Override\n        public void add(long value) throws IOException {\n          Number delta = BigInteger.valueOf(value).subtract(BigInteger.valueOf(minValue));\n          SimpleTextUtil.write(data, encoder.format(delta), scratch);\n          SimpleTextUtil.writeNewline(data);\n          numDocsWritten++;\n        }\n\n        @Override\n        public void finish(FieldInfos fieldInfos, int numDocs) throws IOException {\n          assert numDocs == numDocsWritten;\n          // nocommit: hopefully indexwriter is responsible for \"filling\" like it does stored fields!\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f176b7bac2a187d69335c079b1f923449fb2881f","date":1353257308,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,long,long).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,long,long,int).mjava","sourceNew":"    @Override\n    public NumericDocValuesConsumer addNumericField(FieldInfo field, final long minValue, long maxValue) throws IOException {\n      writeFieldEntry(field);\n      \n      // write our minimum value to the .dat, all entries are deltas from that\n      SimpleTextUtil.write(data, MINVALUE);\n      SimpleTextUtil.write(data, Long.toString(minValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      // build up our fixed-width \"simple text packed ints\" format\n      int maxBytesPerValue = BigInteger.valueOf(maxValue).subtract(BigInteger.valueOf(minValue)).toString().length();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < maxBytesPerValue; i++) {\n        sb.append('0');\n      }\n      \n      // write our pattern to the .dat\n      SimpleTextUtil.write(data, PATTERN);\n      SimpleTextUtil.write(data, sb.toString(), scratch);\n      SimpleTextUtil.writeNewline(data);\n      \n      final DecimalFormat encoder = new DecimalFormat(sb.toString(), new DecimalFormatSymbols(Locale.ROOT));\n      return new NumericDocValuesConsumer() {\n        int numDocsWritten = 0;\n\n        @Override\n        public void add(long value) throws IOException {\n          Number delta = BigInteger.valueOf(value).subtract(BigInteger.valueOf(minValue));\n          SimpleTextUtil.write(data, encoder.format(delta), scratch);\n          SimpleTextUtil.writeNewline(data);\n          numDocsWritten++;\n        }\n\n        @Override\n        public void finish() throws IOException {\n          assert numDocs == numDocsWritten;\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public NumericDocValuesConsumer addNumericField(FieldInfo field, final long minValue, long maxValue, final int numDocs) throws IOException {\n      writeFieldEntry(field);\n      \n      // write our minimum value to the .dat, all entries are deltas from that\n      SimpleTextUtil.write(data, MINVALUE);\n      SimpleTextUtil.write(data, Long.toString(minValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      // build up our fixed-width \"simple text packed ints\" format\n      int maxBytesPerValue = BigInteger.valueOf(maxValue).subtract(BigInteger.valueOf(minValue)).toString().length();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < maxBytesPerValue; i++) {\n        sb.append('0');\n      }\n      \n      // write our pattern to the .dat\n      SimpleTextUtil.write(data, PATTERN);\n      SimpleTextUtil.write(data, sb.toString(), scratch);\n      SimpleTextUtil.writeNewline(data);\n      \n      final DecimalFormat encoder = new DecimalFormat(sb.toString(), new DecimalFormatSymbols(Locale.ROOT));\n      return new NumericDocValuesConsumer() {\n        int numDocsWritten = 0;\n\n        @Override\n        public void add(long value) throws IOException {\n          Number delta = BigInteger.valueOf(value).subtract(BigInteger.valueOf(minValue));\n          SimpleTextUtil.write(data, encoder.format(delta), scratch);\n          SimpleTextUtil.writeNewline(data);\n          numDocsWritten++;\n        }\n\n        @Override\n        public void finish() throws IOException {\n          assert numDocs == numDocsWritten;\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1ed65f3455364344c6d2ff76ea5421aac754eae7","date":1353261762,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,long,long).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,long,long).mjava","sourceNew":"    @Override\n    public NumericDocValuesConsumer addNumericField(FieldInfo field, final long minValue, long maxValue) throws IOException {\n      writeFieldEntry(field);\n      \n      // write our minimum value to the .dat, all entries are deltas from that\n      SimpleTextUtil.write(data, MINVALUE);\n      SimpleTextUtil.write(data, Long.toString(minValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      // build up our fixed-width \"simple text packed ints\" format\n      int maxBytesPerValue = BigInteger.valueOf(maxValue).subtract(BigInteger.valueOf(minValue)).toString().length();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < maxBytesPerValue; i++) {\n        sb.append('0');\n      }\n      \n      // write our pattern to the .dat\n      SimpleTextUtil.write(data, PATTERN);\n      SimpleTextUtil.write(data, sb.toString(), scratch);\n      SimpleTextUtil.writeNewline(data);\n      \n      final DecimalFormat encoder = new DecimalFormat(sb.toString(), new DecimalFormatSymbols(Locale.ROOT));\n      return new NumericDocValuesConsumer() {\n        int numDocsWritten = 0;\n\n        @Override\n        public void add(long value) throws IOException {\n          assert value >= minValue;\n          Number delta = BigInteger.valueOf(value).subtract(BigInteger.valueOf(minValue));\n          SimpleTextUtil.write(data, encoder.format(delta), scratch);\n          SimpleTextUtil.writeNewline(data);\n          numDocsWritten++;\n        }\n\n        @Override\n        public void finish() throws IOException {\n          assert numDocs == numDocsWritten;\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public NumericDocValuesConsumer addNumericField(FieldInfo field, final long minValue, long maxValue) throws IOException {\n      writeFieldEntry(field);\n      \n      // write our minimum value to the .dat, all entries are deltas from that\n      SimpleTextUtil.write(data, MINVALUE);\n      SimpleTextUtil.write(data, Long.toString(minValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      // build up our fixed-width \"simple text packed ints\" format\n      int maxBytesPerValue = BigInteger.valueOf(maxValue).subtract(BigInteger.valueOf(minValue)).toString().length();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < maxBytesPerValue; i++) {\n        sb.append('0');\n      }\n      \n      // write our pattern to the .dat\n      SimpleTextUtil.write(data, PATTERN);\n      SimpleTextUtil.write(data, sb.toString(), scratch);\n      SimpleTextUtil.writeNewline(data);\n      \n      final DecimalFormat encoder = new DecimalFormat(sb.toString(), new DecimalFormatSymbols(Locale.ROOT));\n      return new NumericDocValuesConsumer() {\n        int numDocsWritten = 0;\n\n        @Override\n        public void add(long value) throws IOException {\n          Number delta = BigInteger.valueOf(value).subtract(BigInteger.valueOf(minValue));\n          SimpleTextUtil.write(data, encoder.format(delta), scratch);\n          SimpleTextUtil.writeNewline(data);\n          numDocsWritten++;\n        }\n\n        @Override\n        public void finish() throws IOException {\n          assert numDocs == numDocsWritten;\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3ee07e8e258de164ee9346427b4307823c0b041d","date":1353263551,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,long,long).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,long,long).mjava","sourceNew":"    @Override\n    public NumericDocValuesConsumer addNumericField(FieldInfo field, final long minValue, long maxValue) throws IOException {\n      writeFieldEntry(field);\n      \n      // write our minimum value to the .dat, all entries are deltas from that\n      SimpleTextUtil.write(data, MINVALUE);\n      SimpleTextUtil.write(data, Long.toString(minValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      assert maxValue >= minValue;\n\n      // build up our fixed-width \"simple text packed ints\"\n      // format\n      BigInteger maxBig = BigInteger.valueOf(maxValue);\n      BigInteger minBig = BigInteger.valueOf(minValue);\n      BigInteger diffBig = maxBig.subtract(minBig);\n      int maxBytesPerValue = diffBig.toString().length();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < maxBytesPerValue; i++) {\n        sb.append('0');\n      }\n      \n      // write our pattern to the .dat\n      SimpleTextUtil.write(data, PATTERN);\n      SimpleTextUtil.write(data, sb.toString(), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      final String patternString = sb.toString();\n      \n      final DecimalFormat encoder = new DecimalFormat(patternString, new DecimalFormatSymbols(Locale.ROOT));\n      return new NumericDocValuesConsumer() {\n        int numDocsWritten = 0;\n\n        @Override\n        public void add(long value) throws IOException {\n          assert value >= minValue;\n          Number delta = BigInteger.valueOf(value).subtract(BigInteger.valueOf(minValue));\n          String s = encoder.format(delta);\n          assert s.length() == patternString.length();\n          SimpleTextUtil.write(data, s, scratch);\n          SimpleTextUtil.writeNewline(data);\n          numDocsWritten++;\n        }\n\n        @Override\n        public void finish() throws IOException {\n          assert numDocs == numDocsWritten;\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public NumericDocValuesConsumer addNumericField(FieldInfo field, final long minValue, long maxValue) throws IOException {\n      writeFieldEntry(field);\n      \n      // write our minimum value to the .dat, all entries are deltas from that\n      SimpleTextUtil.write(data, MINVALUE);\n      SimpleTextUtil.write(data, Long.toString(minValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      // build up our fixed-width \"simple text packed ints\" format\n      int maxBytesPerValue = BigInteger.valueOf(maxValue).subtract(BigInteger.valueOf(minValue)).toString().length();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < maxBytesPerValue; i++) {\n        sb.append('0');\n      }\n      \n      // write our pattern to the .dat\n      SimpleTextUtil.write(data, PATTERN);\n      SimpleTextUtil.write(data, sb.toString(), scratch);\n      SimpleTextUtil.writeNewline(data);\n      \n      final DecimalFormat encoder = new DecimalFormat(sb.toString(), new DecimalFormatSymbols(Locale.ROOT));\n      return new NumericDocValuesConsumer() {\n        int numDocsWritten = 0;\n\n        @Override\n        public void add(long value) throws IOException {\n          assert value >= minValue;\n          Number delta = BigInteger.valueOf(value).subtract(BigInteger.valueOf(minValue));\n          SimpleTextUtil.write(data, encoder.format(delta), scratch);\n          SimpleTextUtil.writeNewline(data);\n          numDocsWritten++;\n        }\n\n        @Override\n        public void finish() throws IOException {\n          assert numDocs == numDocsWritten;\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83f7535831b82edd777d50f0276d244b3c9a4734","date":1353267152,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,long,long).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,long,long).mjava","sourceNew":"    @Override\n    public NumericDocValuesConsumer addNumericField(FieldInfo field, final long minValue, long maxValue) throws IOException {\n      assert fieldSeen(field.name);\n      writeFieldEntry(field);\n      \n      // write our minimum value to the .dat, all entries are deltas from that\n      SimpleTextUtil.write(data, MINVALUE);\n      SimpleTextUtil.write(data, Long.toString(minValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      assert maxValue >= minValue;\n\n      // build up our fixed-width \"simple text packed ints\"\n      // format\n      BigInteger maxBig = BigInteger.valueOf(maxValue);\n      BigInteger minBig = BigInteger.valueOf(minValue);\n      BigInteger diffBig = maxBig.subtract(minBig);\n      int maxBytesPerValue = diffBig.toString().length();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < maxBytesPerValue; i++) {\n        sb.append('0');\n      }\n      \n      // write our pattern to the .dat\n      SimpleTextUtil.write(data, PATTERN);\n      SimpleTextUtil.write(data, sb.toString(), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      final String patternString = sb.toString();\n      \n      final DecimalFormat encoder = new DecimalFormat(patternString, new DecimalFormatSymbols(Locale.ROOT));\n      return new NumericDocValuesConsumer() {\n        int numDocsWritten = 0;\n\n        @Override\n        public void add(long value) throws IOException {\n          assert value >= minValue;\n          Number delta = BigInteger.valueOf(value).subtract(BigInteger.valueOf(minValue));\n          String s = encoder.format(delta);\n          assert s.length() == patternString.length();\n          SimpleTextUtil.write(data, s, scratch);\n          SimpleTextUtil.writeNewline(data);\n          numDocsWritten++;\n          assert numDocsWritten <= numDocs;\n        }\n\n        @Override\n        public void finish() throws IOException {\n          assert numDocs == numDocsWritten: \"numDocs=\" + numDocs + \" numDocsWritten=\" + numDocsWritten;\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public NumericDocValuesConsumer addNumericField(FieldInfo field, final long minValue, long maxValue) throws IOException {\n      writeFieldEntry(field);\n      \n      // write our minimum value to the .dat, all entries are deltas from that\n      SimpleTextUtil.write(data, MINVALUE);\n      SimpleTextUtil.write(data, Long.toString(minValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      assert maxValue >= minValue;\n\n      // build up our fixed-width \"simple text packed ints\"\n      // format\n      BigInteger maxBig = BigInteger.valueOf(maxValue);\n      BigInteger minBig = BigInteger.valueOf(minValue);\n      BigInteger diffBig = maxBig.subtract(minBig);\n      int maxBytesPerValue = diffBig.toString().length();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < maxBytesPerValue; i++) {\n        sb.append('0');\n      }\n      \n      // write our pattern to the .dat\n      SimpleTextUtil.write(data, PATTERN);\n      SimpleTextUtil.write(data, sb.toString(), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      final String patternString = sb.toString();\n      \n      final DecimalFormat encoder = new DecimalFormat(patternString, new DecimalFormatSymbols(Locale.ROOT));\n      return new NumericDocValuesConsumer() {\n        int numDocsWritten = 0;\n\n        @Override\n        public void add(long value) throws IOException {\n          assert value >= minValue;\n          Number delta = BigInteger.valueOf(value).subtract(BigInteger.valueOf(minValue));\n          String s = encoder.format(delta);\n          assert s.length() == patternString.length();\n          SimpleTextUtil.write(data, s, scratch);\n          SimpleTextUtil.writeNewline(data);\n          numDocsWritten++;\n        }\n\n        @Override\n        public void finish() throws IOException {\n          assert numDocs == numDocsWritten;\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6837aa82c41dc48163e43628d0c3d29d47915b0","date":1353334604,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,long,long).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,long,long).mjava","sourceNew":"    @Override\n    public NumericDocValuesConsumer addNumericField(FieldInfo field, final long minValue, long maxValue) throws IOException {\n      assert fieldSeen(field.name);\n      writeFieldEntry(field);\n      \n      // write our minimum value to the .dat, all entries are deltas from that\n      SimpleTextUtil.write(data, MINVALUE);\n      SimpleTextUtil.write(data, Long.toString(minValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n      \n      SimpleTextUtil.write(data, MAXVALUE);\n      SimpleTextUtil.write(data, Long.toString(maxValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      assert maxValue >= minValue;\n\n      // build up our fixed-width \"simple text packed ints\"\n      // format\n      BigInteger maxBig = BigInteger.valueOf(maxValue);\n      BigInteger minBig = BigInteger.valueOf(minValue);\n      BigInteger diffBig = maxBig.subtract(minBig);\n      int maxBytesPerValue = diffBig.toString().length();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < maxBytesPerValue; i++) {\n        sb.append('0');\n      }\n      \n      // write our pattern to the .dat\n      SimpleTextUtil.write(data, PATTERN);\n      SimpleTextUtil.write(data, sb.toString(), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      final String patternString = sb.toString();\n      \n      final DecimalFormat encoder = new DecimalFormat(patternString, new DecimalFormatSymbols(Locale.ROOT));\n      return new NumericDocValuesConsumer() {\n        int numDocsWritten = 0;\n\n        @Override\n        public void add(long value) throws IOException {\n          assert value >= minValue;\n          Number delta = BigInteger.valueOf(value).subtract(BigInteger.valueOf(minValue));\n          String s = encoder.format(delta);\n          assert s.length() == patternString.length();\n          SimpleTextUtil.write(data, s, scratch);\n          SimpleTextUtil.writeNewline(data);\n          numDocsWritten++;\n          assert numDocsWritten <= numDocs;\n        }\n\n        @Override\n        public void finish() throws IOException {\n          assert numDocs == numDocsWritten: \"numDocs=\" + numDocs + \" numDocsWritten=\" + numDocsWritten;\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public NumericDocValuesConsumer addNumericField(FieldInfo field, final long minValue, long maxValue) throws IOException {\n      assert fieldSeen(field.name);\n      writeFieldEntry(field);\n      \n      // write our minimum value to the .dat, all entries are deltas from that\n      SimpleTextUtil.write(data, MINVALUE);\n      SimpleTextUtil.write(data, Long.toString(minValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      assert maxValue >= minValue;\n\n      // build up our fixed-width \"simple text packed ints\"\n      // format\n      BigInteger maxBig = BigInteger.valueOf(maxValue);\n      BigInteger minBig = BigInteger.valueOf(minValue);\n      BigInteger diffBig = maxBig.subtract(minBig);\n      int maxBytesPerValue = diffBig.toString().length();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < maxBytesPerValue; i++) {\n        sb.append('0');\n      }\n      \n      // write our pattern to the .dat\n      SimpleTextUtil.write(data, PATTERN);\n      SimpleTextUtil.write(data, sb.toString(), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      final String patternString = sb.toString();\n      \n      final DecimalFormat encoder = new DecimalFormat(patternString, new DecimalFormatSymbols(Locale.ROOT));\n      return new NumericDocValuesConsumer() {\n        int numDocsWritten = 0;\n\n        @Override\n        public void add(long value) throws IOException {\n          assert value >= minValue;\n          Number delta = BigInteger.valueOf(value).subtract(BigInteger.valueOf(minValue));\n          String s = encoder.format(delta);\n          assert s.length() == patternString.length();\n          SimpleTextUtil.write(data, s, scratch);\n          SimpleTextUtil.writeNewline(data);\n          numDocsWritten++;\n          assert numDocsWritten <= numDocs;\n        }\n\n        @Override\n        public void finish() throws IOException {\n          assert numDocs == numDocsWritten: \"numDocs=\" + numDocs + \" numDocsWritten=\" + numDocsWritten;\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e29774db46ad98ca4a8d7fcbfab633ebc01f358","date":1355170812,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,long,long).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,long,long).mjava","sourceNew":"    @Override\n    public NumericDocValuesConsumer addNumericField(FieldInfo field, final long minValue, long maxValue) throws IOException {\n      assert fieldSeen(field.name);\n      assert (field.getDocValuesType() == null || DocValues.isNumber(field.getDocValuesType()) || DocValues.isFloat(field.getDocValuesType())) &&\n        (field.getNormType() == null || DocValues.isNumber(field.getNormType()) || DocValues.isFloat(field.getNormType()));\n      writeFieldEntry(field);\n      \n      // write our minimum value to the .dat, all entries are deltas from that\n      SimpleTextUtil.write(data, MINVALUE);\n      SimpleTextUtil.write(data, Long.toString(minValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n      \n      SimpleTextUtil.write(data, MAXVALUE);\n      SimpleTextUtil.write(data, Long.toString(maxValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      assert maxValue >= minValue;\n\n      // build up our fixed-width \"simple text packed ints\"\n      // format\n      BigInteger maxBig = BigInteger.valueOf(maxValue);\n      BigInteger minBig = BigInteger.valueOf(minValue);\n      BigInteger diffBig = maxBig.subtract(minBig);\n      int maxBytesPerValue = diffBig.toString().length();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < maxBytesPerValue; i++) {\n        sb.append('0');\n      }\n      \n      // write our pattern to the .dat\n      SimpleTextUtil.write(data, PATTERN);\n      SimpleTextUtil.write(data, sb.toString(), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      final String patternString = sb.toString();\n      \n      final DecimalFormat encoder = new DecimalFormat(patternString, new DecimalFormatSymbols(Locale.ROOT));\n      return new NumericDocValuesConsumer() {\n        int numDocsWritten = 0;\n\n        @Override\n        public void add(long value) throws IOException {\n          assert value >= minValue;\n          Number delta = BigInteger.valueOf(value).subtract(BigInteger.valueOf(minValue));\n          String s = encoder.format(delta);\n          assert s.length() == patternString.length();\n          SimpleTextUtil.write(data, s, scratch);\n          SimpleTextUtil.writeNewline(data);\n          numDocsWritten++;\n          assert numDocsWritten <= numDocs;\n        }\n\n        @Override\n        public void finish() throws IOException {\n          assert numDocs == numDocsWritten: \"numDocs=\" + numDocs + \" numDocsWritten=\" + numDocsWritten;\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public NumericDocValuesConsumer addNumericField(FieldInfo field, final long minValue, long maxValue) throws IOException {\n      assert fieldSeen(field.name);\n      writeFieldEntry(field);\n      \n      // write our minimum value to the .dat, all entries are deltas from that\n      SimpleTextUtil.write(data, MINVALUE);\n      SimpleTextUtil.write(data, Long.toString(minValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n      \n      SimpleTextUtil.write(data, MAXVALUE);\n      SimpleTextUtil.write(data, Long.toString(maxValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      assert maxValue >= minValue;\n\n      // build up our fixed-width \"simple text packed ints\"\n      // format\n      BigInteger maxBig = BigInteger.valueOf(maxValue);\n      BigInteger minBig = BigInteger.valueOf(minValue);\n      BigInteger diffBig = maxBig.subtract(minBig);\n      int maxBytesPerValue = diffBig.toString().length();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < maxBytesPerValue; i++) {\n        sb.append('0');\n      }\n      \n      // write our pattern to the .dat\n      SimpleTextUtil.write(data, PATTERN);\n      SimpleTextUtil.write(data, sb.toString(), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      final String patternString = sb.toString();\n      \n      final DecimalFormat encoder = new DecimalFormat(patternString, new DecimalFormatSymbols(Locale.ROOT));\n      return new NumericDocValuesConsumer() {\n        int numDocsWritten = 0;\n\n        @Override\n        public void add(long value) throws IOException {\n          assert value >= minValue;\n          Number delta = BigInteger.valueOf(value).subtract(BigInteger.valueOf(minValue));\n          String s = encoder.format(delta);\n          assert s.length() == patternString.length();\n          SimpleTextUtil.write(data, s, scratch);\n          SimpleTextUtil.writeNewline(data);\n          numDocsWritten++;\n          assert numDocsWritten <= numDocs;\n        }\n\n        @Override\n        public void finish() throws IOException {\n          assert numDocs == numDocsWritten: \"numDocs=\" + numDocs + \" numDocsWritten=\" + numDocsWritten;\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c3d8c0d4f823611bf5e0142245503098724b5ade","date":1355175577,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,long,long).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,long,long).mjava","sourceNew":"    @Override\n    public NumericDocValuesConsumer addNumericField(FieldInfo field, final long minValue, long maxValue) throws IOException {\n      assert fieldSeen(field.name);\n      assert (field.getDocValuesType() != null && (DocValues.isNumber(field.getDocValuesType()) || DocValues.isFloat(field.getDocValuesType()))) ||\n        (field.getNormType() != null && (DocValues.isNumber(field.getNormType()) || DocValues.isFloat(field.getNormType())));\n      writeFieldEntry(field);\n      \n      // write our minimum value to the .dat, all entries are deltas from that\n      SimpleTextUtil.write(data, MINVALUE);\n      SimpleTextUtil.write(data, Long.toString(minValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n      \n      SimpleTextUtil.write(data, MAXVALUE);\n      SimpleTextUtil.write(data, Long.toString(maxValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      assert maxValue >= minValue;\n\n      // build up our fixed-width \"simple text packed ints\"\n      // format\n      BigInteger maxBig = BigInteger.valueOf(maxValue);\n      BigInteger minBig = BigInteger.valueOf(minValue);\n      BigInteger diffBig = maxBig.subtract(minBig);\n      int maxBytesPerValue = diffBig.toString().length();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < maxBytesPerValue; i++) {\n        sb.append('0');\n      }\n      \n      // write our pattern to the .dat\n      SimpleTextUtil.write(data, PATTERN);\n      SimpleTextUtil.write(data, sb.toString(), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      final String patternString = sb.toString();\n      \n      final DecimalFormat encoder = new DecimalFormat(patternString, new DecimalFormatSymbols(Locale.ROOT));\n      return new NumericDocValuesConsumer() {\n        int numDocsWritten = 0;\n\n        @Override\n        public void add(long value) throws IOException {\n          assert value >= minValue;\n          Number delta = BigInteger.valueOf(value).subtract(BigInteger.valueOf(minValue));\n          String s = encoder.format(delta);\n          assert s.length() == patternString.length();\n          SimpleTextUtil.write(data, s, scratch);\n          SimpleTextUtil.writeNewline(data);\n          numDocsWritten++;\n          assert numDocsWritten <= numDocs;\n        }\n\n        @Override\n        public void finish() throws IOException {\n          assert numDocs == numDocsWritten: \"numDocs=\" + numDocs + \" numDocsWritten=\" + numDocsWritten;\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public NumericDocValuesConsumer addNumericField(FieldInfo field, final long minValue, long maxValue) throws IOException {\n      assert fieldSeen(field.name);\n      assert (field.getDocValuesType() == null || DocValues.isNumber(field.getDocValuesType()) || DocValues.isFloat(field.getDocValuesType())) &&\n        (field.getNormType() == null || DocValues.isNumber(field.getNormType()) || DocValues.isFloat(field.getNormType()));\n      writeFieldEntry(field);\n      \n      // write our minimum value to the .dat, all entries are deltas from that\n      SimpleTextUtil.write(data, MINVALUE);\n      SimpleTextUtil.write(data, Long.toString(minValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n      \n      SimpleTextUtil.write(data, MAXVALUE);\n      SimpleTextUtil.write(data, Long.toString(maxValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      assert maxValue >= minValue;\n\n      // build up our fixed-width \"simple text packed ints\"\n      // format\n      BigInteger maxBig = BigInteger.valueOf(maxValue);\n      BigInteger minBig = BigInteger.valueOf(minValue);\n      BigInteger diffBig = maxBig.subtract(minBig);\n      int maxBytesPerValue = diffBig.toString().length();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < maxBytesPerValue; i++) {\n        sb.append('0');\n      }\n      \n      // write our pattern to the .dat\n      SimpleTextUtil.write(data, PATTERN);\n      SimpleTextUtil.write(data, sb.toString(), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      final String patternString = sb.toString();\n      \n      final DecimalFormat encoder = new DecimalFormat(patternString, new DecimalFormatSymbols(Locale.ROOT));\n      return new NumericDocValuesConsumer() {\n        int numDocsWritten = 0;\n\n        @Override\n        public void add(long value) throws IOException {\n          assert value >= minValue;\n          Number delta = BigInteger.valueOf(value).subtract(BigInteger.valueOf(minValue));\n          String s = encoder.format(delta);\n          assert s.length() == patternString.length();\n          SimpleTextUtil.write(data, s, scratch);\n          SimpleTextUtil.writeNewline(data);\n          numDocsWritten++;\n          assert numDocsWritten <= numDocs;\n        }\n\n        @Override\n        public void finish() throws IOException {\n          assert numDocs == numDocsWritten: \"numDocs=\" + numDocs + \" numDocsWritten=\" + numDocsWritten;\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30664cb1b9c7d634d5001fa13052e8adb962ea7c","date":1355178731,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,long,long).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,long,long).mjava","sourceNew":"    @Override\n    public NumericDocValuesConsumer addNumericField(FieldInfo field, final long minValue, long maxValue) throws IOException {\n      assert fieldSeen(field.name);\n      assert (field.getDocValuesType() != null && (DocValues.isNumber(field.getDocValuesType()) || DocValues.isFloat(field.getDocValuesType()))) ||\n        (field.getNormType() != null && (DocValues.isNumber(field.getNormType()) || DocValues.isFloat(field.getNormType()))): \"field=\" + field.name;\n      writeFieldEntry(field);\n      \n      // write our minimum value to the .dat, all entries are deltas from that\n      SimpleTextUtil.write(data, MINVALUE);\n      SimpleTextUtil.write(data, Long.toString(minValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n      \n      SimpleTextUtil.write(data, MAXVALUE);\n      SimpleTextUtil.write(data, Long.toString(maxValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      assert maxValue >= minValue;\n\n      // build up our fixed-width \"simple text packed ints\"\n      // format\n      BigInteger maxBig = BigInteger.valueOf(maxValue);\n      BigInteger minBig = BigInteger.valueOf(minValue);\n      BigInteger diffBig = maxBig.subtract(minBig);\n      int maxBytesPerValue = diffBig.toString().length();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < maxBytesPerValue; i++) {\n        sb.append('0');\n      }\n      \n      // write our pattern to the .dat\n      SimpleTextUtil.write(data, PATTERN);\n      SimpleTextUtil.write(data, sb.toString(), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      final String patternString = sb.toString();\n      \n      final DecimalFormat encoder = new DecimalFormat(patternString, new DecimalFormatSymbols(Locale.ROOT));\n      return new NumericDocValuesConsumer() {\n        int numDocsWritten = 0;\n\n        @Override\n        public void add(long value) throws IOException {\n          assert value >= minValue;\n          Number delta = BigInteger.valueOf(value).subtract(BigInteger.valueOf(minValue));\n          String s = encoder.format(delta);\n          assert s.length() == patternString.length();\n          SimpleTextUtil.write(data, s, scratch);\n          SimpleTextUtil.writeNewline(data);\n          numDocsWritten++;\n          assert numDocsWritten <= numDocs;\n        }\n\n        @Override\n        public void finish() throws IOException {\n          assert numDocs == numDocsWritten: \"numDocs=\" + numDocs + \" numDocsWritten=\" + numDocsWritten;\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public NumericDocValuesConsumer addNumericField(FieldInfo field, final long minValue, long maxValue) throws IOException {\n      assert fieldSeen(field.name);\n      assert (field.getDocValuesType() != null && (DocValues.isNumber(field.getDocValuesType()) || DocValues.isFloat(field.getDocValuesType()))) ||\n        (field.getNormType() != null && (DocValues.isNumber(field.getNormType()) || DocValues.isFloat(field.getNormType())));\n      writeFieldEntry(field);\n      \n      // write our minimum value to the .dat, all entries are deltas from that\n      SimpleTextUtil.write(data, MINVALUE);\n      SimpleTextUtil.write(data, Long.toString(minValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n      \n      SimpleTextUtil.write(data, MAXVALUE);\n      SimpleTextUtil.write(data, Long.toString(maxValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      assert maxValue >= minValue;\n\n      // build up our fixed-width \"simple text packed ints\"\n      // format\n      BigInteger maxBig = BigInteger.valueOf(maxValue);\n      BigInteger minBig = BigInteger.valueOf(minValue);\n      BigInteger diffBig = maxBig.subtract(minBig);\n      int maxBytesPerValue = diffBig.toString().length();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < maxBytesPerValue; i++) {\n        sb.append('0');\n      }\n      \n      // write our pattern to the .dat\n      SimpleTextUtil.write(data, PATTERN);\n      SimpleTextUtil.write(data, sb.toString(), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      final String patternString = sb.toString();\n      \n      final DecimalFormat encoder = new DecimalFormat(patternString, new DecimalFormatSymbols(Locale.ROOT));\n      return new NumericDocValuesConsumer() {\n        int numDocsWritten = 0;\n\n        @Override\n        public void add(long value) throws IOException {\n          assert value >= minValue;\n          Number delta = BigInteger.valueOf(value).subtract(BigInteger.valueOf(minValue));\n          String s = encoder.format(delta);\n          assert s.length() == patternString.length();\n          SimpleTextUtil.write(data, s, scratch);\n          SimpleTextUtil.writeNewline(data);\n          numDocsWritten++;\n          assert numDocsWritten <= numDocs;\n        }\n\n        @Override\n        public void finish() throws IOException {\n          assert numDocs == numDocsWritten: \"numDocs=\" + numDocs + \" numDocsWritten=\" + numDocsWritten;\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"32fb848e256860b63adc9c2b068f386032c77b67","date":1357587205,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,Iterable[Number]).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesWriter#addNumericField(FieldInfo,long,long).mjava","sourceNew":"    @Override\n    public void addNumericField(FieldInfo field, Iterable<Number> values) throws IOException {\n      assert fieldSeen(field.name);\n      assert (field.getDocValuesType() != null && (DocValues.isNumber(field.getDocValuesType()) || DocValues.isFloat(field.getDocValuesType()))) ||\n        (field.getNormType() != null && (DocValues.isNumber(field.getNormType()) || DocValues.isFloat(field.getNormType()))): \"field=\" + field.name;\n      writeFieldEntry(field);\n\n      // first pass to find min/max\n      long minValue = Long.MAX_VALUE;\n      long maxValue = Long.MIN_VALUE;\n      for(Number n : values) {\n        long v = n.longValue();\n        minValue = Math.min(minValue, v);\n        maxValue = Math.max(maxValue, v);\n      }\n      \n      // write our minimum value to the .dat, all entries are deltas from that\n      SimpleTextUtil.write(data, MINVALUE);\n      SimpleTextUtil.write(data, Long.toString(minValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n      \n      // build up our fixed-width \"simple text packed ints\"\n      // format\n      BigInteger maxBig = BigInteger.valueOf(maxValue);\n      BigInteger minBig = BigInteger.valueOf(minValue);\n      BigInteger diffBig = maxBig.subtract(minBig);\n      int maxBytesPerValue = diffBig.toString().length();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < maxBytesPerValue; i++) {\n        sb.append('0');\n      }\n      \n      // write our pattern to the .dat\n      SimpleTextUtil.write(data, PATTERN);\n      SimpleTextUtil.write(data, sb.toString(), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      final String patternString = sb.toString();\n      \n      final DecimalFormat encoder = new DecimalFormat(patternString, new DecimalFormatSymbols(Locale.ROOT));\n      \n      int numDocsWritten = 0;\n\n      // second pass to write the values\n      for(Number n : values) {\n        long value = n.longValue();\n        assert value >= minValue;\n        Number delta = BigInteger.valueOf(value).subtract(BigInteger.valueOf(minValue));\n        String s = encoder.format(delta);\n        assert s.length() == patternString.length();\n        SimpleTextUtil.write(data, s, scratch);\n        SimpleTextUtil.writeNewline(data);\n        numDocsWritten++;\n        assert numDocsWritten <= numDocs;\n      }\n\n      assert numDocs == numDocsWritten: \"numDocs=\" + numDocs + \" numDocsWritten=\" + numDocsWritten;\n    }\n\n","sourceOld":"    @Override\n    public NumericDocValuesConsumer addNumericField(FieldInfo field, final long minValue, long maxValue) throws IOException {\n      assert fieldSeen(field.name);\n      assert (field.getDocValuesType() != null && (DocValues.isNumber(field.getDocValuesType()) || DocValues.isFloat(field.getDocValuesType()))) ||\n        (field.getNormType() != null && (DocValues.isNumber(field.getNormType()) || DocValues.isFloat(field.getNormType()))): \"field=\" + field.name;\n      writeFieldEntry(field);\n      \n      // write our minimum value to the .dat, all entries are deltas from that\n      SimpleTextUtil.write(data, MINVALUE);\n      SimpleTextUtil.write(data, Long.toString(minValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n      \n      SimpleTextUtil.write(data, MAXVALUE);\n      SimpleTextUtil.write(data, Long.toString(maxValue), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      assert maxValue >= minValue;\n\n      // build up our fixed-width \"simple text packed ints\"\n      // format\n      BigInteger maxBig = BigInteger.valueOf(maxValue);\n      BigInteger minBig = BigInteger.valueOf(minValue);\n      BigInteger diffBig = maxBig.subtract(minBig);\n      int maxBytesPerValue = diffBig.toString().length();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < maxBytesPerValue; i++) {\n        sb.append('0');\n      }\n      \n      // write our pattern to the .dat\n      SimpleTextUtil.write(data, PATTERN);\n      SimpleTextUtil.write(data, sb.toString(), scratch);\n      SimpleTextUtil.writeNewline(data);\n\n      final String patternString = sb.toString();\n      \n      final DecimalFormat encoder = new DecimalFormat(patternString, new DecimalFormatSymbols(Locale.ROOT));\n      return new NumericDocValuesConsumer() {\n        int numDocsWritten = 0;\n\n        @Override\n        public void add(long value) throws IOException {\n          assert value >= minValue;\n          Number delta = BigInteger.valueOf(value).subtract(BigInteger.valueOf(minValue));\n          String s = encoder.format(delta);\n          assert s.length() == patternString.length();\n          SimpleTextUtil.write(data, s, scratch);\n          SimpleTextUtil.writeNewline(data);\n          numDocsWritten++;\n          assert numDocsWritten <= numDocs;\n        }\n\n        @Override\n        public void finish() throws IOException {\n          assert numDocs == numDocsWritten: \"numDocs=\" + numDocs + \" numDocsWritten=\" + numDocsWritten;\n        }\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ce73f585d17f53055185a19beb46db23d76e0ad9":["13b40d7b5a40b306d198a2c868823813753fc679"],"1ed65f3455364344c6d2ff76ea5421aac754eae7":["f176b7bac2a187d69335c079b1f923449fb2881f"],"70a62ed2170ac1ef14886df1c66b89c9e4a68567":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"32fb848e256860b63adc9c2b068f386032c77b67":["30664cb1b9c7d634d5001fa13052e8adb962ea7c"],"f176b7bac2a187d69335c079b1f923449fb2881f":["ce73f585d17f53055185a19beb46db23d76e0ad9"],"13b40d7b5a40b306d198a2c868823813753fc679":["70a62ed2170ac1ef14886df1c66b89c9e4a68567"],"3e29774db46ad98ca4a8d7fcbfab633ebc01f358":["b6837aa82c41dc48163e43628d0c3d29d47915b0"],"83f7535831b82edd777d50f0276d244b3c9a4734":["3ee07e8e258de164ee9346427b4307823c0b041d"],"b6837aa82c41dc48163e43628d0c3d29d47915b0":["83f7535831b82edd777d50f0276d244b3c9a4734"],"3ee07e8e258de164ee9346427b4307823c0b041d":["1ed65f3455364344c6d2ff76ea5421aac754eae7"],"c3d8c0d4f823611bf5e0142245503098724b5ade":["3e29774db46ad98ca4a8d7fcbfab633ebc01f358"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"30664cb1b9c7d634d5001fa13052e8adb962ea7c":["c3d8c0d4f823611bf5e0142245503098724b5ade"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"ce73f585d17f53055185a19beb46db23d76e0ad9":["f176b7bac2a187d69335c079b1f923449fb2881f"],"1ed65f3455364344c6d2ff76ea5421aac754eae7":["3ee07e8e258de164ee9346427b4307823c0b041d"],"70a62ed2170ac1ef14886df1c66b89c9e4a68567":["13b40d7b5a40b306d198a2c868823813753fc679"],"f176b7bac2a187d69335c079b1f923449fb2881f":["1ed65f3455364344c6d2ff76ea5421aac754eae7"],"32fb848e256860b63adc9c2b068f386032c77b67":[],"13b40d7b5a40b306d198a2c868823813753fc679":["ce73f585d17f53055185a19beb46db23d76e0ad9"],"3e29774db46ad98ca4a8d7fcbfab633ebc01f358":["c3d8c0d4f823611bf5e0142245503098724b5ade"],"83f7535831b82edd777d50f0276d244b3c9a4734":["b6837aa82c41dc48163e43628d0c3d29d47915b0"],"b6837aa82c41dc48163e43628d0c3d29d47915b0":["3e29774db46ad98ca4a8d7fcbfab633ebc01f358"],"3ee07e8e258de164ee9346427b4307823c0b041d":["83f7535831b82edd777d50f0276d244b3c9a4734"],"c3d8c0d4f823611bf5e0142245503098724b5ade":["30664cb1b9c7d634d5001fa13052e8adb962ea7c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["70a62ed2170ac1ef14886df1c66b89c9e4a68567","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"30664cb1b9c7d634d5001fa13052e8adb962ea7c":["32fb848e256860b63adc9c2b068f386032c77b67"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["32fb848e256860b63adc9c2b068f386032c77b67","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}