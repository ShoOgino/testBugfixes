{"path":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#readDictionaryFiles(Directory,String,List[InputStream],CharsetDecoder,Builder[IntsRef]).mjava","commits":[{"id":"867e3d9153fb761456b54a9dcce566e1545c5ef6","date":1444903098,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#readDictionaryFiles(Directory,String,List[InputStream],CharsetDecoder,Builder[IntsRef]).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#readDictionaryFiles(List[InputStream],CharsetDecoder,Builder[IntsRef]).mjava","sourceNew":"  /**\n   * Reads the dictionary file through the provided InputStreams, building up the words map\n   *\n   * @param dictionaries InputStreams to read the dictionary file through\n   * @param decoder CharsetDecoder used to decode the contents of the file\n   * @throws IOException Can be thrown while reading from the file\n   */\n  private void readDictionaryFiles(Directory tempDir, String tempFileNamePrefix, List<InputStream> dictionaries, CharsetDecoder decoder, Builder<IntsRef> words) throws IOException {\n    BytesRefBuilder flagsScratch = new BytesRefBuilder();\n    IntsRefBuilder scratchInts = new IntsRefBuilder();\n    \n    StringBuilder sb = new StringBuilder();\n\n    IndexOutput unsorted = tempDir.createTempOutput(tempFileNamePrefix, \"dat\", IOContext.DEFAULT);\n    try (ByteSequencesWriter writer = new ByteSequencesWriter(unsorted)) {\n      for (InputStream dictionary : dictionaries) {\n        BufferedReader lines = new BufferedReader(new InputStreamReader(dictionary, decoder));\n        String line = lines.readLine(); // first line is number of entries (approximately, sometimes)\n        \n        while ((line = lines.readLine()) != null) {\n          // wild and unpredictable code comment rules\n          if (line.isEmpty() || line.charAt(0) == '/' || line.charAt(0) == '#' || line.charAt(0) == '\\t') {\n            continue;\n          }\n          line = unescapeEntry(line);\n          // if we havent seen any stem exceptions, try to parse one\n          if (hasStemExceptions == false) {\n            int morphStart = line.indexOf(MORPH_SEPARATOR);\n            if (morphStart >= 0 && morphStart < line.length()) {\n              hasStemExceptions = parseStemException(line.substring(morphStart+1)) != null;\n            }\n          }\n          if (needsInputCleaning) {\n            int flagSep = line.indexOf(FLAG_SEPARATOR);\n            if (flagSep == -1) {\n              flagSep = line.indexOf(MORPH_SEPARATOR);\n            }\n            if (flagSep == -1) {\n              CharSequence cleansed = cleanInput(line, sb);\n              writer.write(cleansed.toString().getBytes(StandardCharsets.UTF_8));\n            } else {\n              String text = line.substring(0, flagSep);\n              CharSequence cleansed = cleanInput(text, sb);\n              if (cleansed != sb) {\n                sb.setLength(0);\n                sb.append(cleansed);\n              }\n              sb.append(line.substring(flagSep));\n              writer.write(sb.toString().getBytes(StandardCharsets.UTF_8));\n            }\n          } else {\n            writer.write(line.getBytes(StandardCharsets.UTF_8));\n          }\n        }\n      }\n    }\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, new Comparator<BytesRef>() {\n      BytesRef scratch1 = new BytesRef();\n      BytesRef scratch2 = new BytesRef();\n      \n      @Override\n      public int compare(BytesRef o1, BytesRef o2) {\n        scratch1.bytes = o1.bytes;\n        scratch1.offset = o1.offset;\n        scratch1.length = o1.length;\n        \n        for (int i = scratch1.length - 1; i >= 0; i--) {\n          if (scratch1.bytes[scratch1.offset + i] == FLAG_SEPARATOR || scratch1.bytes[scratch1.offset + i] == MORPH_SEPARATOR) {\n            scratch1.length = i;\n            break;\n          }\n        }\n        \n        scratch2.bytes = o2.bytes;\n        scratch2.offset = o2.offset;\n        scratch2.length = o2.length;\n        \n        for (int i = scratch2.length - 1; i >= 0; i--) {\n          if (scratch2.bytes[scratch2.offset + i] == FLAG_SEPARATOR || scratch2.bytes[scratch2.offset + i] == MORPH_SEPARATOR) {\n            scratch2.length = i;\n            break;\n          }\n        }\n        \n        int cmp = scratch1.compareTo(scratch2);\n        if (cmp == 0) {\n          // tie break on whole row\n          return o1.compareTo(o2);\n        } else {\n          return cmp;\n        }\n      }\n    });\n\n    String sorted;\n    boolean success = false;\n    try {\n      sorted = sorter.sort(unsorted.getName());\n      success = true;\n    } finally {\n      if (success) {\n        tempDir.deleteFile(unsorted.getName());\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, unsorted.getName());\n      }\n    }\n    \n    boolean success2 = false;\n    \n    try (ByteSequencesReader reader = new ByteSequencesReader(tempDir.openInput(sorted, IOContext.READONCE))) {\n      BytesRefBuilder scratchLine = new BytesRefBuilder();\n    \n      // TODO: the flags themselves can be double-chars (long) or also numeric\n      // either way the trick is to encode them as char... but they must be parsed differently\n    \n      String currentEntry = null;\n      IntsRefBuilder currentOrds = new IntsRefBuilder();\n    \n      String line;\n      while (reader.read(scratchLine)) {\n        line = scratchLine.get().utf8ToString();\n        String entry;\n        char wordForm[];\n        int end;\n\n        int flagSep = line.indexOf(FLAG_SEPARATOR);\n        if (flagSep == -1) {\n          wordForm = NOFLAGS;\n          end = line.indexOf(MORPH_SEPARATOR);\n          entry = line.substring(0, end);\n        } else {\n          end = line.indexOf(MORPH_SEPARATOR);\n          String flagPart = line.substring(flagSep + 1, end);\n          if (aliasCount > 0) {\n            flagPart = getAliasValue(Integer.parseInt(flagPart));\n          } \n        \n          wordForm = flagParsingStrategy.parseFlags(flagPart);\n          Arrays.sort(wordForm);\n          entry = line.substring(0, flagSep);\n        }\n        // we possibly have morphological data\n        int stemExceptionID = 0;\n        if (hasStemExceptions && end+1 < line.length()) {\n          String stemException = parseStemException(line.substring(end+1));\n          if (stemException != null) {\n            if (stemExceptionCount == stemExceptions.length) {\n              int newSize = ArrayUtil.oversize(stemExceptionCount+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF);\n              stemExceptions = Arrays.copyOf(stemExceptions, newSize);\n            }\n            stemExceptionID = stemExceptionCount+1; // we use '0' to indicate no exception for the form\n            stemExceptions[stemExceptionCount++] = stemException;\n          }\n        }\n\n        int cmp = currentEntry == null ? 1 : entry.compareTo(currentEntry);\n        if (cmp < 0) {\n          throw new IllegalArgumentException(\"out of order: \" + entry + \" < \" + currentEntry);\n        } else {\n          encodeFlags(flagsScratch, wordForm);\n          int ord = flagLookup.add(flagsScratch.get());\n          if (ord < 0) {\n            // already exists in our hash\n            ord = (-ord)-1;\n          }\n          // finalize current entry, and switch \"current\" if necessary\n          if (cmp > 0 && currentEntry != null) {\n            Util.toUTF32(currentEntry, scratchInts);\n            words.add(scratchInts.get(), currentOrds.get());\n          }\n          // swap current\n          if (cmp > 0 || currentEntry == null) {\n            currentEntry = entry;\n            currentOrds = new IntsRefBuilder(); // must be this way\n          }\n          if (hasStemExceptions) {\n            currentOrds.append(ord);\n            currentOrds.append(stemExceptionID);\n          } else {\n            currentOrds.append(ord);\n          }\n        }\n      }\n    \n      // finalize last entry\n      Util.toUTF32(currentEntry, scratchInts);\n      words.add(scratchInts.get(), currentOrds.get());\n      success2 = true;\n    } finally {\n      if (success2) {\n        tempDir.deleteFile(sorted);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, sorted);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Reads the dictionary file through the provided InputStreams, building up the words map\n   *\n   * @param dictionaries InputStreams to read the dictionary file through\n   * @param decoder CharsetDecoder used to decode the contents of the file\n   * @throws IOException Can be thrown while reading from the file\n   */\n  private void readDictionaryFiles(List<InputStream> dictionaries, CharsetDecoder decoder, Builder<IntsRef> words) throws IOException {\n    BytesRefBuilder flagsScratch = new BytesRefBuilder();\n    IntsRefBuilder scratchInts = new IntsRefBuilder();\n    \n    StringBuilder sb = new StringBuilder();\n    \n    Path unsorted = Files.createTempFile(tempDir, \"unsorted\", \"dat\");\n    try (ByteSequencesWriter writer = new ByteSequencesWriter(unsorted)) {\n      for (InputStream dictionary : dictionaries) {\n        BufferedReader lines = new BufferedReader(new InputStreamReader(dictionary, decoder));\n        String line = lines.readLine(); // first line is number of entries (approximately, sometimes)\n        \n        while ((line = lines.readLine()) != null) {\n          // wild and unpredictable code comment rules\n          if (line.isEmpty() || line.charAt(0) == '/' || line.charAt(0) == '#' || line.charAt(0) == '\\t') {\n            continue;\n          }\n          line = unescapeEntry(line);\n          // if we havent seen any stem exceptions, try to parse one\n          if (hasStemExceptions == false) {\n            int morphStart = line.indexOf(MORPH_SEPARATOR);\n            if (morphStart >= 0 && morphStart < line.length()) {\n              hasStemExceptions = parseStemException(line.substring(morphStart+1)) != null;\n            }\n          }\n          if (needsInputCleaning) {\n            int flagSep = line.indexOf(FLAG_SEPARATOR);\n            if (flagSep == -1) {\n              flagSep = line.indexOf(MORPH_SEPARATOR);\n            }\n            if (flagSep == -1) {\n              CharSequence cleansed = cleanInput(line, sb);\n              writer.write(cleansed.toString().getBytes(StandardCharsets.UTF_8));\n            } else {\n              String text = line.substring(0, flagSep);\n              CharSequence cleansed = cleanInput(text, sb);\n              if (cleansed != sb) {\n                sb.setLength(0);\n                sb.append(cleansed);\n              }\n              sb.append(line.substring(flagSep));\n              writer.write(sb.toString().getBytes(StandardCharsets.UTF_8));\n            }\n          } else {\n            writer.write(line.getBytes(StandardCharsets.UTF_8));\n          }\n        }\n      }\n    }\n    Path sorted = Files.createTempFile(tempDir, \"sorted\", \"dat\");\n    \n    OfflineSorter sorter = new OfflineSorter(new Comparator<BytesRef>() {\n      BytesRef scratch1 = new BytesRef();\n      BytesRef scratch2 = new BytesRef();\n      \n      @Override\n      public int compare(BytesRef o1, BytesRef o2) {\n        scratch1.bytes = o1.bytes;\n        scratch1.offset = o1.offset;\n        scratch1.length = o1.length;\n        \n        for (int i = scratch1.length - 1; i >= 0; i--) {\n          if (scratch1.bytes[scratch1.offset + i] == FLAG_SEPARATOR || scratch1.bytes[scratch1.offset + i] == MORPH_SEPARATOR) {\n            scratch1.length = i;\n            break;\n          }\n        }\n        \n        scratch2.bytes = o2.bytes;\n        scratch2.offset = o2.offset;\n        scratch2.length = o2.length;\n        \n        for (int i = scratch2.length - 1; i >= 0; i--) {\n          if (scratch2.bytes[scratch2.offset + i] == FLAG_SEPARATOR || scratch2.bytes[scratch2.offset + i] == MORPH_SEPARATOR) {\n            scratch2.length = i;\n            break;\n          }\n        }\n        \n        int cmp = scratch1.compareTo(scratch2);\n        if (cmp == 0) {\n          // tie break on whole row\n          return o1.compareTo(o2);\n        } else {\n          return cmp;\n        }\n      }\n    });\n    boolean success = false;\n    try {\n      sorter.sort(unsorted, sorted);\n      success = true;\n    } finally {\n      if (success) {\n        Files.delete(unsorted);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(unsorted);\n      }\n    }\n    \n    boolean success2 = false;\n    ByteSequencesReader reader = new ByteSequencesReader(sorted);\n    try {\n      BytesRefBuilder scratchLine = new BytesRefBuilder();\n    \n      // TODO: the flags themselves can be double-chars (long) or also numeric\n      // either way the trick is to encode them as char... but they must be parsed differently\n    \n      String currentEntry = null;\n      IntsRefBuilder currentOrds = new IntsRefBuilder();\n    \n      String line;\n      while (reader.read(scratchLine)) {\n        line = scratchLine.get().utf8ToString();\n        String entry;\n        char wordForm[];\n        int end;\n\n        int flagSep = line.indexOf(FLAG_SEPARATOR);\n        if (flagSep == -1) {\n          wordForm = NOFLAGS;\n          end = line.indexOf(MORPH_SEPARATOR);\n          entry = line.substring(0, end);\n        } else {\n          end = line.indexOf(MORPH_SEPARATOR);\n          String flagPart = line.substring(flagSep + 1, end);\n          if (aliasCount > 0) {\n            flagPart = getAliasValue(Integer.parseInt(flagPart));\n          } \n        \n          wordForm = flagParsingStrategy.parseFlags(flagPart);\n          Arrays.sort(wordForm);\n          entry = line.substring(0, flagSep);\n        }\n        // we possibly have morphological data\n        int stemExceptionID = 0;\n        if (hasStemExceptions && end+1 < line.length()) {\n          String stemException = parseStemException(line.substring(end+1));\n          if (stemException != null) {\n            if (stemExceptionCount == stemExceptions.length) {\n              int newSize = ArrayUtil.oversize(stemExceptionCount+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF);\n              stemExceptions = Arrays.copyOf(stemExceptions, newSize);\n            }\n            stemExceptionID = stemExceptionCount+1; // we use '0' to indicate no exception for the form\n            stemExceptions[stemExceptionCount++] = stemException;\n          }\n        }\n\n        int cmp = currentEntry == null ? 1 : entry.compareTo(currentEntry);\n        if (cmp < 0) {\n          throw new IllegalArgumentException(\"out of order: \" + entry + \" < \" + currentEntry);\n        } else {\n          encodeFlags(flagsScratch, wordForm);\n          int ord = flagLookup.add(flagsScratch.get());\n          if (ord < 0) {\n            // already exists in our hash\n            ord = (-ord)-1;\n          }\n          // finalize current entry, and switch \"current\" if necessary\n          if (cmp > 0 && currentEntry != null) {\n            Util.toUTF32(currentEntry, scratchInts);\n            words.add(scratchInts.get(), currentOrds.get());\n          }\n          // swap current\n          if (cmp > 0 || currentEntry == null) {\n            currentEntry = entry;\n            currentOrds = new IntsRefBuilder(); // must be this way\n          }\n          if (hasStemExceptions) {\n            currentOrds.append(ord);\n            currentOrds.append(stemExceptionID);\n          } else {\n            currentOrds.append(ord);\n          }\n        }\n      }\n    \n      // finalize last entry\n      Util.toUTF32(currentEntry, scratchInts);\n      words.add(scratchInts.get(), currentOrds.get());\n      success2 = true;\n    } finally {\n      IOUtils.closeWhileHandlingException(reader);\n      if (success2) {\n        Files.delete(sorted);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(sorted);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bfe104fc023fadc9e709f8d17403d2cc61133fe","date":1454446396,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#readDictionaryFiles(Directory,String,List[InputStream],CharsetDecoder,Builder[IntsRef]).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#readDictionaryFiles(Directory,String,List[InputStream],CharsetDecoder,Builder[IntsRef]).mjava","sourceNew":"  /**\n   * Reads the dictionary file through the provided InputStreams, building up the words map\n   *\n   * @param dictionaries InputStreams to read the dictionary file through\n   * @param decoder CharsetDecoder used to decode the contents of the file\n   * @throws IOException Can be thrown while reading from the file\n   */\n  private void readDictionaryFiles(Directory tempDir, String tempFileNamePrefix, List<InputStream> dictionaries, CharsetDecoder decoder, Builder<IntsRef> words) throws IOException {\n    BytesRefBuilder flagsScratch = new BytesRefBuilder();\n    IntsRefBuilder scratchInts = new IntsRefBuilder();\n    \n    StringBuilder sb = new StringBuilder();\n\n    IndexOutput unsorted = tempDir.createTempOutput(tempFileNamePrefix, \"dat\", IOContext.DEFAULT);\n    try (ByteSequencesWriter writer = new ByteSequencesWriter(unsorted)) {\n      for (InputStream dictionary : dictionaries) {\n        BufferedReader lines = new BufferedReader(new InputStreamReader(dictionary, decoder));\n        String line = lines.readLine(); // first line is number of entries (approximately, sometimes)\n        \n        while ((line = lines.readLine()) != null) {\n          // wild and unpredictable code comment rules\n          if (line.isEmpty() || line.charAt(0) == '/' || line.charAt(0) == '#' || line.charAt(0) == '\\t') {\n            continue;\n          }\n          line = unescapeEntry(line);\n          // if we havent seen any stem exceptions, try to parse one\n          if (hasStemExceptions == false) {\n            int morphStart = line.indexOf(MORPH_SEPARATOR);\n            if (morphStart >= 0 && morphStart < line.length()) {\n              hasStemExceptions = parseStemException(line.substring(morphStart+1)) != null;\n            }\n          }\n          if (needsInputCleaning) {\n            int flagSep = line.indexOf(FLAG_SEPARATOR);\n            if (flagSep == -1) {\n              flagSep = line.indexOf(MORPH_SEPARATOR);\n            }\n            if (flagSep == -1) {\n              CharSequence cleansed = cleanInput(line, sb);\n              writer.write(cleansed.toString().getBytes(StandardCharsets.UTF_8));\n            } else {\n              String text = line.substring(0, flagSep);\n              CharSequence cleansed = cleanInput(text, sb);\n              if (cleansed != sb) {\n                sb.setLength(0);\n                sb.append(cleansed);\n              }\n              sb.append(line.substring(flagSep));\n              writer.write(sb.toString().getBytes(StandardCharsets.UTF_8));\n            }\n          } else {\n            writer.write(line.getBytes(StandardCharsets.UTF_8));\n          }\n        }\n      }\n    }\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, new Comparator<BytesRef>() {\n      BytesRef scratch1 = new BytesRef();\n      BytesRef scratch2 = new BytesRef();\n      \n      @Override\n      public int compare(BytesRef o1, BytesRef o2) {\n        scratch1.bytes = o1.bytes;\n        scratch1.offset = o1.offset;\n        scratch1.length = o1.length;\n        \n        for (int i = scratch1.length - 1; i >= 0; i--) {\n          if (scratch1.bytes[scratch1.offset + i] == FLAG_SEPARATOR || scratch1.bytes[scratch1.offset + i] == MORPH_SEPARATOR) {\n            scratch1.length = i;\n            break;\n          }\n        }\n        \n        scratch2.bytes = o2.bytes;\n        scratch2.offset = o2.offset;\n        scratch2.length = o2.length;\n        \n        for (int i = scratch2.length - 1; i >= 0; i--) {\n          if (scratch2.bytes[scratch2.offset + i] == FLAG_SEPARATOR || scratch2.bytes[scratch2.offset + i] == MORPH_SEPARATOR) {\n            scratch2.length = i;\n            break;\n          }\n        }\n        \n        int cmp = scratch1.compareTo(scratch2);\n        if (cmp == 0) {\n          // tie break on whole row\n          return o1.compareTo(o2);\n        } else {\n          return cmp;\n        }\n      }\n    });\n\n    String sorted;\n    boolean success = false;\n    try {\n      sorted = sorter.sort(unsorted.getName());\n      success = true;\n    } finally {\n      if (success) {\n        tempDir.deleteFiles(Collections.singleton(unsorted.getName()));\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, unsorted.getName());\n      }\n    }\n    \n    boolean success2 = false;\n    \n    try (ByteSequencesReader reader = new ByteSequencesReader(tempDir.openInput(sorted, IOContext.READONCE))) {\n      BytesRefBuilder scratchLine = new BytesRefBuilder();\n    \n      // TODO: the flags themselves can be double-chars (long) or also numeric\n      // either way the trick is to encode them as char... but they must be parsed differently\n    \n      String currentEntry = null;\n      IntsRefBuilder currentOrds = new IntsRefBuilder();\n    \n      String line;\n      while (reader.read(scratchLine)) {\n        line = scratchLine.get().utf8ToString();\n        String entry;\n        char wordForm[];\n        int end;\n\n        int flagSep = line.indexOf(FLAG_SEPARATOR);\n        if (flagSep == -1) {\n          wordForm = NOFLAGS;\n          end = line.indexOf(MORPH_SEPARATOR);\n          entry = line.substring(0, end);\n        } else {\n          end = line.indexOf(MORPH_SEPARATOR);\n          String flagPart = line.substring(flagSep + 1, end);\n          if (aliasCount > 0) {\n            flagPart = getAliasValue(Integer.parseInt(flagPart));\n          } \n        \n          wordForm = flagParsingStrategy.parseFlags(flagPart);\n          Arrays.sort(wordForm);\n          entry = line.substring(0, flagSep);\n        }\n        // we possibly have morphological data\n        int stemExceptionID = 0;\n        if (hasStemExceptions && end+1 < line.length()) {\n          String stemException = parseStemException(line.substring(end+1));\n          if (stemException != null) {\n            if (stemExceptionCount == stemExceptions.length) {\n              int newSize = ArrayUtil.oversize(stemExceptionCount+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF);\n              stemExceptions = Arrays.copyOf(stemExceptions, newSize);\n            }\n            stemExceptionID = stemExceptionCount+1; // we use '0' to indicate no exception for the form\n            stemExceptions[stemExceptionCount++] = stemException;\n          }\n        }\n\n        int cmp = currentEntry == null ? 1 : entry.compareTo(currentEntry);\n        if (cmp < 0) {\n          throw new IllegalArgumentException(\"out of order: \" + entry + \" < \" + currentEntry);\n        } else {\n          encodeFlags(flagsScratch, wordForm);\n          int ord = flagLookup.add(flagsScratch.get());\n          if (ord < 0) {\n            // already exists in our hash\n            ord = (-ord)-1;\n          }\n          // finalize current entry, and switch \"current\" if necessary\n          if (cmp > 0 && currentEntry != null) {\n            Util.toUTF32(currentEntry, scratchInts);\n            words.add(scratchInts.get(), currentOrds.get());\n          }\n          // swap current\n          if (cmp > 0 || currentEntry == null) {\n            currentEntry = entry;\n            currentOrds = new IntsRefBuilder(); // must be this way\n          }\n          if (hasStemExceptions) {\n            currentOrds.append(ord);\n            currentOrds.append(stemExceptionID);\n          } else {\n            currentOrds.append(ord);\n          }\n        }\n      }\n    \n      // finalize last entry\n      Util.toUTF32(currentEntry, scratchInts);\n      words.add(scratchInts.get(), currentOrds.get());\n      success2 = true;\n    } finally {\n      if (success2) {\n        tempDir.deleteFiles(Collections.singleton(sorted));\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, sorted);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Reads the dictionary file through the provided InputStreams, building up the words map\n   *\n   * @param dictionaries InputStreams to read the dictionary file through\n   * @param decoder CharsetDecoder used to decode the contents of the file\n   * @throws IOException Can be thrown while reading from the file\n   */\n  private void readDictionaryFiles(Directory tempDir, String tempFileNamePrefix, List<InputStream> dictionaries, CharsetDecoder decoder, Builder<IntsRef> words) throws IOException {\n    BytesRefBuilder flagsScratch = new BytesRefBuilder();\n    IntsRefBuilder scratchInts = new IntsRefBuilder();\n    \n    StringBuilder sb = new StringBuilder();\n\n    IndexOutput unsorted = tempDir.createTempOutput(tempFileNamePrefix, \"dat\", IOContext.DEFAULT);\n    try (ByteSequencesWriter writer = new ByteSequencesWriter(unsorted)) {\n      for (InputStream dictionary : dictionaries) {\n        BufferedReader lines = new BufferedReader(new InputStreamReader(dictionary, decoder));\n        String line = lines.readLine(); // first line is number of entries (approximately, sometimes)\n        \n        while ((line = lines.readLine()) != null) {\n          // wild and unpredictable code comment rules\n          if (line.isEmpty() || line.charAt(0) == '/' || line.charAt(0) == '#' || line.charAt(0) == '\\t') {\n            continue;\n          }\n          line = unescapeEntry(line);\n          // if we havent seen any stem exceptions, try to parse one\n          if (hasStemExceptions == false) {\n            int morphStart = line.indexOf(MORPH_SEPARATOR);\n            if (morphStart >= 0 && morphStart < line.length()) {\n              hasStemExceptions = parseStemException(line.substring(morphStart+1)) != null;\n            }\n          }\n          if (needsInputCleaning) {\n            int flagSep = line.indexOf(FLAG_SEPARATOR);\n            if (flagSep == -1) {\n              flagSep = line.indexOf(MORPH_SEPARATOR);\n            }\n            if (flagSep == -1) {\n              CharSequence cleansed = cleanInput(line, sb);\n              writer.write(cleansed.toString().getBytes(StandardCharsets.UTF_8));\n            } else {\n              String text = line.substring(0, flagSep);\n              CharSequence cleansed = cleanInput(text, sb);\n              if (cleansed != sb) {\n                sb.setLength(0);\n                sb.append(cleansed);\n              }\n              sb.append(line.substring(flagSep));\n              writer.write(sb.toString().getBytes(StandardCharsets.UTF_8));\n            }\n          } else {\n            writer.write(line.getBytes(StandardCharsets.UTF_8));\n          }\n        }\n      }\n    }\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, new Comparator<BytesRef>() {\n      BytesRef scratch1 = new BytesRef();\n      BytesRef scratch2 = new BytesRef();\n      \n      @Override\n      public int compare(BytesRef o1, BytesRef o2) {\n        scratch1.bytes = o1.bytes;\n        scratch1.offset = o1.offset;\n        scratch1.length = o1.length;\n        \n        for (int i = scratch1.length - 1; i >= 0; i--) {\n          if (scratch1.bytes[scratch1.offset + i] == FLAG_SEPARATOR || scratch1.bytes[scratch1.offset + i] == MORPH_SEPARATOR) {\n            scratch1.length = i;\n            break;\n          }\n        }\n        \n        scratch2.bytes = o2.bytes;\n        scratch2.offset = o2.offset;\n        scratch2.length = o2.length;\n        \n        for (int i = scratch2.length - 1; i >= 0; i--) {\n          if (scratch2.bytes[scratch2.offset + i] == FLAG_SEPARATOR || scratch2.bytes[scratch2.offset + i] == MORPH_SEPARATOR) {\n            scratch2.length = i;\n            break;\n          }\n        }\n        \n        int cmp = scratch1.compareTo(scratch2);\n        if (cmp == 0) {\n          // tie break on whole row\n          return o1.compareTo(o2);\n        } else {\n          return cmp;\n        }\n      }\n    });\n\n    String sorted;\n    boolean success = false;\n    try {\n      sorted = sorter.sort(unsorted.getName());\n      success = true;\n    } finally {\n      if (success) {\n        tempDir.deleteFile(unsorted.getName());\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, unsorted.getName());\n      }\n    }\n    \n    boolean success2 = false;\n    \n    try (ByteSequencesReader reader = new ByteSequencesReader(tempDir.openInput(sorted, IOContext.READONCE))) {\n      BytesRefBuilder scratchLine = new BytesRefBuilder();\n    \n      // TODO: the flags themselves can be double-chars (long) or also numeric\n      // either way the trick is to encode them as char... but they must be parsed differently\n    \n      String currentEntry = null;\n      IntsRefBuilder currentOrds = new IntsRefBuilder();\n    \n      String line;\n      while (reader.read(scratchLine)) {\n        line = scratchLine.get().utf8ToString();\n        String entry;\n        char wordForm[];\n        int end;\n\n        int flagSep = line.indexOf(FLAG_SEPARATOR);\n        if (flagSep == -1) {\n          wordForm = NOFLAGS;\n          end = line.indexOf(MORPH_SEPARATOR);\n          entry = line.substring(0, end);\n        } else {\n          end = line.indexOf(MORPH_SEPARATOR);\n          String flagPart = line.substring(flagSep + 1, end);\n          if (aliasCount > 0) {\n            flagPart = getAliasValue(Integer.parseInt(flagPart));\n          } \n        \n          wordForm = flagParsingStrategy.parseFlags(flagPart);\n          Arrays.sort(wordForm);\n          entry = line.substring(0, flagSep);\n        }\n        // we possibly have morphological data\n        int stemExceptionID = 0;\n        if (hasStemExceptions && end+1 < line.length()) {\n          String stemException = parseStemException(line.substring(end+1));\n          if (stemException != null) {\n            if (stemExceptionCount == stemExceptions.length) {\n              int newSize = ArrayUtil.oversize(stemExceptionCount+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF);\n              stemExceptions = Arrays.copyOf(stemExceptions, newSize);\n            }\n            stemExceptionID = stemExceptionCount+1; // we use '0' to indicate no exception for the form\n            stemExceptions[stemExceptionCount++] = stemException;\n          }\n        }\n\n        int cmp = currentEntry == null ? 1 : entry.compareTo(currentEntry);\n        if (cmp < 0) {\n          throw new IllegalArgumentException(\"out of order: \" + entry + \" < \" + currentEntry);\n        } else {\n          encodeFlags(flagsScratch, wordForm);\n          int ord = flagLookup.add(flagsScratch.get());\n          if (ord < 0) {\n            // already exists in our hash\n            ord = (-ord)-1;\n          }\n          // finalize current entry, and switch \"current\" if necessary\n          if (cmp > 0 && currentEntry != null) {\n            Util.toUTF32(currentEntry, scratchInts);\n            words.add(scratchInts.get(), currentOrds.get());\n          }\n          // swap current\n          if (cmp > 0 || currentEntry == null) {\n            currentEntry = entry;\n            currentOrds = new IntsRefBuilder(); // must be this way\n          }\n          if (hasStemExceptions) {\n            currentOrds.append(ord);\n            currentOrds.append(stemExceptionID);\n          } else {\n            currentOrds.append(ord);\n          }\n        }\n      }\n    \n      // finalize last entry\n      Util.toUTF32(currentEntry, scratchInts);\n      words.add(scratchInts.get(), currentOrds.get());\n      success2 = true;\n    } finally {\n      if (success2) {\n        tempDir.deleteFile(sorted);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, sorted);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1","date":1454513757,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#readDictionaryFiles(Directory,String,List[InputStream],CharsetDecoder,Builder[IntsRef]).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#readDictionaryFiles(Directory,String,List[InputStream],CharsetDecoder,Builder[IntsRef]).mjava","sourceNew":"  /**\n   * Reads the dictionary file through the provided InputStreams, building up the words map\n   *\n   * @param dictionaries InputStreams to read the dictionary file through\n   * @param decoder CharsetDecoder used to decode the contents of the file\n   * @throws IOException Can be thrown while reading from the file\n   */\n  private void readDictionaryFiles(Directory tempDir, String tempFileNamePrefix, List<InputStream> dictionaries, CharsetDecoder decoder, Builder<IntsRef> words) throws IOException {\n    BytesRefBuilder flagsScratch = new BytesRefBuilder();\n    IntsRefBuilder scratchInts = new IntsRefBuilder();\n    \n    StringBuilder sb = new StringBuilder();\n\n    IndexOutput unsorted = tempDir.createTempOutput(tempFileNamePrefix, \"dat\", IOContext.DEFAULT);\n    try (ByteSequencesWriter writer = new ByteSequencesWriter(unsorted)) {\n      for (InputStream dictionary : dictionaries) {\n        BufferedReader lines = new BufferedReader(new InputStreamReader(dictionary, decoder));\n        String line = lines.readLine(); // first line is number of entries (approximately, sometimes)\n        \n        while ((line = lines.readLine()) != null) {\n          // wild and unpredictable code comment rules\n          if (line.isEmpty() || line.charAt(0) == '/' || line.charAt(0) == '#' || line.charAt(0) == '\\t') {\n            continue;\n          }\n          line = unescapeEntry(line);\n          // if we havent seen any stem exceptions, try to parse one\n          if (hasStemExceptions == false) {\n            int morphStart = line.indexOf(MORPH_SEPARATOR);\n            if (morphStart >= 0 && morphStart < line.length()) {\n              hasStemExceptions = parseStemException(line.substring(morphStart+1)) != null;\n            }\n          }\n          if (needsInputCleaning) {\n            int flagSep = line.indexOf(FLAG_SEPARATOR);\n            if (flagSep == -1) {\n              flagSep = line.indexOf(MORPH_SEPARATOR);\n            }\n            if (flagSep == -1) {\n              CharSequence cleansed = cleanInput(line, sb);\n              writer.write(cleansed.toString().getBytes(StandardCharsets.UTF_8));\n            } else {\n              String text = line.substring(0, flagSep);\n              CharSequence cleansed = cleanInput(text, sb);\n              if (cleansed != sb) {\n                sb.setLength(0);\n                sb.append(cleansed);\n              }\n              sb.append(line.substring(flagSep));\n              writer.write(sb.toString().getBytes(StandardCharsets.UTF_8));\n            }\n          } else {\n            writer.write(line.getBytes(StandardCharsets.UTF_8));\n          }\n        }\n      }\n    }\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, new Comparator<BytesRef>() {\n      BytesRef scratch1 = new BytesRef();\n      BytesRef scratch2 = new BytesRef();\n      \n      @Override\n      public int compare(BytesRef o1, BytesRef o2) {\n        scratch1.bytes = o1.bytes;\n        scratch1.offset = o1.offset;\n        scratch1.length = o1.length;\n        \n        for (int i = scratch1.length - 1; i >= 0; i--) {\n          if (scratch1.bytes[scratch1.offset + i] == FLAG_SEPARATOR || scratch1.bytes[scratch1.offset + i] == MORPH_SEPARATOR) {\n            scratch1.length = i;\n            break;\n          }\n        }\n        \n        scratch2.bytes = o2.bytes;\n        scratch2.offset = o2.offset;\n        scratch2.length = o2.length;\n        \n        for (int i = scratch2.length - 1; i >= 0; i--) {\n          if (scratch2.bytes[scratch2.offset + i] == FLAG_SEPARATOR || scratch2.bytes[scratch2.offset + i] == MORPH_SEPARATOR) {\n            scratch2.length = i;\n            break;\n          }\n        }\n        \n        int cmp = scratch1.compareTo(scratch2);\n        if (cmp == 0) {\n          // tie break on whole row\n          return o1.compareTo(o2);\n        } else {\n          return cmp;\n        }\n      }\n    });\n\n    String sorted;\n    boolean success = false;\n    try {\n      sorted = sorter.sort(unsorted.getName());\n      success = true;\n    } finally {\n      if (success) {\n        tempDir.deleteFile(unsorted.getName());\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, unsorted.getName());\n      }\n    }\n    \n    boolean success2 = false;\n    \n    try (ByteSequencesReader reader = new ByteSequencesReader(tempDir.openInput(sorted, IOContext.READONCE))) {\n      BytesRefBuilder scratchLine = new BytesRefBuilder();\n    \n      // TODO: the flags themselves can be double-chars (long) or also numeric\n      // either way the trick is to encode them as char... but they must be parsed differently\n    \n      String currentEntry = null;\n      IntsRefBuilder currentOrds = new IntsRefBuilder();\n    \n      String line;\n      while (reader.read(scratchLine)) {\n        line = scratchLine.get().utf8ToString();\n        String entry;\n        char wordForm[];\n        int end;\n\n        int flagSep = line.indexOf(FLAG_SEPARATOR);\n        if (flagSep == -1) {\n          wordForm = NOFLAGS;\n          end = line.indexOf(MORPH_SEPARATOR);\n          entry = line.substring(0, end);\n        } else {\n          end = line.indexOf(MORPH_SEPARATOR);\n          String flagPart = line.substring(flagSep + 1, end);\n          if (aliasCount > 0) {\n            flagPart = getAliasValue(Integer.parseInt(flagPart));\n          } \n        \n          wordForm = flagParsingStrategy.parseFlags(flagPart);\n          Arrays.sort(wordForm);\n          entry = line.substring(0, flagSep);\n        }\n        // we possibly have morphological data\n        int stemExceptionID = 0;\n        if (hasStemExceptions && end+1 < line.length()) {\n          String stemException = parseStemException(line.substring(end+1));\n          if (stemException != null) {\n            if (stemExceptionCount == stemExceptions.length) {\n              int newSize = ArrayUtil.oversize(stemExceptionCount+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF);\n              stemExceptions = Arrays.copyOf(stemExceptions, newSize);\n            }\n            stemExceptionID = stemExceptionCount+1; // we use '0' to indicate no exception for the form\n            stemExceptions[stemExceptionCount++] = stemException;\n          }\n        }\n\n        int cmp = currentEntry == null ? 1 : entry.compareTo(currentEntry);\n        if (cmp < 0) {\n          throw new IllegalArgumentException(\"out of order: \" + entry + \" < \" + currentEntry);\n        } else {\n          encodeFlags(flagsScratch, wordForm);\n          int ord = flagLookup.add(flagsScratch.get());\n          if (ord < 0) {\n            // already exists in our hash\n            ord = (-ord)-1;\n          }\n          // finalize current entry, and switch \"current\" if necessary\n          if (cmp > 0 && currentEntry != null) {\n            Util.toUTF32(currentEntry, scratchInts);\n            words.add(scratchInts.get(), currentOrds.get());\n          }\n          // swap current\n          if (cmp > 0 || currentEntry == null) {\n            currentEntry = entry;\n            currentOrds = new IntsRefBuilder(); // must be this way\n          }\n          if (hasStemExceptions) {\n            currentOrds.append(ord);\n            currentOrds.append(stemExceptionID);\n          } else {\n            currentOrds.append(ord);\n          }\n        }\n      }\n    \n      // finalize last entry\n      Util.toUTF32(currentEntry, scratchInts);\n      words.add(scratchInts.get(), currentOrds.get());\n      success2 = true;\n    } finally {\n      if (success2) {\n        tempDir.deleteFile(sorted);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, sorted);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Reads the dictionary file through the provided InputStreams, building up the words map\n   *\n   * @param dictionaries InputStreams to read the dictionary file through\n   * @param decoder CharsetDecoder used to decode the contents of the file\n   * @throws IOException Can be thrown while reading from the file\n   */\n  private void readDictionaryFiles(Directory tempDir, String tempFileNamePrefix, List<InputStream> dictionaries, CharsetDecoder decoder, Builder<IntsRef> words) throws IOException {\n    BytesRefBuilder flagsScratch = new BytesRefBuilder();\n    IntsRefBuilder scratchInts = new IntsRefBuilder();\n    \n    StringBuilder sb = new StringBuilder();\n\n    IndexOutput unsorted = tempDir.createTempOutput(tempFileNamePrefix, \"dat\", IOContext.DEFAULT);\n    try (ByteSequencesWriter writer = new ByteSequencesWriter(unsorted)) {\n      for (InputStream dictionary : dictionaries) {\n        BufferedReader lines = new BufferedReader(new InputStreamReader(dictionary, decoder));\n        String line = lines.readLine(); // first line is number of entries (approximately, sometimes)\n        \n        while ((line = lines.readLine()) != null) {\n          // wild and unpredictable code comment rules\n          if (line.isEmpty() || line.charAt(0) == '/' || line.charAt(0) == '#' || line.charAt(0) == '\\t') {\n            continue;\n          }\n          line = unescapeEntry(line);\n          // if we havent seen any stem exceptions, try to parse one\n          if (hasStemExceptions == false) {\n            int morphStart = line.indexOf(MORPH_SEPARATOR);\n            if (morphStart >= 0 && morphStart < line.length()) {\n              hasStemExceptions = parseStemException(line.substring(morphStart+1)) != null;\n            }\n          }\n          if (needsInputCleaning) {\n            int flagSep = line.indexOf(FLAG_SEPARATOR);\n            if (flagSep == -1) {\n              flagSep = line.indexOf(MORPH_SEPARATOR);\n            }\n            if (flagSep == -1) {\n              CharSequence cleansed = cleanInput(line, sb);\n              writer.write(cleansed.toString().getBytes(StandardCharsets.UTF_8));\n            } else {\n              String text = line.substring(0, flagSep);\n              CharSequence cleansed = cleanInput(text, sb);\n              if (cleansed != sb) {\n                sb.setLength(0);\n                sb.append(cleansed);\n              }\n              sb.append(line.substring(flagSep));\n              writer.write(sb.toString().getBytes(StandardCharsets.UTF_8));\n            }\n          } else {\n            writer.write(line.getBytes(StandardCharsets.UTF_8));\n          }\n        }\n      }\n    }\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, new Comparator<BytesRef>() {\n      BytesRef scratch1 = new BytesRef();\n      BytesRef scratch2 = new BytesRef();\n      \n      @Override\n      public int compare(BytesRef o1, BytesRef o2) {\n        scratch1.bytes = o1.bytes;\n        scratch1.offset = o1.offset;\n        scratch1.length = o1.length;\n        \n        for (int i = scratch1.length - 1; i >= 0; i--) {\n          if (scratch1.bytes[scratch1.offset + i] == FLAG_SEPARATOR || scratch1.bytes[scratch1.offset + i] == MORPH_SEPARATOR) {\n            scratch1.length = i;\n            break;\n          }\n        }\n        \n        scratch2.bytes = o2.bytes;\n        scratch2.offset = o2.offset;\n        scratch2.length = o2.length;\n        \n        for (int i = scratch2.length - 1; i >= 0; i--) {\n          if (scratch2.bytes[scratch2.offset + i] == FLAG_SEPARATOR || scratch2.bytes[scratch2.offset + i] == MORPH_SEPARATOR) {\n            scratch2.length = i;\n            break;\n          }\n        }\n        \n        int cmp = scratch1.compareTo(scratch2);\n        if (cmp == 0) {\n          // tie break on whole row\n          return o1.compareTo(o2);\n        } else {\n          return cmp;\n        }\n      }\n    });\n\n    String sorted;\n    boolean success = false;\n    try {\n      sorted = sorter.sort(unsorted.getName());\n      success = true;\n    } finally {\n      if (success) {\n        tempDir.deleteFiles(Collections.singleton(unsorted.getName()));\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, unsorted.getName());\n      }\n    }\n    \n    boolean success2 = false;\n    \n    try (ByteSequencesReader reader = new ByteSequencesReader(tempDir.openInput(sorted, IOContext.READONCE))) {\n      BytesRefBuilder scratchLine = new BytesRefBuilder();\n    \n      // TODO: the flags themselves can be double-chars (long) or also numeric\n      // either way the trick is to encode them as char... but they must be parsed differently\n    \n      String currentEntry = null;\n      IntsRefBuilder currentOrds = new IntsRefBuilder();\n    \n      String line;\n      while (reader.read(scratchLine)) {\n        line = scratchLine.get().utf8ToString();\n        String entry;\n        char wordForm[];\n        int end;\n\n        int flagSep = line.indexOf(FLAG_SEPARATOR);\n        if (flagSep == -1) {\n          wordForm = NOFLAGS;\n          end = line.indexOf(MORPH_SEPARATOR);\n          entry = line.substring(0, end);\n        } else {\n          end = line.indexOf(MORPH_SEPARATOR);\n          String flagPart = line.substring(flagSep + 1, end);\n          if (aliasCount > 0) {\n            flagPart = getAliasValue(Integer.parseInt(flagPart));\n          } \n        \n          wordForm = flagParsingStrategy.parseFlags(flagPart);\n          Arrays.sort(wordForm);\n          entry = line.substring(0, flagSep);\n        }\n        // we possibly have morphological data\n        int stemExceptionID = 0;\n        if (hasStemExceptions && end+1 < line.length()) {\n          String stemException = parseStemException(line.substring(end+1));\n          if (stemException != null) {\n            if (stemExceptionCount == stemExceptions.length) {\n              int newSize = ArrayUtil.oversize(stemExceptionCount+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF);\n              stemExceptions = Arrays.copyOf(stemExceptions, newSize);\n            }\n            stemExceptionID = stemExceptionCount+1; // we use '0' to indicate no exception for the form\n            stemExceptions[stemExceptionCount++] = stemException;\n          }\n        }\n\n        int cmp = currentEntry == null ? 1 : entry.compareTo(currentEntry);\n        if (cmp < 0) {\n          throw new IllegalArgumentException(\"out of order: \" + entry + \" < \" + currentEntry);\n        } else {\n          encodeFlags(flagsScratch, wordForm);\n          int ord = flagLookup.add(flagsScratch.get());\n          if (ord < 0) {\n            // already exists in our hash\n            ord = (-ord)-1;\n          }\n          // finalize current entry, and switch \"current\" if necessary\n          if (cmp > 0 && currentEntry != null) {\n            Util.toUTF32(currentEntry, scratchInts);\n            words.add(scratchInts.get(), currentOrds.get());\n          }\n          // swap current\n          if (cmp > 0 || currentEntry == null) {\n            currentEntry = entry;\n            currentOrds = new IntsRefBuilder(); // must be this way\n          }\n          if (hasStemExceptions) {\n            currentOrds.append(ord);\n            currentOrds.append(stemExceptionID);\n          } else {\n            currentOrds.append(ord);\n          }\n        }\n      }\n    \n      // finalize last entry\n      Util.toUTF32(currentEntry, scratchInts);\n      words.add(scratchInts.get(), currentOrds.get());\n      success2 = true;\n    } finally {\n      if (success2) {\n        tempDir.deleteFiles(Collections.singleton(sorted));\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, sorted);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"950b7a6881d14da782b60444c11295e3ec50d41a","date":1458379095,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#readDictionaryFiles(Directory,String,List[InputStream],CharsetDecoder,Builder[IntsRef]).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#readDictionaryFiles(Directory,String,List[InputStream],CharsetDecoder,Builder[IntsRef]).mjava","sourceNew":"  /**\n   * Reads the dictionary file through the provided InputStreams, building up the words map\n   *\n   * @param dictionaries InputStreams to read the dictionary file through\n   * @param decoder CharsetDecoder used to decode the contents of the file\n   * @throws IOException Can be thrown while reading from the file\n   */\n  private void readDictionaryFiles(Directory tempDir, String tempFileNamePrefix, List<InputStream> dictionaries, CharsetDecoder decoder, Builder<IntsRef> words) throws IOException {\n    BytesRefBuilder flagsScratch = new BytesRefBuilder();\n    IntsRefBuilder scratchInts = new IntsRefBuilder();\n    \n    StringBuilder sb = new StringBuilder();\n\n    IndexOutput unsorted = tempDir.createTempOutput(tempFileNamePrefix, \"dat\", IOContext.DEFAULT);\n    try (ByteSequencesWriter writer = new ByteSequencesWriter(unsorted)) {\n      for (InputStream dictionary : dictionaries) {\n        BufferedReader lines = new BufferedReader(new InputStreamReader(dictionary, decoder));\n        String line = lines.readLine(); // first line is number of entries (approximately, sometimes)\n        \n        while ((line = lines.readLine()) != null) {\n          // wild and unpredictable code comment rules\n          if (line.isEmpty() || line.charAt(0) == '/' || line.charAt(0) == '#' || line.charAt(0) == '\\t') {\n            continue;\n          }\n          line = unescapeEntry(line);\n          // if we havent seen any stem exceptions, try to parse one\n          if (hasStemExceptions == false) {\n            int morphStart = line.indexOf(MORPH_SEPARATOR);\n            if (morphStart >= 0 && morphStart < line.length()) {\n              hasStemExceptions = parseStemException(line.substring(morphStart+1)) != null;\n            }\n          }\n          if (needsInputCleaning) {\n            int flagSep = line.indexOf(FLAG_SEPARATOR);\n            if (flagSep == -1) {\n              flagSep = line.indexOf(MORPH_SEPARATOR);\n            }\n            if (flagSep == -1) {\n              CharSequence cleansed = cleanInput(line, sb);\n              writer.write(cleansed.toString().getBytes(StandardCharsets.UTF_8));\n            } else {\n              String text = line.substring(0, flagSep);\n              CharSequence cleansed = cleanInput(text, sb);\n              if (cleansed != sb) {\n                sb.setLength(0);\n                sb.append(cleansed);\n              }\n              sb.append(line.substring(flagSep));\n              writer.write(sb.toString().getBytes(StandardCharsets.UTF_8));\n            }\n          } else {\n            writer.write(line.getBytes(StandardCharsets.UTF_8));\n          }\n        }\n      }\n      CodecUtil.writeFooter(unsorted);\n    }\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, new Comparator<BytesRef>() {\n      BytesRef scratch1 = new BytesRef();\n      BytesRef scratch2 = new BytesRef();\n      \n      @Override\n      public int compare(BytesRef o1, BytesRef o2) {\n        scratch1.bytes = o1.bytes;\n        scratch1.offset = o1.offset;\n        scratch1.length = o1.length;\n        \n        for (int i = scratch1.length - 1; i >= 0; i--) {\n          if (scratch1.bytes[scratch1.offset + i] == FLAG_SEPARATOR || scratch1.bytes[scratch1.offset + i] == MORPH_SEPARATOR) {\n            scratch1.length = i;\n            break;\n          }\n        }\n        \n        scratch2.bytes = o2.bytes;\n        scratch2.offset = o2.offset;\n        scratch2.length = o2.length;\n        \n        for (int i = scratch2.length - 1; i >= 0; i--) {\n          if (scratch2.bytes[scratch2.offset + i] == FLAG_SEPARATOR || scratch2.bytes[scratch2.offset + i] == MORPH_SEPARATOR) {\n            scratch2.length = i;\n            break;\n          }\n        }\n        \n        int cmp = scratch1.compareTo(scratch2);\n        if (cmp == 0) {\n          // tie break on whole row\n          return o1.compareTo(o2);\n        } else {\n          return cmp;\n        }\n      }\n    });\n\n    String sorted;\n    boolean success = false;\n    try {\n      sorted = sorter.sort(unsorted.getName());\n      success = true;\n    } finally {\n      if (success) {\n        tempDir.deleteFile(unsorted.getName());\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, unsorted.getName());\n      }\n    }\n    \n    boolean success2 = false;\n    \n    try (ByteSequencesReader reader = new ByteSequencesReader(tempDir.openChecksumInput(sorted, IOContext.READONCE), sorted)) {\n      BytesRefBuilder scratchLine = new BytesRefBuilder();\n    \n      // TODO: the flags themselves can be double-chars (long) or also numeric\n      // either way the trick is to encode them as char... but they must be parsed differently\n    \n      String currentEntry = null;\n      IntsRefBuilder currentOrds = new IntsRefBuilder();\n    \n      String line;\n      while (reader.read(scratchLine)) {\n        line = scratchLine.get().utf8ToString();\n        String entry;\n        char wordForm[];\n        int end;\n\n        int flagSep = line.indexOf(FLAG_SEPARATOR);\n        if (flagSep == -1) {\n          wordForm = NOFLAGS;\n          end = line.indexOf(MORPH_SEPARATOR);\n          entry = line.substring(0, end);\n        } else {\n          end = line.indexOf(MORPH_SEPARATOR);\n          String flagPart = line.substring(flagSep + 1, end);\n          if (aliasCount > 0) {\n            flagPart = getAliasValue(Integer.parseInt(flagPart));\n          } \n        \n          wordForm = flagParsingStrategy.parseFlags(flagPart);\n          Arrays.sort(wordForm);\n          entry = line.substring(0, flagSep);\n        }\n        // we possibly have morphological data\n        int stemExceptionID = 0;\n        if (hasStemExceptions && end+1 < line.length()) {\n          String stemException = parseStemException(line.substring(end+1));\n          if (stemException != null) {\n            if (stemExceptionCount == stemExceptions.length) {\n              int newSize = ArrayUtil.oversize(stemExceptionCount+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF);\n              stemExceptions = Arrays.copyOf(stemExceptions, newSize);\n            }\n            stemExceptionID = stemExceptionCount+1; // we use '0' to indicate no exception for the form\n            stemExceptions[stemExceptionCount++] = stemException;\n          }\n        }\n\n        int cmp = currentEntry == null ? 1 : entry.compareTo(currentEntry);\n        if (cmp < 0) {\n          throw new IllegalArgumentException(\"out of order: \" + entry + \" < \" + currentEntry);\n        } else {\n          encodeFlags(flagsScratch, wordForm);\n          int ord = flagLookup.add(flagsScratch.get());\n          if (ord < 0) {\n            // already exists in our hash\n            ord = (-ord)-1;\n          }\n          // finalize current entry, and switch \"current\" if necessary\n          if (cmp > 0 && currentEntry != null) {\n            Util.toUTF32(currentEntry, scratchInts);\n            words.add(scratchInts.get(), currentOrds.get());\n          }\n          // swap current\n          if (cmp > 0 || currentEntry == null) {\n            currentEntry = entry;\n            currentOrds = new IntsRefBuilder(); // must be this way\n          }\n          if (hasStemExceptions) {\n            currentOrds.append(ord);\n            currentOrds.append(stemExceptionID);\n          } else {\n            currentOrds.append(ord);\n          }\n        }\n      }\n    \n      // finalize last entry\n      Util.toUTF32(currentEntry, scratchInts);\n      words.add(scratchInts.get(), currentOrds.get());\n      success2 = true;\n    } finally {\n      if (success2) {\n        tempDir.deleteFile(sorted);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, sorted);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Reads the dictionary file through the provided InputStreams, building up the words map\n   *\n   * @param dictionaries InputStreams to read the dictionary file through\n   * @param decoder CharsetDecoder used to decode the contents of the file\n   * @throws IOException Can be thrown while reading from the file\n   */\n  private void readDictionaryFiles(Directory tempDir, String tempFileNamePrefix, List<InputStream> dictionaries, CharsetDecoder decoder, Builder<IntsRef> words) throws IOException {\n    BytesRefBuilder flagsScratch = new BytesRefBuilder();\n    IntsRefBuilder scratchInts = new IntsRefBuilder();\n    \n    StringBuilder sb = new StringBuilder();\n\n    IndexOutput unsorted = tempDir.createTempOutput(tempFileNamePrefix, \"dat\", IOContext.DEFAULT);\n    try (ByteSequencesWriter writer = new ByteSequencesWriter(unsorted)) {\n      for (InputStream dictionary : dictionaries) {\n        BufferedReader lines = new BufferedReader(new InputStreamReader(dictionary, decoder));\n        String line = lines.readLine(); // first line is number of entries (approximately, sometimes)\n        \n        while ((line = lines.readLine()) != null) {\n          // wild and unpredictable code comment rules\n          if (line.isEmpty() || line.charAt(0) == '/' || line.charAt(0) == '#' || line.charAt(0) == '\\t') {\n            continue;\n          }\n          line = unescapeEntry(line);\n          // if we havent seen any stem exceptions, try to parse one\n          if (hasStemExceptions == false) {\n            int morphStart = line.indexOf(MORPH_SEPARATOR);\n            if (morphStart >= 0 && morphStart < line.length()) {\n              hasStemExceptions = parseStemException(line.substring(morphStart+1)) != null;\n            }\n          }\n          if (needsInputCleaning) {\n            int flagSep = line.indexOf(FLAG_SEPARATOR);\n            if (flagSep == -1) {\n              flagSep = line.indexOf(MORPH_SEPARATOR);\n            }\n            if (flagSep == -1) {\n              CharSequence cleansed = cleanInput(line, sb);\n              writer.write(cleansed.toString().getBytes(StandardCharsets.UTF_8));\n            } else {\n              String text = line.substring(0, flagSep);\n              CharSequence cleansed = cleanInput(text, sb);\n              if (cleansed != sb) {\n                sb.setLength(0);\n                sb.append(cleansed);\n              }\n              sb.append(line.substring(flagSep));\n              writer.write(sb.toString().getBytes(StandardCharsets.UTF_8));\n            }\n          } else {\n            writer.write(line.getBytes(StandardCharsets.UTF_8));\n          }\n        }\n      }\n    }\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, new Comparator<BytesRef>() {\n      BytesRef scratch1 = new BytesRef();\n      BytesRef scratch2 = new BytesRef();\n      \n      @Override\n      public int compare(BytesRef o1, BytesRef o2) {\n        scratch1.bytes = o1.bytes;\n        scratch1.offset = o1.offset;\n        scratch1.length = o1.length;\n        \n        for (int i = scratch1.length - 1; i >= 0; i--) {\n          if (scratch1.bytes[scratch1.offset + i] == FLAG_SEPARATOR || scratch1.bytes[scratch1.offset + i] == MORPH_SEPARATOR) {\n            scratch1.length = i;\n            break;\n          }\n        }\n        \n        scratch2.bytes = o2.bytes;\n        scratch2.offset = o2.offset;\n        scratch2.length = o2.length;\n        \n        for (int i = scratch2.length - 1; i >= 0; i--) {\n          if (scratch2.bytes[scratch2.offset + i] == FLAG_SEPARATOR || scratch2.bytes[scratch2.offset + i] == MORPH_SEPARATOR) {\n            scratch2.length = i;\n            break;\n          }\n        }\n        \n        int cmp = scratch1.compareTo(scratch2);\n        if (cmp == 0) {\n          // tie break on whole row\n          return o1.compareTo(o2);\n        } else {\n          return cmp;\n        }\n      }\n    });\n\n    String sorted;\n    boolean success = false;\n    try {\n      sorted = sorter.sort(unsorted.getName());\n      success = true;\n    } finally {\n      if (success) {\n        tempDir.deleteFile(unsorted.getName());\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, unsorted.getName());\n      }\n    }\n    \n    boolean success2 = false;\n    \n    try (ByteSequencesReader reader = new ByteSequencesReader(tempDir.openInput(sorted, IOContext.READONCE))) {\n      BytesRefBuilder scratchLine = new BytesRefBuilder();\n    \n      // TODO: the flags themselves can be double-chars (long) or also numeric\n      // either way the trick is to encode them as char... but they must be parsed differently\n    \n      String currentEntry = null;\n      IntsRefBuilder currentOrds = new IntsRefBuilder();\n    \n      String line;\n      while (reader.read(scratchLine)) {\n        line = scratchLine.get().utf8ToString();\n        String entry;\n        char wordForm[];\n        int end;\n\n        int flagSep = line.indexOf(FLAG_SEPARATOR);\n        if (flagSep == -1) {\n          wordForm = NOFLAGS;\n          end = line.indexOf(MORPH_SEPARATOR);\n          entry = line.substring(0, end);\n        } else {\n          end = line.indexOf(MORPH_SEPARATOR);\n          String flagPart = line.substring(flagSep + 1, end);\n          if (aliasCount > 0) {\n            flagPart = getAliasValue(Integer.parseInt(flagPart));\n          } \n        \n          wordForm = flagParsingStrategy.parseFlags(flagPart);\n          Arrays.sort(wordForm);\n          entry = line.substring(0, flagSep);\n        }\n        // we possibly have morphological data\n        int stemExceptionID = 0;\n        if (hasStemExceptions && end+1 < line.length()) {\n          String stemException = parseStemException(line.substring(end+1));\n          if (stemException != null) {\n            if (stemExceptionCount == stemExceptions.length) {\n              int newSize = ArrayUtil.oversize(stemExceptionCount+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF);\n              stemExceptions = Arrays.copyOf(stemExceptions, newSize);\n            }\n            stemExceptionID = stemExceptionCount+1; // we use '0' to indicate no exception for the form\n            stemExceptions[stemExceptionCount++] = stemException;\n          }\n        }\n\n        int cmp = currentEntry == null ? 1 : entry.compareTo(currentEntry);\n        if (cmp < 0) {\n          throw new IllegalArgumentException(\"out of order: \" + entry + \" < \" + currentEntry);\n        } else {\n          encodeFlags(flagsScratch, wordForm);\n          int ord = flagLookup.add(flagsScratch.get());\n          if (ord < 0) {\n            // already exists in our hash\n            ord = (-ord)-1;\n          }\n          // finalize current entry, and switch \"current\" if necessary\n          if (cmp > 0 && currentEntry != null) {\n            Util.toUTF32(currentEntry, scratchInts);\n            words.add(scratchInts.get(), currentOrds.get());\n          }\n          // swap current\n          if (cmp > 0 || currentEntry == null) {\n            currentEntry = entry;\n            currentOrds = new IntsRefBuilder(); // must be this way\n          }\n          if (hasStemExceptions) {\n            currentOrds.append(ord);\n            currentOrds.append(stemExceptionID);\n          } else {\n            currentOrds.append(ord);\n          }\n        }\n      }\n    \n      // finalize last entry\n      Util.toUTF32(currentEntry, scratchInts);\n      words.add(scratchInts.get(), currentOrds.get());\n      success2 = true;\n    } finally {\n      if (success2) {\n        tempDir.deleteFile(sorted);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, sorted);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7849935cc625c020857f3b29be91b5d4323d19aa","date":1458978426,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#readDictionaryFiles(Directory,String,List[InputStream],CharsetDecoder,Builder[IntsRef]).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#readDictionaryFiles(Directory,String,List[InputStream],CharsetDecoder,Builder[IntsRef]).mjava","sourceNew":"  /**\n   * Reads the dictionary file through the provided InputStreams, building up the words map\n   *\n   * @param dictionaries InputStreams to read the dictionary file through\n   * @param decoder CharsetDecoder used to decode the contents of the file\n   * @throws IOException Can be thrown while reading from the file\n   */\n  private void readDictionaryFiles(Directory tempDir, String tempFileNamePrefix, List<InputStream> dictionaries, CharsetDecoder decoder, Builder<IntsRef> words) throws IOException {\n    BytesRefBuilder flagsScratch = new BytesRefBuilder();\n    IntsRefBuilder scratchInts = new IntsRefBuilder();\n    \n    StringBuilder sb = new StringBuilder();\n\n    IndexOutput unsorted = tempDir.createTempOutput(tempFileNamePrefix, \"dat\", IOContext.DEFAULT);\n    try (ByteSequencesWriter writer = new ByteSequencesWriter(unsorted)) {\n      for (InputStream dictionary : dictionaries) {\n        BufferedReader lines = new BufferedReader(new InputStreamReader(dictionary, decoder));\n        String line = lines.readLine(); // first line is number of entries (approximately, sometimes)\n        \n        while ((line = lines.readLine()) != null) {\n          // wild and unpredictable code comment rules\n          if (line.isEmpty() || line.charAt(0) == '/' || line.charAt(0) == '#' || line.charAt(0) == '\\t') {\n            continue;\n          }\n          line = unescapeEntry(line);\n          // if we havent seen any stem exceptions, try to parse one\n          if (hasStemExceptions == false) {\n            int morphStart = line.indexOf(MORPH_SEPARATOR);\n            if (morphStart >= 0 && morphStart < line.length()) {\n              hasStemExceptions = parseStemException(line.substring(morphStart+1)) != null;\n            }\n          }\n          if (needsInputCleaning) {\n            int flagSep = line.indexOf(FLAG_SEPARATOR);\n            if (flagSep == -1) {\n              flagSep = line.indexOf(MORPH_SEPARATOR);\n            }\n            if (flagSep == -1) {\n              CharSequence cleansed = cleanInput(line, sb);\n              writer.write(cleansed.toString().getBytes(StandardCharsets.UTF_8));\n            } else {\n              String text = line.substring(0, flagSep);\n              CharSequence cleansed = cleanInput(text, sb);\n              if (cleansed != sb) {\n                sb.setLength(0);\n                sb.append(cleansed);\n              }\n              sb.append(line.substring(flagSep));\n              writer.write(sb.toString().getBytes(StandardCharsets.UTF_8));\n            }\n          } else {\n            writer.write(line.getBytes(StandardCharsets.UTF_8));\n          }\n        }\n      }\n      CodecUtil.writeFooter(unsorted);\n    }\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, new Comparator<BytesRef>() {\n      BytesRef scratch1 = new BytesRef();\n      BytesRef scratch2 = new BytesRef();\n      \n      @Override\n      public int compare(BytesRef o1, BytesRef o2) {\n        scratch1.bytes = o1.bytes;\n        scratch1.offset = o1.offset;\n        scratch1.length = o1.length;\n        \n        for (int i = scratch1.length - 1; i >= 0; i--) {\n          if (scratch1.bytes[scratch1.offset + i] == FLAG_SEPARATOR || scratch1.bytes[scratch1.offset + i] == MORPH_SEPARATOR) {\n            scratch1.length = i;\n            break;\n          }\n        }\n        \n        scratch2.bytes = o2.bytes;\n        scratch2.offset = o2.offset;\n        scratch2.length = o2.length;\n        \n        for (int i = scratch2.length - 1; i >= 0; i--) {\n          if (scratch2.bytes[scratch2.offset + i] == FLAG_SEPARATOR || scratch2.bytes[scratch2.offset + i] == MORPH_SEPARATOR) {\n            scratch2.length = i;\n            break;\n          }\n        }\n        \n        int cmp = scratch1.compareTo(scratch2);\n        if (cmp == 0) {\n          // tie break on whole row\n          return o1.compareTo(o2);\n        } else {\n          return cmp;\n        }\n      }\n    });\n\n    String sorted;\n    boolean success = false;\n    try {\n      sorted = sorter.sort(unsorted.getName());\n      success = true;\n    } finally {\n      if (success) {\n        tempDir.deleteFile(unsorted.getName());\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, unsorted.getName());\n      }\n    }\n    \n    boolean success2 = false;\n    \n    try (ByteSequencesReader reader = new ByteSequencesReader(tempDir.openChecksumInput(sorted, IOContext.READONCE), sorted)) {\n    \n      // TODO: the flags themselves can be double-chars (long) or also numeric\n      // either way the trick is to encode them as char... but they must be parsed differently\n    \n      String currentEntry = null;\n      IntsRefBuilder currentOrds = new IntsRefBuilder();\n\n      while (true) {\n        BytesRef scratch = reader.next();\n        if (scratch == null) {\n          break;\n        }\n        \n        String line = scratch.utf8ToString();\n        String entry;\n        char wordForm[];\n        int end;\n\n        int flagSep = line.indexOf(FLAG_SEPARATOR);\n        if (flagSep == -1) {\n          wordForm = NOFLAGS;\n          end = line.indexOf(MORPH_SEPARATOR);\n          entry = line.substring(0, end);\n        } else {\n          end = line.indexOf(MORPH_SEPARATOR);\n          String flagPart = line.substring(flagSep + 1, end);\n          if (aliasCount > 0) {\n            flagPart = getAliasValue(Integer.parseInt(flagPart));\n          } \n        \n          wordForm = flagParsingStrategy.parseFlags(flagPart);\n          Arrays.sort(wordForm);\n          entry = line.substring(0, flagSep);\n        }\n        // we possibly have morphological data\n        int stemExceptionID = 0;\n        if (hasStemExceptions && end+1 < line.length()) {\n          String stemException = parseStemException(line.substring(end+1));\n          if (stemException != null) {\n            if (stemExceptionCount == stemExceptions.length) {\n              int newSize = ArrayUtil.oversize(stemExceptionCount+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF);\n              stemExceptions = Arrays.copyOf(stemExceptions, newSize);\n            }\n            stemExceptionID = stemExceptionCount+1; // we use '0' to indicate no exception for the form\n            stemExceptions[stemExceptionCount++] = stemException;\n          }\n        }\n\n        int cmp = currentEntry == null ? 1 : entry.compareTo(currentEntry);\n        if (cmp < 0) {\n          throw new IllegalArgumentException(\"out of order: \" + entry + \" < \" + currentEntry);\n        } else {\n          encodeFlags(flagsScratch, wordForm);\n          int ord = flagLookup.add(flagsScratch.get());\n          if (ord < 0) {\n            // already exists in our hash\n            ord = (-ord)-1;\n          }\n          // finalize current entry, and switch \"current\" if necessary\n          if (cmp > 0 && currentEntry != null) {\n            Util.toUTF32(currentEntry, scratchInts);\n            words.add(scratchInts.get(), currentOrds.get());\n          }\n          // swap current\n          if (cmp > 0 || currentEntry == null) {\n            currentEntry = entry;\n            currentOrds = new IntsRefBuilder(); // must be this way\n          }\n          if (hasStemExceptions) {\n            currentOrds.append(ord);\n            currentOrds.append(stemExceptionID);\n          } else {\n            currentOrds.append(ord);\n          }\n        }\n      }\n    \n      // finalize last entry\n      Util.toUTF32(currentEntry, scratchInts);\n      words.add(scratchInts.get(), currentOrds.get());\n      success2 = true;\n    } finally {\n      if (success2) {\n        tempDir.deleteFile(sorted);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, sorted);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Reads the dictionary file through the provided InputStreams, building up the words map\n   *\n   * @param dictionaries InputStreams to read the dictionary file through\n   * @param decoder CharsetDecoder used to decode the contents of the file\n   * @throws IOException Can be thrown while reading from the file\n   */\n  private void readDictionaryFiles(Directory tempDir, String tempFileNamePrefix, List<InputStream> dictionaries, CharsetDecoder decoder, Builder<IntsRef> words) throws IOException {\n    BytesRefBuilder flagsScratch = new BytesRefBuilder();\n    IntsRefBuilder scratchInts = new IntsRefBuilder();\n    \n    StringBuilder sb = new StringBuilder();\n\n    IndexOutput unsorted = tempDir.createTempOutput(tempFileNamePrefix, \"dat\", IOContext.DEFAULT);\n    try (ByteSequencesWriter writer = new ByteSequencesWriter(unsorted)) {\n      for (InputStream dictionary : dictionaries) {\n        BufferedReader lines = new BufferedReader(new InputStreamReader(dictionary, decoder));\n        String line = lines.readLine(); // first line is number of entries (approximately, sometimes)\n        \n        while ((line = lines.readLine()) != null) {\n          // wild and unpredictable code comment rules\n          if (line.isEmpty() || line.charAt(0) == '/' || line.charAt(0) == '#' || line.charAt(0) == '\\t') {\n            continue;\n          }\n          line = unescapeEntry(line);\n          // if we havent seen any stem exceptions, try to parse one\n          if (hasStemExceptions == false) {\n            int morphStart = line.indexOf(MORPH_SEPARATOR);\n            if (morphStart >= 0 && morphStart < line.length()) {\n              hasStemExceptions = parseStemException(line.substring(morphStart+1)) != null;\n            }\n          }\n          if (needsInputCleaning) {\n            int flagSep = line.indexOf(FLAG_SEPARATOR);\n            if (flagSep == -1) {\n              flagSep = line.indexOf(MORPH_SEPARATOR);\n            }\n            if (flagSep == -1) {\n              CharSequence cleansed = cleanInput(line, sb);\n              writer.write(cleansed.toString().getBytes(StandardCharsets.UTF_8));\n            } else {\n              String text = line.substring(0, flagSep);\n              CharSequence cleansed = cleanInput(text, sb);\n              if (cleansed != sb) {\n                sb.setLength(0);\n                sb.append(cleansed);\n              }\n              sb.append(line.substring(flagSep));\n              writer.write(sb.toString().getBytes(StandardCharsets.UTF_8));\n            }\n          } else {\n            writer.write(line.getBytes(StandardCharsets.UTF_8));\n          }\n        }\n      }\n      CodecUtil.writeFooter(unsorted);\n    }\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, new Comparator<BytesRef>() {\n      BytesRef scratch1 = new BytesRef();\n      BytesRef scratch2 = new BytesRef();\n      \n      @Override\n      public int compare(BytesRef o1, BytesRef o2) {\n        scratch1.bytes = o1.bytes;\n        scratch1.offset = o1.offset;\n        scratch1.length = o1.length;\n        \n        for (int i = scratch1.length - 1; i >= 0; i--) {\n          if (scratch1.bytes[scratch1.offset + i] == FLAG_SEPARATOR || scratch1.bytes[scratch1.offset + i] == MORPH_SEPARATOR) {\n            scratch1.length = i;\n            break;\n          }\n        }\n        \n        scratch2.bytes = o2.bytes;\n        scratch2.offset = o2.offset;\n        scratch2.length = o2.length;\n        \n        for (int i = scratch2.length - 1; i >= 0; i--) {\n          if (scratch2.bytes[scratch2.offset + i] == FLAG_SEPARATOR || scratch2.bytes[scratch2.offset + i] == MORPH_SEPARATOR) {\n            scratch2.length = i;\n            break;\n          }\n        }\n        \n        int cmp = scratch1.compareTo(scratch2);\n        if (cmp == 0) {\n          // tie break on whole row\n          return o1.compareTo(o2);\n        } else {\n          return cmp;\n        }\n      }\n    });\n\n    String sorted;\n    boolean success = false;\n    try {\n      sorted = sorter.sort(unsorted.getName());\n      success = true;\n    } finally {\n      if (success) {\n        tempDir.deleteFile(unsorted.getName());\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, unsorted.getName());\n      }\n    }\n    \n    boolean success2 = false;\n    \n    try (ByteSequencesReader reader = new ByteSequencesReader(tempDir.openChecksumInput(sorted, IOContext.READONCE), sorted)) {\n      BytesRefBuilder scratchLine = new BytesRefBuilder();\n    \n      // TODO: the flags themselves can be double-chars (long) or also numeric\n      // either way the trick is to encode them as char... but they must be parsed differently\n    \n      String currentEntry = null;\n      IntsRefBuilder currentOrds = new IntsRefBuilder();\n    \n      String line;\n      while (reader.read(scratchLine)) {\n        line = scratchLine.get().utf8ToString();\n        String entry;\n        char wordForm[];\n        int end;\n\n        int flagSep = line.indexOf(FLAG_SEPARATOR);\n        if (flagSep == -1) {\n          wordForm = NOFLAGS;\n          end = line.indexOf(MORPH_SEPARATOR);\n          entry = line.substring(0, end);\n        } else {\n          end = line.indexOf(MORPH_SEPARATOR);\n          String flagPart = line.substring(flagSep + 1, end);\n          if (aliasCount > 0) {\n            flagPart = getAliasValue(Integer.parseInt(flagPart));\n          } \n        \n          wordForm = flagParsingStrategy.parseFlags(flagPart);\n          Arrays.sort(wordForm);\n          entry = line.substring(0, flagSep);\n        }\n        // we possibly have morphological data\n        int stemExceptionID = 0;\n        if (hasStemExceptions && end+1 < line.length()) {\n          String stemException = parseStemException(line.substring(end+1));\n          if (stemException != null) {\n            if (stemExceptionCount == stemExceptions.length) {\n              int newSize = ArrayUtil.oversize(stemExceptionCount+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF);\n              stemExceptions = Arrays.copyOf(stemExceptions, newSize);\n            }\n            stemExceptionID = stemExceptionCount+1; // we use '0' to indicate no exception for the form\n            stemExceptions[stemExceptionCount++] = stemException;\n          }\n        }\n\n        int cmp = currentEntry == null ? 1 : entry.compareTo(currentEntry);\n        if (cmp < 0) {\n          throw new IllegalArgumentException(\"out of order: \" + entry + \" < \" + currentEntry);\n        } else {\n          encodeFlags(flagsScratch, wordForm);\n          int ord = flagLookup.add(flagsScratch.get());\n          if (ord < 0) {\n            // already exists in our hash\n            ord = (-ord)-1;\n          }\n          // finalize current entry, and switch \"current\" if necessary\n          if (cmp > 0 && currentEntry != null) {\n            Util.toUTF32(currentEntry, scratchInts);\n            words.add(scratchInts.get(), currentOrds.get());\n          }\n          // swap current\n          if (cmp > 0 || currentEntry == null) {\n            currentEntry = entry;\n            currentOrds = new IntsRefBuilder(); // must be this way\n          }\n          if (hasStemExceptions) {\n            currentOrds.append(ord);\n            currentOrds.append(stemExceptionID);\n          } else {\n            currentOrds.append(ord);\n          }\n        }\n      }\n    \n      // finalize last entry\n      Util.toUTF32(currentEntry, scratchInts);\n      words.add(scratchInts.get(), currentOrds.get());\n      success2 = true;\n    } finally {\n      if (success2) {\n        tempDir.deleteFile(sorted);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, sorted);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9798d0818e7a880546802b509792d3f3d57babd2","date":1528358901,"type":3,"author":"Nhat Nguyen","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#readDictionaryFiles(Directory,String,List[InputStream],CharsetDecoder,Builder[IntsRef]).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#readDictionaryFiles(Directory,String,List[InputStream],CharsetDecoder,Builder[IntsRef]).mjava","sourceNew":"  /**\n   * Reads the dictionary file through the provided InputStreams, building up the words map\n   *\n   * @param dictionaries InputStreams to read the dictionary file through\n   * @param decoder CharsetDecoder used to decode the contents of the file\n   * @throws IOException Can be thrown while reading from the file\n   */\n  private void readDictionaryFiles(Directory tempDir, String tempFileNamePrefix, List<InputStream> dictionaries, CharsetDecoder decoder, Builder<IntsRef> words) throws IOException {\n    BytesRefBuilder flagsScratch = new BytesRefBuilder();\n    IntsRefBuilder scratchInts = new IntsRefBuilder();\n    \n    StringBuilder sb = new StringBuilder();\n\n    IndexOutput unsorted = tempDir.createTempOutput(tempFileNamePrefix, \"dat\", IOContext.DEFAULT);\n    try (ByteSequencesWriter writer = new ByteSequencesWriter(unsorted)) {\n      for (InputStream dictionary : dictionaries) {\n        BufferedReader lines = new BufferedReader(new InputStreamReader(dictionary, decoder));\n        String line = lines.readLine(); // first line is number of entries (approximately, sometimes)\n        \n        while ((line = lines.readLine()) != null) {\n          // wild and unpredictable code comment rules\n          if (line.isEmpty() || line.charAt(0) == '/' || line.charAt(0) == '#' || line.charAt(0) == '\\t') {\n            continue;\n          }\n          line = unescapeEntry(line);\n          // if we havent seen any stem exceptions, try to parse one\n          if (hasStemExceptions == false) {\n            int morphStart = line.indexOf(MORPH_SEPARATOR);\n            if (morphStart >= 0 && morphStart < line.length()) {\n              hasStemExceptions = parseStemException(line.substring(morphStart+1)) != null;\n            }\n          }\n          if (needsInputCleaning) {\n            int flagSep = line.indexOf(FLAG_SEPARATOR);\n            if (flagSep == -1) {\n              flagSep = line.indexOf(MORPH_SEPARATOR);\n            }\n            if (flagSep == -1) {\n              CharSequence cleansed = cleanInput(line, sb);\n              writer.write(cleansed.toString().getBytes(StandardCharsets.UTF_8));\n            } else {\n              String text = line.substring(0, flagSep);\n              CharSequence cleansed = cleanInput(text, sb);\n              if (cleansed != sb) {\n                sb.setLength(0);\n                sb.append(cleansed);\n              }\n              sb.append(line.substring(flagSep));\n              writer.write(sb.toString().getBytes(StandardCharsets.UTF_8));\n            }\n          } else {\n            writer.write(line.getBytes(StandardCharsets.UTF_8));\n          }\n        }\n      }\n      CodecUtil.writeFooter(unsorted);\n    }\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, new Comparator<BytesRef>() {\n      BytesRef scratch1 = new BytesRef();\n      BytesRef scratch2 = new BytesRef();\n      \n      @Override\n      public int compare(BytesRef o1, BytesRef o2) {\n        scratch1.bytes = o1.bytes;\n        scratch1.offset = o1.offset;\n        scratch1.length = o1.length;\n        \n        for (int i = scratch1.length - 1; i >= 0; i--) {\n          if (scratch1.bytes[scratch1.offset + i] == FLAG_SEPARATOR || scratch1.bytes[scratch1.offset + i] == MORPH_SEPARATOR) {\n            scratch1.length = i;\n            break;\n          }\n        }\n        \n        scratch2.bytes = o2.bytes;\n        scratch2.offset = o2.offset;\n        scratch2.length = o2.length;\n        \n        for (int i = scratch2.length - 1; i >= 0; i--) {\n          if (scratch2.bytes[scratch2.offset + i] == FLAG_SEPARATOR || scratch2.bytes[scratch2.offset + i] == MORPH_SEPARATOR) {\n            scratch2.length = i;\n            break;\n          }\n        }\n        \n        int cmp = scratch1.compareTo(scratch2);\n        if (cmp == 0) {\n          // tie break on whole row\n          return o1.compareTo(o2);\n        } else {\n          return cmp;\n        }\n      }\n    });\n\n    String sorted;\n    boolean success = false;\n    try {\n      sorted = sorter.sort(unsorted.getName());\n      success = true;\n    } finally {\n      if (success) {\n        tempDir.deleteFile(unsorted.getName());\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, unsorted.getName());\n      }\n    }\n    \n    boolean success2 = false;\n    \n    try (ByteSequencesReader reader = new ByteSequencesReader(tempDir.openChecksumInput(sorted, IOContext.READONCE), sorted)) {\n    \n      // TODO: the flags themselves can be double-chars (long) or also numeric\n      // either way the trick is to encode them as char... but they must be parsed differently\n    \n      String currentEntry = null;\n      IntsRefBuilder currentOrds = new IntsRefBuilder();\n\n      while (true) {\n        BytesRef scratch = reader.next();\n        if (scratch == null) {\n          break;\n        }\n        \n        String line = scratch.utf8ToString();\n        String entry;\n        char wordForm[];\n        int end;\n\n        int flagSep = line.indexOf(FLAG_SEPARATOR);\n        if (flagSep == -1) {\n          wordForm = NOFLAGS;\n          end = line.indexOf(MORPH_SEPARATOR);\n          entry = line.substring(0, end);\n        } else {\n          end = line.indexOf(MORPH_SEPARATOR);\n          String flagPart = line.substring(flagSep + 1, end);\n          if (aliasCount > 0) {\n            flagPart = getAliasValue(Integer.parseInt(flagPart));\n          } \n        \n          wordForm = flagParsingStrategy.parseFlags(flagPart);\n          Arrays.sort(wordForm);\n          entry = line.substring(0, flagSep);\n        }\n        // we possibly have morphological data\n        int stemExceptionID = 0;\n        if (hasStemExceptions && end+1 < line.length()) {\n          String stemException = parseStemException(line.substring(end+1));\n          if (stemException != null) {\n            stemExceptions = ArrayUtil.grow(stemExceptions, stemExceptionCount+1);\n            stemExceptionID = stemExceptionCount+1; // we use '0' to indicate no exception for the form\n            stemExceptions[stemExceptionCount++] = stemException;\n          }\n        }\n\n        int cmp = currentEntry == null ? 1 : entry.compareTo(currentEntry);\n        if (cmp < 0) {\n          throw new IllegalArgumentException(\"out of order: \" + entry + \" < \" + currentEntry);\n        } else {\n          encodeFlags(flagsScratch, wordForm);\n          int ord = flagLookup.add(flagsScratch.get());\n          if (ord < 0) {\n            // already exists in our hash\n            ord = (-ord)-1;\n          }\n          // finalize current entry, and switch \"current\" if necessary\n          if (cmp > 0 && currentEntry != null) {\n            Util.toUTF32(currentEntry, scratchInts);\n            words.add(scratchInts.get(), currentOrds.get());\n          }\n          // swap current\n          if (cmp > 0 || currentEntry == null) {\n            currentEntry = entry;\n            currentOrds = new IntsRefBuilder(); // must be this way\n          }\n          if (hasStemExceptions) {\n            currentOrds.append(ord);\n            currentOrds.append(stemExceptionID);\n          } else {\n            currentOrds.append(ord);\n          }\n        }\n      }\n    \n      // finalize last entry\n      Util.toUTF32(currentEntry, scratchInts);\n      words.add(scratchInts.get(), currentOrds.get());\n      success2 = true;\n    } finally {\n      if (success2) {\n        tempDir.deleteFile(sorted);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, sorted);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Reads the dictionary file through the provided InputStreams, building up the words map\n   *\n   * @param dictionaries InputStreams to read the dictionary file through\n   * @param decoder CharsetDecoder used to decode the contents of the file\n   * @throws IOException Can be thrown while reading from the file\n   */\n  private void readDictionaryFiles(Directory tempDir, String tempFileNamePrefix, List<InputStream> dictionaries, CharsetDecoder decoder, Builder<IntsRef> words) throws IOException {\n    BytesRefBuilder flagsScratch = new BytesRefBuilder();\n    IntsRefBuilder scratchInts = new IntsRefBuilder();\n    \n    StringBuilder sb = new StringBuilder();\n\n    IndexOutput unsorted = tempDir.createTempOutput(tempFileNamePrefix, \"dat\", IOContext.DEFAULT);\n    try (ByteSequencesWriter writer = new ByteSequencesWriter(unsorted)) {\n      for (InputStream dictionary : dictionaries) {\n        BufferedReader lines = new BufferedReader(new InputStreamReader(dictionary, decoder));\n        String line = lines.readLine(); // first line is number of entries (approximately, sometimes)\n        \n        while ((line = lines.readLine()) != null) {\n          // wild and unpredictable code comment rules\n          if (line.isEmpty() || line.charAt(0) == '/' || line.charAt(0) == '#' || line.charAt(0) == '\\t') {\n            continue;\n          }\n          line = unescapeEntry(line);\n          // if we havent seen any stem exceptions, try to parse one\n          if (hasStemExceptions == false) {\n            int morphStart = line.indexOf(MORPH_SEPARATOR);\n            if (morphStart >= 0 && morphStart < line.length()) {\n              hasStemExceptions = parseStemException(line.substring(morphStart+1)) != null;\n            }\n          }\n          if (needsInputCleaning) {\n            int flagSep = line.indexOf(FLAG_SEPARATOR);\n            if (flagSep == -1) {\n              flagSep = line.indexOf(MORPH_SEPARATOR);\n            }\n            if (flagSep == -1) {\n              CharSequence cleansed = cleanInput(line, sb);\n              writer.write(cleansed.toString().getBytes(StandardCharsets.UTF_8));\n            } else {\n              String text = line.substring(0, flagSep);\n              CharSequence cleansed = cleanInput(text, sb);\n              if (cleansed != sb) {\n                sb.setLength(0);\n                sb.append(cleansed);\n              }\n              sb.append(line.substring(flagSep));\n              writer.write(sb.toString().getBytes(StandardCharsets.UTF_8));\n            }\n          } else {\n            writer.write(line.getBytes(StandardCharsets.UTF_8));\n          }\n        }\n      }\n      CodecUtil.writeFooter(unsorted);\n    }\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, new Comparator<BytesRef>() {\n      BytesRef scratch1 = new BytesRef();\n      BytesRef scratch2 = new BytesRef();\n      \n      @Override\n      public int compare(BytesRef o1, BytesRef o2) {\n        scratch1.bytes = o1.bytes;\n        scratch1.offset = o1.offset;\n        scratch1.length = o1.length;\n        \n        for (int i = scratch1.length - 1; i >= 0; i--) {\n          if (scratch1.bytes[scratch1.offset + i] == FLAG_SEPARATOR || scratch1.bytes[scratch1.offset + i] == MORPH_SEPARATOR) {\n            scratch1.length = i;\n            break;\n          }\n        }\n        \n        scratch2.bytes = o2.bytes;\n        scratch2.offset = o2.offset;\n        scratch2.length = o2.length;\n        \n        for (int i = scratch2.length - 1; i >= 0; i--) {\n          if (scratch2.bytes[scratch2.offset + i] == FLAG_SEPARATOR || scratch2.bytes[scratch2.offset + i] == MORPH_SEPARATOR) {\n            scratch2.length = i;\n            break;\n          }\n        }\n        \n        int cmp = scratch1.compareTo(scratch2);\n        if (cmp == 0) {\n          // tie break on whole row\n          return o1.compareTo(o2);\n        } else {\n          return cmp;\n        }\n      }\n    });\n\n    String sorted;\n    boolean success = false;\n    try {\n      sorted = sorter.sort(unsorted.getName());\n      success = true;\n    } finally {\n      if (success) {\n        tempDir.deleteFile(unsorted.getName());\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, unsorted.getName());\n      }\n    }\n    \n    boolean success2 = false;\n    \n    try (ByteSequencesReader reader = new ByteSequencesReader(tempDir.openChecksumInput(sorted, IOContext.READONCE), sorted)) {\n    \n      // TODO: the flags themselves can be double-chars (long) or also numeric\n      // either way the trick is to encode them as char... but they must be parsed differently\n    \n      String currentEntry = null;\n      IntsRefBuilder currentOrds = new IntsRefBuilder();\n\n      while (true) {\n        BytesRef scratch = reader.next();\n        if (scratch == null) {\n          break;\n        }\n        \n        String line = scratch.utf8ToString();\n        String entry;\n        char wordForm[];\n        int end;\n\n        int flagSep = line.indexOf(FLAG_SEPARATOR);\n        if (flagSep == -1) {\n          wordForm = NOFLAGS;\n          end = line.indexOf(MORPH_SEPARATOR);\n          entry = line.substring(0, end);\n        } else {\n          end = line.indexOf(MORPH_SEPARATOR);\n          String flagPart = line.substring(flagSep + 1, end);\n          if (aliasCount > 0) {\n            flagPart = getAliasValue(Integer.parseInt(flagPart));\n          } \n        \n          wordForm = flagParsingStrategy.parseFlags(flagPart);\n          Arrays.sort(wordForm);\n          entry = line.substring(0, flagSep);\n        }\n        // we possibly have morphological data\n        int stemExceptionID = 0;\n        if (hasStemExceptions && end+1 < line.length()) {\n          String stemException = parseStemException(line.substring(end+1));\n          if (stemException != null) {\n            if (stemExceptionCount == stemExceptions.length) {\n              int newSize = ArrayUtil.oversize(stemExceptionCount+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF);\n              stemExceptions = Arrays.copyOf(stemExceptions, newSize);\n            }\n            stemExceptionID = stemExceptionCount+1; // we use '0' to indicate no exception for the form\n            stemExceptions[stemExceptionCount++] = stemException;\n          }\n        }\n\n        int cmp = currentEntry == null ? 1 : entry.compareTo(currentEntry);\n        if (cmp < 0) {\n          throw new IllegalArgumentException(\"out of order: \" + entry + \" < \" + currentEntry);\n        } else {\n          encodeFlags(flagsScratch, wordForm);\n          int ord = flagLookup.add(flagsScratch.get());\n          if (ord < 0) {\n            // already exists in our hash\n            ord = (-ord)-1;\n          }\n          // finalize current entry, and switch \"current\" if necessary\n          if (cmp > 0 && currentEntry != null) {\n            Util.toUTF32(currentEntry, scratchInts);\n            words.add(scratchInts.get(), currentOrds.get());\n          }\n          // swap current\n          if (cmp > 0 || currentEntry == null) {\n            currentEntry = entry;\n            currentOrds = new IntsRefBuilder(); // must be this way\n          }\n          if (hasStemExceptions) {\n            currentOrds.append(ord);\n            currentOrds.append(stemExceptionID);\n          } else {\n            currentOrds.append(ord);\n          }\n        }\n      }\n    \n      // finalize last entry\n      Util.toUTF32(currentEntry, scratchInts);\n      words.add(scratchInts.get(), currentOrds.get());\n      success2 = true;\n    } finally {\n      if (success2) {\n        tempDir.deleteFile(sorted);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, sorted);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#readDictionaryFiles(Directory,String,List[InputStream],CharsetDecoder,Builder[IntsRef]).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#readDictionaryFiles(Directory,String,List[InputStream],CharsetDecoder,Builder[IntsRef]).mjava","sourceNew":"  /**\n   * Reads the dictionary file through the provided InputStreams, building up the words map\n   *\n   * @param dictionaries InputStreams to read the dictionary file through\n   * @param decoder CharsetDecoder used to decode the contents of the file\n   * @throws IOException Can be thrown while reading from the file\n   */\n  private void readDictionaryFiles(Directory tempDir, String tempFileNamePrefix, List<InputStream> dictionaries, CharsetDecoder decoder, Builder<IntsRef> words) throws IOException {\n    BytesRefBuilder flagsScratch = new BytesRefBuilder();\n    IntsRefBuilder scratchInts = new IntsRefBuilder();\n    \n    StringBuilder sb = new StringBuilder();\n\n    IndexOutput unsorted = tempDir.createTempOutput(tempFileNamePrefix, \"dat\", IOContext.DEFAULT);\n    try (ByteSequencesWriter writer = new ByteSequencesWriter(unsorted)) {\n      for (InputStream dictionary : dictionaries) {\n        BufferedReader lines = new BufferedReader(new InputStreamReader(dictionary, decoder));\n        String line = lines.readLine(); // first line is number of entries (approximately, sometimes)\n        \n        while ((line = lines.readLine()) != null) {\n          // wild and unpredictable code comment rules\n          if (line.isEmpty() || line.charAt(0) == '/' || line.charAt(0) == '#' || line.charAt(0) == '\\t') {\n            continue;\n          }\n          line = unescapeEntry(line);\n          // if we havent seen any stem exceptions, try to parse one\n          if (hasStemExceptions == false) {\n            int morphStart = line.indexOf(MORPH_SEPARATOR);\n            if (morphStart >= 0 && morphStart < line.length()) {\n              hasStemExceptions = parseStemException(line.substring(morphStart+1)) != null;\n            }\n          }\n          if (needsInputCleaning) {\n            int flagSep = line.indexOf(FLAG_SEPARATOR);\n            if (flagSep == -1) {\n              flagSep = line.indexOf(MORPH_SEPARATOR);\n            }\n            if (flagSep == -1) {\n              CharSequence cleansed = cleanInput(line, sb);\n              writer.write(cleansed.toString().getBytes(StandardCharsets.UTF_8));\n            } else {\n              String text = line.substring(0, flagSep);\n              CharSequence cleansed = cleanInput(text, sb);\n              if (cleansed != sb) {\n                sb.setLength(0);\n                sb.append(cleansed);\n              }\n              sb.append(line.substring(flagSep));\n              writer.write(sb.toString().getBytes(StandardCharsets.UTF_8));\n            }\n          } else {\n            writer.write(line.getBytes(StandardCharsets.UTF_8));\n          }\n        }\n      }\n      CodecUtil.writeFooter(unsorted);\n    }\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, new Comparator<BytesRef>() {\n      BytesRef scratch1 = new BytesRef();\n      BytesRef scratch2 = new BytesRef();\n      \n      @Override\n      public int compare(BytesRef o1, BytesRef o2) {\n        scratch1.bytes = o1.bytes;\n        scratch1.offset = o1.offset;\n        scratch1.length = o1.length;\n        \n        for (int i = scratch1.length - 1; i >= 0; i--) {\n          if (scratch1.bytes[scratch1.offset + i] == FLAG_SEPARATOR || scratch1.bytes[scratch1.offset + i] == MORPH_SEPARATOR) {\n            scratch1.length = i;\n            break;\n          }\n        }\n        \n        scratch2.bytes = o2.bytes;\n        scratch2.offset = o2.offset;\n        scratch2.length = o2.length;\n        \n        for (int i = scratch2.length - 1; i >= 0; i--) {\n          if (scratch2.bytes[scratch2.offset + i] == FLAG_SEPARATOR || scratch2.bytes[scratch2.offset + i] == MORPH_SEPARATOR) {\n            scratch2.length = i;\n            break;\n          }\n        }\n        \n        int cmp = scratch1.compareTo(scratch2);\n        if (cmp == 0) {\n          // tie break on whole row\n          return o1.compareTo(o2);\n        } else {\n          return cmp;\n        }\n      }\n    });\n\n    String sorted;\n    boolean success = false;\n    try {\n      sorted = sorter.sort(unsorted.getName());\n      success = true;\n    } finally {\n      if (success) {\n        tempDir.deleteFile(unsorted.getName());\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, unsorted.getName());\n      }\n    }\n    \n    boolean success2 = false;\n    \n    try (ByteSequencesReader reader = new ByteSequencesReader(tempDir.openChecksumInput(sorted, IOContext.READONCE), sorted)) {\n    \n      // TODO: the flags themselves can be double-chars (long) or also numeric\n      // either way the trick is to encode them as char... but they must be parsed differently\n    \n      String currentEntry = null;\n      IntsRefBuilder currentOrds = new IntsRefBuilder();\n\n      while (true) {\n        BytesRef scratch = reader.next();\n        if (scratch == null) {\n          break;\n        }\n        \n        String line = scratch.utf8ToString();\n        String entry;\n        char wordForm[];\n        int end;\n\n        int flagSep = line.indexOf(FLAG_SEPARATOR);\n        if (flagSep == -1) {\n          wordForm = NOFLAGS;\n          end = line.indexOf(MORPH_SEPARATOR);\n          entry = line.substring(0, end);\n        } else {\n          end = line.indexOf(MORPH_SEPARATOR);\n          String flagPart = line.substring(flagSep + 1, end);\n          if (aliasCount > 0) {\n            flagPart = getAliasValue(Integer.parseInt(flagPart));\n          } \n        \n          wordForm = flagParsingStrategy.parseFlags(flagPart);\n          Arrays.sort(wordForm);\n          entry = line.substring(0, flagSep);\n        }\n        // we possibly have morphological data\n        int stemExceptionID = 0;\n        if (hasStemExceptions && end+1 < line.length()) {\n          String stemException = parseStemException(line.substring(end+1));\n          if (stemException != null) {\n            stemExceptions = ArrayUtil.grow(stemExceptions, stemExceptionCount+1);\n            stemExceptionID = stemExceptionCount+1; // we use '0' to indicate no exception for the form\n            stemExceptions[stemExceptionCount++] = stemException;\n          }\n        }\n\n        int cmp = currentEntry == null ? 1 : entry.compareTo(currentEntry);\n        if (cmp < 0) {\n          throw new IllegalArgumentException(\"out of order: \" + entry + \" < \" + currentEntry);\n        } else {\n          encodeFlags(flagsScratch, wordForm);\n          int ord = flagLookup.add(flagsScratch.get());\n          if (ord < 0) {\n            // already exists in our hash\n            ord = (-ord)-1;\n          }\n          // finalize current entry, and switch \"current\" if necessary\n          if (cmp > 0 && currentEntry != null) {\n            Util.toUTF32(currentEntry, scratchInts);\n            words.add(scratchInts.get(), currentOrds.get());\n          }\n          // swap current\n          if (cmp > 0 || currentEntry == null) {\n            currentEntry = entry;\n            currentOrds = new IntsRefBuilder(); // must be this way\n          }\n          if (hasStemExceptions) {\n            currentOrds.append(ord);\n            currentOrds.append(stemExceptionID);\n          } else {\n            currentOrds.append(ord);\n          }\n        }\n      }\n    \n      // finalize last entry\n      Util.toUTF32(currentEntry, scratchInts);\n      words.add(scratchInts.get(), currentOrds.get());\n      success2 = true;\n    } finally {\n      if (success2) {\n        tempDir.deleteFile(sorted);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, sorted);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Reads the dictionary file through the provided InputStreams, building up the words map\n   *\n   * @param dictionaries InputStreams to read the dictionary file through\n   * @param decoder CharsetDecoder used to decode the contents of the file\n   * @throws IOException Can be thrown while reading from the file\n   */\n  private void readDictionaryFiles(Directory tempDir, String tempFileNamePrefix, List<InputStream> dictionaries, CharsetDecoder decoder, Builder<IntsRef> words) throws IOException {\n    BytesRefBuilder flagsScratch = new BytesRefBuilder();\n    IntsRefBuilder scratchInts = new IntsRefBuilder();\n    \n    StringBuilder sb = new StringBuilder();\n\n    IndexOutput unsorted = tempDir.createTempOutput(tempFileNamePrefix, \"dat\", IOContext.DEFAULT);\n    try (ByteSequencesWriter writer = new ByteSequencesWriter(unsorted)) {\n      for (InputStream dictionary : dictionaries) {\n        BufferedReader lines = new BufferedReader(new InputStreamReader(dictionary, decoder));\n        String line = lines.readLine(); // first line is number of entries (approximately, sometimes)\n        \n        while ((line = lines.readLine()) != null) {\n          // wild and unpredictable code comment rules\n          if (line.isEmpty() || line.charAt(0) == '/' || line.charAt(0) == '#' || line.charAt(0) == '\\t') {\n            continue;\n          }\n          line = unescapeEntry(line);\n          // if we havent seen any stem exceptions, try to parse one\n          if (hasStemExceptions == false) {\n            int morphStart = line.indexOf(MORPH_SEPARATOR);\n            if (morphStart >= 0 && morphStart < line.length()) {\n              hasStemExceptions = parseStemException(line.substring(morphStart+1)) != null;\n            }\n          }\n          if (needsInputCleaning) {\n            int flagSep = line.indexOf(FLAG_SEPARATOR);\n            if (flagSep == -1) {\n              flagSep = line.indexOf(MORPH_SEPARATOR);\n            }\n            if (flagSep == -1) {\n              CharSequence cleansed = cleanInput(line, sb);\n              writer.write(cleansed.toString().getBytes(StandardCharsets.UTF_8));\n            } else {\n              String text = line.substring(0, flagSep);\n              CharSequence cleansed = cleanInput(text, sb);\n              if (cleansed != sb) {\n                sb.setLength(0);\n                sb.append(cleansed);\n              }\n              sb.append(line.substring(flagSep));\n              writer.write(sb.toString().getBytes(StandardCharsets.UTF_8));\n            }\n          } else {\n            writer.write(line.getBytes(StandardCharsets.UTF_8));\n          }\n        }\n      }\n      CodecUtil.writeFooter(unsorted);\n    }\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, new Comparator<BytesRef>() {\n      BytesRef scratch1 = new BytesRef();\n      BytesRef scratch2 = new BytesRef();\n      \n      @Override\n      public int compare(BytesRef o1, BytesRef o2) {\n        scratch1.bytes = o1.bytes;\n        scratch1.offset = o1.offset;\n        scratch1.length = o1.length;\n        \n        for (int i = scratch1.length - 1; i >= 0; i--) {\n          if (scratch1.bytes[scratch1.offset + i] == FLAG_SEPARATOR || scratch1.bytes[scratch1.offset + i] == MORPH_SEPARATOR) {\n            scratch1.length = i;\n            break;\n          }\n        }\n        \n        scratch2.bytes = o2.bytes;\n        scratch2.offset = o2.offset;\n        scratch2.length = o2.length;\n        \n        for (int i = scratch2.length - 1; i >= 0; i--) {\n          if (scratch2.bytes[scratch2.offset + i] == FLAG_SEPARATOR || scratch2.bytes[scratch2.offset + i] == MORPH_SEPARATOR) {\n            scratch2.length = i;\n            break;\n          }\n        }\n        \n        int cmp = scratch1.compareTo(scratch2);\n        if (cmp == 0) {\n          // tie break on whole row\n          return o1.compareTo(o2);\n        } else {\n          return cmp;\n        }\n      }\n    });\n\n    String sorted;\n    boolean success = false;\n    try {\n      sorted = sorter.sort(unsorted.getName());\n      success = true;\n    } finally {\n      if (success) {\n        tempDir.deleteFile(unsorted.getName());\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, unsorted.getName());\n      }\n    }\n    \n    boolean success2 = false;\n    \n    try (ByteSequencesReader reader = new ByteSequencesReader(tempDir.openChecksumInput(sorted, IOContext.READONCE), sorted)) {\n    \n      // TODO: the flags themselves can be double-chars (long) or also numeric\n      // either way the trick is to encode them as char... but they must be parsed differently\n    \n      String currentEntry = null;\n      IntsRefBuilder currentOrds = new IntsRefBuilder();\n\n      while (true) {\n        BytesRef scratch = reader.next();\n        if (scratch == null) {\n          break;\n        }\n        \n        String line = scratch.utf8ToString();\n        String entry;\n        char wordForm[];\n        int end;\n\n        int flagSep = line.indexOf(FLAG_SEPARATOR);\n        if (flagSep == -1) {\n          wordForm = NOFLAGS;\n          end = line.indexOf(MORPH_SEPARATOR);\n          entry = line.substring(0, end);\n        } else {\n          end = line.indexOf(MORPH_SEPARATOR);\n          String flagPart = line.substring(flagSep + 1, end);\n          if (aliasCount > 0) {\n            flagPart = getAliasValue(Integer.parseInt(flagPart));\n          } \n        \n          wordForm = flagParsingStrategy.parseFlags(flagPart);\n          Arrays.sort(wordForm);\n          entry = line.substring(0, flagSep);\n        }\n        // we possibly have morphological data\n        int stemExceptionID = 0;\n        if (hasStemExceptions && end+1 < line.length()) {\n          String stemException = parseStemException(line.substring(end+1));\n          if (stemException != null) {\n            if (stemExceptionCount == stemExceptions.length) {\n              int newSize = ArrayUtil.oversize(stemExceptionCount+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF);\n              stemExceptions = Arrays.copyOf(stemExceptions, newSize);\n            }\n            stemExceptionID = stemExceptionCount+1; // we use '0' to indicate no exception for the form\n            stemExceptions[stemExceptionCount++] = stemException;\n          }\n        }\n\n        int cmp = currentEntry == null ? 1 : entry.compareTo(currentEntry);\n        if (cmp < 0) {\n          throw new IllegalArgumentException(\"out of order: \" + entry + \" < \" + currentEntry);\n        } else {\n          encodeFlags(flagsScratch, wordForm);\n          int ord = flagLookup.add(flagsScratch.get());\n          if (ord < 0) {\n            // already exists in our hash\n            ord = (-ord)-1;\n          }\n          // finalize current entry, and switch \"current\" if necessary\n          if (cmp > 0 && currentEntry != null) {\n            Util.toUTF32(currentEntry, scratchInts);\n            words.add(scratchInts.get(), currentOrds.get());\n          }\n          // swap current\n          if (cmp > 0 || currentEntry == null) {\n            currentEntry = entry;\n            currentOrds = new IntsRefBuilder(); // must be this way\n          }\n          if (hasStemExceptions) {\n            currentOrds.append(ord);\n            currentOrds.append(stemExceptionID);\n          } else {\n            currentOrds.append(ord);\n          }\n        }\n      }\n    \n      // finalize last entry\n      Util.toUTF32(currentEntry, scratchInts);\n      words.add(scratchInts.get(), currentOrds.get());\n      success2 = true;\n    } finally {\n      if (success2) {\n        tempDir.deleteFile(sorted);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, sorted);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#readDictionaryFiles(Directory,String,List[InputStream],CharsetDecoder,Builder[IntsRef]).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#readDictionaryFiles(Directory,String,List[InputStream],CharsetDecoder,Builder[IntsRef]).mjava","sourceNew":"  /**\n   * Reads the dictionary file through the provided InputStreams, building up the words map\n   *\n   * @param dictionaries InputStreams to read the dictionary file through\n   * @param decoder CharsetDecoder used to decode the contents of the file\n   * @throws IOException Can be thrown while reading from the file\n   */\n  private void readDictionaryFiles(Directory tempDir, String tempFileNamePrefix, List<InputStream> dictionaries, CharsetDecoder decoder, Builder<IntsRef> words) throws IOException {\n    BytesRefBuilder flagsScratch = new BytesRefBuilder();\n    IntsRefBuilder scratchInts = new IntsRefBuilder();\n    \n    StringBuilder sb = new StringBuilder();\n\n    IndexOutput unsorted = tempDir.createTempOutput(tempFileNamePrefix, \"dat\", IOContext.DEFAULT);\n    try (ByteSequencesWriter writer = new ByteSequencesWriter(unsorted)) {\n      for (InputStream dictionary : dictionaries) {\n        BufferedReader lines = new BufferedReader(new InputStreamReader(dictionary, decoder));\n        String line = lines.readLine(); // first line is number of entries (approximately, sometimes)\n        \n        while ((line = lines.readLine()) != null) {\n          // wild and unpredictable code comment rules\n          if (line.isEmpty() || line.charAt(0) == '/' || line.charAt(0) == '#' || line.charAt(0) == '\\t') {\n            continue;\n          }\n          line = unescapeEntry(line);\n          // if we havent seen any stem exceptions, try to parse one\n          if (hasStemExceptions == false) {\n            int morphStart = line.indexOf(MORPH_SEPARATOR);\n            if (morphStart >= 0 && morphStart < line.length()) {\n              hasStemExceptions = parseStemException(line.substring(morphStart+1)) != null;\n            }\n          }\n          if (needsInputCleaning) {\n            int flagSep = line.indexOf(FLAG_SEPARATOR);\n            if (flagSep == -1) {\n              flagSep = line.indexOf(MORPH_SEPARATOR);\n            }\n            if (flagSep == -1) {\n              CharSequence cleansed = cleanInput(line, sb);\n              writer.write(cleansed.toString().getBytes(StandardCharsets.UTF_8));\n            } else {\n              String text = line.substring(0, flagSep);\n              CharSequence cleansed = cleanInput(text, sb);\n              if (cleansed != sb) {\n                sb.setLength(0);\n                sb.append(cleansed);\n              }\n              sb.append(line.substring(flagSep));\n              writer.write(sb.toString().getBytes(StandardCharsets.UTF_8));\n            }\n          } else {\n            writer.write(line.getBytes(StandardCharsets.UTF_8));\n          }\n        }\n      }\n      CodecUtil.writeFooter(unsorted);\n    }\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, new Comparator<BytesRef>() {\n      BytesRef scratch1 = new BytesRef();\n      BytesRef scratch2 = new BytesRef();\n      \n      @Override\n      public int compare(BytesRef o1, BytesRef o2) {\n        scratch1.bytes = o1.bytes;\n        scratch1.offset = o1.offset;\n        scratch1.length = o1.length;\n        \n        for (int i = scratch1.length - 1; i >= 0; i--) {\n          if (scratch1.bytes[scratch1.offset + i] == FLAG_SEPARATOR || scratch1.bytes[scratch1.offset + i] == MORPH_SEPARATOR) {\n            scratch1.length = i;\n            break;\n          }\n        }\n        \n        scratch2.bytes = o2.bytes;\n        scratch2.offset = o2.offset;\n        scratch2.length = o2.length;\n        \n        for (int i = scratch2.length - 1; i >= 0; i--) {\n          if (scratch2.bytes[scratch2.offset + i] == FLAG_SEPARATOR || scratch2.bytes[scratch2.offset + i] == MORPH_SEPARATOR) {\n            scratch2.length = i;\n            break;\n          }\n        }\n        \n        int cmp = scratch1.compareTo(scratch2);\n        if (cmp == 0) {\n          // tie break on whole row\n          return o1.compareTo(o2);\n        } else {\n          return cmp;\n        }\n      }\n    });\n\n    String sorted;\n    boolean success = false;\n    try {\n      sorted = sorter.sort(unsorted.getName());\n      success = true;\n    } finally {\n      if (success) {\n        tempDir.deleteFile(unsorted.getName());\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, unsorted.getName());\n      }\n    }\n    \n    boolean success2 = false;\n    \n    try (ByteSequencesReader reader = new ByteSequencesReader(tempDir.openChecksumInput(sorted, IOContext.READONCE), sorted)) {\n    \n      // TODO: the flags themselves can be double-chars (long) or also numeric\n      // either way the trick is to encode them as char... but they must be parsed differently\n    \n      String currentEntry = null;\n      IntsRefBuilder currentOrds = new IntsRefBuilder();\n\n      while (true) {\n        BytesRef scratch = reader.next();\n        if (scratch == null) {\n          break;\n        }\n        \n        String line = scratch.utf8ToString();\n        String entry;\n        char wordForm[];\n        int end;\n\n        int flagSep = line.indexOf(FLAG_SEPARATOR);\n        if (flagSep == -1) {\n          wordForm = NOFLAGS;\n          end = line.indexOf(MORPH_SEPARATOR);\n          entry = line.substring(0, end);\n        } else {\n          end = line.indexOf(MORPH_SEPARATOR);\n          String flagPart = line.substring(flagSep + 1, end);\n          if (aliasCount > 0) {\n            flagPart = getAliasValue(Integer.parseInt(flagPart));\n          } \n        \n          wordForm = flagParsingStrategy.parseFlags(flagPart);\n          Arrays.sort(wordForm);\n          entry = line.substring(0, flagSep);\n        }\n        // we possibly have morphological data\n        int stemExceptionID = 0;\n        if (hasStemExceptions && end+1 < line.length()) {\n          String stemException = parseStemException(line.substring(end+1));\n          if (stemException != null) {\n            stemExceptions = ArrayUtil.grow(stemExceptions, stemExceptionCount+1);\n            stemExceptionID = stemExceptionCount+1; // we use '0' to indicate no exception for the form\n            stemExceptions[stemExceptionCount++] = stemException;\n          }\n        }\n\n        int cmp = currentEntry == null ? 1 : entry.compareTo(currentEntry);\n        if (cmp < 0) {\n          throw new IllegalArgumentException(\"out of order: \" + entry + \" < \" + currentEntry);\n        } else {\n          encodeFlags(flagsScratch, wordForm);\n          int ord = flagLookup.add(flagsScratch.get());\n          if (ord < 0) {\n            // already exists in our hash\n            ord = (-ord)-1;\n          }\n          // finalize current entry, and switch \"current\" if necessary\n          if (cmp > 0 && currentEntry != null) {\n            Util.toUTF32(currentEntry, scratchInts);\n            words.add(scratchInts.get(), currentOrds.get());\n          }\n          // swap current\n          if (cmp > 0 || currentEntry == null) {\n            currentEntry = entry;\n            currentOrds = new IntsRefBuilder(); // must be this way\n          }\n          if (hasStemExceptions) {\n            currentOrds.append(ord);\n            currentOrds.append(stemExceptionID);\n          } else {\n            currentOrds.append(ord);\n          }\n        }\n      }\n    \n      // finalize last entry\n      Util.toUTF32(currentEntry, scratchInts);\n      words.add(scratchInts.get(), currentOrds.get());\n      success2 = true;\n    } finally {\n      if (success2) {\n        tempDir.deleteFile(sorted);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, sorted);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Reads the dictionary file through the provided InputStreams, building up the words map\n   *\n   * @param dictionaries InputStreams to read the dictionary file through\n   * @param decoder CharsetDecoder used to decode the contents of the file\n   * @throws IOException Can be thrown while reading from the file\n   */\n  private void readDictionaryFiles(Directory tempDir, String tempFileNamePrefix, List<InputStream> dictionaries, CharsetDecoder decoder, Builder<IntsRef> words) throws IOException {\n    BytesRefBuilder flagsScratch = new BytesRefBuilder();\n    IntsRefBuilder scratchInts = new IntsRefBuilder();\n    \n    StringBuilder sb = new StringBuilder();\n\n    IndexOutput unsorted = tempDir.createTempOutput(tempFileNamePrefix, \"dat\", IOContext.DEFAULT);\n    try (ByteSequencesWriter writer = new ByteSequencesWriter(unsorted)) {\n      for (InputStream dictionary : dictionaries) {\n        BufferedReader lines = new BufferedReader(new InputStreamReader(dictionary, decoder));\n        String line = lines.readLine(); // first line is number of entries (approximately, sometimes)\n        \n        while ((line = lines.readLine()) != null) {\n          // wild and unpredictable code comment rules\n          if (line.isEmpty() || line.charAt(0) == '/' || line.charAt(0) == '#' || line.charAt(0) == '\\t') {\n            continue;\n          }\n          line = unescapeEntry(line);\n          // if we havent seen any stem exceptions, try to parse one\n          if (hasStemExceptions == false) {\n            int morphStart = line.indexOf(MORPH_SEPARATOR);\n            if (morphStart >= 0 && morphStart < line.length()) {\n              hasStemExceptions = parseStemException(line.substring(morphStart+1)) != null;\n            }\n          }\n          if (needsInputCleaning) {\n            int flagSep = line.indexOf(FLAG_SEPARATOR);\n            if (flagSep == -1) {\n              flagSep = line.indexOf(MORPH_SEPARATOR);\n            }\n            if (flagSep == -1) {\n              CharSequence cleansed = cleanInput(line, sb);\n              writer.write(cleansed.toString().getBytes(StandardCharsets.UTF_8));\n            } else {\n              String text = line.substring(0, flagSep);\n              CharSequence cleansed = cleanInput(text, sb);\n              if (cleansed != sb) {\n                sb.setLength(0);\n                sb.append(cleansed);\n              }\n              sb.append(line.substring(flagSep));\n              writer.write(sb.toString().getBytes(StandardCharsets.UTF_8));\n            }\n          } else {\n            writer.write(line.getBytes(StandardCharsets.UTF_8));\n          }\n        }\n      }\n      CodecUtil.writeFooter(unsorted);\n    }\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, new Comparator<BytesRef>() {\n      BytesRef scratch1 = new BytesRef();\n      BytesRef scratch2 = new BytesRef();\n      \n      @Override\n      public int compare(BytesRef o1, BytesRef o2) {\n        scratch1.bytes = o1.bytes;\n        scratch1.offset = o1.offset;\n        scratch1.length = o1.length;\n        \n        for (int i = scratch1.length - 1; i >= 0; i--) {\n          if (scratch1.bytes[scratch1.offset + i] == FLAG_SEPARATOR || scratch1.bytes[scratch1.offset + i] == MORPH_SEPARATOR) {\n            scratch1.length = i;\n            break;\n          }\n        }\n        \n        scratch2.bytes = o2.bytes;\n        scratch2.offset = o2.offset;\n        scratch2.length = o2.length;\n        \n        for (int i = scratch2.length - 1; i >= 0; i--) {\n          if (scratch2.bytes[scratch2.offset + i] == FLAG_SEPARATOR || scratch2.bytes[scratch2.offset + i] == MORPH_SEPARATOR) {\n            scratch2.length = i;\n            break;\n          }\n        }\n        \n        int cmp = scratch1.compareTo(scratch2);\n        if (cmp == 0) {\n          // tie break on whole row\n          return o1.compareTo(o2);\n        } else {\n          return cmp;\n        }\n      }\n    });\n\n    String sorted;\n    boolean success = false;\n    try {\n      sorted = sorter.sort(unsorted.getName());\n      success = true;\n    } finally {\n      if (success) {\n        tempDir.deleteFile(unsorted.getName());\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, unsorted.getName());\n      }\n    }\n    \n    boolean success2 = false;\n    \n    try (ByteSequencesReader reader = new ByteSequencesReader(tempDir.openChecksumInput(sorted, IOContext.READONCE), sorted)) {\n    \n      // TODO: the flags themselves can be double-chars (long) or also numeric\n      // either way the trick is to encode them as char... but they must be parsed differently\n    \n      String currentEntry = null;\n      IntsRefBuilder currentOrds = new IntsRefBuilder();\n\n      while (true) {\n        BytesRef scratch = reader.next();\n        if (scratch == null) {\n          break;\n        }\n        \n        String line = scratch.utf8ToString();\n        String entry;\n        char wordForm[];\n        int end;\n\n        int flagSep = line.indexOf(FLAG_SEPARATOR);\n        if (flagSep == -1) {\n          wordForm = NOFLAGS;\n          end = line.indexOf(MORPH_SEPARATOR);\n          entry = line.substring(0, end);\n        } else {\n          end = line.indexOf(MORPH_SEPARATOR);\n          String flagPart = line.substring(flagSep + 1, end);\n          if (aliasCount > 0) {\n            flagPart = getAliasValue(Integer.parseInt(flagPart));\n          } \n        \n          wordForm = flagParsingStrategy.parseFlags(flagPart);\n          Arrays.sort(wordForm);\n          entry = line.substring(0, flagSep);\n        }\n        // we possibly have morphological data\n        int stemExceptionID = 0;\n        if (hasStemExceptions && end+1 < line.length()) {\n          String stemException = parseStemException(line.substring(end+1));\n          if (stemException != null) {\n            if (stemExceptionCount == stemExceptions.length) {\n              int newSize = ArrayUtil.oversize(stemExceptionCount+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF);\n              stemExceptions = Arrays.copyOf(stemExceptions, newSize);\n            }\n            stemExceptionID = stemExceptionCount+1; // we use '0' to indicate no exception for the form\n            stemExceptions[stemExceptionCount++] = stemException;\n          }\n        }\n\n        int cmp = currentEntry == null ? 1 : entry.compareTo(currentEntry);\n        if (cmp < 0) {\n          throw new IllegalArgumentException(\"out of order: \" + entry + \" < \" + currentEntry);\n        } else {\n          encodeFlags(flagsScratch, wordForm);\n          int ord = flagLookup.add(flagsScratch.get());\n          if (ord < 0) {\n            // already exists in our hash\n            ord = (-ord)-1;\n          }\n          // finalize current entry, and switch \"current\" if necessary\n          if (cmp > 0 && currentEntry != null) {\n            Util.toUTF32(currentEntry, scratchInts);\n            words.add(scratchInts.get(), currentOrds.get());\n          }\n          // swap current\n          if (cmp > 0 || currentEntry == null) {\n            currentEntry = entry;\n            currentOrds = new IntsRefBuilder(); // must be this way\n          }\n          if (hasStemExceptions) {\n            currentOrds.append(ord);\n            currentOrds.append(stemExceptionID);\n          } else {\n            currentOrds.append(ord);\n          }\n        }\n      }\n    \n      // finalize last entry\n      Util.toUTF32(currentEntry, scratchInts);\n      words.add(scratchInts.get(), currentOrds.get());\n      success2 = true;\n    } finally {\n      if (success2) {\n        tempDir.deleteFile(sorted);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, sorted);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f5661e6a04d3172e262ad741b717924f2f1b6a5","date":1576244274,"type":5,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#readDictionaryFiles(Directory,String,List[InputStream],CharsetDecoder,FSTCompiler[IntsRef]).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#readDictionaryFiles(Directory,String,List[InputStream],CharsetDecoder,Builder[IntsRef]).mjava","sourceNew":"  /**\n   * Reads the dictionary file through the provided InputStreams, building up the words map\n   *\n   * @param dictionaries InputStreams to read the dictionary file through\n   * @param decoder CharsetDecoder used to decode the contents of the file\n   * @throws IOException Can be thrown while reading from the file\n   */\n  private void readDictionaryFiles(Directory tempDir, String tempFileNamePrefix, List<InputStream> dictionaries, CharsetDecoder decoder, FSTCompiler<IntsRef> words) throws IOException {\n    BytesRefBuilder flagsScratch = new BytesRefBuilder();\n    IntsRefBuilder scratchInts = new IntsRefBuilder();\n    \n    StringBuilder sb = new StringBuilder();\n\n    IndexOutput unsorted = tempDir.createTempOutput(tempFileNamePrefix, \"dat\", IOContext.DEFAULT);\n    try (ByteSequencesWriter writer = new ByteSequencesWriter(unsorted)) {\n      for (InputStream dictionary : dictionaries) {\n        BufferedReader lines = new BufferedReader(new InputStreamReader(dictionary, decoder));\n        String line = lines.readLine(); // first line is number of entries (approximately, sometimes)\n        \n        while ((line = lines.readLine()) != null) {\n          // wild and unpredictable code comment rules\n          if (line.isEmpty() || line.charAt(0) == '/' || line.charAt(0) == '#' || line.charAt(0) == '\\t') {\n            continue;\n          }\n          line = unescapeEntry(line);\n          // if we havent seen any stem exceptions, try to parse one\n          if (hasStemExceptions == false) {\n            int morphStart = line.indexOf(MORPH_SEPARATOR);\n            if (morphStart >= 0 && morphStart < line.length()) {\n              hasStemExceptions = parseStemException(line.substring(morphStart+1)) != null;\n            }\n          }\n          if (needsInputCleaning) {\n            int flagSep = line.indexOf(FLAG_SEPARATOR);\n            if (flagSep == -1) {\n              flagSep = line.indexOf(MORPH_SEPARATOR);\n            }\n            if (flagSep == -1) {\n              CharSequence cleansed = cleanInput(line, sb);\n              writer.write(cleansed.toString().getBytes(StandardCharsets.UTF_8));\n            } else {\n              String text = line.substring(0, flagSep);\n              CharSequence cleansed = cleanInput(text, sb);\n              if (cleansed != sb) {\n                sb.setLength(0);\n                sb.append(cleansed);\n              }\n              sb.append(line.substring(flagSep));\n              writer.write(sb.toString().getBytes(StandardCharsets.UTF_8));\n            }\n          } else {\n            writer.write(line.getBytes(StandardCharsets.UTF_8));\n          }\n        }\n      }\n      CodecUtil.writeFooter(unsorted);\n    }\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, new Comparator<BytesRef>() {\n      BytesRef scratch1 = new BytesRef();\n      BytesRef scratch2 = new BytesRef();\n      \n      @Override\n      public int compare(BytesRef o1, BytesRef o2) {\n        scratch1.bytes = o1.bytes;\n        scratch1.offset = o1.offset;\n        scratch1.length = o1.length;\n        \n        for (int i = scratch1.length - 1; i >= 0; i--) {\n          if (scratch1.bytes[scratch1.offset + i] == FLAG_SEPARATOR || scratch1.bytes[scratch1.offset + i] == MORPH_SEPARATOR) {\n            scratch1.length = i;\n            break;\n          }\n        }\n        \n        scratch2.bytes = o2.bytes;\n        scratch2.offset = o2.offset;\n        scratch2.length = o2.length;\n        \n        for (int i = scratch2.length - 1; i >= 0; i--) {\n          if (scratch2.bytes[scratch2.offset + i] == FLAG_SEPARATOR || scratch2.bytes[scratch2.offset + i] == MORPH_SEPARATOR) {\n            scratch2.length = i;\n            break;\n          }\n        }\n        \n        int cmp = scratch1.compareTo(scratch2);\n        if (cmp == 0) {\n          // tie break on whole row\n          return o1.compareTo(o2);\n        } else {\n          return cmp;\n        }\n      }\n    });\n\n    String sorted;\n    boolean success = false;\n    try {\n      sorted = sorter.sort(unsorted.getName());\n      success = true;\n    } finally {\n      if (success) {\n        tempDir.deleteFile(unsorted.getName());\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, unsorted.getName());\n      }\n    }\n    \n    boolean success2 = false;\n    \n    try (ByteSequencesReader reader = new ByteSequencesReader(tempDir.openChecksumInput(sorted, IOContext.READONCE), sorted)) {\n    \n      // TODO: the flags themselves can be double-chars (long) or also numeric\n      // either way the trick is to encode them as char... but they must be parsed differently\n    \n      String currentEntry = null;\n      IntsRefBuilder currentOrds = new IntsRefBuilder();\n\n      while (true) {\n        BytesRef scratch = reader.next();\n        if (scratch == null) {\n          break;\n        }\n        \n        String line = scratch.utf8ToString();\n        String entry;\n        char wordForm[];\n        int end;\n\n        int flagSep = line.indexOf(FLAG_SEPARATOR);\n        if (flagSep == -1) {\n          wordForm = NOFLAGS;\n          end = line.indexOf(MORPH_SEPARATOR);\n          entry = line.substring(0, end);\n        } else {\n          end = line.indexOf(MORPH_SEPARATOR);\n          String flagPart = line.substring(flagSep + 1, end);\n          if (aliasCount > 0) {\n            flagPart = getAliasValue(Integer.parseInt(flagPart));\n          } \n        \n          wordForm = flagParsingStrategy.parseFlags(flagPart);\n          Arrays.sort(wordForm);\n          entry = line.substring(0, flagSep);\n        }\n        // we possibly have morphological data\n        int stemExceptionID = 0;\n        if (hasStemExceptions && end+1 < line.length()) {\n          String stemException = parseStemException(line.substring(end+1));\n          if (stemException != null) {\n            stemExceptions = ArrayUtil.grow(stemExceptions, stemExceptionCount+1);\n            stemExceptionID = stemExceptionCount+1; // we use '0' to indicate no exception for the form\n            stemExceptions[stemExceptionCount++] = stemException;\n          }\n        }\n\n        int cmp = currentEntry == null ? 1 : entry.compareTo(currentEntry);\n        if (cmp < 0) {\n          throw new IllegalArgumentException(\"out of order: \" + entry + \" < \" + currentEntry);\n        } else {\n          encodeFlags(flagsScratch, wordForm);\n          int ord = flagLookup.add(flagsScratch.get());\n          if (ord < 0) {\n            // already exists in our hash\n            ord = (-ord)-1;\n          }\n          // finalize current entry, and switch \"current\" if necessary\n          if (cmp > 0 && currentEntry != null) {\n            Util.toUTF32(currentEntry, scratchInts);\n            words.add(scratchInts.get(), currentOrds.get());\n          }\n          // swap current\n          if (cmp > 0 || currentEntry == null) {\n            currentEntry = entry;\n            currentOrds = new IntsRefBuilder(); // must be this way\n          }\n          if (hasStemExceptions) {\n            currentOrds.append(ord);\n            currentOrds.append(stemExceptionID);\n          } else {\n            currentOrds.append(ord);\n          }\n        }\n      }\n    \n      // finalize last entry\n      Util.toUTF32(currentEntry, scratchInts);\n      words.add(scratchInts.get(), currentOrds.get());\n      success2 = true;\n    } finally {\n      if (success2) {\n        tempDir.deleteFile(sorted);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, sorted);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Reads the dictionary file through the provided InputStreams, building up the words map\n   *\n   * @param dictionaries InputStreams to read the dictionary file through\n   * @param decoder CharsetDecoder used to decode the contents of the file\n   * @throws IOException Can be thrown while reading from the file\n   */\n  private void readDictionaryFiles(Directory tempDir, String tempFileNamePrefix, List<InputStream> dictionaries, CharsetDecoder decoder, Builder<IntsRef> words) throws IOException {\n    BytesRefBuilder flagsScratch = new BytesRefBuilder();\n    IntsRefBuilder scratchInts = new IntsRefBuilder();\n    \n    StringBuilder sb = new StringBuilder();\n\n    IndexOutput unsorted = tempDir.createTempOutput(tempFileNamePrefix, \"dat\", IOContext.DEFAULT);\n    try (ByteSequencesWriter writer = new ByteSequencesWriter(unsorted)) {\n      for (InputStream dictionary : dictionaries) {\n        BufferedReader lines = new BufferedReader(new InputStreamReader(dictionary, decoder));\n        String line = lines.readLine(); // first line is number of entries (approximately, sometimes)\n        \n        while ((line = lines.readLine()) != null) {\n          // wild and unpredictable code comment rules\n          if (line.isEmpty() || line.charAt(0) == '/' || line.charAt(0) == '#' || line.charAt(0) == '\\t') {\n            continue;\n          }\n          line = unescapeEntry(line);\n          // if we havent seen any stem exceptions, try to parse one\n          if (hasStemExceptions == false) {\n            int morphStart = line.indexOf(MORPH_SEPARATOR);\n            if (morphStart >= 0 && morphStart < line.length()) {\n              hasStemExceptions = parseStemException(line.substring(morphStart+1)) != null;\n            }\n          }\n          if (needsInputCleaning) {\n            int flagSep = line.indexOf(FLAG_SEPARATOR);\n            if (flagSep == -1) {\n              flagSep = line.indexOf(MORPH_SEPARATOR);\n            }\n            if (flagSep == -1) {\n              CharSequence cleansed = cleanInput(line, sb);\n              writer.write(cleansed.toString().getBytes(StandardCharsets.UTF_8));\n            } else {\n              String text = line.substring(0, flagSep);\n              CharSequence cleansed = cleanInput(text, sb);\n              if (cleansed != sb) {\n                sb.setLength(0);\n                sb.append(cleansed);\n              }\n              sb.append(line.substring(flagSep));\n              writer.write(sb.toString().getBytes(StandardCharsets.UTF_8));\n            }\n          } else {\n            writer.write(line.getBytes(StandardCharsets.UTF_8));\n          }\n        }\n      }\n      CodecUtil.writeFooter(unsorted);\n    }\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, new Comparator<BytesRef>() {\n      BytesRef scratch1 = new BytesRef();\n      BytesRef scratch2 = new BytesRef();\n      \n      @Override\n      public int compare(BytesRef o1, BytesRef o2) {\n        scratch1.bytes = o1.bytes;\n        scratch1.offset = o1.offset;\n        scratch1.length = o1.length;\n        \n        for (int i = scratch1.length - 1; i >= 0; i--) {\n          if (scratch1.bytes[scratch1.offset + i] == FLAG_SEPARATOR || scratch1.bytes[scratch1.offset + i] == MORPH_SEPARATOR) {\n            scratch1.length = i;\n            break;\n          }\n        }\n        \n        scratch2.bytes = o2.bytes;\n        scratch2.offset = o2.offset;\n        scratch2.length = o2.length;\n        \n        for (int i = scratch2.length - 1; i >= 0; i--) {\n          if (scratch2.bytes[scratch2.offset + i] == FLAG_SEPARATOR || scratch2.bytes[scratch2.offset + i] == MORPH_SEPARATOR) {\n            scratch2.length = i;\n            break;\n          }\n        }\n        \n        int cmp = scratch1.compareTo(scratch2);\n        if (cmp == 0) {\n          // tie break on whole row\n          return o1.compareTo(o2);\n        } else {\n          return cmp;\n        }\n      }\n    });\n\n    String sorted;\n    boolean success = false;\n    try {\n      sorted = sorter.sort(unsorted.getName());\n      success = true;\n    } finally {\n      if (success) {\n        tempDir.deleteFile(unsorted.getName());\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, unsorted.getName());\n      }\n    }\n    \n    boolean success2 = false;\n    \n    try (ByteSequencesReader reader = new ByteSequencesReader(tempDir.openChecksumInput(sorted, IOContext.READONCE), sorted)) {\n    \n      // TODO: the flags themselves can be double-chars (long) or also numeric\n      // either way the trick is to encode them as char... but they must be parsed differently\n    \n      String currentEntry = null;\n      IntsRefBuilder currentOrds = new IntsRefBuilder();\n\n      while (true) {\n        BytesRef scratch = reader.next();\n        if (scratch == null) {\n          break;\n        }\n        \n        String line = scratch.utf8ToString();\n        String entry;\n        char wordForm[];\n        int end;\n\n        int flagSep = line.indexOf(FLAG_SEPARATOR);\n        if (flagSep == -1) {\n          wordForm = NOFLAGS;\n          end = line.indexOf(MORPH_SEPARATOR);\n          entry = line.substring(0, end);\n        } else {\n          end = line.indexOf(MORPH_SEPARATOR);\n          String flagPart = line.substring(flagSep + 1, end);\n          if (aliasCount > 0) {\n            flagPart = getAliasValue(Integer.parseInt(flagPart));\n          } \n        \n          wordForm = flagParsingStrategy.parseFlags(flagPart);\n          Arrays.sort(wordForm);\n          entry = line.substring(0, flagSep);\n        }\n        // we possibly have morphological data\n        int stemExceptionID = 0;\n        if (hasStemExceptions && end+1 < line.length()) {\n          String stemException = parseStemException(line.substring(end+1));\n          if (stemException != null) {\n            stemExceptions = ArrayUtil.grow(stemExceptions, stemExceptionCount+1);\n            stemExceptionID = stemExceptionCount+1; // we use '0' to indicate no exception for the form\n            stemExceptions[stemExceptionCount++] = stemException;\n          }\n        }\n\n        int cmp = currentEntry == null ? 1 : entry.compareTo(currentEntry);\n        if (cmp < 0) {\n          throw new IllegalArgumentException(\"out of order: \" + entry + \" < \" + currentEntry);\n        } else {\n          encodeFlags(flagsScratch, wordForm);\n          int ord = flagLookup.add(flagsScratch.get());\n          if (ord < 0) {\n            // already exists in our hash\n            ord = (-ord)-1;\n          }\n          // finalize current entry, and switch \"current\" if necessary\n          if (cmp > 0 && currentEntry != null) {\n            Util.toUTF32(currentEntry, scratchInts);\n            words.add(scratchInts.get(), currentOrds.get());\n          }\n          // swap current\n          if (cmp > 0 || currentEntry == null) {\n            currentEntry = entry;\n            currentOrds = new IntsRefBuilder(); // must be this way\n          }\n          if (hasStemExceptions) {\n            currentOrds.append(ord);\n            currentOrds.append(stemExceptionID);\n          } else {\n            currentOrds.append(ord);\n          }\n        }\n      }\n    \n      // finalize last entry\n      Util.toUTF32(currentEntry, scratchInts);\n      words.add(scratchInts.get(), currentOrds.get());\n      success2 = true;\n    } finally {\n      if (success2) {\n        tempDir.deleteFile(sorted);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, sorted);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","date":1576247714,"type":5,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#readDictionaryFiles(Directory,String,List[InputStream],CharsetDecoder,FSTCompiler[IntsRef]).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#readDictionaryFiles(Directory,String,List[InputStream],CharsetDecoder,Builder[IntsRef]).mjava","sourceNew":"  /**\n   * Reads the dictionary file through the provided InputStreams, building up the words map\n   *\n   * @param dictionaries InputStreams to read the dictionary file through\n   * @param decoder CharsetDecoder used to decode the contents of the file\n   * @throws IOException Can be thrown while reading from the file\n   */\n  private void readDictionaryFiles(Directory tempDir, String tempFileNamePrefix, List<InputStream> dictionaries, CharsetDecoder decoder, FSTCompiler<IntsRef> words) throws IOException {\n    BytesRefBuilder flagsScratch = new BytesRefBuilder();\n    IntsRefBuilder scratchInts = new IntsRefBuilder();\n    \n    StringBuilder sb = new StringBuilder();\n\n    IndexOutput unsorted = tempDir.createTempOutput(tempFileNamePrefix, \"dat\", IOContext.DEFAULT);\n    try (ByteSequencesWriter writer = new ByteSequencesWriter(unsorted)) {\n      for (InputStream dictionary : dictionaries) {\n        BufferedReader lines = new BufferedReader(new InputStreamReader(dictionary, decoder));\n        String line = lines.readLine(); // first line is number of entries (approximately, sometimes)\n        \n        while ((line = lines.readLine()) != null) {\n          // wild and unpredictable code comment rules\n          if (line.isEmpty() || line.charAt(0) == '/' || line.charAt(0) == '#' || line.charAt(0) == '\\t') {\n            continue;\n          }\n          line = unescapeEntry(line);\n          // if we havent seen any stem exceptions, try to parse one\n          if (hasStemExceptions == false) {\n            int morphStart = line.indexOf(MORPH_SEPARATOR);\n            if (morphStart >= 0 && morphStart < line.length()) {\n              hasStemExceptions = parseStemException(line.substring(morphStart+1)) != null;\n            }\n          }\n          if (needsInputCleaning) {\n            int flagSep = line.indexOf(FLAG_SEPARATOR);\n            if (flagSep == -1) {\n              flagSep = line.indexOf(MORPH_SEPARATOR);\n            }\n            if (flagSep == -1) {\n              CharSequence cleansed = cleanInput(line, sb);\n              writer.write(cleansed.toString().getBytes(StandardCharsets.UTF_8));\n            } else {\n              String text = line.substring(0, flagSep);\n              CharSequence cleansed = cleanInput(text, sb);\n              if (cleansed != sb) {\n                sb.setLength(0);\n                sb.append(cleansed);\n              }\n              sb.append(line.substring(flagSep));\n              writer.write(sb.toString().getBytes(StandardCharsets.UTF_8));\n            }\n          } else {\n            writer.write(line.getBytes(StandardCharsets.UTF_8));\n          }\n        }\n      }\n      CodecUtil.writeFooter(unsorted);\n    }\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, new Comparator<BytesRef>() {\n      BytesRef scratch1 = new BytesRef();\n      BytesRef scratch2 = new BytesRef();\n      \n      @Override\n      public int compare(BytesRef o1, BytesRef o2) {\n        scratch1.bytes = o1.bytes;\n        scratch1.offset = o1.offset;\n        scratch1.length = o1.length;\n        \n        for (int i = scratch1.length - 1; i >= 0; i--) {\n          if (scratch1.bytes[scratch1.offset + i] == FLAG_SEPARATOR || scratch1.bytes[scratch1.offset + i] == MORPH_SEPARATOR) {\n            scratch1.length = i;\n            break;\n          }\n        }\n        \n        scratch2.bytes = o2.bytes;\n        scratch2.offset = o2.offset;\n        scratch2.length = o2.length;\n        \n        for (int i = scratch2.length - 1; i >= 0; i--) {\n          if (scratch2.bytes[scratch2.offset + i] == FLAG_SEPARATOR || scratch2.bytes[scratch2.offset + i] == MORPH_SEPARATOR) {\n            scratch2.length = i;\n            break;\n          }\n        }\n        \n        int cmp = scratch1.compareTo(scratch2);\n        if (cmp == 0) {\n          // tie break on whole row\n          return o1.compareTo(o2);\n        } else {\n          return cmp;\n        }\n      }\n    });\n\n    String sorted;\n    boolean success = false;\n    try {\n      sorted = sorter.sort(unsorted.getName());\n      success = true;\n    } finally {\n      if (success) {\n        tempDir.deleteFile(unsorted.getName());\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, unsorted.getName());\n      }\n    }\n    \n    boolean success2 = false;\n    \n    try (ByteSequencesReader reader = new ByteSequencesReader(tempDir.openChecksumInput(sorted, IOContext.READONCE), sorted)) {\n    \n      // TODO: the flags themselves can be double-chars (long) or also numeric\n      // either way the trick is to encode them as char... but they must be parsed differently\n    \n      String currentEntry = null;\n      IntsRefBuilder currentOrds = new IntsRefBuilder();\n\n      while (true) {\n        BytesRef scratch = reader.next();\n        if (scratch == null) {\n          break;\n        }\n        \n        String line = scratch.utf8ToString();\n        String entry;\n        char wordForm[];\n        int end;\n\n        int flagSep = line.indexOf(FLAG_SEPARATOR);\n        if (flagSep == -1) {\n          wordForm = NOFLAGS;\n          end = line.indexOf(MORPH_SEPARATOR);\n          entry = line.substring(0, end);\n        } else {\n          end = line.indexOf(MORPH_SEPARATOR);\n          String flagPart = line.substring(flagSep + 1, end);\n          if (aliasCount > 0) {\n            flagPart = getAliasValue(Integer.parseInt(flagPart));\n          } \n        \n          wordForm = flagParsingStrategy.parseFlags(flagPart);\n          Arrays.sort(wordForm);\n          entry = line.substring(0, flagSep);\n        }\n        // we possibly have morphological data\n        int stemExceptionID = 0;\n        if (hasStemExceptions && end+1 < line.length()) {\n          String stemException = parseStemException(line.substring(end+1));\n          if (stemException != null) {\n            stemExceptions = ArrayUtil.grow(stemExceptions, stemExceptionCount+1);\n            stemExceptionID = stemExceptionCount+1; // we use '0' to indicate no exception for the form\n            stemExceptions[stemExceptionCount++] = stemException;\n          }\n        }\n\n        int cmp = currentEntry == null ? 1 : entry.compareTo(currentEntry);\n        if (cmp < 0) {\n          throw new IllegalArgumentException(\"out of order: \" + entry + \" < \" + currentEntry);\n        } else {\n          encodeFlags(flagsScratch, wordForm);\n          int ord = flagLookup.add(flagsScratch.get());\n          if (ord < 0) {\n            // already exists in our hash\n            ord = (-ord)-1;\n          }\n          // finalize current entry, and switch \"current\" if necessary\n          if (cmp > 0 && currentEntry != null) {\n            Util.toUTF32(currentEntry, scratchInts);\n            words.add(scratchInts.get(), currentOrds.get());\n          }\n          // swap current\n          if (cmp > 0 || currentEntry == null) {\n            currentEntry = entry;\n            currentOrds = new IntsRefBuilder(); // must be this way\n          }\n          if (hasStemExceptions) {\n            currentOrds.append(ord);\n            currentOrds.append(stemExceptionID);\n          } else {\n            currentOrds.append(ord);\n          }\n        }\n      }\n    \n      // finalize last entry\n      Util.toUTF32(currentEntry, scratchInts);\n      words.add(scratchInts.get(), currentOrds.get());\n      success2 = true;\n    } finally {\n      if (success2) {\n        tempDir.deleteFile(sorted);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, sorted);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Reads the dictionary file through the provided InputStreams, building up the words map\n   *\n   * @param dictionaries InputStreams to read the dictionary file through\n   * @param decoder CharsetDecoder used to decode the contents of the file\n   * @throws IOException Can be thrown while reading from the file\n   */\n  private void readDictionaryFiles(Directory tempDir, String tempFileNamePrefix, List<InputStream> dictionaries, CharsetDecoder decoder, Builder<IntsRef> words) throws IOException {\n    BytesRefBuilder flagsScratch = new BytesRefBuilder();\n    IntsRefBuilder scratchInts = new IntsRefBuilder();\n    \n    StringBuilder sb = new StringBuilder();\n\n    IndexOutput unsorted = tempDir.createTempOutput(tempFileNamePrefix, \"dat\", IOContext.DEFAULT);\n    try (ByteSequencesWriter writer = new ByteSequencesWriter(unsorted)) {\n      for (InputStream dictionary : dictionaries) {\n        BufferedReader lines = new BufferedReader(new InputStreamReader(dictionary, decoder));\n        String line = lines.readLine(); // first line is number of entries (approximately, sometimes)\n        \n        while ((line = lines.readLine()) != null) {\n          // wild and unpredictable code comment rules\n          if (line.isEmpty() || line.charAt(0) == '/' || line.charAt(0) == '#' || line.charAt(0) == '\\t') {\n            continue;\n          }\n          line = unescapeEntry(line);\n          // if we havent seen any stem exceptions, try to parse one\n          if (hasStemExceptions == false) {\n            int morphStart = line.indexOf(MORPH_SEPARATOR);\n            if (morphStart >= 0 && morphStart < line.length()) {\n              hasStemExceptions = parseStemException(line.substring(morphStart+1)) != null;\n            }\n          }\n          if (needsInputCleaning) {\n            int flagSep = line.indexOf(FLAG_SEPARATOR);\n            if (flagSep == -1) {\n              flagSep = line.indexOf(MORPH_SEPARATOR);\n            }\n            if (flagSep == -1) {\n              CharSequence cleansed = cleanInput(line, sb);\n              writer.write(cleansed.toString().getBytes(StandardCharsets.UTF_8));\n            } else {\n              String text = line.substring(0, flagSep);\n              CharSequence cleansed = cleanInput(text, sb);\n              if (cleansed != sb) {\n                sb.setLength(0);\n                sb.append(cleansed);\n              }\n              sb.append(line.substring(flagSep));\n              writer.write(sb.toString().getBytes(StandardCharsets.UTF_8));\n            }\n          } else {\n            writer.write(line.getBytes(StandardCharsets.UTF_8));\n          }\n        }\n      }\n      CodecUtil.writeFooter(unsorted);\n    }\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, new Comparator<BytesRef>() {\n      BytesRef scratch1 = new BytesRef();\n      BytesRef scratch2 = new BytesRef();\n      \n      @Override\n      public int compare(BytesRef o1, BytesRef o2) {\n        scratch1.bytes = o1.bytes;\n        scratch1.offset = o1.offset;\n        scratch1.length = o1.length;\n        \n        for (int i = scratch1.length - 1; i >= 0; i--) {\n          if (scratch1.bytes[scratch1.offset + i] == FLAG_SEPARATOR || scratch1.bytes[scratch1.offset + i] == MORPH_SEPARATOR) {\n            scratch1.length = i;\n            break;\n          }\n        }\n        \n        scratch2.bytes = o2.bytes;\n        scratch2.offset = o2.offset;\n        scratch2.length = o2.length;\n        \n        for (int i = scratch2.length - 1; i >= 0; i--) {\n          if (scratch2.bytes[scratch2.offset + i] == FLAG_SEPARATOR || scratch2.bytes[scratch2.offset + i] == MORPH_SEPARATOR) {\n            scratch2.length = i;\n            break;\n          }\n        }\n        \n        int cmp = scratch1.compareTo(scratch2);\n        if (cmp == 0) {\n          // tie break on whole row\n          return o1.compareTo(o2);\n        } else {\n          return cmp;\n        }\n      }\n    });\n\n    String sorted;\n    boolean success = false;\n    try {\n      sorted = sorter.sort(unsorted.getName());\n      success = true;\n    } finally {\n      if (success) {\n        tempDir.deleteFile(unsorted.getName());\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, unsorted.getName());\n      }\n    }\n    \n    boolean success2 = false;\n    \n    try (ByteSequencesReader reader = new ByteSequencesReader(tempDir.openChecksumInput(sorted, IOContext.READONCE), sorted)) {\n    \n      // TODO: the flags themselves can be double-chars (long) or also numeric\n      // either way the trick is to encode them as char... but they must be parsed differently\n    \n      String currentEntry = null;\n      IntsRefBuilder currentOrds = new IntsRefBuilder();\n\n      while (true) {\n        BytesRef scratch = reader.next();\n        if (scratch == null) {\n          break;\n        }\n        \n        String line = scratch.utf8ToString();\n        String entry;\n        char wordForm[];\n        int end;\n\n        int flagSep = line.indexOf(FLAG_SEPARATOR);\n        if (flagSep == -1) {\n          wordForm = NOFLAGS;\n          end = line.indexOf(MORPH_SEPARATOR);\n          entry = line.substring(0, end);\n        } else {\n          end = line.indexOf(MORPH_SEPARATOR);\n          String flagPart = line.substring(flagSep + 1, end);\n          if (aliasCount > 0) {\n            flagPart = getAliasValue(Integer.parseInt(flagPart));\n          } \n        \n          wordForm = flagParsingStrategy.parseFlags(flagPart);\n          Arrays.sort(wordForm);\n          entry = line.substring(0, flagSep);\n        }\n        // we possibly have morphological data\n        int stemExceptionID = 0;\n        if (hasStemExceptions && end+1 < line.length()) {\n          String stemException = parseStemException(line.substring(end+1));\n          if (stemException != null) {\n            stemExceptions = ArrayUtil.grow(stemExceptions, stemExceptionCount+1);\n            stemExceptionID = stemExceptionCount+1; // we use '0' to indicate no exception for the form\n            stemExceptions[stemExceptionCount++] = stemException;\n          }\n        }\n\n        int cmp = currentEntry == null ? 1 : entry.compareTo(currentEntry);\n        if (cmp < 0) {\n          throw new IllegalArgumentException(\"out of order: \" + entry + \" < \" + currentEntry);\n        } else {\n          encodeFlags(flagsScratch, wordForm);\n          int ord = flagLookup.add(flagsScratch.get());\n          if (ord < 0) {\n            // already exists in our hash\n            ord = (-ord)-1;\n          }\n          // finalize current entry, and switch \"current\" if necessary\n          if (cmp > 0 && currentEntry != null) {\n            Util.toUTF32(currentEntry, scratchInts);\n            words.add(scratchInts.get(), currentOrds.get());\n          }\n          // swap current\n          if (cmp > 0 || currentEntry == null) {\n            currentEntry = entry;\n            currentOrds = new IntsRefBuilder(); // must be this way\n          }\n          if (hasStemExceptions) {\n            currentOrds.append(ord);\n            currentOrds.append(stemExceptionID);\n          } else {\n            currentOrds.append(ord);\n          }\n        }\n      }\n    \n      // finalize last entry\n      Util.toUTF32(currentEntry, scratchInts);\n      words.add(scratchInts.get(), currentOrds.get());\n      success2 = true;\n    } finally {\n      if (success2) {\n        tempDir.deleteFile(sorted);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempDir, sorted);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1":["6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"7849935cc625c020857f3b29be91b5d4323d19aa":["950b7a6881d14da782b60444c11295e3ec50d41a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["7849935cc625c020857f3b29be91b5d4323d19aa","9798d0818e7a880546802b509792d3f3d57babd2"],"950b7a6881d14da782b60444c11295e3ec50d41a":["867e3d9153fb761456b54a9dcce566e1545c5ef6"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["867e3d9153fb761456b54a9dcce566e1545c5ef6"],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":["9798d0818e7a880546802b509792d3f3d57babd2","0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["9798d0818e7a880546802b509792d3f3d57babd2"],"9798d0818e7a880546802b509792d3f3d57babd2":["7849935cc625c020857f3b29be91b5d4323d19aa"],"867e3d9153fb761456b54a9dcce566e1545c5ef6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["7849935cc625c020857f3b29be91b5d4323d19aa","9798d0818e7a880546802b509792d3f3d57babd2"]},"commit2Childs":{"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1":[],"7849935cc625c020857f3b29be91b5d4323d19aa":["b70042a8a492f7054d480ccdd2be9796510d4327","9798d0818e7a880546802b509792d3f3d57babd2","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["867e3d9153fb761456b54a9dcce566e1545c5ef6"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["8f4e2dcb5e470991d83a63c264bfe20880d3b3c1"],"950b7a6881d14da782b60444c11295e3ec50d41a":["7849935cc625c020857f3b29be91b5d4323d19aa"],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":[],"9798d0818e7a880546802b509792d3f3d57babd2":["b70042a8a492f7054d480ccdd2be9796510d4327","c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","0f5661e6a04d3172e262ad741b717924f2f1b6a5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"867e3d9153fb761456b54a9dcce566e1545c5ef6":["950b7a6881d14da782b60444c11295e3ec50d41a","6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["8f4e2dcb5e470991d83a63c264bfe20880d3b3c1","b70042a8a492f7054d480ccdd2be9796510d4327","c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}