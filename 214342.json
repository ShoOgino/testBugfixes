{"path":"solr/solrj/src/java/org/apache/solr/common/util/Hash#murmurhash3_x86_32(byte[],int,int,int).mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/Hash#murmurhash3_x86_32(byte[],int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns the MurmurHash3_x86_32 hash.\n   * Original source/tests at https://github.com/yonik/java_util/\n   */\n  public static int murmurhash3_x86_32(byte[] data, int offset, int len, int seed) {\n\n    final int c1 = 0xcc9e2d51;\n    final int c2 = 0x1b873593;\n\n    int h1 = seed;\n    int roundedEnd = offset + (len & 0xfffffffc);  // round down to 4 byte block\n\n    for (int i=offset; i<roundedEnd; i+=4) {\n      // little endian load order\n      int k1 = (data[i] & 0xff) | ((data[i+1] & 0xff) << 8) | ((data[i+2] & 0xff) << 16) | (data[i+3] << 24);\n      k1 *= c1;\n      k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n      k1 *= c2;\n\n      h1 ^= k1;\n      h1 = (h1 << 13) | (h1 >>> 19);  // ROTL32(h1,13);\n      h1 = h1*5+0xe6546b64;\n    }\n\n    // tail\n    int k1 = 0;\n\n    switch(len & 0x03) {\n      case 3:\n        k1 = (data[roundedEnd + 2] & 0xff) << 16;\n        // fallthrough\n      case 2:\n        k1 |= (data[roundedEnd + 1] & 0xff) << 8;\n        // fallthrough\n      case 1:\n        k1 |= (data[roundedEnd] & 0xff);\n        k1 *= c1;\n        k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n        k1 *= c2;\n        h1 ^= k1;\n    }\n\n    // finalization\n    h1 ^= len;\n\n    // fmix(h1);\n    h1 ^= h1 >>> 16;\n    h1 *= 0x85ebca6b;\n    h1 ^= h1 >>> 13;\n    h1 *= 0xc2b2ae35;\n    h1 ^= h1 >>> 16;\n\n    return h1;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/Hash#murmurhash3_x86_32(byte[],int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns the MurmurHash3_x86_32 hash.\n   * Original source/tests at https://github.com/yonik/java_util/\n   */\n  public static int murmurhash3_x86_32(byte[] data, int offset, int len, int seed) {\n\n    final int c1 = 0xcc9e2d51;\n    final int c2 = 0x1b873593;\n\n    int h1 = seed;\n    int roundedEnd = offset + (len & 0xfffffffc);  // round down to 4 byte block\n\n    for (int i=offset; i<roundedEnd; i+=4) {\n      // little endian load order\n      int k1 = (data[i] & 0xff) | ((data[i+1] & 0xff) << 8) | ((data[i+2] & 0xff) << 16) | (data[i+3] << 24);\n      k1 *= c1;\n      k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n      k1 *= c2;\n\n      h1 ^= k1;\n      h1 = (h1 << 13) | (h1 >>> 19);  // ROTL32(h1,13);\n      h1 = h1*5+0xe6546b64;\n    }\n\n    // tail\n    int k1 = 0;\n\n    switch(len & 0x03) {\n      case 3:\n        k1 = (data[roundedEnd + 2] & 0xff) << 16;\n        // fallthrough\n      case 2:\n        k1 |= (data[roundedEnd + 1] & 0xff) << 8;\n        // fallthrough\n      case 1:\n        k1 |= (data[roundedEnd] & 0xff);\n        k1 *= c1;\n        k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n        k1 *= c2;\n        h1 ^= k1;\n    }\n\n    // finalization\n    h1 ^= len;\n\n    // fmix(h1);\n    h1 ^= h1 >>> 16;\n    h1 *= 0x85ebca6b;\n    h1 ^= h1 >>> 13;\n    h1 *= 0xc2b2ae35;\n    h1 ^= h1 >>> 16;\n\n    return h1;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/Hash#murmurhash3_x86_32(byte[],int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns the MurmurHash3_x86_32 hash.\n   * Original source/tests at https://github.com/yonik/java_util/\n   */\n  public static int murmurhash3_x86_32(byte[] data, int offset, int len, int seed) {\n\n    final int c1 = 0xcc9e2d51;\n    final int c2 = 0x1b873593;\n\n    int h1 = seed;\n    int roundedEnd = offset + (len & 0xfffffffc);  // round down to 4 byte block\n\n    for (int i=offset; i<roundedEnd; i+=4) {\n      // little endian load order\n      int k1 = (data[i] & 0xff) | ((data[i+1] & 0xff) << 8) | ((data[i+2] & 0xff) << 16) | (data[i+3] << 24);\n      k1 *= c1;\n      k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n      k1 *= c2;\n\n      h1 ^= k1;\n      h1 = (h1 << 13) | (h1 >>> 19);  // ROTL32(h1,13);\n      h1 = h1*5+0xe6546b64;\n    }\n\n    // tail\n    int k1 = 0;\n\n    switch(len & 0x03) {\n      case 3:\n        k1 = (data[roundedEnd + 2] & 0xff) << 16;\n        // fallthrough\n      case 2:\n        k1 |= (data[roundedEnd + 1] & 0xff) << 8;\n        // fallthrough\n      case 1:\n        k1 |= (data[roundedEnd] & 0xff);\n        k1 *= c1;\n        k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n        k1 *= c2;\n        h1 ^= k1;\n    }\n\n    // finalization\n    h1 ^= len;\n\n    // fmix(h1);\n    h1 ^= h1 >>> 16;\n    h1 *= 0x85ebca6b;\n    h1 ^= h1 >>> 13;\n    h1 *= 0xc2b2ae35;\n    h1 ^= h1 >>> 16;\n\n    return h1;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"19275ba31e621f6da1b83bf13af75233876fd3d4","date":1374846698,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/Hash#murmurhash3_x86_32(byte[],int,int,int).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/Hash#murmurhash3_x86_32(byte[],int,int,int).mjava","sourceNew":"  /** Returns the MurmurHash3_x86_32 hash.\n   * Original source/tests at https://github.com/yonik/java_util/\n   */\n  public static int murmurhash3_x86_32(byte[] data, int offset, int len, int seed) {\n\n    final int c1 = 0xcc9e2d51;\n    final int c2 = 0x1b873593;\n\n    int h1 = seed;\n    int roundedEnd = offset + (len & 0xfffffffc);  // round down to 4 byte block\n\n    for (int i=offset; i<roundedEnd; i+=4) {\n      // little endian load order\n      int k1 = (data[i] & 0xff) | ((data[i+1] & 0xff) << 8) | ((data[i+2] & 0xff) << 16) | (data[i+3] << 24);\n      k1 *= c1;\n      k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n      k1 *= c2;\n\n      h1 ^= k1;\n      h1 = (h1 << 13) | (h1 >>> 19);  // ROTL32(h1,13);\n      h1 = h1*5+0xe6546b64;\n    }\n\n    // tail\n    int k1 = 0;\n\n    switch(len & 0x03) {\n      case 3:\n        k1 = (data[roundedEnd + 2] & 0xff) << 16;\n        // fallthrough\n      case 2:\n        k1 |= (data[roundedEnd + 1] & 0xff) << 8;\n        // fallthrough\n      case 1:\n        k1 |= (data[roundedEnd] & 0xff);\n        k1 *= c1;\n        k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n        k1 *= c2;\n        h1 ^= k1;\n    }\n\n    // finalization\n    h1 ^= len;\n\n    // fmix(h1);\n    h1 ^= h1 >>> 16;\n    h1 *= 0x85ebca6b;\n    h1 ^= h1 >>> 13;\n    h1 *= 0xc2b2ae35;\n    h1 ^= h1 >>> 16;\n\n    return h1;\n  }\n\n","sourceOld":"  /** Returns the MurmurHash3_x86_32 hash.\n   * Original source/tests at https://github.com/yonik/java_util/\n   */\n  public static int murmurhash3_x86_32(byte[] data, int offset, int len, int seed) {\n\n    final int c1 = 0xcc9e2d51;\n    final int c2 = 0x1b873593;\n\n    int h1 = seed;\n    int roundedEnd = offset + (len & 0xfffffffc);  // round down to 4 byte block\n\n    for (int i=offset; i<roundedEnd; i+=4) {\n      // little endian load order\n      int k1 = (data[i] & 0xff) | ((data[i+1] & 0xff) << 8) | ((data[i+2] & 0xff) << 16) | (data[i+3] << 24);\n      k1 *= c1;\n      k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n      k1 *= c2;\n\n      h1 ^= k1;\n      h1 = (h1 << 13) | (h1 >>> 19);  // ROTL32(h1,13);\n      h1 = h1*5+0xe6546b64;\n    }\n\n    // tail\n    int k1 = 0;\n\n    switch(len & 0x03) {\n      case 3:\n        k1 = (data[roundedEnd + 2] & 0xff) << 16;\n        // fallthrough\n      case 2:\n        k1 |= (data[roundedEnd + 1] & 0xff) << 8;\n        // fallthrough\n      case 1:\n        k1 |= (data[roundedEnd] & 0xff);\n        k1 *= c1;\n        k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n        k1 *= c2;\n        h1 ^= k1;\n    }\n\n    // finalization\n    h1 ^= len;\n\n    // fmix(h1);\n    h1 ^= h1 >>> 16;\n    h1 *= 0x85ebca6b;\n    h1 ^= h1 >>> 13;\n    h1 *= 0xc2b2ae35;\n    h1 ^= h1 >>> 16;\n\n    return h1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/Hash#murmurhash3_x86_32(byte[],int,int,int).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/Hash#murmurhash3_x86_32(byte[],int,int,int).mjava","sourceNew":"  /** Returns the MurmurHash3_x86_32 hash.\n   * Original source/tests at https://github.com/yonik/java_util/\n   */\n  public static int murmurhash3_x86_32(byte[] data, int offset, int len, int seed) {\n\n    final int c1 = 0xcc9e2d51;\n    final int c2 = 0x1b873593;\n\n    int h1 = seed;\n    int roundedEnd = offset + (len & 0xfffffffc);  // round down to 4 byte block\n\n    for (int i=offset; i<roundedEnd; i+=4) {\n      // little endian load order\n      int k1 = (data[i] & 0xff) | ((data[i+1] & 0xff) << 8) | ((data[i+2] & 0xff) << 16) | (data[i+3] << 24);\n      k1 *= c1;\n      k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n      k1 *= c2;\n\n      h1 ^= k1;\n      h1 = (h1 << 13) | (h1 >>> 19);  // ROTL32(h1,13);\n      h1 = h1*5+0xe6546b64;\n    }\n\n    // tail\n    int k1 = 0;\n\n    switch(len & 0x03) {\n      case 3:\n        k1 = (data[roundedEnd + 2] & 0xff) << 16;\n        // fallthrough\n      case 2:\n        k1 |= (data[roundedEnd + 1] & 0xff) << 8;\n        // fallthrough\n      case 1:\n        k1 |= (data[roundedEnd] & 0xff);\n        k1 *= c1;\n        k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n        k1 *= c2;\n        h1 ^= k1;\n    }\n\n    // finalization\n    h1 ^= len;\n\n    // fmix(h1);\n    h1 ^= h1 >>> 16;\n    h1 *= 0x85ebca6b;\n    h1 ^= h1 >>> 13;\n    h1 *= 0xc2b2ae35;\n    h1 ^= h1 >>> 16;\n\n    return h1;\n  }\n\n","sourceOld":"  /** Returns the MurmurHash3_x86_32 hash.\n   * Original source/tests at https://github.com/yonik/java_util/\n   */\n  public static int murmurhash3_x86_32(byte[] data, int offset, int len, int seed) {\n\n    final int c1 = 0xcc9e2d51;\n    final int c2 = 0x1b873593;\n\n    int h1 = seed;\n    int roundedEnd = offset + (len & 0xfffffffc);  // round down to 4 byte block\n\n    for (int i=offset; i<roundedEnd; i+=4) {\n      // little endian load order\n      int k1 = (data[i] & 0xff) | ((data[i+1] & 0xff) << 8) | ((data[i+2] & 0xff) << 16) | (data[i+3] << 24);\n      k1 *= c1;\n      k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n      k1 *= c2;\n\n      h1 ^= k1;\n      h1 = (h1 << 13) | (h1 >>> 19);  // ROTL32(h1,13);\n      h1 = h1*5+0xe6546b64;\n    }\n\n    // tail\n    int k1 = 0;\n\n    switch(len & 0x03) {\n      case 3:\n        k1 = (data[roundedEnd + 2] & 0xff) << 16;\n        // fallthrough\n      case 2:\n        k1 |= (data[roundedEnd + 1] & 0xff) << 8;\n        // fallthrough\n      case 1:\n        k1 |= (data[roundedEnd] & 0xff);\n        k1 *= c1;\n        k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n        k1 *= c2;\n        h1 ^= k1;\n    }\n\n    // finalization\n    h1 ^= len;\n\n    // fmix(h1);\n    h1 ^= h1 >>> 16;\n    h1 *= 0x85ebca6b;\n    h1 ^= h1 >>> 13;\n    h1 *= 0xc2b2ae35;\n    h1 ^= h1 >>> 16;\n\n    return h1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a7dfea4f7c80813344b0152e37fc18b31369e8ff","date":1592136683,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/Hash#murmurhash3_x86_32(byte[],int,int,int).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/Hash#murmurhash3_x86_32(byte[],int,int,int).mjava","sourceNew":"  /** Returns the MurmurHash3_x86_32 hash.\n   * Original source/tests at https://github.com/yonik/java_util/\n   */\n  @SuppressWarnings({\"fallthrough\"})\n  public static int murmurhash3_x86_32(byte[] data, int offset, int len, int seed) {\n\n    final int c1 = 0xcc9e2d51;\n    final int c2 = 0x1b873593;\n\n    int h1 = seed;\n    int roundedEnd = offset + (len & 0xfffffffc);  // round down to 4 byte block\n\n    for (int i=offset; i<roundedEnd; i+=4) {\n      // little endian load order\n      int k1 = (data[i] & 0xff) | ((data[i+1] & 0xff) << 8) | ((data[i+2] & 0xff) << 16) | (data[i+3] << 24);\n      k1 *= c1;\n      k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n      k1 *= c2;\n\n      h1 ^= k1;\n      h1 = (h1 << 13) | (h1 >>> 19);  // ROTL32(h1,13);\n      h1 = h1*5+0xe6546b64;\n    }\n\n    // tail\n    int k1 = 0;\n\n    switch(len & 0x03) {\n      case 3:\n        k1 = (data[roundedEnd + 2] & 0xff) << 16;\n        // fallthrough\n      case 2:\n        k1 |= (data[roundedEnd + 1] & 0xff) << 8;\n        // fallthrough\n      case 1:\n        k1 |= (data[roundedEnd] & 0xff);\n        k1 *= c1;\n        k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n        k1 *= c2;\n        h1 ^= k1;\n    }\n\n    // finalization\n    h1 ^= len;\n\n    // fmix(h1);\n    h1 ^= h1 >>> 16;\n    h1 *= 0x85ebca6b;\n    h1 ^= h1 >>> 13;\n    h1 *= 0xc2b2ae35;\n    h1 ^= h1 >>> 16;\n\n    return h1;\n  }\n\n","sourceOld":"  /** Returns the MurmurHash3_x86_32 hash.\n   * Original source/tests at https://github.com/yonik/java_util/\n   */\n  public static int murmurhash3_x86_32(byte[] data, int offset, int len, int seed) {\n\n    final int c1 = 0xcc9e2d51;\n    final int c2 = 0x1b873593;\n\n    int h1 = seed;\n    int roundedEnd = offset + (len & 0xfffffffc);  // round down to 4 byte block\n\n    for (int i=offset; i<roundedEnd; i+=4) {\n      // little endian load order\n      int k1 = (data[i] & 0xff) | ((data[i+1] & 0xff) << 8) | ((data[i+2] & 0xff) << 16) | (data[i+3] << 24);\n      k1 *= c1;\n      k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n      k1 *= c2;\n\n      h1 ^= k1;\n      h1 = (h1 << 13) | (h1 >>> 19);  // ROTL32(h1,13);\n      h1 = h1*5+0xe6546b64;\n    }\n\n    // tail\n    int k1 = 0;\n\n    switch(len & 0x03) {\n      case 3:\n        k1 = (data[roundedEnd + 2] & 0xff) << 16;\n        // fallthrough\n      case 2:\n        k1 |= (data[roundedEnd + 1] & 0xff) << 8;\n        // fallthrough\n      case 1:\n        k1 |= (data[roundedEnd] & 0xff);\n        k1 *= c1;\n        k1 = (k1 << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n        k1 *= c2;\n        h1 ^= k1;\n    }\n\n    // finalization\n    h1 ^= len;\n\n    // fmix(h1);\n    h1 ^= h1 >>> 16;\n    h1 *= 0x85ebca6b;\n    h1 ^= h1 >>> 13;\n    h1 *= 0xc2b2ae35;\n    h1 ^= h1 >>> 16;\n\n    return h1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","19275ba31e621f6da1b83bf13af75233876fd3d4"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a7dfea4f7c80813344b0152e37fc18b31369e8ff":["19275ba31e621f6da1b83bf13af75233876fd3d4"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a7dfea4f7c80813344b0152e37fc18b31369e8ff"]},"commit2Childs":{"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":[],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a7dfea4f7c80813344b0152e37fc18b31369e8ff":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","19275ba31e621f6da1b83bf13af75233876fd3d4"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","a7dfea4f7c80813344b0152e37fc18b31369e8ff"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}