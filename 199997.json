{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat#fieldsProducer(SegmentReadState).mjava","commits":[{"id":"4ba81908bd58bd5079d89f3dafc90bce86fa08a6","date":1354575765,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat#fieldsProducer(SegmentReadState).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public SimpleDVProducer fieldsProducer(SegmentReadState state) throws IOException {\n    final SimpleDVProducer producer = new SimpleTextDocValuesReader(state, \"dat\");\n\n    return new SimpleDVProducer() {\n\n      @Override\n      public NumericDocValues getNumeric(FieldInfo field) throws IOException {\n        NumericDocValues valuesIn = producer.getNumeric(field);\n\n        // nocommit more ram efficient\n        final int maxDoc = valuesIn.size();\n        final long minValue = valuesIn.minValue();\n        final long maxValue = valuesIn.maxValue();\n\n        final long[] values = new long[maxDoc];\n        for(int docID=0;docID<maxDoc;docID++) {\n          values[docID] = valuesIn.get(docID);\n        }\n\n        return new NumericDocValues() {\n\n          @Override\n          public long get(int docID) {\n            return values[docID];\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public long minValue() {\n            return minValue;\n          }\n\n          @Override\n          public long maxValue() {\n            return maxValue;\n          }\n        };\n      }\n      \n      @Override\n      public BinaryDocValues getBinary(FieldInfo field) throws IOException {\n        BinaryDocValues valuesIn = producer.getBinary(field);\n        final int maxDoc = valuesIn.size();\n        final int maxLength = valuesIn.maxLength();\n        final boolean fixedLength = valuesIn.isFixedLength();\n        // nocommit more ram efficient\n        final byte[][] values = new byte[maxDoc][];\n        BytesRef scratch = new BytesRef();\n        for(int docID=0;docID<maxDoc;docID++) {\n          valuesIn.get(docID, scratch);\n          values[docID] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[docID], 0, scratch.length);\n        }\n\n        return new BinaryDocValues() {\n\n          @Override\n          public void get(int docID, BytesRef result) {\n            result.bytes = values[docID];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public boolean isFixedLength() {\n            return fixedLength;\n          }\n\n          @Override\n          public int maxLength() {\n            return maxLength;\n          }\n        };\n      }\n\n      public SortedDocValues getSorted(FieldInfo field) throws IOException {\n        SortedDocValues valuesIn = producer.getSorted(field);\n        final int maxDoc = valuesIn.size();\n        final int maxLength = valuesIn.maxLength();\n        final boolean fixedLength = valuesIn.isFixedLength();\n        final int valueCount = valuesIn.getValueCount();\n\n        // nocommit used packed ints and so on\n        final byte[][] values = new byte[valueCount][];\n        BytesRef scratch = new BytesRef();\n        for(int ord=0;ord<values.length;ord++) {\n          valuesIn.lookupOrd(ord, scratch);\n          values[ord] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[ord], 0, scratch.length);\n        }\n\n        final int[] docToOrd = new int[maxDoc];\n        for(int docID=0;docID<maxDoc;docID++) {\n          docToOrd[docID] = valuesIn.getOrd(docID);\n        }\n        return new SortedDocValues() {\n\n          @Override\n          public int getOrd(int docID) {\n            return docToOrd[docID];\n          }\n\n          @Override\n          public void lookupOrd(int ord, BytesRef result) {\n            result.bytes = values[ord];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int getValueCount() {\n            return valueCount;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public boolean isFixedLength() {\n            return fixedLength;\n          }\n\n          @Override\n          public int maxLength() {\n            return maxLength;\n          }\n        };\n      }\n\n      @Override\n      public void close() throws IOException {\n        producer.close();\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2899ae5069a2533466ac842042478e67263e1f43","date":1354624628,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat#fieldsProducer(SegmentReadState).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat#fieldsProducer(SegmentReadState).mjava","sourceNew":"  @Override\n  public SimpleDVProducer fieldsProducer(SegmentReadState state) throws IOException {\n    final SimpleDVProducer producer = new SimpleTextDocValuesReader(state, \"dat\");\n\n    return new SimpleDVProducer() {\n\n      @Override\n      public NumericDocValues getNumeric(FieldInfo field) throws IOException {\n        NumericDocValues valuesIn = producer.getNumeric(field);\n\n        // nocommit more ram efficient\n        final int maxDoc = valuesIn.size();\n        final long minValue = valuesIn.minValue();\n        final long maxValue = valuesIn.maxValue();\n\n        final long[] values = new long[maxDoc];\n        for(int docID=0;docID<maxDoc;docID++) {\n          values[docID] = valuesIn.get(docID);\n        }\n\n        return new NumericDocValues() {\n\n          @Override\n          public long get(int docID) {\n            return values[docID];\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public long minValue() {\n            return minValue;\n          }\n\n          @Override\n          public long maxValue() {\n            return maxValue;\n          }\n        };\n      }\n      \n      @Override\n      public BinaryDocValues getBinary(FieldInfo field) throws IOException {\n        BinaryDocValues valuesIn = producer.getBinary(field);\n        final int maxDoc = valuesIn.size();\n        final int maxLength = valuesIn.maxLength();\n        final boolean fixedLength = valuesIn.isFixedLength();\n        // nocommit more ram efficient\n        final byte[][] values = new byte[maxDoc][];\n        BytesRef scratch = new BytesRef();\n        for(int docID=0;docID<maxDoc;docID++) {\n          valuesIn.get(docID, scratch);\n          values[docID] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[docID], 0, scratch.length);\n        }\n\n        return new BinaryDocValues() {\n\n          @Override\n          public void get(int docID, BytesRef result) {\n            result.bytes = values[docID];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public boolean isFixedLength() {\n            return fixedLength;\n          }\n\n          @Override\n          public int maxLength() {\n            return maxLength;\n          }\n        };\n      }\n\n      @Override\n      public SortedDocValues getSorted(FieldInfo field) throws IOException {\n        SortedDocValues valuesIn = producer.getSorted(field);\n        final int maxDoc = valuesIn.size();\n        final int maxLength = valuesIn.maxLength();\n        final boolean fixedLength = valuesIn.isFixedLength();\n        final int valueCount = valuesIn.getValueCount();\n\n        // nocommit used packed ints and so on\n        final byte[][] values = new byte[valueCount][];\n        BytesRef scratch = new BytesRef();\n        for(int ord=0;ord<values.length;ord++) {\n          valuesIn.lookupOrd(ord, scratch);\n          values[ord] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[ord], 0, scratch.length);\n        }\n\n        final int[] docToOrd = new int[maxDoc];\n        for(int docID=0;docID<maxDoc;docID++) {\n          docToOrd[docID] = valuesIn.getOrd(docID);\n        }\n        return new SortedDocValues() {\n\n          @Override\n          public int getOrd(int docID) {\n            return docToOrd[docID];\n          }\n\n          @Override\n          public void lookupOrd(int ord, BytesRef result) {\n            result.bytes = values[ord];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int getValueCount() {\n            return valueCount;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public boolean isFixedLength() {\n            return fixedLength;\n          }\n\n          @Override\n          public int maxLength() {\n            return maxLength;\n          }\n        };\n      }\n\n      @Override\n      public SimpleDVProducer clone() {\n        // We are already thread-safe:\n        return this;\n      }\n\n      @Override\n      public void close() throws IOException {\n        producer.close();\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public SimpleDVProducer fieldsProducer(SegmentReadState state) throws IOException {\n    final SimpleDVProducer producer = new SimpleTextDocValuesReader(state, \"dat\");\n\n    return new SimpleDVProducer() {\n\n      @Override\n      public NumericDocValues getNumeric(FieldInfo field) throws IOException {\n        NumericDocValues valuesIn = producer.getNumeric(field);\n\n        // nocommit more ram efficient\n        final int maxDoc = valuesIn.size();\n        final long minValue = valuesIn.minValue();\n        final long maxValue = valuesIn.maxValue();\n\n        final long[] values = new long[maxDoc];\n        for(int docID=0;docID<maxDoc;docID++) {\n          values[docID] = valuesIn.get(docID);\n        }\n\n        return new NumericDocValues() {\n\n          @Override\n          public long get(int docID) {\n            return values[docID];\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public long minValue() {\n            return minValue;\n          }\n\n          @Override\n          public long maxValue() {\n            return maxValue;\n          }\n        };\n      }\n      \n      @Override\n      public BinaryDocValues getBinary(FieldInfo field) throws IOException {\n        BinaryDocValues valuesIn = producer.getBinary(field);\n        final int maxDoc = valuesIn.size();\n        final int maxLength = valuesIn.maxLength();\n        final boolean fixedLength = valuesIn.isFixedLength();\n        // nocommit more ram efficient\n        final byte[][] values = new byte[maxDoc][];\n        BytesRef scratch = new BytesRef();\n        for(int docID=0;docID<maxDoc;docID++) {\n          valuesIn.get(docID, scratch);\n          values[docID] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[docID], 0, scratch.length);\n        }\n\n        return new BinaryDocValues() {\n\n          @Override\n          public void get(int docID, BytesRef result) {\n            result.bytes = values[docID];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public boolean isFixedLength() {\n            return fixedLength;\n          }\n\n          @Override\n          public int maxLength() {\n            return maxLength;\n          }\n        };\n      }\n\n      public SortedDocValues getSorted(FieldInfo field) throws IOException {\n        SortedDocValues valuesIn = producer.getSorted(field);\n        final int maxDoc = valuesIn.size();\n        final int maxLength = valuesIn.maxLength();\n        final boolean fixedLength = valuesIn.isFixedLength();\n        final int valueCount = valuesIn.getValueCount();\n\n        // nocommit used packed ints and so on\n        final byte[][] values = new byte[valueCount][];\n        BytesRef scratch = new BytesRef();\n        for(int ord=0;ord<values.length;ord++) {\n          valuesIn.lookupOrd(ord, scratch);\n          values[ord] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[ord], 0, scratch.length);\n        }\n\n        final int[] docToOrd = new int[maxDoc];\n        for(int docID=0;docID<maxDoc;docID++) {\n          docToOrd[docID] = valuesIn.getOrd(docID);\n        }\n        return new SortedDocValues() {\n\n          @Override\n          public int getOrd(int docID) {\n            return docToOrd[docID];\n          }\n\n          @Override\n          public void lookupOrd(int ord, BytesRef result) {\n            result.bytes = values[ord];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int getValueCount() {\n            return valueCount;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public boolean isFixedLength() {\n            return fixedLength;\n          }\n\n          @Override\n          public int maxLength() {\n            return maxLength;\n          }\n        };\n      }\n\n      @Override\n      public void close() throws IOException {\n        producer.close();\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"acef9ded108f8fefd1a6cf5d0642e198a1196f11","date":1354826126,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat#fieldsProducer(SegmentReadState).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat#fieldsProducer(SegmentReadState).mjava","sourceNew":"  @Override\n  public SimpleDVProducer fieldsProducer(SegmentReadState state) throws IOException {\n    final SimpleDVProducer producer = new SimpleTextDocValuesReader(state, \"dat\");\n\n    return new SimpleDVProducer() {\n\n      @Override\n      public NumericDocValues getNumeric(FieldInfo field) throws IOException {\n        NumericDocValues valuesIn = producer.getNumeric(field);\n\n        final int maxDoc = valuesIn.size();\n        final long minValue = valuesIn.minValue();\n        final long maxValue = valuesIn.maxValue();\n\n        final long delta = maxValue - minValue;\n        final int bitsRequired = delta < 0 ? 64 : PackedInts.bitsRequired(delta);\n        final PackedInts.Mutable values = PackedInts.getMutable(maxDoc, bitsRequired, PackedInts.COMPACT);\n        for(int docID=0;docID<maxDoc;docID++) {\n          values.set(docID, valuesIn.get(docID) - minValue);\n        }\n\n        return new NumericDocValues() {\n\n          @Override\n          public long get(int docID) {\n            return minValue + values.get(docID);\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public long minValue() {\n            return minValue;\n          }\n\n          @Override\n          public long maxValue() {\n            return maxValue;\n          }\n        };\n      }\n      \n      @Override\n      public BinaryDocValues getBinary(FieldInfo field) throws IOException {\n        BinaryDocValues valuesIn = producer.getBinary(field);\n        final int maxDoc = valuesIn.size();\n        final int maxLength = valuesIn.maxLength();\n        final boolean fixedLength = valuesIn.isFixedLength();\n        // nocommit more ram efficient\n        final byte[][] values = new byte[maxDoc][];\n        BytesRef scratch = new BytesRef();\n        for(int docID=0;docID<maxDoc;docID++) {\n          valuesIn.get(docID, scratch);\n          values[docID] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[docID], 0, scratch.length);\n        }\n\n        return new BinaryDocValues() {\n\n          @Override\n          public void get(int docID, BytesRef result) {\n            result.bytes = values[docID];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public boolean isFixedLength() {\n            return fixedLength;\n          }\n\n          @Override\n          public int maxLength() {\n            return maxLength;\n          }\n        };\n      }\n\n      @Override\n      public SortedDocValues getSorted(FieldInfo field) throws IOException {\n        SortedDocValues valuesIn = producer.getSorted(field);\n        final int maxDoc = valuesIn.size();\n        final int maxLength = valuesIn.maxLength();\n        final boolean fixedLength = valuesIn.isFixedLength();\n        final int valueCount = valuesIn.getValueCount();\n\n        // nocommit used packed ints and so on\n        final byte[][] values = new byte[valueCount][];\n        BytesRef scratch = new BytesRef();\n        for(int ord=0;ord<values.length;ord++) {\n          valuesIn.lookupOrd(ord, scratch);\n          values[ord] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[ord], 0, scratch.length);\n        }\n\n        final int[] docToOrd = new int[maxDoc];\n        for(int docID=0;docID<maxDoc;docID++) {\n          docToOrd[docID] = valuesIn.getOrd(docID);\n        }\n        return new SortedDocValues() {\n\n          @Override\n          public int getOrd(int docID) {\n            return docToOrd[docID];\n          }\n\n          @Override\n          public void lookupOrd(int ord, BytesRef result) {\n            result.bytes = values[ord];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int getValueCount() {\n            return valueCount;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public boolean isFixedLength() {\n            return fixedLength;\n          }\n\n          @Override\n          public int maxLength() {\n            return maxLength;\n          }\n        };\n      }\n\n      @Override\n      public SimpleDVProducer clone() {\n        // We are already thread-safe:\n        return this;\n      }\n\n      @Override\n      public void close() throws IOException {\n        producer.close();\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public SimpleDVProducer fieldsProducer(SegmentReadState state) throws IOException {\n    final SimpleDVProducer producer = new SimpleTextDocValuesReader(state, \"dat\");\n\n    return new SimpleDVProducer() {\n\n      @Override\n      public NumericDocValues getNumeric(FieldInfo field) throws IOException {\n        NumericDocValues valuesIn = producer.getNumeric(field);\n\n        // nocommit more ram efficient\n        final int maxDoc = valuesIn.size();\n        final long minValue = valuesIn.minValue();\n        final long maxValue = valuesIn.maxValue();\n\n        final long[] values = new long[maxDoc];\n        for(int docID=0;docID<maxDoc;docID++) {\n          values[docID] = valuesIn.get(docID);\n        }\n\n        return new NumericDocValues() {\n\n          @Override\n          public long get(int docID) {\n            return values[docID];\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public long minValue() {\n            return minValue;\n          }\n\n          @Override\n          public long maxValue() {\n            return maxValue;\n          }\n        };\n      }\n      \n      @Override\n      public BinaryDocValues getBinary(FieldInfo field) throws IOException {\n        BinaryDocValues valuesIn = producer.getBinary(field);\n        final int maxDoc = valuesIn.size();\n        final int maxLength = valuesIn.maxLength();\n        final boolean fixedLength = valuesIn.isFixedLength();\n        // nocommit more ram efficient\n        final byte[][] values = new byte[maxDoc][];\n        BytesRef scratch = new BytesRef();\n        for(int docID=0;docID<maxDoc;docID++) {\n          valuesIn.get(docID, scratch);\n          values[docID] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[docID], 0, scratch.length);\n        }\n\n        return new BinaryDocValues() {\n\n          @Override\n          public void get(int docID, BytesRef result) {\n            result.bytes = values[docID];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public boolean isFixedLength() {\n            return fixedLength;\n          }\n\n          @Override\n          public int maxLength() {\n            return maxLength;\n          }\n        };\n      }\n\n      @Override\n      public SortedDocValues getSorted(FieldInfo field) throws IOException {\n        SortedDocValues valuesIn = producer.getSorted(field);\n        final int maxDoc = valuesIn.size();\n        final int maxLength = valuesIn.maxLength();\n        final boolean fixedLength = valuesIn.isFixedLength();\n        final int valueCount = valuesIn.getValueCount();\n\n        // nocommit used packed ints and so on\n        final byte[][] values = new byte[valueCount][];\n        BytesRef scratch = new BytesRef();\n        for(int ord=0;ord<values.length;ord++) {\n          valuesIn.lookupOrd(ord, scratch);\n          values[ord] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[ord], 0, scratch.length);\n        }\n\n        final int[] docToOrd = new int[maxDoc];\n        for(int docID=0;docID<maxDoc;docID++) {\n          docToOrd[docID] = valuesIn.getOrd(docID);\n        }\n        return new SortedDocValues() {\n\n          @Override\n          public int getOrd(int docID) {\n            return docToOrd[docID];\n          }\n\n          @Override\n          public void lookupOrd(int ord, BytesRef result) {\n            result.bytes = values[ord];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int getValueCount() {\n            return valueCount;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public boolean isFixedLength() {\n            return fixedLength;\n          }\n\n          @Override\n          public int maxLength() {\n            return maxLength;\n          }\n        };\n      }\n\n      @Override\n      public SimpleDVProducer clone() {\n        // We are already thread-safe:\n        return this;\n      }\n\n      @Override\n      public void close() throws IOException {\n        producer.close();\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e29774db46ad98ca4a8d7fcbfab633ebc01f358","date":1355170812,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat#fieldsProducer(SegmentReadState).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat#fieldsProducer(SegmentReadState).mjava","sourceNew":"  @Override\n  public SimpleDVProducer fieldsProducer(SegmentReadState state) throws IOException {\n    final SimpleDVProducer producer = new SimpleTextDocValuesReader(state, \"dat\");\n\n    return new SimpleDVProducer() {\n\n      @Override\n      public NumericDocValues getNumeric(FieldInfo field) throws IOException {\n        // nocommit is that clone() ok...?  it IS necessary\n        NumericDocValues valuesIn = producer.clone().getNumeric(field);\n\n        final int maxDoc = valuesIn.size();\n        final long minValue = valuesIn.minValue();\n        final long maxValue = valuesIn.maxValue();\n\n        final long delta = maxValue - minValue;\n        final int bitsRequired = delta < 0 ? 64 : PackedInts.bitsRequired(delta);\n        final PackedInts.Mutable values = PackedInts.getMutable(maxDoc, bitsRequired, PackedInts.COMPACT);\n        for(int docID=0;docID<maxDoc;docID++) {\n          values.set(docID, valuesIn.get(docID) - minValue);\n        }\n\n        return new NumericDocValues() {\n\n          @Override\n          public long get(int docID) {\n            return minValue + values.get(docID);\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public long minValue() {\n            return minValue;\n          }\n\n          @Override\n          public long maxValue() {\n            return maxValue;\n          }\n        };\n      }\n      \n      @Override\n      public BinaryDocValues getBinary(FieldInfo field) throws IOException {\n        // nocommit is that clone() ok...?  it IS necessary\n        BinaryDocValues valuesIn = producer.clone().getBinary(field);\n        final int maxDoc = valuesIn.size();\n        final int maxLength = valuesIn.maxLength();\n        final boolean fixedLength = valuesIn.isFixedLength();\n        // nocommit more ram efficient\n        final byte[][] values = new byte[maxDoc][];\n        BytesRef scratch = new BytesRef();\n        for(int docID=0;docID<maxDoc;docID++) {\n          valuesIn.get(docID, scratch);\n          values[docID] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[docID], 0, scratch.length);\n        }\n\n        return new BinaryDocValues() {\n\n          @Override\n          public void get(int docID, BytesRef result) {\n            result.bytes = values[docID];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public boolean isFixedLength() {\n            return fixedLength;\n          }\n\n          @Override\n          public int maxLength() {\n            return maxLength;\n          }\n        };\n      }\n\n      @Override\n      public SortedDocValues getSorted(FieldInfo field) throws IOException {\n        // nocommit is that clone() ok...?  it IS necessary\n        SortedDocValues valuesIn = producer.clone().getSorted(field);\n        final int maxDoc = valuesIn.size();\n        final int maxLength = valuesIn.maxLength();\n        final boolean fixedLength = valuesIn.isFixedLength();\n        final int valueCount = valuesIn.getValueCount();\n\n        // nocommit used packed ints and so on\n        final byte[][] values = new byte[valueCount][];\n        BytesRef scratch = new BytesRef();\n        for(int ord=0;ord<values.length;ord++) {\n          valuesIn.lookupOrd(ord, scratch);\n          values[ord] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[ord], 0, scratch.length);\n        }\n\n        final int[] docToOrd = new int[maxDoc];\n        for(int docID=0;docID<maxDoc;docID++) {\n          docToOrd[docID] = valuesIn.getOrd(docID);\n        }\n        return new SortedDocValues() {\n\n          @Override\n          public int getOrd(int docID) {\n            return docToOrd[docID];\n          }\n\n          @Override\n          public void lookupOrd(int ord, BytesRef result) {\n            result.bytes = values[ord];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int getValueCount() {\n            return valueCount;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public boolean isFixedLength() {\n            return fixedLength;\n          }\n\n          @Override\n          public int maxLength() {\n            return maxLength;\n          }\n        };\n      }\n\n      @Override\n      public SimpleDVProducer clone() {\n        // We are already thread-safe:\n        return this;\n      }\n\n      @Override\n      public void close() throws IOException {\n        producer.close();\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public SimpleDVProducer fieldsProducer(SegmentReadState state) throws IOException {\n    final SimpleDVProducer producer = new SimpleTextDocValuesReader(state, \"dat\");\n\n    return new SimpleDVProducer() {\n\n      @Override\n      public NumericDocValues getNumeric(FieldInfo field) throws IOException {\n        NumericDocValues valuesIn = producer.getNumeric(field);\n\n        final int maxDoc = valuesIn.size();\n        final long minValue = valuesIn.minValue();\n        final long maxValue = valuesIn.maxValue();\n\n        final long delta = maxValue - minValue;\n        final int bitsRequired = delta < 0 ? 64 : PackedInts.bitsRequired(delta);\n        final PackedInts.Mutable values = PackedInts.getMutable(maxDoc, bitsRequired, PackedInts.COMPACT);\n        for(int docID=0;docID<maxDoc;docID++) {\n          values.set(docID, valuesIn.get(docID) - minValue);\n        }\n\n        return new NumericDocValues() {\n\n          @Override\n          public long get(int docID) {\n            return minValue + values.get(docID);\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public long minValue() {\n            return minValue;\n          }\n\n          @Override\n          public long maxValue() {\n            return maxValue;\n          }\n        };\n      }\n      \n      @Override\n      public BinaryDocValues getBinary(FieldInfo field) throws IOException {\n        BinaryDocValues valuesIn = producer.getBinary(field);\n        final int maxDoc = valuesIn.size();\n        final int maxLength = valuesIn.maxLength();\n        final boolean fixedLength = valuesIn.isFixedLength();\n        // nocommit more ram efficient\n        final byte[][] values = new byte[maxDoc][];\n        BytesRef scratch = new BytesRef();\n        for(int docID=0;docID<maxDoc;docID++) {\n          valuesIn.get(docID, scratch);\n          values[docID] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[docID], 0, scratch.length);\n        }\n\n        return new BinaryDocValues() {\n\n          @Override\n          public void get(int docID, BytesRef result) {\n            result.bytes = values[docID];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public boolean isFixedLength() {\n            return fixedLength;\n          }\n\n          @Override\n          public int maxLength() {\n            return maxLength;\n          }\n        };\n      }\n\n      @Override\n      public SortedDocValues getSorted(FieldInfo field) throws IOException {\n        SortedDocValues valuesIn = producer.getSorted(field);\n        final int maxDoc = valuesIn.size();\n        final int maxLength = valuesIn.maxLength();\n        final boolean fixedLength = valuesIn.isFixedLength();\n        final int valueCount = valuesIn.getValueCount();\n\n        // nocommit used packed ints and so on\n        final byte[][] values = new byte[valueCount][];\n        BytesRef scratch = new BytesRef();\n        for(int ord=0;ord<values.length;ord++) {\n          valuesIn.lookupOrd(ord, scratch);\n          values[ord] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[ord], 0, scratch.length);\n        }\n\n        final int[] docToOrd = new int[maxDoc];\n        for(int docID=0;docID<maxDoc;docID++) {\n          docToOrd[docID] = valuesIn.getOrd(docID);\n        }\n        return new SortedDocValues() {\n\n          @Override\n          public int getOrd(int docID) {\n            return docToOrd[docID];\n          }\n\n          @Override\n          public void lookupOrd(int ord, BytesRef result) {\n            result.bytes = values[ord];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int getValueCount() {\n            return valueCount;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public boolean isFixedLength() {\n            return fixedLength;\n          }\n\n          @Override\n          public int maxLength() {\n            return maxLength;\n          }\n        };\n      }\n\n      @Override\n      public SimpleDVProducer clone() {\n        // We are already thread-safe:\n        return this;\n      }\n\n      @Override\n      public void close() throws IOException {\n        producer.close();\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ed00c8118962f490744732ab611c595c91b80d1c","date":1356020966,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat#fieldsProducer(SegmentReadState).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat#fieldsProducer(SegmentReadState).mjava","sourceNew":"  @Override\n  public SimpleDVProducer fieldsProducer(SegmentReadState state) throws IOException {\n    final SimpleDVProducer producer = new SimpleTextDocValuesReader(state, \"dat\");\n\n    return new SimpleDVProducer() {\n\n      @Override\n      public NumericDocValues getNumeric(FieldInfo field) throws IOException {\n        NumericDocValues valuesIn = producer.getNumeric(field);\n\n        final int maxDoc = valuesIn.size();\n        final long minValue = valuesIn.minValue();\n        final long maxValue = valuesIn.maxValue();\n\n        final long delta = maxValue - minValue;\n        final int bitsRequired = delta < 0 ? 64 : PackedInts.bitsRequired(delta);\n        final PackedInts.Mutable values = PackedInts.getMutable(maxDoc, bitsRequired, PackedInts.COMPACT);\n        for(int docID=0;docID<maxDoc;docID++) {\n          values.set(docID, valuesIn.get(docID) - minValue);\n        }\n\n        return new NumericDocValues() {\n\n          @Override\n          public long get(int docID) {\n            return minValue + values.get(docID);\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public long minValue() {\n            return minValue;\n          }\n\n          @Override\n          public long maxValue() {\n            return maxValue;\n          }\n        };\n      }\n      \n      @Override\n      public BinaryDocValues getBinary(FieldInfo field) throws IOException {\n        BinaryDocValues valuesIn = producer.getBinary(field);\n        final int maxDoc = valuesIn.size();\n        final int maxLength = valuesIn.maxLength();\n        final boolean fixedLength = valuesIn.isFixedLength();\n        // nocommit more ram efficient\n        final byte[][] values = new byte[maxDoc][];\n        BytesRef scratch = new BytesRef();\n        for(int docID=0;docID<maxDoc;docID++) {\n          valuesIn.get(docID, scratch);\n          values[docID] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[docID], 0, scratch.length);\n        }\n\n        return new BinaryDocValues() {\n\n          @Override\n          public void get(int docID, BytesRef result) {\n            result.bytes = values[docID];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public boolean isFixedLength() {\n            return fixedLength;\n          }\n\n          @Override\n          public int maxLength() {\n            return maxLength;\n          }\n        };\n      }\n\n      @Override\n      public SortedDocValues getSorted(FieldInfo field) throws IOException {\n        SortedDocValues valuesIn = producer.getSorted(field);\n        final int maxDoc = valuesIn.size();\n        final int maxLength = valuesIn.maxLength();\n        final boolean fixedLength = valuesIn.isFixedLength();\n        final int valueCount = valuesIn.getValueCount();\n\n        // nocommit used packed ints and so on\n        final byte[][] values = new byte[valueCount][];\n        BytesRef scratch = new BytesRef();\n        for(int ord=0;ord<values.length;ord++) {\n          valuesIn.lookupOrd(ord, scratch);\n          values[ord] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[ord], 0, scratch.length);\n        }\n\n        final int[] docToOrd = new int[maxDoc];\n        for(int docID=0;docID<maxDoc;docID++) {\n          docToOrd[docID] = valuesIn.getOrd(docID);\n        }\n        return new SortedDocValues() {\n\n          @Override\n          public int getOrd(int docID) {\n            return docToOrd[docID];\n          }\n\n          @Override\n          public void lookupOrd(int ord, BytesRef result) {\n            result.bytes = values[ord];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int getValueCount() {\n            return valueCount;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public boolean isFixedLength() {\n            return fixedLength;\n          }\n\n          @Override\n          public int maxLength() {\n            return maxLength;\n          }\n        };\n      }\n\n      @Override\n      public SimpleDVProducer clone() {\n        // We are already thread-safe:\n        return this;\n      }\n\n      @Override\n      public void close() throws IOException {\n        producer.close();\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public SimpleDVProducer fieldsProducer(SegmentReadState state) throws IOException {\n    final SimpleDVProducer producer = new SimpleTextDocValuesReader(state, \"dat\");\n\n    return new SimpleDVProducer() {\n\n      @Override\n      public NumericDocValues getNumeric(FieldInfo field) throws IOException {\n        // nocommit is that clone() ok...?  it IS necessary\n        NumericDocValues valuesIn = producer.clone().getNumeric(field);\n\n        final int maxDoc = valuesIn.size();\n        final long minValue = valuesIn.minValue();\n        final long maxValue = valuesIn.maxValue();\n\n        final long delta = maxValue - minValue;\n        final int bitsRequired = delta < 0 ? 64 : PackedInts.bitsRequired(delta);\n        final PackedInts.Mutable values = PackedInts.getMutable(maxDoc, bitsRequired, PackedInts.COMPACT);\n        for(int docID=0;docID<maxDoc;docID++) {\n          values.set(docID, valuesIn.get(docID) - minValue);\n        }\n\n        return new NumericDocValues() {\n\n          @Override\n          public long get(int docID) {\n            return minValue + values.get(docID);\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public long minValue() {\n            return minValue;\n          }\n\n          @Override\n          public long maxValue() {\n            return maxValue;\n          }\n        };\n      }\n      \n      @Override\n      public BinaryDocValues getBinary(FieldInfo field) throws IOException {\n        // nocommit is that clone() ok...?  it IS necessary\n        BinaryDocValues valuesIn = producer.clone().getBinary(field);\n        final int maxDoc = valuesIn.size();\n        final int maxLength = valuesIn.maxLength();\n        final boolean fixedLength = valuesIn.isFixedLength();\n        // nocommit more ram efficient\n        final byte[][] values = new byte[maxDoc][];\n        BytesRef scratch = new BytesRef();\n        for(int docID=0;docID<maxDoc;docID++) {\n          valuesIn.get(docID, scratch);\n          values[docID] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[docID], 0, scratch.length);\n        }\n\n        return new BinaryDocValues() {\n\n          @Override\n          public void get(int docID, BytesRef result) {\n            result.bytes = values[docID];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public boolean isFixedLength() {\n            return fixedLength;\n          }\n\n          @Override\n          public int maxLength() {\n            return maxLength;\n          }\n        };\n      }\n\n      @Override\n      public SortedDocValues getSorted(FieldInfo field) throws IOException {\n        // nocommit is that clone() ok...?  it IS necessary\n        SortedDocValues valuesIn = producer.clone().getSorted(field);\n        final int maxDoc = valuesIn.size();\n        final int maxLength = valuesIn.maxLength();\n        final boolean fixedLength = valuesIn.isFixedLength();\n        final int valueCount = valuesIn.getValueCount();\n\n        // nocommit used packed ints and so on\n        final byte[][] values = new byte[valueCount][];\n        BytesRef scratch = new BytesRef();\n        for(int ord=0;ord<values.length;ord++) {\n          valuesIn.lookupOrd(ord, scratch);\n          values[ord] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[ord], 0, scratch.length);\n        }\n\n        final int[] docToOrd = new int[maxDoc];\n        for(int docID=0;docID<maxDoc;docID++) {\n          docToOrd[docID] = valuesIn.getOrd(docID);\n        }\n        return new SortedDocValues() {\n\n          @Override\n          public int getOrd(int docID) {\n            return docToOrd[docID];\n          }\n\n          @Override\n          public void lookupOrd(int ord, BytesRef result) {\n            result.bytes = values[ord];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int getValueCount() {\n            return valueCount;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public boolean isFixedLength() {\n            return fixedLength;\n          }\n\n          @Override\n          public int maxLength() {\n            return maxLength;\n          }\n        };\n      }\n\n      @Override\n      public SimpleDVProducer clone() {\n        // We are already thread-safe:\n        return this;\n      }\n\n      @Override\n      public void close() throws IOException {\n        producer.close();\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"32fb848e256860b63adc9c2b068f386032c77b67","date":1357587205,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat#fieldsProducer(SegmentReadState).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat#fieldsProducer(SegmentReadState).mjava","sourceNew":"  @Override\n  public SimpleDVProducer fieldsProducer(SegmentReadState state) throws IOException {\n    final SimpleDVProducer producer = new SimpleTextDocValuesReader(state, \"dat\");\n\n    return new SimpleDVProducer() {\n\n      @Override\n      public NumericDocValues getNumeric(FieldInfo field) throws IOException {\n        NumericDocValues valuesIn = producer.getNumeric(field);\n\n        final int maxDoc = valuesIn.size();\n        long minValue = Long.MAX_VALUE;\n        long maxValue = Long.MIN_VALUE;\n        for(int docID=0;docID<maxDoc;docID++) {\n          long v = valuesIn.get(docID);\n          minValue = Math.min(minValue, v);\n          maxValue = Math.max(maxValue, v);\n        }\n\n        final long delta = maxValue - minValue;\n        final int bitsRequired = delta < 0 ? 64 : PackedInts.bitsRequired(delta);\n        final PackedInts.Mutable values = PackedInts.getMutable(maxDoc, bitsRequired, PackedInts.COMPACT);\n        for(int docID=0;docID<maxDoc;docID++) {\n          values.set(docID, valuesIn.get(docID) - minValue);\n        }\n\n        final long finalMinValue = minValue;\n\n        return new NumericDocValues() {\n\n          @Override\n          public long get(int docID) {\n            return finalMinValue + values.get(docID);\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n        };\n      }\n      \n      @Override\n      public BinaryDocValues getBinary(FieldInfo field) throws IOException {\n        BinaryDocValues valuesIn = producer.getBinary(field);\n        final int maxDoc = valuesIn.size();\n        final int maxLength = valuesIn.maxLength();\n        final boolean fixedLength = valuesIn.isFixedLength();\n        // nocommit more ram efficient\n        final byte[][] values = new byte[maxDoc][];\n        BytesRef scratch = new BytesRef();\n        for(int docID=0;docID<maxDoc;docID++) {\n          valuesIn.get(docID, scratch);\n          values[docID] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[docID], 0, scratch.length);\n        }\n\n        return new BinaryDocValues() {\n\n          @Override\n          public void get(int docID, BytesRef result) {\n            result.bytes = values[docID];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public boolean isFixedLength() {\n            return fixedLength;\n          }\n\n          @Override\n          public int maxLength() {\n            return maxLength;\n          }\n        };\n      }\n\n      @Override\n      public SortedDocValues getSorted(FieldInfo field) throws IOException {\n        SortedDocValues valuesIn = producer.getSorted(field);\n        final int maxDoc = valuesIn.size();\n        final int maxLength = valuesIn.maxLength();\n        final boolean fixedLength = valuesIn.isFixedLength();\n        final int valueCount = valuesIn.getValueCount();\n\n        // nocommit used packed ints and so on\n        final byte[][] values = new byte[valueCount][];\n        BytesRef scratch = new BytesRef();\n        for(int ord=0;ord<values.length;ord++) {\n          valuesIn.lookupOrd(ord, scratch);\n          values[ord] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[ord], 0, scratch.length);\n        }\n\n        final int[] docToOrd = new int[maxDoc];\n        for(int docID=0;docID<maxDoc;docID++) {\n          docToOrd[docID] = valuesIn.getOrd(docID);\n        }\n        return new SortedDocValues() {\n\n          @Override\n          public int getOrd(int docID) {\n            return docToOrd[docID];\n          }\n\n          @Override\n          public void lookupOrd(int ord, BytesRef result) {\n            result.bytes = values[ord];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int getValueCount() {\n            return valueCount;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public boolean isFixedLength() {\n            return fixedLength;\n          }\n\n          @Override\n          public int maxLength() {\n            return maxLength;\n          }\n        };\n      }\n\n      @Override\n      public SimpleDVProducer clone() {\n        // We are already thread-safe:\n        return this;\n      }\n\n      @Override\n      public void close() throws IOException {\n        producer.close();\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public SimpleDVProducer fieldsProducer(SegmentReadState state) throws IOException {\n    final SimpleDVProducer producer = new SimpleTextDocValuesReader(state, \"dat\");\n\n    return new SimpleDVProducer() {\n\n      @Override\n      public NumericDocValues getNumeric(FieldInfo field) throws IOException {\n        NumericDocValues valuesIn = producer.getNumeric(field);\n\n        final int maxDoc = valuesIn.size();\n        final long minValue = valuesIn.minValue();\n        final long maxValue = valuesIn.maxValue();\n\n        final long delta = maxValue - minValue;\n        final int bitsRequired = delta < 0 ? 64 : PackedInts.bitsRequired(delta);\n        final PackedInts.Mutable values = PackedInts.getMutable(maxDoc, bitsRequired, PackedInts.COMPACT);\n        for(int docID=0;docID<maxDoc;docID++) {\n          values.set(docID, valuesIn.get(docID) - minValue);\n        }\n\n        return new NumericDocValues() {\n\n          @Override\n          public long get(int docID) {\n            return minValue + values.get(docID);\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public long minValue() {\n            return minValue;\n          }\n\n          @Override\n          public long maxValue() {\n            return maxValue;\n          }\n        };\n      }\n      \n      @Override\n      public BinaryDocValues getBinary(FieldInfo field) throws IOException {\n        BinaryDocValues valuesIn = producer.getBinary(field);\n        final int maxDoc = valuesIn.size();\n        final int maxLength = valuesIn.maxLength();\n        final boolean fixedLength = valuesIn.isFixedLength();\n        // nocommit more ram efficient\n        final byte[][] values = new byte[maxDoc][];\n        BytesRef scratch = new BytesRef();\n        for(int docID=0;docID<maxDoc;docID++) {\n          valuesIn.get(docID, scratch);\n          values[docID] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[docID], 0, scratch.length);\n        }\n\n        return new BinaryDocValues() {\n\n          @Override\n          public void get(int docID, BytesRef result) {\n            result.bytes = values[docID];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public boolean isFixedLength() {\n            return fixedLength;\n          }\n\n          @Override\n          public int maxLength() {\n            return maxLength;\n          }\n        };\n      }\n\n      @Override\n      public SortedDocValues getSorted(FieldInfo field) throws IOException {\n        SortedDocValues valuesIn = producer.getSorted(field);\n        final int maxDoc = valuesIn.size();\n        final int maxLength = valuesIn.maxLength();\n        final boolean fixedLength = valuesIn.isFixedLength();\n        final int valueCount = valuesIn.getValueCount();\n\n        // nocommit used packed ints and so on\n        final byte[][] values = new byte[valueCount][];\n        BytesRef scratch = new BytesRef();\n        for(int ord=0;ord<values.length;ord++) {\n          valuesIn.lookupOrd(ord, scratch);\n          values[ord] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[ord], 0, scratch.length);\n        }\n\n        final int[] docToOrd = new int[maxDoc];\n        for(int docID=0;docID<maxDoc;docID++) {\n          docToOrd[docID] = valuesIn.getOrd(docID);\n        }\n        return new SortedDocValues() {\n\n          @Override\n          public int getOrd(int docID) {\n            return docToOrd[docID];\n          }\n\n          @Override\n          public void lookupOrd(int ord, BytesRef result) {\n            result.bytes = values[ord];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int getValueCount() {\n            return valueCount;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public boolean isFixedLength() {\n            return fixedLength;\n          }\n\n          @Override\n          public int maxLength() {\n            return maxLength;\n          }\n        };\n      }\n\n      @Override\n      public SimpleDVProducer clone() {\n        // We are already thread-safe:\n        return this;\n      }\n\n      @Override\n      public void close() throws IOException {\n        producer.close();\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"746e3645169db50c8f53252b30d6bc9ac21dea7c","date":1357597773,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat#fieldsProducer(SegmentReadState).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat#fieldsProducer(SegmentReadState).mjava","sourceNew":"  @Override\n  public SimpleDVProducer fieldsProducer(SegmentReadState state) throws IOException {\n    final SimpleDVProducer producer = new SimpleTextDocValuesReader(state, \"dat\");\n\n    return new SimpleDVProducer() {\n\n      @Override\n      public NumericDocValues getNumeric(FieldInfo field) throws IOException {\n        NumericDocValues valuesIn = producer.getNumeric(field);\n\n        final int maxDoc = valuesIn.size();\n        long minValue = Long.MAX_VALUE;\n        long maxValue = Long.MIN_VALUE;\n        for(int docID=0;docID<maxDoc;docID++) {\n          long v = valuesIn.get(docID);\n          minValue = Math.min(minValue, v);\n          maxValue = Math.max(maxValue, v);\n        }\n\n        final long delta = maxValue - minValue;\n        final int bitsRequired = delta < 0 ? 64 : PackedInts.bitsRequired(delta);\n        final PackedInts.Mutable values = PackedInts.getMutable(maxDoc, bitsRequired, PackedInts.COMPACT);\n        for(int docID=0;docID<maxDoc;docID++) {\n          values.set(docID, valuesIn.get(docID) - minValue);\n        }\n\n        final long finalMinValue = minValue;\n\n        return new NumericDocValues() {\n\n          @Override\n          public long get(int docID) {\n            return finalMinValue + values.get(docID);\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n        };\n      }\n      \n      @Override\n      public BinaryDocValues getBinary(FieldInfo field) throws IOException {\n        BinaryDocValues valuesIn = producer.getBinary(field);\n        final int maxDoc = valuesIn.size();\n        // nocommit more ram efficient\n        final byte[][] values = new byte[maxDoc][];\n        BytesRef scratch = new BytesRef();\n        for(int docID=0;docID<maxDoc;docID++) {\n          valuesIn.get(docID, scratch);\n          values[docID] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[docID], 0, scratch.length);\n        }\n\n        return new BinaryDocValues() {\n\n          @Override\n          public void get(int docID, BytesRef result) {\n            result.bytes = values[docID];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n        };\n      }\n\n      @Override\n      public SortedDocValues getSorted(FieldInfo field) throws IOException {\n        SortedDocValues valuesIn = producer.getSorted(field);\n        final int maxDoc = valuesIn.size();\n        final int maxLength = valuesIn.maxLength();\n        final boolean fixedLength = valuesIn.isFixedLength();\n        final int valueCount = valuesIn.getValueCount();\n\n        // nocommit used packed ints and so on\n        final byte[][] values = new byte[valueCount][];\n        BytesRef scratch = new BytesRef();\n        for(int ord=0;ord<values.length;ord++) {\n          valuesIn.lookupOrd(ord, scratch);\n          values[ord] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[ord], 0, scratch.length);\n        }\n\n        final int[] docToOrd = new int[maxDoc];\n        for(int docID=0;docID<maxDoc;docID++) {\n          docToOrd[docID] = valuesIn.getOrd(docID);\n        }\n        return new SortedDocValues() {\n\n          @Override\n          public int getOrd(int docID) {\n            return docToOrd[docID];\n          }\n\n          @Override\n          public void lookupOrd(int ord, BytesRef result) {\n            result.bytes = values[ord];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int getValueCount() {\n            return valueCount;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public boolean isFixedLength() {\n            return fixedLength;\n          }\n\n          @Override\n          public int maxLength() {\n            return maxLength;\n          }\n        };\n      }\n\n      @Override\n      public SimpleDVProducer clone() {\n        // We are already thread-safe:\n        return this;\n      }\n\n      @Override\n      public void close() throws IOException {\n        producer.close();\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public SimpleDVProducer fieldsProducer(SegmentReadState state) throws IOException {\n    final SimpleDVProducer producer = new SimpleTextDocValuesReader(state, \"dat\");\n\n    return new SimpleDVProducer() {\n\n      @Override\n      public NumericDocValues getNumeric(FieldInfo field) throws IOException {\n        NumericDocValues valuesIn = producer.getNumeric(field);\n\n        final int maxDoc = valuesIn.size();\n        long minValue = Long.MAX_VALUE;\n        long maxValue = Long.MIN_VALUE;\n        for(int docID=0;docID<maxDoc;docID++) {\n          long v = valuesIn.get(docID);\n          minValue = Math.min(minValue, v);\n          maxValue = Math.max(maxValue, v);\n        }\n\n        final long delta = maxValue - minValue;\n        final int bitsRequired = delta < 0 ? 64 : PackedInts.bitsRequired(delta);\n        final PackedInts.Mutable values = PackedInts.getMutable(maxDoc, bitsRequired, PackedInts.COMPACT);\n        for(int docID=0;docID<maxDoc;docID++) {\n          values.set(docID, valuesIn.get(docID) - minValue);\n        }\n\n        final long finalMinValue = minValue;\n\n        return new NumericDocValues() {\n\n          @Override\n          public long get(int docID) {\n            return finalMinValue + values.get(docID);\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n        };\n      }\n      \n      @Override\n      public BinaryDocValues getBinary(FieldInfo field) throws IOException {\n        BinaryDocValues valuesIn = producer.getBinary(field);\n        final int maxDoc = valuesIn.size();\n        final int maxLength = valuesIn.maxLength();\n        final boolean fixedLength = valuesIn.isFixedLength();\n        // nocommit more ram efficient\n        final byte[][] values = new byte[maxDoc][];\n        BytesRef scratch = new BytesRef();\n        for(int docID=0;docID<maxDoc;docID++) {\n          valuesIn.get(docID, scratch);\n          values[docID] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[docID], 0, scratch.length);\n        }\n\n        return new BinaryDocValues() {\n\n          @Override\n          public void get(int docID, BytesRef result) {\n            result.bytes = values[docID];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public boolean isFixedLength() {\n            return fixedLength;\n          }\n\n          @Override\n          public int maxLength() {\n            return maxLength;\n          }\n        };\n      }\n\n      @Override\n      public SortedDocValues getSorted(FieldInfo field) throws IOException {\n        SortedDocValues valuesIn = producer.getSorted(field);\n        final int maxDoc = valuesIn.size();\n        final int maxLength = valuesIn.maxLength();\n        final boolean fixedLength = valuesIn.isFixedLength();\n        final int valueCount = valuesIn.getValueCount();\n\n        // nocommit used packed ints and so on\n        final byte[][] values = new byte[valueCount][];\n        BytesRef scratch = new BytesRef();\n        for(int ord=0;ord<values.length;ord++) {\n          valuesIn.lookupOrd(ord, scratch);\n          values[ord] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[ord], 0, scratch.length);\n        }\n\n        final int[] docToOrd = new int[maxDoc];\n        for(int docID=0;docID<maxDoc;docID++) {\n          docToOrd[docID] = valuesIn.getOrd(docID);\n        }\n        return new SortedDocValues() {\n\n          @Override\n          public int getOrd(int docID) {\n            return docToOrd[docID];\n          }\n\n          @Override\n          public void lookupOrd(int ord, BytesRef result) {\n            result.bytes = values[ord];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int getValueCount() {\n            return valueCount;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public boolean isFixedLength() {\n            return fixedLength;\n          }\n\n          @Override\n          public int maxLength() {\n            return maxLength;\n          }\n        };\n      }\n\n      @Override\n      public SimpleDVProducer clone() {\n        // We are already thread-safe:\n        return this;\n      }\n\n      @Override\n      public void close() throws IOException {\n        producer.close();\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1ed9002c5afac843c7f2d04d88e74b40d627e1af","date":1357602069,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat#fieldsProducer(SegmentReadState).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat#fieldsProducer(SegmentReadState).mjava","sourceNew":"  @Override\n  public SimpleDVProducer fieldsProducer(SegmentReadState state) throws IOException {\n    final SimpleDVProducer producer = new SimpleTextDocValuesReader(state, \"dat\");\n\n    return new SimpleDVProducer() {\n\n      @Override\n      public NumericDocValues getNumeric(FieldInfo field) throws IOException {\n        NumericDocValues valuesIn = producer.getNumeric(field);\n\n        final int maxDoc = valuesIn.size();\n        long minValue = Long.MAX_VALUE;\n        long maxValue = Long.MIN_VALUE;\n        for(int docID=0;docID<maxDoc;docID++) {\n          long v = valuesIn.get(docID);\n          minValue = Math.min(minValue, v);\n          maxValue = Math.max(maxValue, v);\n        }\n\n        final long delta = maxValue - minValue;\n        final int bitsRequired = delta < 0 ? 64 : PackedInts.bitsRequired(delta);\n        final PackedInts.Mutable values = PackedInts.getMutable(maxDoc, bitsRequired, PackedInts.COMPACT);\n        for(int docID=0;docID<maxDoc;docID++) {\n          values.set(docID, valuesIn.get(docID) - minValue);\n        }\n\n        final long finalMinValue = minValue;\n\n        return new NumericDocValues() {\n\n          @Override\n          public long get(int docID) {\n            return finalMinValue + values.get(docID);\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n        };\n      }\n      \n      @Override\n      public BinaryDocValues getBinary(FieldInfo field) throws IOException {\n        BinaryDocValues valuesIn = producer.getBinary(field);\n        final int maxDoc = valuesIn.size();\n        // nocommit more ram efficient\n        final byte[][] values = new byte[maxDoc][];\n        BytesRef scratch = new BytesRef();\n        for(int docID=0;docID<maxDoc;docID++) {\n          valuesIn.get(docID, scratch);\n          values[docID] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[docID], 0, scratch.length);\n        }\n\n        return new BinaryDocValues() {\n\n          @Override\n          public void get(int docID, BytesRef result) {\n            result.bytes = values[docID];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n        };\n      }\n\n      @Override\n      public SortedDocValues getSorted(FieldInfo field) throws IOException {\n        SortedDocValues valuesIn = producer.getSorted(field);\n        final int maxDoc = valuesIn.size();\n        final int valueCount = valuesIn.getValueCount();\n\n        // nocommit used packed ints and so on\n        final byte[][] values = new byte[valueCount][];\n        BytesRef scratch = new BytesRef();\n        for(int ord=0;ord<values.length;ord++) {\n          valuesIn.lookupOrd(ord, scratch);\n          values[ord] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[ord], 0, scratch.length);\n        }\n\n        final int[] docToOrd = new int[maxDoc];\n        for(int docID=0;docID<maxDoc;docID++) {\n          docToOrd[docID] = valuesIn.getOrd(docID);\n        }\n        return new SortedDocValues() {\n\n          @Override\n          public int getOrd(int docID) {\n            return docToOrd[docID];\n          }\n\n          @Override\n          public void lookupOrd(int ord, BytesRef result) {\n            result.bytes = values[ord];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int getValueCount() {\n            return valueCount;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n        };\n      }\n\n      @Override\n      public SimpleDVProducer clone() {\n        // We are already thread-safe:\n        return this;\n      }\n\n      @Override\n      public void close() throws IOException {\n        producer.close();\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public SimpleDVProducer fieldsProducer(SegmentReadState state) throws IOException {\n    final SimpleDVProducer producer = new SimpleTextDocValuesReader(state, \"dat\");\n\n    return new SimpleDVProducer() {\n\n      @Override\n      public NumericDocValues getNumeric(FieldInfo field) throws IOException {\n        NumericDocValues valuesIn = producer.getNumeric(field);\n\n        final int maxDoc = valuesIn.size();\n        long minValue = Long.MAX_VALUE;\n        long maxValue = Long.MIN_VALUE;\n        for(int docID=0;docID<maxDoc;docID++) {\n          long v = valuesIn.get(docID);\n          minValue = Math.min(minValue, v);\n          maxValue = Math.max(maxValue, v);\n        }\n\n        final long delta = maxValue - minValue;\n        final int bitsRequired = delta < 0 ? 64 : PackedInts.bitsRequired(delta);\n        final PackedInts.Mutable values = PackedInts.getMutable(maxDoc, bitsRequired, PackedInts.COMPACT);\n        for(int docID=0;docID<maxDoc;docID++) {\n          values.set(docID, valuesIn.get(docID) - minValue);\n        }\n\n        final long finalMinValue = minValue;\n\n        return new NumericDocValues() {\n\n          @Override\n          public long get(int docID) {\n            return finalMinValue + values.get(docID);\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n        };\n      }\n      \n      @Override\n      public BinaryDocValues getBinary(FieldInfo field) throws IOException {\n        BinaryDocValues valuesIn = producer.getBinary(field);\n        final int maxDoc = valuesIn.size();\n        // nocommit more ram efficient\n        final byte[][] values = new byte[maxDoc][];\n        BytesRef scratch = new BytesRef();\n        for(int docID=0;docID<maxDoc;docID++) {\n          valuesIn.get(docID, scratch);\n          values[docID] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[docID], 0, scratch.length);\n        }\n\n        return new BinaryDocValues() {\n\n          @Override\n          public void get(int docID, BytesRef result) {\n            result.bytes = values[docID];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n        };\n      }\n\n      @Override\n      public SortedDocValues getSorted(FieldInfo field) throws IOException {\n        SortedDocValues valuesIn = producer.getSorted(field);\n        final int maxDoc = valuesIn.size();\n        final int maxLength = valuesIn.maxLength();\n        final boolean fixedLength = valuesIn.isFixedLength();\n        final int valueCount = valuesIn.getValueCount();\n\n        // nocommit used packed ints and so on\n        final byte[][] values = new byte[valueCount][];\n        BytesRef scratch = new BytesRef();\n        for(int ord=0;ord<values.length;ord++) {\n          valuesIn.lookupOrd(ord, scratch);\n          values[ord] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[ord], 0, scratch.length);\n        }\n\n        final int[] docToOrd = new int[maxDoc];\n        for(int docID=0;docID<maxDoc;docID++) {\n          docToOrd[docID] = valuesIn.getOrd(docID);\n        }\n        return new SortedDocValues() {\n\n          @Override\n          public int getOrd(int docID) {\n            return docToOrd[docID];\n          }\n\n          @Override\n          public void lookupOrd(int ord, BytesRef result) {\n            result.bytes = values[ord];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int getValueCount() {\n            return valueCount;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n\n          @Override\n          public boolean isFixedLength() {\n            return fixedLength;\n          }\n\n          @Override\n          public int maxLength() {\n            return maxLength;\n          }\n        };\n      }\n\n      @Override\n      public SimpleDVProducer clone() {\n        // We are already thread-safe:\n        return this;\n      }\n\n      @Override\n      public void close() throws IOException {\n        producer.close();\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb81b54e140a68aa997b4df84461c4fc54f6c999","date":1357736893,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat#fieldsProducer(SegmentReadState).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat#fieldsProducer(SegmentReadState).mjava","sourceNew":"  @Override\n  public SimpleDVProducer fieldsProducer(SegmentReadState state) throws IOException {\n    final SimpleDVProducer producer = new SimpleTextDocValuesReader(state, \"dat\");\n\n    return new SimpleDVProducer() {\n\n      @Override\n      public NumericDocValues getNumeric(FieldInfo field) throws IOException {\n        NumericDocValues valuesIn = producer.getNumeric(field);\n\n        final int maxDoc = valuesIn.size();\n        long minValue = Long.MAX_VALUE;\n        long maxValue = Long.MIN_VALUE;\n        for(int docID=0;docID<maxDoc;docID++) {\n          long v = valuesIn.get(docID);\n          minValue = Math.min(minValue, v);\n          maxValue = Math.max(maxValue, v);\n        }\n\n        final long delta = maxValue - minValue;\n        final int bitsRequired = delta < 0 ? 64 : PackedInts.bitsRequired(delta);\n        final PackedInts.Mutable values = PackedInts.getMutable(maxDoc, bitsRequired, PackedInts.COMPACT);\n        for(int docID=0;docID<maxDoc;docID++) {\n          values.set(docID, valuesIn.get(docID) - minValue);\n        }\n\n        final long finalMinValue = minValue;\n\n        return new NumericDocValues() {\n\n          @Override\n          public long get(int docID) {\n            return finalMinValue + values.get(docID);\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n        };\n      }\n      \n      @Override\n      public BinaryDocValues getBinary(FieldInfo field) throws IOException {\n        BinaryDocValues valuesIn = producer.getBinary(field);\n        final int maxDoc = valuesIn.size();\n        // nocommit more ram efficient\n        final byte[][] values = new byte[maxDoc][];\n        BytesRef scratch = new BytesRef();\n        for(int docID=0;docID<maxDoc;docID++) {\n          valuesIn.get(docID, scratch);\n          values[docID] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[docID], 0, scratch.length);\n        }\n\n        return new BinaryDocValues() {\n\n          @Override\n          public void get(int docID, BytesRef result) {\n            result.bytes = values[docID];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n        };\n      }\n\n      @Override\n      public SortedDocValues getSorted(FieldInfo field) throws IOException {\n        SortedDocValues valuesIn = producer.getSorted(field);\n        final int maxDoc = valuesIn.size();\n        final int valueCount = valuesIn.getValueCount();\n\n        // nocommit used packed ints and so on\n        final byte[][] values = new byte[valueCount][];\n        BytesRef scratch = new BytesRef();\n        for(int ord=0;ord<values.length;ord++) {\n          valuesIn.lookupOrd(ord, scratch);\n          values[ord] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[ord], 0, scratch.length);\n        }\n\n        final int[] docToOrd = new int[maxDoc];\n        for(int docID=0;docID<maxDoc;docID++) {\n          docToOrd[docID] = valuesIn.getOrd(docID);\n        }\n        return new SortedDocValues() {\n\n          @Override\n          public int getOrd(int docID) {\n            return docToOrd[docID];\n          }\n\n          @Override\n          public void lookupOrd(int ord, BytesRef result) {\n            result.bytes = values[ord];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int getValueCount() {\n            return valueCount;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n        };\n      }\n\n      @Override\n      public void close() throws IOException {\n        producer.close();\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public SimpleDVProducer fieldsProducer(SegmentReadState state) throws IOException {\n    final SimpleDVProducer producer = new SimpleTextDocValuesReader(state, \"dat\");\n\n    return new SimpleDVProducer() {\n\n      @Override\n      public NumericDocValues getNumeric(FieldInfo field) throws IOException {\n        NumericDocValues valuesIn = producer.getNumeric(field);\n\n        final int maxDoc = valuesIn.size();\n        long minValue = Long.MAX_VALUE;\n        long maxValue = Long.MIN_VALUE;\n        for(int docID=0;docID<maxDoc;docID++) {\n          long v = valuesIn.get(docID);\n          minValue = Math.min(minValue, v);\n          maxValue = Math.max(maxValue, v);\n        }\n\n        final long delta = maxValue - minValue;\n        final int bitsRequired = delta < 0 ? 64 : PackedInts.bitsRequired(delta);\n        final PackedInts.Mutable values = PackedInts.getMutable(maxDoc, bitsRequired, PackedInts.COMPACT);\n        for(int docID=0;docID<maxDoc;docID++) {\n          values.set(docID, valuesIn.get(docID) - minValue);\n        }\n\n        final long finalMinValue = minValue;\n\n        return new NumericDocValues() {\n\n          @Override\n          public long get(int docID) {\n            return finalMinValue + values.get(docID);\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n        };\n      }\n      \n      @Override\n      public BinaryDocValues getBinary(FieldInfo field) throws IOException {\n        BinaryDocValues valuesIn = producer.getBinary(field);\n        final int maxDoc = valuesIn.size();\n        // nocommit more ram efficient\n        final byte[][] values = new byte[maxDoc][];\n        BytesRef scratch = new BytesRef();\n        for(int docID=0;docID<maxDoc;docID++) {\n          valuesIn.get(docID, scratch);\n          values[docID] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[docID], 0, scratch.length);\n        }\n\n        return new BinaryDocValues() {\n\n          @Override\n          public void get(int docID, BytesRef result) {\n            result.bytes = values[docID];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n        };\n      }\n\n      @Override\n      public SortedDocValues getSorted(FieldInfo field) throws IOException {\n        SortedDocValues valuesIn = producer.getSorted(field);\n        final int maxDoc = valuesIn.size();\n        final int valueCount = valuesIn.getValueCount();\n\n        // nocommit used packed ints and so on\n        final byte[][] values = new byte[valueCount][];\n        BytesRef scratch = new BytesRef();\n        for(int ord=0;ord<values.length;ord++) {\n          valuesIn.lookupOrd(ord, scratch);\n          values[ord] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[ord], 0, scratch.length);\n        }\n\n        final int[] docToOrd = new int[maxDoc];\n        for(int docID=0;docID<maxDoc;docID++) {\n          docToOrd[docID] = valuesIn.getOrd(docID);\n        }\n        return new SortedDocValues() {\n\n          @Override\n          public int getOrd(int docID) {\n            return docToOrd[docID];\n          }\n\n          @Override\n          public void lookupOrd(int ord, BytesRef result) {\n            result.bytes = values[ord];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int getValueCount() {\n            return valueCount;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n        };\n      }\n\n      @Override\n      public SimpleDVProducer clone() {\n        // We are already thread-safe:\n        return this;\n      }\n\n      @Override\n      public void close() throws IOException {\n        producer.close();\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"32608e0a08e76fe8668cd1dcca0e7a8f6d7f3f0a","date":1357739321,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat#fieldsProducer(SegmentReadState).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat#fieldsProducer(SegmentReadState).mjava","sourceNew":"  @Override\n  public SimpleDVProducer fieldsProducer(SegmentReadState state) throws IOException {\n    final int maxDoc = state.segmentInfo.getDocCount();\n    final SimpleDVProducer producer = new SimpleTextDocValuesReader(state, \"dat\");\n\n    return new SimpleDVProducer() {\n\n      @Override\n      public NumericDocValues getNumeric(FieldInfo field) throws IOException {\n        NumericDocValues valuesIn = producer.getNumeric(field);\n\n        long minValue = Long.MAX_VALUE;\n        long maxValue = Long.MIN_VALUE;\n        for(int docID=0;docID<maxDoc;docID++) {\n          long v = valuesIn.get(docID);\n          minValue = Math.min(minValue, v);\n          maxValue = Math.max(maxValue, v);\n        }\n\n        final long delta = maxValue - minValue;\n        final int bitsRequired = delta < 0 ? 64 : PackedInts.bitsRequired(delta);\n        final PackedInts.Mutable values = PackedInts.getMutable(maxDoc, bitsRequired, PackedInts.COMPACT);\n        for(int docID=0;docID<maxDoc;docID++) {\n          values.set(docID, valuesIn.get(docID) - minValue);\n        }\n\n        final long finalMinValue = minValue;\n\n        return new NumericDocValues() {\n\n          @Override\n          public long get(int docID) {\n            return finalMinValue + values.get(docID);\n          }\n        };\n      }\n      \n      @Override\n      public BinaryDocValues getBinary(FieldInfo field) throws IOException {\n        BinaryDocValues valuesIn = producer.getBinary(field);\n        // nocommit more ram efficient\n        final byte[][] values = new byte[maxDoc][];\n        BytesRef scratch = new BytesRef();\n        for(int docID=0;docID<maxDoc;docID++) {\n          valuesIn.get(docID, scratch);\n          values[docID] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[docID], 0, scratch.length);\n        }\n\n        return new BinaryDocValues() {\n\n          @Override\n          public void get(int docID, BytesRef result) {\n            result.bytes = values[docID];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n        };\n      }\n\n      @Override\n      public SortedDocValues getSorted(FieldInfo field) throws IOException {\n        SortedDocValues valuesIn = producer.getSorted(field);\n        final int valueCount = valuesIn.getValueCount();\n\n        // nocommit used packed ints and so on\n        final byte[][] values = new byte[valueCount][];\n        BytesRef scratch = new BytesRef();\n        for(int ord=0;ord<values.length;ord++) {\n          valuesIn.lookupOrd(ord, scratch);\n          values[ord] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[ord], 0, scratch.length);\n        }\n\n        final int[] docToOrd = new int[maxDoc];\n        for(int docID=0;docID<maxDoc;docID++) {\n          docToOrd[docID] = valuesIn.getOrd(docID);\n        }\n        return new SortedDocValues() {\n\n          @Override\n          public int getOrd(int docID) {\n            return docToOrd[docID];\n          }\n\n          @Override\n          public void lookupOrd(int ord, BytesRef result) {\n            result.bytes = values[ord];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int getValueCount() {\n            return valueCount;\n          }\n        };\n      }\n\n      @Override\n      public void close() throws IOException {\n        producer.close();\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public SimpleDVProducer fieldsProducer(SegmentReadState state) throws IOException {\n    final SimpleDVProducer producer = new SimpleTextDocValuesReader(state, \"dat\");\n\n    return new SimpleDVProducer() {\n\n      @Override\n      public NumericDocValues getNumeric(FieldInfo field) throws IOException {\n        NumericDocValues valuesIn = producer.getNumeric(field);\n\n        final int maxDoc = valuesIn.size();\n        long minValue = Long.MAX_VALUE;\n        long maxValue = Long.MIN_VALUE;\n        for(int docID=0;docID<maxDoc;docID++) {\n          long v = valuesIn.get(docID);\n          minValue = Math.min(minValue, v);\n          maxValue = Math.max(maxValue, v);\n        }\n\n        final long delta = maxValue - minValue;\n        final int bitsRequired = delta < 0 ? 64 : PackedInts.bitsRequired(delta);\n        final PackedInts.Mutable values = PackedInts.getMutable(maxDoc, bitsRequired, PackedInts.COMPACT);\n        for(int docID=0;docID<maxDoc;docID++) {\n          values.set(docID, valuesIn.get(docID) - minValue);\n        }\n\n        final long finalMinValue = minValue;\n\n        return new NumericDocValues() {\n\n          @Override\n          public long get(int docID) {\n            return finalMinValue + values.get(docID);\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n        };\n      }\n      \n      @Override\n      public BinaryDocValues getBinary(FieldInfo field) throws IOException {\n        BinaryDocValues valuesIn = producer.getBinary(field);\n        final int maxDoc = valuesIn.size();\n        // nocommit more ram efficient\n        final byte[][] values = new byte[maxDoc][];\n        BytesRef scratch = new BytesRef();\n        for(int docID=0;docID<maxDoc;docID++) {\n          valuesIn.get(docID, scratch);\n          values[docID] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[docID], 0, scratch.length);\n        }\n\n        return new BinaryDocValues() {\n\n          @Override\n          public void get(int docID, BytesRef result) {\n            result.bytes = values[docID];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n        };\n      }\n\n      @Override\n      public SortedDocValues getSorted(FieldInfo field) throws IOException {\n        SortedDocValues valuesIn = producer.getSorted(field);\n        final int maxDoc = valuesIn.size();\n        final int valueCount = valuesIn.getValueCount();\n\n        // nocommit used packed ints and so on\n        final byte[][] values = new byte[valueCount][];\n        BytesRef scratch = new BytesRef();\n        for(int ord=0;ord<values.length;ord++) {\n          valuesIn.lookupOrd(ord, scratch);\n          values[ord] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[ord], 0, scratch.length);\n        }\n\n        final int[] docToOrd = new int[maxDoc];\n        for(int docID=0;docID<maxDoc;docID++) {\n          docToOrd[docID] = valuesIn.getOrd(docID);\n        }\n        return new SortedDocValues() {\n\n          @Override\n          public int getOrd(int docID) {\n            return docToOrd[docID];\n          }\n\n          @Override\n          public void lookupOrd(int ord, BytesRef result) {\n            result.bytes = values[ord];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int getValueCount() {\n            return valueCount;\n          }\n\n          @Override\n          public int size() {\n            return maxDoc;\n          }\n        };\n      }\n\n      @Override\n      public void close() throws IOException {\n        producer.close();\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200","date":1358521790,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat#fieldsProducer(SegmentReadState).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat#fieldsProducer(SegmentReadState).mjava","sourceNew":"  @Override\n  public DocValuesProducer fieldsProducer(SegmentReadState state) throws IOException {\n    final int maxDoc = state.segmentInfo.getDocCount();\n    final DocValuesProducer producer = new SimpleTextDocValuesReader(state, \"dat\");\n\n    return new DocValuesProducer() {\n\n      @Override\n      public NumericDocValues getNumeric(FieldInfo field) throws IOException {\n        NumericDocValues valuesIn = producer.getNumeric(field);\n\n        long minValue = Long.MAX_VALUE;\n        long maxValue = Long.MIN_VALUE;\n        for(int docID=0;docID<maxDoc;docID++) {\n          long v = valuesIn.get(docID);\n          minValue = Math.min(minValue, v);\n          maxValue = Math.max(maxValue, v);\n        }\n\n        final long delta = maxValue - minValue;\n        final int bitsRequired = delta < 0 ? 64 : PackedInts.bitsRequired(delta);\n        final PackedInts.Mutable values = PackedInts.getMutable(maxDoc, bitsRequired, PackedInts.COMPACT);\n        for(int docID=0;docID<maxDoc;docID++) {\n          values.set(docID, valuesIn.get(docID) - minValue);\n        }\n\n        final long finalMinValue = minValue;\n\n        return new NumericDocValues() {\n\n          @Override\n          public long get(int docID) {\n            return finalMinValue + values.get(docID);\n          }\n        };\n      }\n      \n      @Override\n      public BinaryDocValues getBinary(FieldInfo field) throws IOException {\n        BinaryDocValues valuesIn = producer.getBinary(field);\n        // nocommit more ram efficient\n        final byte[][] values = new byte[maxDoc][];\n        BytesRef scratch = new BytesRef();\n        for(int docID=0;docID<maxDoc;docID++) {\n          valuesIn.get(docID, scratch);\n          values[docID] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[docID], 0, scratch.length);\n        }\n\n        return new BinaryDocValues() {\n\n          @Override\n          public void get(int docID, BytesRef result) {\n            result.bytes = values[docID];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n        };\n      }\n\n      @Override\n      public SortedDocValues getSorted(FieldInfo field) throws IOException {\n        SortedDocValues valuesIn = producer.getSorted(field);\n        final int valueCount = valuesIn.getValueCount();\n\n        // nocommit used packed ints and so on\n        final byte[][] values = new byte[valueCount][];\n        BytesRef scratch = new BytesRef();\n        for(int ord=0;ord<values.length;ord++) {\n          valuesIn.lookupOrd(ord, scratch);\n          values[ord] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[ord], 0, scratch.length);\n        }\n\n        final int[] docToOrd = new int[maxDoc];\n        for(int docID=0;docID<maxDoc;docID++) {\n          docToOrd[docID] = valuesIn.getOrd(docID);\n        }\n        return new SortedDocValues() {\n\n          @Override\n          public int getOrd(int docID) {\n            return docToOrd[docID];\n          }\n\n          @Override\n          public void lookupOrd(int ord, BytesRef result) {\n            result.bytes = values[ord];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int getValueCount() {\n            return valueCount;\n          }\n        };\n      }\n\n      @Override\n      public void close() throws IOException {\n        producer.close();\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public SimpleDVProducer fieldsProducer(SegmentReadState state) throws IOException {\n    final int maxDoc = state.segmentInfo.getDocCount();\n    final SimpleDVProducer producer = new SimpleTextDocValuesReader(state, \"dat\");\n\n    return new SimpleDVProducer() {\n\n      @Override\n      public NumericDocValues getNumeric(FieldInfo field) throws IOException {\n        NumericDocValues valuesIn = producer.getNumeric(field);\n\n        long minValue = Long.MAX_VALUE;\n        long maxValue = Long.MIN_VALUE;\n        for(int docID=0;docID<maxDoc;docID++) {\n          long v = valuesIn.get(docID);\n          minValue = Math.min(minValue, v);\n          maxValue = Math.max(maxValue, v);\n        }\n\n        final long delta = maxValue - minValue;\n        final int bitsRequired = delta < 0 ? 64 : PackedInts.bitsRequired(delta);\n        final PackedInts.Mutable values = PackedInts.getMutable(maxDoc, bitsRequired, PackedInts.COMPACT);\n        for(int docID=0;docID<maxDoc;docID++) {\n          values.set(docID, valuesIn.get(docID) - minValue);\n        }\n\n        final long finalMinValue = minValue;\n\n        return new NumericDocValues() {\n\n          @Override\n          public long get(int docID) {\n            return finalMinValue + values.get(docID);\n          }\n        };\n      }\n      \n      @Override\n      public BinaryDocValues getBinary(FieldInfo field) throws IOException {\n        BinaryDocValues valuesIn = producer.getBinary(field);\n        // nocommit more ram efficient\n        final byte[][] values = new byte[maxDoc][];\n        BytesRef scratch = new BytesRef();\n        for(int docID=0;docID<maxDoc;docID++) {\n          valuesIn.get(docID, scratch);\n          values[docID] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[docID], 0, scratch.length);\n        }\n\n        return new BinaryDocValues() {\n\n          @Override\n          public void get(int docID, BytesRef result) {\n            result.bytes = values[docID];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n        };\n      }\n\n      @Override\n      public SortedDocValues getSorted(FieldInfo field) throws IOException {\n        SortedDocValues valuesIn = producer.getSorted(field);\n        final int valueCount = valuesIn.getValueCount();\n\n        // nocommit used packed ints and so on\n        final byte[][] values = new byte[valueCount][];\n        BytesRef scratch = new BytesRef();\n        for(int ord=0;ord<values.length;ord++) {\n          valuesIn.lookupOrd(ord, scratch);\n          values[ord] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[ord], 0, scratch.length);\n        }\n\n        final int[] docToOrd = new int[maxDoc];\n        for(int docID=0;docID<maxDoc;docID++) {\n          docToOrd[docID] = valuesIn.getOrd(docID);\n        }\n        return new SortedDocValues() {\n\n          @Override\n          public int getOrd(int docID) {\n            return docToOrd[docID];\n          }\n\n          @Override\n          public void lookupOrd(int ord, BytesRef result) {\n            result.bytes = values[ord];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int getValueCount() {\n            return valueCount;\n          }\n        };\n      }\n\n      @Override\n      public void close() throws IOException {\n        producer.close();\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8f06b860886fc48ea071171354835b8aed8a94de","date":1358789970,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat#fieldsProducer(SegmentReadState).mjava","sourceNew":null,"sourceOld":"  @Override\n  public DocValuesProducer fieldsProducer(SegmentReadState state) throws IOException {\n    final int maxDoc = state.segmentInfo.getDocCount();\n    final DocValuesProducer producer = new SimpleTextDocValuesReader(state, \"dat\");\n\n    return new DocValuesProducer() {\n\n      @Override\n      public NumericDocValues getNumeric(FieldInfo field) throws IOException {\n        NumericDocValues valuesIn = producer.getNumeric(field);\n\n        long minValue = Long.MAX_VALUE;\n        long maxValue = Long.MIN_VALUE;\n        for(int docID=0;docID<maxDoc;docID++) {\n          long v = valuesIn.get(docID);\n          minValue = Math.min(minValue, v);\n          maxValue = Math.max(maxValue, v);\n        }\n\n        final long delta = maxValue - minValue;\n        final int bitsRequired = delta < 0 ? 64 : PackedInts.bitsRequired(delta);\n        final PackedInts.Mutable values = PackedInts.getMutable(maxDoc, bitsRequired, PackedInts.COMPACT);\n        for(int docID=0;docID<maxDoc;docID++) {\n          values.set(docID, valuesIn.get(docID) - minValue);\n        }\n\n        final long finalMinValue = minValue;\n\n        return new NumericDocValues() {\n\n          @Override\n          public long get(int docID) {\n            return finalMinValue + values.get(docID);\n          }\n        };\n      }\n      \n      @Override\n      public BinaryDocValues getBinary(FieldInfo field) throws IOException {\n        BinaryDocValues valuesIn = producer.getBinary(field);\n        // nocommit more ram efficient\n        final byte[][] values = new byte[maxDoc][];\n        BytesRef scratch = new BytesRef();\n        for(int docID=0;docID<maxDoc;docID++) {\n          valuesIn.get(docID, scratch);\n          values[docID] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[docID], 0, scratch.length);\n        }\n\n        return new BinaryDocValues() {\n\n          @Override\n          public void get(int docID, BytesRef result) {\n            result.bytes = values[docID];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n        };\n      }\n\n      @Override\n      public SortedDocValues getSorted(FieldInfo field) throws IOException {\n        SortedDocValues valuesIn = producer.getSorted(field);\n        final int valueCount = valuesIn.getValueCount();\n\n        // nocommit used packed ints and so on\n        final byte[][] values = new byte[valueCount][];\n        BytesRef scratch = new BytesRef();\n        for(int ord=0;ord<values.length;ord++) {\n          valuesIn.lookupOrd(ord, scratch);\n          values[ord] = new byte[scratch.length];\n          System.arraycopy(scratch.bytes, scratch.offset, values[ord], 0, scratch.length);\n        }\n\n        final int[] docToOrd = new int[maxDoc];\n        for(int docID=0;docID<maxDoc;docID++) {\n          docToOrd[docID] = valuesIn.getOrd(docID);\n        }\n        return new SortedDocValues() {\n\n          @Override\n          public int getOrd(int docID) {\n            return docToOrd[docID];\n          }\n\n          @Override\n          public void lookupOrd(int ord, BytesRef result) {\n            result.bytes = values[ord];\n            result.offset = 0;\n            result.length = result.bytes.length;\n          }\n\n          @Override\n          public int getValueCount() {\n            return valueCount;\n          }\n        };\n      }\n\n      @Override\n      public void close() throws IOException {\n        producer.close();\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e8550173e67bccdaad7c5cbb85fb81886fecfcb7","date":1376943063,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat#fieldsProducer(SegmentReadState).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public DocValuesProducer fieldsProducer(SegmentReadState state) throws IOException {\n    return new MemoryDocValuesProducer(state, DATA_CODEC, DATA_EXTENSION, METADATA_CODEC, METADATA_EXTENSION);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff","date":1377034255,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat#fieldsProducer(SegmentReadState).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public DocValuesProducer fieldsProducer(SegmentReadState state) throws IOException {\n    return new MemoryDocValuesProducer(state, DATA_CODEC, DATA_EXTENSION, METADATA_CODEC, METADATA_EXTENSION);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":0,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat#fieldsProducer(SegmentReadState).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public DocValuesProducer fieldsProducer(SegmentReadState state) throws IOException {\n    return new MemoryDocValuesProducer(state, DATA_CODEC, DATA_EXTENSION, METADATA_CODEC, METADATA_EXTENSION);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"24f89e8a6aac05753cde4c83d62a74356098200d","date":1525768331,"type":4,"author":"Dawid Weiss","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat#fieldsProducer(SegmentReadState).mjava","sourceNew":null,"sourceOld":"  @Override\n  public DocValuesProducer fieldsProducer(SegmentReadState state) throws IOException {\n    return new MemoryDocValuesProducer(state, DATA_CODEC, DATA_EXTENSION, METADATA_CODEC, METADATA_EXTENSION);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4ba81908bd58bd5079d89f3dafc90bce86fa08a6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"746e3645169db50c8f53252b30d6bc9ac21dea7c":["32fb848e256860b63adc9c2b068f386032c77b67"],"8f06b860886fc48ea071171354835b8aed8a94de":["b8acf0807ca5f38beda8e0f7d5ab46ff39f81200"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"2899ae5069a2533466ac842042478e67263e1f43":["4ba81908bd58bd5079d89f3dafc90bce86fa08a6"],"acef9ded108f8fefd1a6cf5d0642e198a1196f11":["2899ae5069a2533466ac842042478e67263e1f43"],"32fb848e256860b63adc9c2b068f386032c77b67":["ed00c8118962f490744732ab611c595c91b80d1c"],"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e8550173e67bccdaad7c5cbb85fb81886fecfcb7"],"e8550173e67bccdaad7c5cbb85fb81886fecfcb7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3e29774db46ad98ca4a8d7fcbfab633ebc01f358":["acef9ded108f8fefd1a6cf5d0642e198a1196f11"],"32608e0a08e76fe8668cd1dcca0e7a8f6d7f3f0a":["bb81b54e140a68aa997b4df84461c4fc54f6c999"],"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200":["32608e0a08e76fe8668cd1dcca0e7a8f6d7f3f0a"],"24f89e8a6aac05753cde4c83d62a74356098200d":["e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"ed00c8118962f490744732ab611c595c91b80d1c":["3e29774db46ad98ca4a8d7fcbfab633ebc01f358"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bb81b54e140a68aa997b4df84461c4fc54f6c999":["1ed9002c5afac843c7f2d04d88e74b40d627e1af"],"1ed9002c5afac843c7f2d04d88e74b40d627e1af":["746e3645169db50c8f53252b30d6bc9ac21dea7c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["24f89e8a6aac05753cde4c83d62a74356098200d"]},"commit2Childs":{"4ba81908bd58bd5079d89f3dafc90bce86fa08a6":["2899ae5069a2533466ac842042478e67263e1f43"],"746e3645169db50c8f53252b30d6bc9ac21dea7c":["1ed9002c5afac843c7f2d04d88e74b40d627e1af"],"8f06b860886fc48ea071171354835b8aed8a94de":[],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"2899ae5069a2533466ac842042478e67263e1f43":["acef9ded108f8fefd1a6cf5d0642e198a1196f11"],"acef9ded108f8fefd1a6cf5d0642e198a1196f11":["3e29774db46ad98ca4a8d7fcbfab633ebc01f358"],"32fb848e256860b63adc9c2b068f386032c77b67":["746e3645169db50c8f53252b30d6bc9ac21dea7c"],"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","24f89e8a6aac05753cde4c83d62a74356098200d"],"e8550173e67bccdaad7c5cbb85fb81886fecfcb7":["e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"3e29774db46ad98ca4a8d7fcbfab633ebc01f358":["ed00c8118962f490744732ab611c595c91b80d1c"],"32608e0a08e76fe8668cd1dcca0e7a8f6d7f3f0a":["b8acf0807ca5f38beda8e0f7d5ab46ff39f81200"],"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200":["8f06b860886fc48ea071171354835b8aed8a94de"],"ed00c8118962f490744732ab611c595c91b80d1c":["32fb848e256860b63adc9c2b068f386032c77b67"],"24f89e8a6aac05753cde4c83d62a74356098200d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4ba81908bd58bd5079d89f3dafc90bce86fa08a6","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff","e8550173e67bccdaad7c5cbb85fb81886fecfcb7"],"bb81b54e140a68aa997b4df84461c4fc54f6c999":["32608e0a08e76fe8668cd1dcca0e7a8f6d7f3f0a"],"1ed9002c5afac843c7f2d04d88e74b40d627e1af":["bb81b54e140a68aa997b4df84461c4fc54f6c999"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8f06b860886fc48ea071171354835b8aed8a94de","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}