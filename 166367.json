{"path":"lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain#writeNorms(SegmentWriteState).mjava","commits":[{"id":"52c7e49be259508735752fba88085255014a6ecf","date":1398706273,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain#writeNorms(SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/NormsConsumer#flush(Map[String,InvertedDocEndConsumerPerField],SegmentWriteState).mjava","sourceNew":"  private void writeNorms(SegmentWriteState state) throws IOException {\n    boolean success = false;\n    DocValuesConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        NormsFormat normsFormat = state.segmentInfo.getCodec().normsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          PerField perField = getPerField(fi.name);\n          assert perField != null;\n\n          // we must check the final value of omitNorms for the fieldinfo: it could have \n          // changed for this field since the first time we added it.\n          if (fi.omitsNorms() == false) {\n            if (perField.norms != null) {\n              perField.norms.finish(state.segmentInfo.getDocCount());\n              perField.norms.flush(state, normsConsumer);\n              assert fi.getNormType() == DocValuesType.NUMERIC;\n            } else if (fi.isIndexed()) {\n              assert fi.getNormType() == null: \"got \" + fi.getNormType() + \"; field=\" + fi.name;\n            }\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void flush(Map<String,InvertedDocEndConsumerPerField> fieldsToFlush, SegmentWriteState state) throws IOException {\n    boolean success = false;\n    DocValuesConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        NormsFormat normsFormat = state.segmentInfo.getCodec().normsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          final NormsConsumerPerField toWrite = (NormsConsumerPerField) fieldsToFlush.get(fi.name);\n          // we must check the final value of omitNorms for the fieldinfo, it could have \n          // changed for this field since the first time we added it.\n          if (!fi.omitsNorms()) {\n            if (toWrite != null && !toWrite.isEmpty()) {\n              toWrite.flush(state, normsConsumer);\n              assert fi.getNormType() == DocValuesType.NUMERIC;\n            } else if (fi.isIndexed()) {\n              assert fi.getNormType() == null: \"got \" + fi.getNormType() + \"; field=\" + fi.name;\n            }\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3394716f52b34ab259ad5247e7595d9f9db6e935","date":1398791921,"type":1,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain#writeNorms(SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/NormsConsumer#flush(Map[String,InvertedDocEndConsumerPerField],SegmentWriteState).mjava","sourceNew":"  private void writeNorms(SegmentWriteState state) throws IOException {\n    boolean success = false;\n    DocValuesConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        NormsFormat normsFormat = state.segmentInfo.getCodec().normsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          PerField perField = getPerField(fi.name);\n          assert perField != null;\n\n          // we must check the final value of omitNorms for the fieldinfo: it could have \n          // changed for this field since the first time we added it.\n          if (fi.omitsNorms() == false) {\n            if (perField.norms != null) {\n              perField.norms.finish(state.segmentInfo.getDocCount());\n              perField.norms.flush(state, normsConsumer);\n              assert fi.getNormType() == DocValuesType.NUMERIC;\n            } else if (fi.isIndexed()) {\n              assert fi.getNormType() == null: \"got \" + fi.getNormType() + \"; field=\" + fi.name;\n            }\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void flush(Map<String,InvertedDocEndConsumerPerField> fieldsToFlush, SegmentWriteState state) throws IOException {\n    boolean success = false;\n    DocValuesConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        NormsFormat normsFormat = state.segmentInfo.getCodec().normsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          final NormsConsumerPerField toWrite = (NormsConsumerPerField) fieldsToFlush.get(fi.name);\n          // we must check the final value of omitNorms for the fieldinfo, it could have \n          // changed for this field since the first time we added it.\n          if (!fi.omitsNorms()) {\n            if (toWrite != null && !toWrite.isEmpty()) {\n              toWrite.flush(state, normsConsumer);\n              assert fi.getNormType() == DocValuesType.NUMERIC;\n            } else if (fi.isIndexed()) {\n              assert fi.getNormType() == null: \"got \" + fi.getNormType() + \"; field=\" + fi.name;\n            }\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","date":1398844771,"type":1,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain#writeNorms(SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/NormsConsumer#flush(Map[String,InvertedDocEndConsumerPerField],SegmentWriteState).mjava","sourceNew":"  private void writeNorms(SegmentWriteState state) throws IOException {\n    boolean success = false;\n    DocValuesConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        NormsFormat normsFormat = state.segmentInfo.getCodec().normsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          PerField perField = getPerField(fi.name);\n          assert perField != null;\n\n          // we must check the final value of omitNorms for the fieldinfo: it could have \n          // changed for this field since the first time we added it.\n          if (fi.omitsNorms() == false) {\n            if (perField.norms != null) {\n              perField.norms.finish(state.segmentInfo.getDocCount());\n              perField.norms.flush(state, normsConsumer);\n              assert fi.getNormType() == DocValuesType.NUMERIC;\n            } else if (fi.isIndexed()) {\n              assert fi.getNormType() == null: \"got \" + fi.getNormType() + \"; field=\" + fi.name;\n            }\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void flush(Map<String,InvertedDocEndConsumerPerField> fieldsToFlush, SegmentWriteState state) throws IOException {\n    boolean success = false;\n    DocValuesConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        NormsFormat normsFormat = state.segmentInfo.getCodec().normsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          final NormsConsumerPerField toWrite = (NormsConsumerPerField) fieldsToFlush.get(fi.name);\n          // we must check the final value of omitNorms for the fieldinfo, it could have \n          // changed for this field since the first time we added it.\n          if (!fi.omitsNorms()) {\n            if (toWrite != null && !toWrite.isEmpty()) {\n              toWrite.flush(state, normsConsumer);\n              assert fi.getNormType() == DocValuesType.NUMERIC;\n            } else if (fi.isIndexed()) {\n              assert fi.getNormType() == null: \"got \" + fi.getNormType() + \"; field=\" + fi.name;\n            }\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"22a2e66dfda83847e80095b8693c660742ab3e9c","date":1408628796,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain#writeNorms(SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain#writeNorms(SegmentWriteState).mjava","sourceNew":"  private void writeNorms(SegmentWriteState state) throws IOException {\n    boolean success = false;\n    NormsConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        NormsFormat normsFormat = state.segmentInfo.getCodec().normsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          PerField perField = getPerField(fi.name);\n          assert perField != null;\n\n          // we must check the final value of omitNorms for the fieldinfo: it could have \n          // changed for this field since the first time we added it.\n          if (fi.omitsNorms() == false) {\n            if (perField.norms != null) {\n              perField.norms.finish(state.segmentInfo.getDocCount());\n              perField.norms.flush(state, normsConsumer);\n              assert fi.getNormType() == DocValuesType.NUMERIC;\n            } else if (fi.isIndexed()) {\n              assert fi.getNormType() == null: \"got \" + fi.getNormType() + \"; field=\" + fi.name;\n            }\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","sourceOld":"  private void writeNorms(SegmentWriteState state) throws IOException {\n    boolean success = false;\n    DocValuesConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        NormsFormat normsFormat = state.segmentInfo.getCodec().normsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          PerField perField = getPerField(fi.name);\n          assert perField != null;\n\n          // we must check the final value of omitNorms for the fieldinfo: it could have \n          // changed for this field since the first time we added it.\n          if (fi.omitsNorms() == false) {\n            if (perField.norms != null) {\n              perField.norms.finish(state.segmentInfo.getDocCount());\n              perField.norms.flush(state, normsConsumer);\n              assert fi.getNormType() == DocValuesType.NUMERIC;\n            } else if (fi.isIndexed()) {\n              assert fi.getNormType() == null: \"got \" + fi.getNormType() + \"; field=\" + fi.name;\n            }\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"05da2d758a6089e737cdfc230e57a51b472b94b6","date":1413392310,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain#writeNorms(SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain#writeNorms(SegmentWriteState).mjava","sourceNew":"  private void writeNorms(SegmentWriteState state) throws IOException {\n    boolean success = false;\n    NormsConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        NormsFormat normsFormat = state.segmentInfo.getCodec().normsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          PerField perField = getPerField(fi.name);\n          assert perField != null;\n\n          // we must check the final value of omitNorms for the fieldinfo: it could have \n          // changed for this field since the first time we added it.\n          if (fi.omitsNorms() == false && fi.isIndexed()) {\n            assert perField.norms != null: \"field=\" + fi.name;\n            perField.norms.finish(state.segmentInfo.getDocCount());\n            perField.norms.flush(state, normsConsumer);\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","sourceOld":"  private void writeNorms(SegmentWriteState state) throws IOException {\n    boolean success = false;\n    NormsConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        NormsFormat normsFormat = state.segmentInfo.getCodec().normsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          PerField perField = getPerField(fi.name);\n          assert perField != null;\n\n          // we must check the final value of omitNorms for the fieldinfo: it could have \n          // changed for this field since the first time we added it.\n          if (fi.omitsNorms() == false) {\n            if (perField.norms != null) {\n              perField.norms.finish(state.segmentInfo.getDocCount());\n              perField.norms.flush(state, normsConsumer);\n              assert fi.getNormType() == DocValuesType.NUMERIC;\n            } else if (fi.isIndexed()) {\n              assert fi.getNormType() == null: \"got \" + fi.getNormType() + \"; field=\" + fi.name;\n            }\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84","date":1413458798,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain#writeNorms(SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain#writeNorms(SegmentWriteState).mjava","sourceNew":"  private void writeNorms(SegmentWriteState state) throws IOException {\n    boolean success = false;\n    NormsConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        NormsFormat normsFormat = state.segmentInfo.getCodec().normsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          PerField perField = getPerField(fi.name);\n          assert perField != null;\n\n          // we must check the final value of omitNorms for the fieldinfo: it could have \n          // changed for this field since the first time we added it.\n          if (fi.omitsNorms() == false && fi.isIndexed()) {\n            assert perField.norms != null: \"field=\" + fi.name;\n            perField.norms.finish(state.segmentInfo.getDocCount());\n            perField.norms.flush(state, normsConsumer);\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","sourceOld":"  private void writeNorms(SegmentWriteState state) throws IOException {\n    boolean success = false;\n    NormsConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        NormsFormat normsFormat = state.segmentInfo.getCodec().normsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          PerField perField = getPerField(fi.name);\n          assert perField != null;\n\n          // we must check the final value of omitNorms for the fieldinfo: it could have \n          // changed for this field since the first time we added it.\n          if (fi.omitsNorms() == false) {\n            if (perField.norms != null) {\n              perField.norms.finish(state.segmentInfo.getDocCount());\n              perField.norms.flush(state, normsConsumer);\n              assert fi.getNormType() == DocValuesType.NUMERIC;\n            } else if (fi.isIndexed()) {\n              assert fi.getNormType() == null: \"got \" + fi.getNormType() + \"; field=\" + fi.name;\n            }\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"556a4aab886d75371b2af129d87be3c2795cea76","date":1414954991,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain#writeNorms(SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain#writeNorms(SegmentWriteState).mjava","sourceNew":"  private void writeNorms(SegmentWriteState state) throws IOException {\n    boolean success = false;\n    NormsConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        NormsFormat normsFormat = state.segmentInfo.getCodec().normsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          PerField perField = getPerField(fi.name);\n          assert perField != null;\n\n          // we must check the final value of omitNorms for the fieldinfo: it could have \n          // changed for this field since the first time we added it.\n          if (fi.omitsNorms() == false && fi.getIndexOptions() != IndexOptions.NONE) {\n            assert perField.norms != null: \"field=\" + fi.name;\n            perField.norms.finish(state.segmentInfo.getDocCount());\n            perField.norms.flush(state, normsConsumer);\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","sourceOld":"  private void writeNorms(SegmentWriteState state) throws IOException {\n    boolean success = false;\n    NormsConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        NormsFormat normsFormat = state.segmentInfo.getCodec().normsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          PerField perField = getPerField(fi.name);\n          assert perField != null;\n\n          // we must check the final value of omitNorms for the fieldinfo: it could have \n          // changed for this field since the first time we added it.\n          if (fi.omitsNorms() == false && fi.isIndexed()) {\n            assert perField.norms != null: \"field=\" + fi.name;\n            perField.norms.finish(state.segmentInfo.getDocCount());\n            perField.norms.flush(state, normsConsumer);\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0267c69e2456a3477a1ad785723f2135da3117e","date":1425317087,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain#writeNorms(SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain#writeNorms(SegmentWriteState).mjava","sourceNew":"  private void writeNorms(SegmentWriteState state) throws IOException {\n    boolean success = false;\n    NormsConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        NormsFormat normsFormat = state.segmentInfo.getCodec().normsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          PerField perField = getPerField(fi.name);\n          assert perField != null;\n\n          // we must check the final value of omitNorms for the fieldinfo: it could have \n          // changed for this field since the first time we added it.\n          if (fi.omitsNorms() == false && fi.getIndexOptions() != IndexOptions.NONE) {\n            assert perField.norms != null: \"field=\" + fi.name;\n            perField.norms.finish(state.segmentInfo.maxDoc());\n            perField.norms.flush(state, normsConsumer);\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","sourceOld":"  private void writeNorms(SegmentWriteState state) throws IOException {\n    boolean success = false;\n    NormsConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        NormsFormat normsFormat = state.segmentInfo.getCodec().normsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          PerField perField = getPerField(fi.name);\n          assert perField != null;\n\n          // we must check the final value of omitNorms for the fieldinfo: it could have \n          // changed for this field since the first time we added it.\n          if (fi.omitsNorms() == false && fi.getIndexOptions() != IndexOptions.NONE) {\n            assert perField.norms != null: \"field=\" + fi.name;\n            perField.norms.finish(state.segmentInfo.getDocCount());\n            perField.norms.flush(state, normsConsumer);\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b06445ae1731e049327712db0454e5643ca9b7fe","date":1425329139,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain#writeNorms(SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain#writeNorms(SegmentWriteState).mjava","sourceNew":"  private void writeNorms(SegmentWriteState state) throws IOException {\n    boolean success = false;\n    NormsConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        NormsFormat normsFormat = state.segmentInfo.getCodec().normsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          PerField perField = getPerField(fi.name);\n          assert perField != null;\n\n          // we must check the final value of omitNorms for the fieldinfo: it could have \n          // changed for this field since the first time we added it.\n          if (fi.omitsNorms() == false && fi.getIndexOptions() != IndexOptions.NONE) {\n            assert perField.norms != null: \"field=\" + fi.name;\n            perField.norms.finish(state.segmentInfo.maxDoc());\n            perField.norms.flush(state, normsConsumer);\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","sourceOld":"  private void writeNorms(SegmentWriteState state) throws IOException {\n    boolean success = false;\n    NormsConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        NormsFormat normsFormat = state.segmentInfo.getCodec().normsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          PerField perField = getPerField(fi.name);\n          assert perField != null;\n\n          // we must check the final value of omitNorms for the fieldinfo: it could have \n          // changed for this field since the first time we added it.\n          if (fi.omitsNorms() == false && fi.getIndexOptions() != IndexOptions.NONE) {\n            assert perField.norms != null: \"field=\" + fi.name;\n            perField.norms.finish(state.segmentInfo.getDocCount());\n            perField.norms.flush(state, normsConsumer);\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain#writeNorms(SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain#writeNorms(SegmentWriteState).mjava","sourceNew":"  private void writeNorms(SegmentWriteState state) throws IOException {\n    boolean success = false;\n    NormsConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        NormsFormat normsFormat = state.segmentInfo.getCodec().normsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          PerField perField = getPerField(fi.name);\n          assert perField != null;\n\n          // we must check the final value of omitNorms for the fieldinfo: it could have \n          // changed for this field since the first time we added it.\n          if (fi.omitsNorms() == false && fi.getIndexOptions() != IndexOptions.NONE) {\n            assert perField.norms != null: \"field=\" + fi.name;\n            perField.norms.finish(state.segmentInfo.maxDoc());\n            perField.norms.flush(state, normsConsumer);\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","sourceOld":"  private void writeNorms(SegmentWriteState state) throws IOException {\n    boolean success = false;\n    NormsConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        NormsFormat normsFormat = state.segmentInfo.getCodec().normsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          PerField perField = getPerField(fi.name);\n          assert perField != null;\n\n          // we must check the final value of omitNorms for the fieldinfo: it could have \n          // changed for this field since the first time we added it.\n          if (fi.omitsNorms() == false && fi.getIndexOptions() != IndexOptions.NONE) {\n            assert perField.norms != null: \"field=\" + fi.name;\n            perField.norms.finish(state.segmentInfo.getDocCount());\n            perField.norms.flush(state, normsConsumer);\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86a0a50d2d14aaee1e635bbec914468551f7f9a2","date":1482234306,"type":5,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain#writeNorms(SegmentWriteState,Sorter.DocMap).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain#writeNorms(SegmentWriteState).mjava","sourceNew":"  private void writeNorms(SegmentWriteState state, Sorter.DocMap sortMap) throws IOException {\n    boolean success = false;\n    NormsConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        NormsFormat normsFormat = state.segmentInfo.getCodec().normsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          PerField perField = getPerField(fi.name);\n          assert perField != null;\n\n          // we must check the final value of omitNorms for the fieldinfo: it could have \n          // changed for this field since the first time we added it.\n          if (fi.omitsNorms() == false && fi.getIndexOptions() != IndexOptions.NONE) {\n            assert perField.norms != null: \"field=\" + fi.name;\n            perField.norms.finish(state.segmentInfo.maxDoc());\n            perField.norms.flush(state, sortMap, normsConsumer);\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","sourceOld":"  private void writeNorms(SegmentWriteState state) throws IOException {\n    boolean success = false;\n    NormsConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        NormsFormat normsFormat = state.segmentInfo.getCodec().normsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          PerField perField = getPerField(fi.name);\n          assert perField != null;\n\n          // we must check the final value of omitNorms for the fieldinfo: it could have \n          // changed for this field since the first time we added it.\n          if (fi.omitsNorms() == false && fi.getIndexOptions() != IndexOptions.NONE) {\n            assert perField.norms != null: \"field=\" + fi.name;\n            perField.norms.finish(state.segmentInfo.maxDoc());\n            perField.norms.flush(state, normsConsumer);\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","date":1482251961,"type":4,"author":"Kevin Risden","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain#writeNorms(SegmentWriteState).mjava","sourceNew":null,"sourceOld":"  private void writeNorms(SegmentWriteState state) throws IOException {\n    boolean success = false;\n    NormsConsumer normsConsumer = null;\n    try {\n      if (state.fieldInfos.hasNorms()) {\n        NormsFormat normsFormat = state.segmentInfo.getCodec().normsFormat();\n        assert normsFormat != null;\n        normsConsumer = normsFormat.normsConsumer(state);\n\n        for (FieldInfo fi : state.fieldInfos) {\n          PerField perField = getPerField(fi.name);\n          assert perField != null;\n\n          // we must check the final value of omitNorms for the fieldinfo: it could have \n          // changed for this field since the first time we added it.\n          if (fi.omitsNorms() == false && fi.getIndexOptions() != IndexOptions.NONE) {\n            assert perField.norms != null: \"field=\" + fi.name;\n            perField.norms.finish(state.segmentInfo.maxDoc());\n            perField.norms.flush(state, normsConsumer);\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(normsConsumer);\n      } else {\n        IOUtils.closeWhileHandlingException(normsConsumer);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"05da2d758a6089e737cdfc230e57a51b472b94b6":["22a2e66dfda83847e80095b8693c660742ab3e9c"],"c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84":["22a2e66dfda83847e80095b8693c660742ab3e9c","05da2d758a6089e737cdfc230e57a51b472b94b6"],"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3394716f52b34ab259ad5247e7595d9f9db6e935"],"b0267c69e2456a3477a1ad785723f2135da3117e":["556a4aab886d75371b2af129d87be3c2795cea76"],"556a4aab886d75371b2af129d87be3c2795cea76":["05da2d758a6089e737cdfc230e57a51b472b94b6"],"3394716f52b34ab259ad5247e7595d9f9db6e935":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","52c7e49be259508735752fba88085255014a6ecf"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["556a4aab886d75371b2af129d87be3c2795cea76","b0267c69e2456a3477a1ad785723f2135da3117e"],"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf":["b0267c69e2456a3477a1ad785723f2135da3117e","86a0a50d2d14aaee1e635bbec914468551f7f9a2"],"b06445ae1731e049327712db0454e5643ca9b7fe":["556a4aab886d75371b2af129d87be3c2795cea76","b0267c69e2456a3477a1ad785723f2135da3117e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"22a2e66dfda83847e80095b8693c660742ab3e9c":["3394716f52b34ab259ad5247e7595d9f9db6e935"],"86a0a50d2d14aaee1e635bbec914468551f7f9a2":["b0267c69e2456a3477a1ad785723f2135da3117e"],"52c7e49be259508735752fba88085255014a6ecf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["86a0a50d2d14aaee1e635bbec914468551f7f9a2"]},"commit2Childs":{"05da2d758a6089e737cdfc230e57a51b472b94b6":["c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84","556a4aab886d75371b2af129d87be3c2795cea76"],"c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84":[],"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":[],"b0267c69e2456a3477a1ad785723f2135da3117e":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","b06445ae1731e049327712db0454e5643ca9b7fe","86a0a50d2d14aaee1e635bbec914468551f7f9a2"],"556a4aab886d75371b2af129d87be3c2795cea76":["b0267c69e2456a3477a1ad785723f2135da3117e","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe"],"3394716f52b34ab259ad5247e7595d9f9db6e935":["c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","22a2e66dfda83847e80095b8693c660742ab3e9c"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf":[],"b06445ae1731e049327712db0454e5643ca9b7fe":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","3394716f52b34ab259ad5247e7595d9f9db6e935","52c7e49be259508735752fba88085255014a6ecf"],"22a2e66dfda83847e80095b8693c660742ab3e9c":["05da2d758a6089e737cdfc230e57a51b472b94b6","c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84"],"52c7e49be259508735752fba88085255014a6ecf":["3394716f52b34ab259ad5247e7595d9f9db6e935"],"86a0a50d2d14aaee1e635bbec914468551f7f9a2":["5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84","c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","b06445ae1731e049327712db0454e5643ca9b7fe","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}