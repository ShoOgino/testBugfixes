{"path":"solr/core/src/java/org/apache/solr/core/LibListener.ExtHandler#updateReqHandlers(Map[String,Object],boolean).mjava","commits":[{"id":"fb50877dc038c021eba3a70999fd1f6ed85001c1","date":1563596432,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/LibListener.ExtHandler#updateReqHandlers(Map[String,Object],boolean).mjava","pathOld":"/dev/null","sourceNew":"    private void updateReqHandlers(Map<String, Object> properties, boolean forceReload) {\n      Map m = (Map) properties.getOrDefault(SolrRequestHandler.TYPE, Collections.emptyMap());\n      if (m.isEmpty() && customHandlers.isEmpty()) return;\n      boolean hasChanged = true;\n      if (customHandlers.size() == m.size() && customHandlers.keySet().containsAll(m.keySet())) hasChanged = false;\n      if (forceReload || hasChanged) {\n        log.debug(\"RequestHandlers being reloaded : {}\", m.keySet());\n        Map<String, SolrRequestHandler> newCustomHandlers = new HashMap<>();\n        m.forEach((k, v) -> {\n          if (v instanceof Map) {\n            String klas = (String) ((Map) v).get(FieldType.CLASS_NAME);\n            if (klas != null) {\n              SolrRequestHandler inst = libListener.newInstance(klas, SolrRequestHandler.class);\n              if (inst instanceof PluginInfoInitialized) {\n                ((PluginInfoInitialized) inst).init(new PluginInfo(SolrRequestHandler.TYPE, (Map) v));\n              }\n              newCustomHandlers.put((String) k, inst);\n            }\n          } else {\n            log.error(\"Invalid data for requestHandler : {} , {}\", k, v);\n          }\n        });\n\n        log.debug(\"Registering request handlers {} \", newCustomHandlers.keySet());\n        Map<String, SolrRequestHandler> old = customHandlers;\n        customHandlers = newCustomHandlers;\n        old.forEach((s, h) -> PluginBag.closeQuietly(h));\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"39dabfd19b49b248d63cedbb01ea144ee5ad071c","date":1566241238,"type":5,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/PackageManager.ExtHandler#updateReqHandlers(Map[String,Object],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/LibListener.ExtHandler#updateReqHandlers(Map[String,Object],boolean).mjava","sourceNew":"    private void updateReqHandlers(Map<String, Object> properties, boolean forceReload) {\n      Map m = (Map) properties.getOrDefault(SolrRequestHandler.TYPE, Collections.emptyMap());\n      if (m.isEmpty() && customHandlers.isEmpty()) return;\n      boolean hasChanged = true;\n      if (customHandlers.size() == m.size() && customHandlers.keySet().containsAll(m.keySet())) hasChanged = false;\n      if (forceReload || hasChanged) {\n        log.debug(\"RequestHandlers being reloaded : {}\", m.keySet());\n        Map<String, Handler> newCustomHandlers = new HashMap<>();\n        m.forEach((k, v) -> {\n          if (v instanceof Map) {\n            Map metaData = (Map) v;\n            Handler existing = customHandlers.get(k);\n            String name = (String) k;\n            if (existing == null || existing.shouldReload(metaData, packageManager.pkgs)) {\n              String klas = (String) metaData.get(FieldType.CLASS_NAME);\n              if (klas != null) {\n                String pkg = (String) metaData.get(PACKAGE);\n                SolrRequestHandler inst = packageManager.newInstance(klas, SolrRequestHandler.class, pkg);\n                if (inst instanceof PluginInfoInitialized) {\n                  ((PluginInfoInitialized) inst).init(new PluginInfo(SolrRequestHandler.TYPE, metaData));\n                }\n                Package p = packageManager.pkgs.get(pkg);\n                newCustomHandlers.put(name, new Handler(inst, pkg, p == null ? -1 : p.lib.getZnodeVersion(), metaData, name));\n              } else {\n                log.error(\"Invalid requestHandler {}\", Utils.toJSONString(v));\n              }\n\n            } else {\n              newCustomHandlers.put(name, existing);\n            }\n\n          } else {\n            log.error(\"Invalid data for requestHandler : {} , {}\", k, v);\n          }\n        });\n\n        log.debug(\"Registering request handlers {} \", newCustomHandlers.keySet());\n        Map<String, Handler> old = customHandlers;\n        customHandlers = newCustomHandlers;\n        old.forEach((s, h) -> PluginBag.closeQuietly(h));\n      }\n    }\n\n","sourceOld":"    private void updateReqHandlers(Map<String, Object> properties, boolean forceReload) {\n      Map m = (Map) properties.getOrDefault(SolrRequestHandler.TYPE, Collections.emptyMap());\n      if (m.isEmpty() && customHandlers.isEmpty()) return;\n      boolean hasChanged = true;\n      if (customHandlers.size() == m.size() && customHandlers.keySet().containsAll(m.keySet())) hasChanged = false;\n      if (forceReload || hasChanged) {\n        log.debug(\"RequestHandlers being reloaded : {}\", m.keySet());\n        Map<String, SolrRequestHandler> newCustomHandlers = new HashMap<>();\n        m.forEach((k, v) -> {\n          if (v instanceof Map) {\n            String klas = (String) ((Map) v).get(FieldType.CLASS_NAME);\n            if (klas != null) {\n              SolrRequestHandler inst = libListener.newInstance(klas, SolrRequestHandler.class);\n              if (inst instanceof PluginInfoInitialized) {\n                ((PluginInfoInitialized) inst).init(new PluginInfo(SolrRequestHandler.TYPE, (Map) v));\n              }\n              newCustomHandlers.put((String) k, inst);\n            }\n          } else {\n            log.error(\"Invalid data for requestHandler : {} , {}\", k, v);\n          }\n        });\n\n        log.debug(\"Registering request handlers {} \", newCustomHandlers.keySet());\n        Map<String, SolrRequestHandler> old = customHandlers;\n        customHandlers = newCustomHandlers;\n        old.forEach((s, h) -> PluginBag.closeQuietly(h));\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"39dabfd19b49b248d63cedbb01ea144ee5ad071c":["fb50877dc038c021eba3a70999fd1f6ed85001c1"],"fb50877dc038c021eba3a70999fd1f6ed85001c1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["39dabfd19b49b248d63cedbb01ea144ee5ad071c"]},"commit2Childs":{"39dabfd19b49b248d63cedbb01ea144ee5ad071c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fb50877dc038c021eba3a70999fd1f6ed85001c1":["39dabfd19b49b248d63cedbb01ea144ee5ad071c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fb50877dc038c021eba3a70999fd1f6ed85001c1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}