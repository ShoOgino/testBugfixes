{"path":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#shallowCopy(boolean).mjava","commits":[{"id":"08970e5b8411182a29412c177eff67ec1110095b","date":1366640815,"type":0,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#shallowCopy(boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Makes a shallow copy of this schema.\n   * \n   * Not copied: analyzers \n   * \n   * @param includeFieldDataStructures if true, fields, fieldsWithDefaultValue, and requiredFields\n   *                                   are copied; otherwise, they are not.\n   * @return A shallow copy of this schema\n   */\n  private ManagedIndexSchema shallowCopy(boolean includeFieldDataStructures) {\n    ManagedIndexSchema newSchema = null;\n    try {\n      newSchema = new ManagedIndexSchema\n          (solrConfig, loader, isMutable, managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    assert newSchema != null;\n    \n    newSchema.name = name;\n    newSchema.version = version;\n    newSchema.defaultSearchFieldName = defaultSearchFieldName;\n    newSchema.queryParserDefaultOperator = queryParserDefaultOperator;\n    newSchema.isExplicitQueryParserDefaultOperator = isExplicitQueryParserDefaultOperator;\n    newSchema.similarity = similarity;\n    newSchema.similarityFactory = similarityFactory;\n    newSchema.isExplicitSimilarity = isExplicitSimilarity;\n    newSchema.uniqueKeyField = uniqueKeyField;\n\n    if (includeFieldDataStructures) {\n      // These need new collections, since addFields() can add members to them\n      newSchema.fields.putAll(fields);\n      newSchema.fieldsWithDefaultValue.addAll(fieldsWithDefaultValue);\n      newSchema.requiredFields.addAll(requiredFields);\n    }\n\n    // These don't need new collections - addFields() won't add members to them \n    newSchema.fieldTypes = fieldTypes;\n    newSchema.dynamicFields = dynamicFields;\n    newSchema.dynamicCopyFields = dynamicCopyFields;\n    newSchema.copyFieldsMap = copyFieldsMap;\n    newSchema.copyFieldTargetCounts = copyFieldTargetCounts;\n    newSchema.schemaAware = schemaAware;\n\n    return newSchema;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["df151630bfbea5338a007b97bfd37e4ec94f873f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5a7624bc6b738f100f63bb9902e91a84dd67d86f","date":1372889271,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#shallowCopy(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#shallowCopy(boolean).mjava","sourceNew":"  /**\n   * Makes a shallow copy of this schema.\n   * \n   * Not copied: analyzers \n   * \n   * @param includeFieldDataStructures if true, fields, fieldsWithDefaultValue, and requiredFields\n   *                                   are copied; otherwise, they are not.\n   * @return A shallow copy of this schema\n   */\n  private ManagedIndexSchema shallowCopy(boolean includeFieldDataStructures) {\n    ManagedIndexSchema newSchema = null;\n    try {\n      newSchema = new ManagedIndexSchema\n          (solrConfig, loader, isMutable, managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    assert newSchema != null;\n    \n    newSchema.name = name;\n    newSchema.version = version;\n    newSchema.defaultSearchFieldName = defaultSearchFieldName;\n    newSchema.queryParserDefaultOperator = queryParserDefaultOperator;\n    newSchema.isExplicitQueryParserDefaultOperator = isExplicitQueryParserDefaultOperator;\n    newSchema.similarity = similarity;\n    newSchema.similarityFactory = similarityFactory;\n    newSchema.isExplicitSimilarity = isExplicitSimilarity;\n    newSchema.uniqueKeyField = uniqueKeyField;\n    newSchema.uniqueKeyFieldName = uniqueKeyFieldName;\n    newSchema.uniqueKeyFieldType = uniqueKeyFieldType;\n\n    if (includeFieldDataStructures) {\n      // These need new collections, since addFields() can add members to them\n      newSchema.fields.putAll(fields);\n      newSchema.fieldsWithDefaultValue.addAll(fieldsWithDefaultValue);\n      newSchema.requiredFields.addAll(requiredFields);\n    }\n\n    // These don't need new collections - addFields() won't add members to them \n    newSchema.fieldTypes = fieldTypes;\n    newSchema.dynamicFields = dynamicFields;\n    newSchema.dynamicCopyFields = dynamicCopyFields;\n    newSchema.copyFieldsMap = copyFieldsMap;\n    newSchema.copyFieldTargetCounts = copyFieldTargetCounts;\n    newSchema.schemaAware = schemaAware;\n\n    return newSchema;\n  }\n\n","sourceOld":"  /**\n   * Makes a shallow copy of this schema.\n   * \n   * Not copied: analyzers \n   * \n   * @param includeFieldDataStructures if true, fields, fieldsWithDefaultValue, and requiredFields\n   *                                   are copied; otherwise, they are not.\n   * @return A shallow copy of this schema\n   */\n  private ManagedIndexSchema shallowCopy(boolean includeFieldDataStructures) {\n    ManagedIndexSchema newSchema = null;\n    try {\n      newSchema = new ManagedIndexSchema\n          (solrConfig, loader, isMutable, managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    assert newSchema != null;\n    \n    newSchema.name = name;\n    newSchema.version = version;\n    newSchema.defaultSearchFieldName = defaultSearchFieldName;\n    newSchema.queryParserDefaultOperator = queryParserDefaultOperator;\n    newSchema.isExplicitQueryParserDefaultOperator = isExplicitQueryParserDefaultOperator;\n    newSchema.similarity = similarity;\n    newSchema.similarityFactory = similarityFactory;\n    newSchema.isExplicitSimilarity = isExplicitSimilarity;\n    newSchema.uniqueKeyField = uniqueKeyField;\n\n    if (includeFieldDataStructures) {\n      // These need new collections, since addFields() can add members to them\n      newSchema.fields.putAll(fields);\n      newSchema.fieldsWithDefaultValue.addAll(fieldsWithDefaultValue);\n      newSchema.requiredFields.addAll(requiredFields);\n    }\n\n    // These don't need new collections - addFields() won't add members to them \n    newSchema.fieldTypes = fieldTypes;\n    newSchema.dynamicFields = dynamicFields;\n    newSchema.dynamicCopyFields = dynamicCopyFields;\n    newSchema.copyFieldsMap = copyFieldsMap;\n    newSchema.copyFieldTargetCounts = copyFieldTargetCounts;\n    newSchema.schemaAware = schemaAware;\n\n    return newSchema;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#shallowCopy(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#shallowCopy(boolean).mjava","sourceNew":"  /**\n   * Makes a shallow copy of this schema.\n   * \n   * Not copied: analyzers \n   * \n   * @param includeFieldDataStructures if true, fields, fieldsWithDefaultValue, and requiredFields\n   *                                   are copied; otherwise, they are not.\n   * @return A shallow copy of this schema\n   */\n  private ManagedIndexSchema shallowCopy(boolean includeFieldDataStructures) {\n    ManagedIndexSchema newSchema = null;\n    try {\n      newSchema = new ManagedIndexSchema\n          (solrConfig, loader, isMutable, managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    assert newSchema != null;\n    \n    newSchema.name = name;\n    newSchema.version = version;\n    newSchema.defaultSearchFieldName = defaultSearchFieldName;\n    newSchema.queryParserDefaultOperator = queryParserDefaultOperator;\n    newSchema.isExplicitQueryParserDefaultOperator = isExplicitQueryParserDefaultOperator;\n    newSchema.similarity = similarity;\n    newSchema.similarityFactory = similarityFactory;\n    newSchema.isExplicitSimilarity = isExplicitSimilarity;\n    newSchema.uniqueKeyField = uniqueKeyField;\n    newSchema.uniqueKeyFieldName = uniqueKeyFieldName;\n    newSchema.uniqueKeyFieldType = uniqueKeyFieldType;\n\n    if (includeFieldDataStructures) {\n      // These need new collections, since addFields() can add members to them\n      newSchema.fields.putAll(fields);\n      newSchema.fieldsWithDefaultValue.addAll(fieldsWithDefaultValue);\n      newSchema.requiredFields.addAll(requiredFields);\n    }\n\n    // These don't need new collections - addFields() won't add members to them \n    newSchema.fieldTypes = fieldTypes;\n    newSchema.dynamicFields = dynamicFields;\n    newSchema.dynamicCopyFields = dynamicCopyFields;\n    newSchema.copyFieldsMap = copyFieldsMap;\n    newSchema.copyFieldTargetCounts = copyFieldTargetCounts;\n    newSchema.schemaAware = schemaAware;\n\n    return newSchema;\n  }\n\n","sourceOld":"  /**\n   * Makes a shallow copy of this schema.\n   * \n   * Not copied: analyzers \n   * \n   * @param includeFieldDataStructures if true, fields, fieldsWithDefaultValue, and requiredFields\n   *                                   are copied; otherwise, they are not.\n   * @return A shallow copy of this schema\n   */\n  private ManagedIndexSchema shallowCopy(boolean includeFieldDataStructures) {\n    ManagedIndexSchema newSchema = null;\n    try {\n      newSchema = new ManagedIndexSchema\n          (solrConfig, loader, isMutable, managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    assert newSchema != null;\n    \n    newSchema.name = name;\n    newSchema.version = version;\n    newSchema.defaultSearchFieldName = defaultSearchFieldName;\n    newSchema.queryParserDefaultOperator = queryParserDefaultOperator;\n    newSchema.isExplicitQueryParserDefaultOperator = isExplicitQueryParserDefaultOperator;\n    newSchema.similarity = similarity;\n    newSchema.similarityFactory = similarityFactory;\n    newSchema.isExplicitSimilarity = isExplicitSimilarity;\n    newSchema.uniqueKeyField = uniqueKeyField;\n\n    if (includeFieldDataStructures) {\n      // These need new collections, since addFields() can add members to them\n      newSchema.fields.putAll(fields);\n      newSchema.fieldsWithDefaultValue.addAll(fieldsWithDefaultValue);\n      newSchema.requiredFields.addAll(requiredFields);\n    }\n\n    // These don't need new collections - addFields() won't add members to them \n    newSchema.fieldTypes = fieldTypes;\n    newSchema.dynamicFields = dynamicFields;\n    newSchema.dynamicCopyFields = dynamicCopyFields;\n    newSchema.copyFieldsMap = copyFieldsMap;\n    newSchema.copyFieldTargetCounts = copyFieldTargetCounts;\n    newSchema.schemaAware = schemaAware;\n\n    return newSchema;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c84120abb208489fa02365a639464653d793cbb3","date":1376338597,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#shallowCopy(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#shallowCopy(boolean).mjava","sourceNew":"  /**\n   * Makes a shallow copy of this schema.\n   * \n   * Not copied: analyzers \n   * \n   * @param includeFieldDataStructures if true, fields, fieldsWithDefaultValue, and requiredFields\n   *                                   are copied; otherwise, they are not.\n   * @return A shallow copy of this schema\n   */\n  private ManagedIndexSchema shallowCopy(boolean includeFieldDataStructures) {\n    ManagedIndexSchema newSchema = null;\n    try {\n      newSchema = new ManagedIndexSchema\n          (solrConfig, loader, isMutable, managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    assert newSchema != null;\n    \n    newSchema.name = name;\n    newSchema.version = version;\n    newSchema.defaultSearchFieldName = defaultSearchFieldName;\n    newSchema.queryParserDefaultOperator = queryParserDefaultOperator;\n    newSchema.isExplicitQueryParserDefaultOperator = isExplicitQueryParserDefaultOperator;\n    newSchema.similarity = similarity;\n    newSchema.similarityFactory = similarityFactory;\n    newSchema.isExplicitSimilarity = isExplicitSimilarity;\n    newSchema.uniqueKeyField = uniqueKeyField;\n    newSchema.uniqueKeyFieldName = uniqueKeyFieldName;\n    newSchema.uniqueKeyFieldType = uniqueKeyFieldType;\n    \n    // After the schema is persisted, resourceName is the same as managedSchemaResourceName\n    newSchema.resourceName = managedSchemaResourceName;\n\n    if (includeFieldDataStructures) {\n      // These need new collections, since addFields() can add members to them\n      newSchema.fields.putAll(fields);\n      newSchema.fieldsWithDefaultValue.addAll(fieldsWithDefaultValue);\n      newSchema.requiredFields.addAll(requiredFields);\n    }\n\n    // These don't need new collections - addFields() won't add members to them \n    newSchema.fieldTypes = fieldTypes;\n    newSchema.dynamicFields = dynamicFields;\n    newSchema.dynamicCopyFields = dynamicCopyFields;\n    newSchema.copyFieldsMap = copyFieldsMap;\n    newSchema.copyFieldTargetCounts = copyFieldTargetCounts;\n    newSchema.schemaAware = schemaAware;\n\n    return newSchema;\n  }\n\n","sourceOld":"  /**\n   * Makes a shallow copy of this schema.\n   * \n   * Not copied: analyzers \n   * \n   * @param includeFieldDataStructures if true, fields, fieldsWithDefaultValue, and requiredFields\n   *                                   are copied; otherwise, they are not.\n   * @return A shallow copy of this schema\n   */\n  private ManagedIndexSchema shallowCopy(boolean includeFieldDataStructures) {\n    ManagedIndexSchema newSchema = null;\n    try {\n      newSchema = new ManagedIndexSchema\n          (solrConfig, loader, isMutable, managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    assert newSchema != null;\n    \n    newSchema.name = name;\n    newSchema.version = version;\n    newSchema.defaultSearchFieldName = defaultSearchFieldName;\n    newSchema.queryParserDefaultOperator = queryParserDefaultOperator;\n    newSchema.isExplicitQueryParserDefaultOperator = isExplicitQueryParserDefaultOperator;\n    newSchema.similarity = similarity;\n    newSchema.similarityFactory = similarityFactory;\n    newSchema.isExplicitSimilarity = isExplicitSimilarity;\n    newSchema.uniqueKeyField = uniqueKeyField;\n    newSchema.uniqueKeyFieldName = uniqueKeyFieldName;\n    newSchema.uniqueKeyFieldType = uniqueKeyFieldType;\n\n    if (includeFieldDataStructures) {\n      // These need new collections, since addFields() can add members to them\n      newSchema.fields.putAll(fields);\n      newSchema.fieldsWithDefaultValue.addAll(fieldsWithDefaultValue);\n      newSchema.requiredFields.addAll(requiredFields);\n    }\n\n    // These don't need new collections - addFields() won't add members to them \n    newSchema.fieldTypes = fieldTypes;\n    newSchema.dynamicFields = dynamicFields;\n    newSchema.dynamicCopyFields = dynamicCopyFields;\n    newSchema.copyFieldsMap = copyFieldsMap;\n    newSchema.copyFieldTargetCounts = copyFieldTargetCounts;\n    newSchema.schemaAware = schemaAware;\n\n    return newSchema;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#shallowCopy(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#shallowCopy(boolean).mjava","sourceNew":"  /**\n   * Makes a shallow copy of this schema.\n   * \n   * Not copied: analyzers \n   * \n   * @param includeFieldDataStructures if true, fields, fieldsWithDefaultValue, and requiredFields\n   *                                   are copied; otherwise, they are not.\n   * @return A shallow copy of this schema\n   */\n  private ManagedIndexSchema shallowCopy(boolean includeFieldDataStructures) {\n    ManagedIndexSchema newSchema = null;\n    try {\n      newSchema = new ManagedIndexSchema\n          (solrConfig, loader, isMutable, managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    assert newSchema != null;\n    \n    newSchema.name = name;\n    newSchema.version = version;\n    newSchema.defaultSearchFieldName = defaultSearchFieldName;\n    newSchema.queryParserDefaultOperator = queryParserDefaultOperator;\n    newSchema.isExplicitQueryParserDefaultOperator = isExplicitQueryParserDefaultOperator;\n    newSchema.similarity = similarity;\n    newSchema.similarityFactory = similarityFactory;\n    newSchema.isExplicitSimilarity = isExplicitSimilarity;\n    newSchema.uniqueKeyField = uniqueKeyField;\n    newSchema.uniqueKeyFieldName = uniqueKeyFieldName;\n    newSchema.uniqueKeyFieldType = uniqueKeyFieldType;\n    \n    // After the schema is persisted, resourceName is the same as managedSchemaResourceName\n    newSchema.resourceName = managedSchemaResourceName;\n\n    if (includeFieldDataStructures) {\n      // These need new collections, since addFields() can add members to them\n      newSchema.fields.putAll(fields);\n      newSchema.fieldsWithDefaultValue.addAll(fieldsWithDefaultValue);\n      newSchema.requiredFields.addAll(requiredFields);\n    }\n\n    // These don't need new collections - addFields() won't add members to them \n    newSchema.fieldTypes = fieldTypes;\n    newSchema.dynamicFields = dynamicFields;\n    newSchema.dynamicCopyFields = dynamicCopyFields;\n    newSchema.copyFieldsMap = copyFieldsMap;\n    newSchema.copyFieldTargetCounts = copyFieldTargetCounts;\n    newSchema.schemaAware = schemaAware;\n\n    return newSchema;\n  }\n\n","sourceOld":"  /**\n   * Makes a shallow copy of this schema.\n   * \n   * Not copied: analyzers \n   * \n   * @param includeFieldDataStructures if true, fields, fieldsWithDefaultValue, and requiredFields\n   *                                   are copied; otherwise, they are not.\n   * @return A shallow copy of this schema\n   */\n  private ManagedIndexSchema shallowCopy(boolean includeFieldDataStructures) {\n    ManagedIndexSchema newSchema = null;\n    try {\n      newSchema = new ManagedIndexSchema\n          (solrConfig, loader, isMutable, managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    assert newSchema != null;\n    \n    newSchema.name = name;\n    newSchema.version = version;\n    newSchema.defaultSearchFieldName = defaultSearchFieldName;\n    newSchema.queryParserDefaultOperator = queryParserDefaultOperator;\n    newSchema.isExplicitQueryParserDefaultOperator = isExplicitQueryParserDefaultOperator;\n    newSchema.similarity = similarity;\n    newSchema.similarityFactory = similarityFactory;\n    newSchema.isExplicitSimilarity = isExplicitSimilarity;\n    newSchema.uniqueKeyField = uniqueKeyField;\n    newSchema.uniqueKeyFieldName = uniqueKeyFieldName;\n    newSchema.uniqueKeyFieldType = uniqueKeyFieldType;\n\n    if (includeFieldDataStructures) {\n      // These need new collections, since addFields() can add members to them\n      newSchema.fields.putAll(fields);\n      newSchema.fieldsWithDefaultValue.addAll(fieldsWithDefaultValue);\n      newSchema.requiredFields.addAll(requiredFields);\n    }\n\n    // These don't need new collections - addFields() won't add members to them \n    newSchema.fieldTypes = fieldTypes;\n    newSchema.dynamicFields = dynamicFields;\n    newSchema.dynamicCopyFields = dynamicCopyFields;\n    newSchema.copyFieldsMap = copyFieldsMap;\n    newSchema.copyFieldTargetCounts = copyFieldTargetCounts;\n    newSchema.schemaAware = schemaAware;\n\n    return newSchema;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4a54d9ede1b7f2f026639186eb07f3f314d87d9a","date":1412176848,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#shallowCopy(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#shallowCopy(boolean).mjava","sourceNew":"  /**\n   * Makes a shallow copy of this schema.\n   * \n   * Not copied: analyzers \n   * \n   * @param includeFieldDataStructures if true, fields, fieldsWithDefaultValue, and requiredFields\n   *                                   are copied; otherwise, they are not.\n   * @return A shallow copy of this schema\n   */\n   ManagedIndexSchema shallowCopy(boolean includeFieldDataStructures) {\n    ManagedIndexSchema newSchema = null;\n    try {\n      newSchema = new ManagedIndexSchema\n          (solrConfig, loader, isMutable, managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    assert newSchema != null;\n    \n    newSchema.name = name;\n    newSchema.version = version;\n    newSchema.defaultSearchFieldName = defaultSearchFieldName;\n    newSchema.queryParserDefaultOperator = queryParserDefaultOperator;\n    newSchema.isExplicitQueryParserDefaultOperator = isExplicitQueryParserDefaultOperator;\n    newSchema.similarity = similarity;\n    newSchema.similarityFactory = similarityFactory;\n    newSchema.isExplicitSimilarity = isExplicitSimilarity;\n    newSchema.uniqueKeyField = uniqueKeyField;\n    newSchema.uniqueKeyFieldName = uniqueKeyFieldName;\n    newSchema.uniqueKeyFieldType = uniqueKeyFieldType;\n    \n    // After the schema is persisted, resourceName is the same as managedSchemaResourceName\n    newSchema.resourceName = managedSchemaResourceName;\n\n    if (includeFieldDataStructures) {\n      // These need new collections, since addFields() can add members to them\n      newSchema.fields.putAll(fields);\n      newSchema.fieldsWithDefaultValue.addAll(fieldsWithDefaultValue);\n      newSchema.requiredFields.addAll(requiredFields);\n    }\n\n    // These don't need new collections - addFields() won't add members to them \n    newSchema.fieldTypes = fieldTypes;\n    newSchema.dynamicFields = dynamicFields;\n    newSchema.dynamicCopyFields = dynamicCopyFields;\n    newSchema.copyFieldsMap = copyFieldsMap;\n    newSchema.copyFieldTargetCounts = copyFieldTargetCounts;\n    newSchema.schemaAware = schemaAware;\n\n    return newSchema;\n  }\n\n","sourceOld":"  /**\n   * Makes a shallow copy of this schema.\n   * \n   * Not copied: analyzers \n   * \n   * @param includeFieldDataStructures if true, fields, fieldsWithDefaultValue, and requiredFields\n   *                                   are copied; otherwise, they are not.\n   * @return A shallow copy of this schema\n   */\n  private ManagedIndexSchema shallowCopy(boolean includeFieldDataStructures) {\n    ManagedIndexSchema newSchema = null;\n    try {\n      newSchema = new ManagedIndexSchema\n          (solrConfig, loader, isMutable, managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    assert newSchema != null;\n    \n    newSchema.name = name;\n    newSchema.version = version;\n    newSchema.defaultSearchFieldName = defaultSearchFieldName;\n    newSchema.queryParserDefaultOperator = queryParserDefaultOperator;\n    newSchema.isExplicitQueryParserDefaultOperator = isExplicitQueryParserDefaultOperator;\n    newSchema.similarity = similarity;\n    newSchema.similarityFactory = similarityFactory;\n    newSchema.isExplicitSimilarity = isExplicitSimilarity;\n    newSchema.uniqueKeyField = uniqueKeyField;\n    newSchema.uniqueKeyFieldName = uniqueKeyFieldName;\n    newSchema.uniqueKeyFieldType = uniqueKeyFieldType;\n    \n    // After the schema is persisted, resourceName is the same as managedSchemaResourceName\n    newSchema.resourceName = managedSchemaResourceName;\n\n    if (includeFieldDataStructures) {\n      // These need new collections, since addFields() can add members to them\n      newSchema.fields.putAll(fields);\n      newSchema.fieldsWithDefaultValue.addAll(fieldsWithDefaultValue);\n      newSchema.requiredFields.addAll(requiredFields);\n    }\n\n    // These don't need new collections - addFields() won't add members to them \n    newSchema.fieldTypes = fieldTypes;\n    newSchema.dynamicFields = dynamicFields;\n    newSchema.dynamicCopyFields = dynamicCopyFields;\n    newSchema.copyFieldsMap = copyFieldsMap;\n    newSchema.copyFieldTargetCounts = copyFieldTargetCounts;\n    newSchema.schemaAware = schemaAware;\n\n    return newSchema;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d9a47902d6207303f5ed3e7aaca62ca33433af66","date":1412435312,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#shallowCopy(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#shallowCopy(boolean).mjava","sourceNew":"  /**\n   * Makes a shallow copy of this schema.\n   * \n   * Not copied: analyzers \n   * \n   * @param includeFieldDataStructures if true, fields, fieldsWithDefaultValue, and requiredFields\n   *                                   are copied; otherwise, they are not.\n   * @return A shallow copy of this schema\n   */\n   ManagedIndexSchema shallowCopy(boolean includeFieldDataStructures) {\n    ManagedIndexSchema newSchema = null;\n    try {\n      newSchema = new ManagedIndexSchema\n          (solrConfig, loader, isMutable, managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    assert newSchema != null;\n    \n    newSchema.name = name;\n    newSchema.version = version;\n    newSchema.defaultSearchFieldName = defaultSearchFieldName;\n    newSchema.queryParserDefaultOperator = queryParserDefaultOperator;\n    newSchema.isExplicitQueryParserDefaultOperator = isExplicitQueryParserDefaultOperator;\n    newSchema.similarity = similarity;\n    newSchema.similarityFactory = similarityFactory;\n    newSchema.isExplicitSimilarity = isExplicitSimilarity;\n    newSchema.uniqueKeyField = uniqueKeyField;\n    newSchema.uniqueKeyFieldName = uniqueKeyFieldName;\n    newSchema.uniqueKeyFieldType = uniqueKeyFieldType;\n    \n    // After the schema is persisted, resourceName is the same as managedSchemaResourceName\n    newSchema.resourceName = managedSchemaResourceName;\n\n    if (includeFieldDataStructures) {\n      // These need new collections, since addFields() can add members to them\n      newSchema.fields.putAll(fields);\n      newSchema.fieldsWithDefaultValue.addAll(fieldsWithDefaultValue);\n      newSchema.requiredFields.addAll(requiredFields);\n    }\n\n    // These don't need new collections - addFields() won't add members to them \n    newSchema.fieldTypes = fieldTypes;\n    newSchema.dynamicFields = dynamicFields;\n    newSchema.dynamicCopyFields = dynamicCopyFields;\n    newSchema.copyFieldsMap = copyFieldsMap;\n    newSchema.copyFieldTargetCounts = copyFieldTargetCounts;\n    newSchema.schemaAware = schemaAware;\n\n    return newSchema;\n  }\n\n","sourceOld":"  /**\n   * Makes a shallow copy of this schema.\n   * \n   * Not copied: analyzers \n   * \n   * @param includeFieldDataStructures if true, fields, fieldsWithDefaultValue, and requiredFields\n   *                                   are copied; otherwise, they are not.\n   * @return A shallow copy of this schema\n   */\n  private ManagedIndexSchema shallowCopy(boolean includeFieldDataStructures) {\n    ManagedIndexSchema newSchema = null;\n    try {\n      newSchema = new ManagedIndexSchema\n          (solrConfig, loader, isMutable, managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    assert newSchema != null;\n    \n    newSchema.name = name;\n    newSchema.version = version;\n    newSchema.defaultSearchFieldName = defaultSearchFieldName;\n    newSchema.queryParserDefaultOperator = queryParserDefaultOperator;\n    newSchema.isExplicitQueryParserDefaultOperator = isExplicitQueryParserDefaultOperator;\n    newSchema.similarity = similarity;\n    newSchema.similarityFactory = similarityFactory;\n    newSchema.isExplicitSimilarity = isExplicitSimilarity;\n    newSchema.uniqueKeyField = uniqueKeyField;\n    newSchema.uniqueKeyFieldName = uniqueKeyFieldName;\n    newSchema.uniqueKeyFieldType = uniqueKeyFieldType;\n    \n    // After the schema is persisted, resourceName is the same as managedSchemaResourceName\n    newSchema.resourceName = managedSchemaResourceName;\n\n    if (includeFieldDataStructures) {\n      // These need new collections, since addFields() can add members to them\n      newSchema.fields.putAll(fields);\n      newSchema.fieldsWithDefaultValue.addAll(fieldsWithDefaultValue);\n      newSchema.requiredFields.addAll(requiredFields);\n    }\n\n    // These don't need new collections - addFields() won't add members to them \n    newSchema.fieldTypes = fieldTypes;\n    newSchema.dynamicFields = dynamicFields;\n    newSchema.dynamicCopyFields = dynamicCopyFields;\n    newSchema.copyFieldsMap = copyFieldsMap;\n    newSchema.copyFieldTargetCounts = copyFieldTargetCounts;\n    newSchema.schemaAware = schemaAware;\n\n    return newSchema;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c418b5fb43bf7b591b636df532dd1ac44296469a","date":1494834249,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#shallowCopy(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#shallowCopy(boolean).mjava","sourceNew":"  /**\n   * Makes a shallow copy of this schema.\n   * \n   * Not copied: analyzers \n   * \n   * @param includeFieldDataStructures if true, fields, fieldsWithDefaultValue, and requiredFields\n   *                                   are copied; otherwise, they are not.\n   * @return A shallow copy of this schema\n   */\n   ManagedIndexSchema shallowCopy(boolean includeFieldDataStructures) {\n    ManagedIndexSchema newSchema = null;\n    try {\n      newSchema = new ManagedIndexSchema\n          (solrConfig, loader, isMutable, managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    assert newSchema != null;\n    \n    newSchema.name = name;\n    newSchema.version = version;\n    newSchema.defaultSearchFieldName = defaultSearchFieldName;\n    newSchema.similarity = similarity;\n    newSchema.similarityFactory = similarityFactory;\n    newSchema.isExplicitSimilarity = isExplicitSimilarity;\n    newSchema.uniqueKeyField = uniqueKeyField;\n    newSchema.uniqueKeyFieldName = uniqueKeyFieldName;\n    newSchema.uniqueKeyFieldType = uniqueKeyFieldType;\n    \n    // After the schema is persisted, resourceName is the same as managedSchemaResourceName\n    newSchema.resourceName = managedSchemaResourceName;\n\n    if (includeFieldDataStructures) {\n      // These need new collections, since addFields() can add members to them\n      newSchema.fields.putAll(fields);\n      newSchema.fieldsWithDefaultValue.addAll(fieldsWithDefaultValue);\n      newSchema.requiredFields.addAll(requiredFields);\n    }\n\n    // These don't need new collections - addFields() won't add members to them \n    newSchema.fieldTypes = fieldTypes;\n    newSchema.dynamicFields = dynamicFields;\n    newSchema.dynamicCopyFields = dynamicCopyFields;\n    newSchema.copyFieldsMap = copyFieldsMap;\n    newSchema.copyFieldTargetCounts = copyFieldTargetCounts;\n    newSchema.schemaAware = schemaAware;\n\n    return newSchema;\n  }\n\n","sourceOld":"  /**\n   * Makes a shallow copy of this schema.\n   * \n   * Not copied: analyzers \n   * \n   * @param includeFieldDataStructures if true, fields, fieldsWithDefaultValue, and requiredFields\n   *                                   are copied; otherwise, they are not.\n   * @return A shallow copy of this schema\n   */\n   ManagedIndexSchema shallowCopy(boolean includeFieldDataStructures) {\n    ManagedIndexSchema newSchema = null;\n    try {\n      newSchema = new ManagedIndexSchema\n          (solrConfig, loader, isMutable, managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    assert newSchema != null;\n    \n    newSchema.name = name;\n    newSchema.version = version;\n    newSchema.defaultSearchFieldName = defaultSearchFieldName;\n    newSchema.queryParserDefaultOperator = queryParserDefaultOperator;\n    newSchema.isExplicitQueryParserDefaultOperator = isExplicitQueryParserDefaultOperator;\n    newSchema.similarity = similarity;\n    newSchema.similarityFactory = similarityFactory;\n    newSchema.isExplicitSimilarity = isExplicitSimilarity;\n    newSchema.uniqueKeyField = uniqueKeyField;\n    newSchema.uniqueKeyFieldName = uniqueKeyFieldName;\n    newSchema.uniqueKeyFieldType = uniqueKeyFieldType;\n    \n    // After the schema is persisted, resourceName is the same as managedSchemaResourceName\n    newSchema.resourceName = managedSchemaResourceName;\n\n    if (includeFieldDataStructures) {\n      // These need new collections, since addFields() can add members to them\n      newSchema.fields.putAll(fields);\n      newSchema.fieldsWithDefaultValue.addAll(fieldsWithDefaultValue);\n      newSchema.requiredFields.addAll(requiredFields);\n    }\n\n    // These don't need new collections - addFields() won't add members to them \n    newSchema.fieldTypes = fieldTypes;\n    newSchema.dynamicFields = dynamicFields;\n    newSchema.dynamicCopyFields = dynamicCopyFields;\n    newSchema.copyFieldsMap = copyFieldsMap;\n    newSchema.copyFieldTargetCounts = copyFieldTargetCounts;\n    newSchema.schemaAware = schemaAware;\n\n    return newSchema;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c5536d1fc2015d46bbeb8163f6f8b99483c7cc1f","date":1495081498,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#shallowCopy(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#shallowCopy(boolean).mjava","sourceNew":"  /**\n   * Makes a shallow copy of this schema.\n   * \n   * Not copied: analyzers \n   * \n   * @param includeFieldDataStructures if true, fields, fieldsWithDefaultValue, and requiredFields\n   *                                   are copied; otherwise, they are not.\n   * @return A shallow copy of this schema\n   */\n   ManagedIndexSchema shallowCopy(boolean includeFieldDataStructures) {\n    ManagedIndexSchema newSchema = null;\n    try {\n      newSchema = new ManagedIndexSchema\n          (solrConfig, loader, isMutable, managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    assert newSchema != null;\n    \n    newSchema.name = name;\n    newSchema.version = version;\n    newSchema.defaultSearchFieldName = defaultSearchFieldName;\n    newSchema.similarity = similarity;\n    newSchema.similarityFactory = similarityFactory;\n    newSchema.isExplicitSimilarity = isExplicitSimilarity;\n    newSchema.uniqueKeyField = uniqueKeyField;\n    newSchema.uniqueKeyFieldName = uniqueKeyFieldName;\n    newSchema.uniqueKeyFieldType = uniqueKeyFieldType;\n    \n    // After the schema is persisted, resourceName is the same as managedSchemaResourceName\n    newSchema.resourceName = managedSchemaResourceName;\n\n    if (includeFieldDataStructures) {\n      // These need new collections, since addFields() can add members to them\n      newSchema.fields.putAll(fields);\n      newSchema.fieldsWithDefaultValue.addAll(fieldsWithDefaultValue);\n      newSchema.requiredFields.addAll(requiredFields);\n    }\n\n    // These don't need new collections - addFields() won't add members to them \n    newSchema.fieldTypes = fieldTypes;\n    newSchema.dynamicFields = dynamicFields;\n    newSchema.dynamicCopyFields = dynamicCopyFields;\n    newSchema.copyFieldsMap = copyFieldsMap;\n    newSchema.copyFieldTargetCounts = copyFieldTargetCounts;\n    newSchema.schemaAware = schemaAware;\n\n    return newSchema;\n  }\n\n","sourceOld":"  /**\n   * Makes a shallow copy of this schema.\n   * \n   * Not copied: analyzers \n   * \n   * @param includeFieldDataStructures if true, fields, fieldsWithDefaultValue, and requiredFields\n   *                                   are copied; otherwise, they are not.\n   * @return A shallow copy of this schema\n   */\n   ManagedIndexSchema shallowCopy(boolean includeFieldDataStructures) {\n    ManagedIndexSchema newSchema = null;\n    try {\n      newSchema = new ManagedIndexSchema\n          (solrConfig, loader, isMutable, managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    assert newSchema != null;\n    \n    newSchema.name = name;\n    newSchema.version = version;\n    newSchema.defaultSearchFieldName = defaultSearchFieldName;\n    newSchema.queryParserDefaultOperator = queryParserDefaultOperator;\n    newSchema.isExplicitQueryParserDefaultOperator = isExplicitQueryParserDefaultOperator;\n    newSchema.similarity = similarity;\n    newSchema.similarityFactory = similarityFactory;\n    newSchema.isExplicitSimilarity = isExplicitSimilarity;\n    newSchema.uniqueKeyField = uniqueKeyField;\n    newSchema.uniqueKeyFieldName = uniqueKeyFieldName;\n    newSchema.uniqueKeyFieldType = uniqueKeyFieldType;\n    \n    // After the schema is persisted, resourceName is the same as managedSchemaResourceName\n    newSchema.resourceName = managedSchemaResourceName;\n\n    if (includeFieldDataStructures) {\n      // These need new collections, since addFields() can add members to them\n      newSchema.fields.putAll(fields);\n      newSchema.fieldsWithDefaultValue.addAll(fieldsWithDefaultValue);\n      newSchema.requiredFields.addAll(requiredFields);\n    }\n\n    // These don't need new collections - addFields() won't add members to them \n    newSchema.fieldTypes = fieldTypes;\n    newSchema.dynamicFields = dynamicFields;\n    newSchema.dynamicCopyFields = dynamicCopyFields;\n    newSchema.copyFieldsMap = copyFieldsMap;\n    newSchema.copyFieldTargetCounts = copyFieldTargetCounts;\n    newSchema.schemaAware = schemaAware;\n\n    return newSchema;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d057970b5f9fcaabc49d2f54c59a5d2a09da1769","date":1495200448,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#shallowCopy(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#shallowCopy(boolean).mjava","sourceNew":"  /**\n   * Makes a shallow copy of this schema.\n   * \n   * Not copied: analyzers \n   * \n   * @param includeFieldDataStructures if true, fields, fieldsWithDefaultValue, and requiredFields\n   *                                   are copied; otherwise, they are not.\n   * @return A shallow copy of this schema\n   */\n   ManagedIndexSchema shallowCopy(boolean includeFieldDataStructures) {\n    ManagedIndexSchema newSchema = null;\n    try {\n      newSchema = new ManagedIndexSchema\n          (solrConfig, loader, isMutable, managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    assert newSchema != null;\n    \n    newSchema.name = name;\n    newSchema.version = version;\n    newSchema.similarity = similarity;\n    newSchema.similarityFactory = similarityFactory;\n    newSchema.isExplicitSimilarity = isExplicitSimilarity;\n    newSchema.uniqueKeyField = uniqueKeyField;\n    newSchema.uniqueKeyFieldName = uniqueKeyFieldName;\n    newSchema.uniqueKeyFieldType = uniqueKeyFieldType;\n    \n    // After the schema is persisted, resourceName is the same as managedSchemaResourceName\n    newSchema.resourceName = managedSchemaResourceName;\n\n    if (includeFieldDataStructures) {\n      // These need new collections, since addFields() can add members to them\n      newSchema.fields.putAll(fields);\n      newSchema.fieldsWithDefaultValue.addAll(fieldsWithDefaultValue);\n      newSchema.requiredFields.addAll(requiredFields);\n    }\n\n    // These don't need new collections - addFields() won't add members to them \n    newSchema.fieldTypes = fieldTypes;\n    newSchema.dynamicFields = dynamicFields;\n    newSchema.dynamicCopyFields = dynamicCopyFields;\n    newSchema.copyFieldsMap = copyFieldsMap;\n    newSchema.copyFieldTargetCounts = copyFieldTargetCounts;\n    newSchema.schemaAware = schemaAware;\n\n    return newSchema;\n  }\n\n","sourceOld":"  /**\n   * Makes a shallow copy of this schema.\n   * \n   * Not copied: analyzers \n   * \n   * @param includeFieldDataStructures if true, fields, fieldsWithDefaultValue, and requiredFields\n   *                                   are copied; otherwise, they are not.\n   * @return A shallow copy of this schema\n   */\n   ManagedIndexSchema shallowCopy(boolean includeFieldDataStructures) {\n    ManagedIndexSchema newSchema = null;\n    try {\n      newSchema = new ManagedIndexSchema\n          (solrConfig, loader, isMutable, managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    assert newSchema != null;\n    \n    newSchema.name = name;\n    newSchema.version = version;\n    newSchema.defaultSearchFieldName = defaultSearchFieldName;\n    newSchema.similarity = similarity;\n    newSchema.similarityFactory = similarityFactory;\n    newSchema.isExplicitSimilarity = isExplicitSimilarity;\n    newSchema.uniqueKeyField = uniqueKeyField;\n    newSchema.uniqueKeyFieldName = uniqueKeyFieldName;\n    newSchema.uniqueKeyFieldType = uniqueKeyFieldType;\n    \n    // After the schema is persisted, resourceName is the same as managedSchemaResourceName\n    newSchema.resourceName = managedSchemaResourceName;\n\n    if (includeFieldDataStructures) {\n      // These need new collections, since addFields() can add members to them\n      newSchema.fields.putAll(fields);\n      newSchema.fieldsWithDefaultValue.addAll(fieldsWithDefaultValue);\n      newSchema.requiredFields.addAll(requiredFields);\n    }\n\n    // These don't need new collections - addFields() won't add members to them \n    newSchema.fieldTypes = fieldTypes;\n    newSchema.dynamicFields = dynamicFields;\n    newSchema.dynamicCopyFields = dynamicCopyFields;\n    newSchema.copyFieldsMap = copyFieldsMap;\n    newSchema.copyFieldTargetCounts = copyFieldTargetCounts;\n    newSchema.schemaAware = schemaAware;\n\n    return newSchema;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#shallowCopy(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#shallowCopy(boolean).mjava","sourceNew":"  /**\n   * Makes a shallow copy of this schema.\n   * \n   * Not copied: analyzers \n   * \n   * @param includeFieldDataStructures if true, fields, fieldsWithDefaultValue, and requiredFields\n   *                                   are copied; otherwise, they are not.\n   * @return A shallow copy of this schema\n   */\n   ManagedIndexSchema shallowCopy(boolean includeFieldDataStructures) {\n    ManagedIndexSchema newSchema = null;\n    try {\n      newSchema = new ManagedIndexSchema\n          (solrConfig, loader, isMutable, managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    assert newSchema != null;\n    \n    newSchema.name = name;\n    newSchema.version = version;\n    newSchema.similarity = similarity;\n    newSchema.similarityFactory = similarityFactory;\n    newSchema.isExplicitSimilarity = isExplicitSimilarity;\n    newSchema.uniqueKeyField = uniqueKeyField;\n    newSchema.uniqueKeyFieldName = uniqueKeyFieldName;\n    newSchema.uniqueKeyFieldType = uniqueKeyFieldType;\n    \n    // After the schema is persisted, resourceName is the same as managedSchemaResourceName\n    newSchema.resourceName = managedSchemaResourceName;\n\n    if (includeFieldDataStructures) {\n      // These need new collections, since addFields() can add members to them\n      newSchema.fields.putAll(fields);\n      newSchema.fieldsWithDefaultValue.addAll(fieldsWithDefaultValue);\n      newSchema.requiredFields.addAll(requiredFields);\n    }\n\n    // These don't need new collections - addFields() won't add members to them \n    newSchema.fieldTypes = fieldTypes;\n    newSchema.dynamicFields = dynamicFields;\n    newSchema.dynamicCopyFields = dynamicCopyFields;\n    newSchema.copyFieldsMap = copyFieldsMap;\n    newSchema.copyFieldTargetCounts = copyFieldTargetCounts;\n    newSchema.schemaAware = schemaAware;\n\n    return newSchema;\n  }\n\n","sourceOld":"  /**\n   * Makes a shallow copy of this schema.\n   * \n   * Not copied: analyzers \n   * \n   * @param includeFieldDataStructures if true, fields, fieldsWithDefaultValue, and requiredFields\n   *                                   are copied; otherwise, they are not.\n   * @return A shallow copy of this schema\n   */\n   ManagedIndexSchema shallowCopy(boolean includeFieldDataStructures) {\n    ManagedIndexSchema newSchema = null;\n    try {\n      newSchema = new ManagedIndexSchema\n          (solrConfig, loader, isMutable, managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    assert newSchema != null;\n    \n    newSchema.name = name;\n    newSchema.version = version;\n    newSchema.defaultSearchFieldName = defaultSearchFieldName;\n    newSchema.queryParserDefaultOperator = queryParserDefaultOperator;\n    newSchema.isExplicitQueryParserDefaultOperator = isExplicitQueryParserDefaultOperator;\n    newSchema.similarity = similarity;\n    newSchema.similarityFactory = similarityFactory;\n    newSchema.isExplicitSimilarity = isExplicitSimilarity;\n    newSchema.uniqueKeyField = uniqueKeyField;\n    newSchema.uniqueKeyFieldName = uniqueKeyFieldName;\n    newSchema.uniqueKeyFieldType = uniqueKeyFieldType;\n    \n    // After the schema is persisted, resourceName is the same as managedSchemaResourceName\n    newSchema.resourceName = managedSchemaResourceName;\n\n    if (includeFieldDataStructures) {\n      // These need new collections, since addFields() can add members to them\n      newSchema.fields.putAll(fields);\n      newSchema.fieldsWithDefaultValue.addAll(fieldsWithDefaultValue);\n      newSchema.requiredFields.addAll(requiredFields);\n    }\n\n    // These don't need new collections - addFields() won't add members to them \n    newSchema.fieldTypes = fieldTypes;\n    newSchema.dynamicFields = dynamicFields;\n    newSchema.dynamicCopyFields = dynamicCopyFields;\n    newSchema.copyFieldsMap = copyFieldsMap;\n    newSchema.copyFieldTargetCounts = copyFieldTargetCounts;\n    newSchema.schemaAware = schemaAware;\n\n    return newSchema;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df151630bfbea5338a007b97bfd37e4ec94f873f","date":1553017904,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#shallowCopy(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#shallowCopy(boolean).mjava","sourceNew":"  /**\n   * Makes a shallow copy of this schema.\n   * \n   * Not copied: analyzers \n   * \n   * @param includeFieldDataStructures if true, fields, fieldsWithDefaultValue, and requiredFields\n   *                                   are copied; otherwise, they are not.\n   * @return A shallow copy of this schema\n   */\n   ManagedIndexSchema shallowCopy(boolean includeFieldDataStructures) {\n     ManagedIndexSchema newSchema = new ManagedIndexSchema\n         (luceneVersion, loader, isMutable, managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n\n    newSchema.name = name;\n    newSchema.version = version;\n    newSchema.similarity = similarity;\n    newSchema.similarityFactory = similarityFactory;\n    newSchema.isExplicitSimilarity = isExplicitSimilarity;\n    newSchema.uniqueKeyField = uniqueKeyField;\n    newSchema.uniqueKeyFieldName = uniqueKeyFieldName;\n    newSchema.uniqueKeyFieldType = uniqueKeyFieldType;\n    \n    // After the schema is persisted, resourceName is the same as managedSchemaResourceName\n    newSchema.resourceName = managedSchemaResourceName;\n\n    if (includeFieldDataStructures) {\n      // These need new collections, since addFields() can add members to them\n      newSchema.fields.putAll(fields);\n      newSchema.fieldsWithDefaultValue.addAll(fieldsWithDefaultValue);\n      newSchema.requiredFields.addAll(requiredFields);\n    }\n\n    // These don't need new collections - addFields() won't add members to them \n    newSchema.fieldTypes = fieldTypes;\n    newSchema.dynamicFields = dynamicFields;\n    newSchema.dynamicCopyFields = dynamicCopyFields;\n    newSchema.copyFieldsMap = copyFieldsMap;\n    newSchema.copyFieldTargetCounts = copyFieldTargetCounts;\n    newSchema.schemaAware = schemaAware;\n\n    return newSchema;\n  }\n\n","sourceOld":"  /**\n   * Makes a shallow copy of this schema.\n   * \n   * Not copied: analyzers \n   * \n   * @param includeFieldDataStructures if true, fields, fieldsWithDefaultValue, and requiredFields\n   *                                   are copied; otherwise, they are not.\n   * @return A shallow copy of this schema\n   */\n   ManagedIndexSchema shallowCopy(boolean includeFieldDataStructures) {\n    ManagedIndexSchema newSchema = null;\n    try {\n      newSchema = new ManagedIndexSchema\n          (solrConfig, loader, isMutable, managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n    } catch (KeeperException e) {\n      final String msg = \"Error instantiating ManagedIndexSchema\";\n      log.error(msg, e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);\n    } catch (InterruptedException e) {\n      // Restore the interrupted status\n      Thread.currentThread().interrupt();\n      log.warn(\"\", e);\n    }\n\n    assert newSchema != null;\n    \n    newSchema.name = name;\n    newSchema.version = version;\n    newSchema.similarity = similarity;\n    newSchema.similarityFactory = similarityFactory;\n    newSchema.isExplicitSimilarity = isExplicitSimilarity;\n    newSchema.uniqueKeyField = uniqueKeyField;\n    newSchema.uniqueKeyFieldName = uniqueKeyFieldName;\n    newSchema.uniqueKeyFieldType = uniqueKeyFieldType;\n    \n    // After the schema is persisted, resourceName is the same as managedSchemaResourceName\n    newSchema.resourceName = managedSchemaResourceName;\n\n    if (includeFieldDataStructures) {\n      // These need new collections, since addFields() can add members to them\n      newSchema.fields.putAll(fields);\n      newSchema.fieldsWithDefaultValue.addAll(fieldsWithDefaultValue);\n      newSchema.requiredFields.addAll(requiredFields);\n    }\n\n    // These don't need new collections - addFields() won't add members to them \n    newSchema.fieldTypes = fieldTypes;\n    newSchema.dynamicFields = dynamicFields;\n    newSchema.dynamicCopyFields = dynamicCopyFields;\n    newSchema.copyFieldsMap = copyFieldsMap;\n    newSchema.copyFieldTargetCounts = copyFieldTargetCounts;\n    newSchema.schemaAware = schemaAware;\n\n    return newSchema;\n  }\n\n","bugFix":["08970e5b8411182a29412c177eff67ec1110095b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3","date":1583932828,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#shallowCopy(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema#shallowCopy(boolean).mjava","sourceNew":"  /**\n   * Makes a shallow copy of this schema.\n   * \n   * Not copied: analyzers \n   * \n   * @param includeFieldDataStructures if true, fields, fieldsWithDefaultValue, and requiredFields\n   *                                   are copied; otherwise, they are not.\n   * @return A shallow copy of this schema\n   */\n   ManagedIndexSchema shallowCopy(boolean includeFieldDataStructures) {\n     ManagedIndexSchema newSchema = new ManagedIndexSchema\n         (luceneVersion, loader, isMutable, managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock(), substitutableProperties);\n\n    newSchema.name = name;\n    newSchema.version = version;\n    newSchema.similarity = similarity;\n    newSchema.similarityFactory = similarityFactory;\n    newSchema.isExplicitSimilarity = isExplicitSimilarity;\n    newSchema.uniqueKeyField = uniqueKeyField;\n    newSchema.uniqueKeyFieldName = uniqueKeyFieldName;\n    newSchema.uniqueKeyFieldType = uniqueKeyFieldType;\n    \n    // After the schema is persisted, resourceName is the same as managedSchemaResourceName\n    newSchema.resourceName = managedSchemaResourceName;\n\n    if (includeFieldDataStructures) {\n      // These need new collections, since addFields() can add members to them\n      newSchema.fields.putAll(fields);\n      newSchema.fieldsWithDefaultValue.addAll(fieldsWithDefaultValue);\n      newSchema.requiredFields.addAll(requiredFields);\n    }\n\n    // These don't need new collections - addFields() won't add members to them \n    newSchema.fieldTypes = fieldTypes;\n    newSchema.dynamicFields = dynamicFields;\n    newSchema.dynamicCopyFields = dynamicCopyFields;\n    newSchema.copyFieldsMap = copyFieldsMap;\n    newSchema.copyFieldTargetCounts = copyFieldTargetCounts;\n    newSchema.schemaAware = schemaAware;\n\n    return newSchema;\n  }\n\n","sourceOld":"  /**\n   * Makes a shallow copy of this schema.\n   * \n   * Not copied: analyzers \n   * \n   * @param includeFieldDataStructures if true, fields, fieldsWithDefaultValue, and requiredFields\n   *                                   are copied; otherwise, they are not.\n   * @return A shallow copy of this schema\n   */\n   ManagedIndexSchema shallowCopy(boolean includeFieldDataStructures) {\n     ManagedIndexSchema newSchema = new ManagedIndexSchema\n         (luceneVersion, loader, isMutable, managedSchemaResourceName, schemaZkVersion, getSchemaUpdateLock());\n\n    newSchema.name = name;\n    newSchema.version = version;\n    newSchema.similarity = similarity;\n    newSchema.similarityFactory = similarityFactory;\n    newSchema.isExplicitSimilarity = isExplicitSimilarity;\n    newSchema.uniqueKeyField = uniqueKeyField;\n    newSchema.uniqueKeyFieldName = uniqueKeyFieldName;\n    newSchema.uniqueKeyFieldType = uniqueKeyFieldType;\n    \n    // After the schema is persisted, resourceName is the same as managedSchemaResourceName\n    newSchema.resourceName = managedSchemaResourceName;\n\n    if (includeFieldDataStructures) {\n      // These need new collections, since addFields() can add members to them\n      newSchema.fields.putAll(fields);\n      newSchema.fieldsWithDefaultValue.addAll(fieldsWithDefaultValue);\n      newSchema.requiredFields.addAll(requiredFields);\n    }\n\n    // These don't need new collections - addFields() won't add members to them \n    newSchema.fieldTypes = fieldTypes;\n    newSchema.dynamicFields = dynamicFields;\n    newSchema.dynamicCopyFields = dynamicCopyFields;\n    newSchema.copyFieldsMap = copyFieldsMap;\n    newSchema.copyFieldTargetCounts = copyFieldTargetCounts;\n    newSchema.schemaAware = schemaAware;\n\n    return newSchema;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["37a0f60745e53927c4c876cfe5b5a58170f0646c","c84120abb208489fa02365a639464653d793cbb3"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["08970e5b8411182a29412c177eff67ec1110095b","5a7624bc6b738f100f63bb9902e91a84dd67d86f"],"d057970b5f9fcaabc49d2f54c59a5d2a09da1769":["c5536d1fc2015d46bbeb8163f6f8b99483c7cc1f"],"4a54d9ede1b7f2f026639186eb07f3f314d87d9a":["c84120abb208489fa02365a639464653d793cbb3"],"d9a47902d6207303f5ed3e7aaca62ca33433af66":["c84120abb208489fa02365a639464653d793cbb3","4a54d9ede1b7f2f026639186eb07f3f314d87d9a"],"c5536d1fc2015d46bbeb8163f6f8b99483c7cc1f":["4a54d9ede1b7f2f026639186eb07f3f314d87d9a","c418b5fb43bf7b591b636df532dd1ac44296469a"],"08970e5b8411182a29412c177eff67ec1110095b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c418b5fb43bf7b591b636df532dd1ac44296469a":["4a54d9ede1b7f2f026639186eb07f3f314d87d9a"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["4a54d9ede1b7f2f026639186eb07f3f314d87d9a","d057970b5f9fcaabc49d2f54c59a5d2a09da1769"],"ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3":["df151630bfbea5338a007b97bfd37e4ec94f873f"],"df151630bfbea5338a007b97bfd37e4ec94f873f":["d057970b5f9fcaabc49d2f54c59a5d2a09da1769"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5a7624bc6b738f100f63bb9902e91a84dd67d86f":["08970e5b8411182a29412c177eff67ec1110095b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3"],"c84120abb208489fa02365a639464653d793cbb3":["5a7624bc6b738f100f63bb9902e91a84dd67d86f"]},"commit2Childs":{"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":[],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec"],"d057970b5f9fcaabc49d2f54c59a5d2a09da1769":["e9017cf144952056066919f1ebc7897ff9bd71b1","df151630bfbea5338a007b97bfd37e4ec94f873f"],"4a54d9ede1b7f2f026639186eb07f3f314d87d9a":["d9a47902d6207303f5ed3e7aaca62ca33433af66","c5536d1fc2015d46bbeb8163f6f8b99483c7cc1f","c418b5fb43bf7b591b636df532dd1ac44296469a","e9017cf144952056066919f1ebc7897ff9bd71b1"],"d9a47902d6207303f5ed3e7aaca62ca33433af66":[],"c5536d1fc2015d46bbeb8163f6f8b99483c7cc1f":["d057970b5f9fcaabc49d2f54c59a5d2a09da1769"],"08970e5b8411182a29412c177eff67ec1110095b":["37a0f60745e53927c4c876cfe5b5a58170f0646c","5a7624bc6b738f100f63bb9902e91a84dd67d86f"],"c418b5fb43bf7b591b636df532dd1ac44296469a":["c5536d1fc2015d46bbeb8163f6f8b99483c7cc1f"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"df151630bfbea5338a007b97bfd37e4ec94f873f":["ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["08970e5b8411182a29412c177eff67ec1110095b"],"5a7624bc6b738f100f63bb9902e91a84dd67d86f":["37a0f60745e53927c4c876cfe5b5a58170f0646c","c84120abb208489fa02365a639464653d793cbb3"],"c84120abb208489fa02365a639464653d793cbb3":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","4a54d9ede1b7f2f026639186eb07f3f314d87d9a","d9a47902d6207303f5ed3e7aaca62ca33433af66"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","d9a47902d6207303f5ed3e7aaca62ca33433af66","e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}