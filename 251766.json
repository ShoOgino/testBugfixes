{"path":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testSortedSubFacetRefinementWhenParentOnlyReturnedByOneShardProcessEmpty().mjava","commits":[{"id":"84a99d9041ffa5585158e5a283ea1736b6b8b473","date":1532019928,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testSortedSubFacetRefinementWhenParentOnlyReturnedByOneShardProcessEmpty().mjava","pathOld":"/dev/null","sourceNew":"  /** @see #testSortedSubFacetRefinementWhenParentOnlyReturnedByOneShard */\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12556\")\n  @Test\n  public void testSortedSubFacetRefinementWhenParentOnlyReturnedByOneShardProcessEmpty() throws Exception {\n    final int numDocs = initSomeDocsWhere1ShardHasOnlyParentFacetField();\n    final Client client = servers.getClient(random().nextInt());\n    final List<SolrClient> clients = client.getClientProvider().all();\n    final int numClients = clients.size();\n    \n    assertTrue(numClients >= 3); // we only use 2, but assert at least 3 to also test empty shard\n    final SolrClient c0 = clients.get(0);\n    final SolrClient c1 = clients.get(1);\n    \n    // if we do the same request as testSortedSubFacetRefinementWhenParentOnlyReturnedByOneShard,\n    // but with processEmpty:true, then ideally we should get the same buckets & counts as before,\n    // but the debug info should indicate that every shard contributed to every bucket (either initially,\n    // or during refinement)\n    //\n    // The problem comes in with how \"empty\" bucket lists are dealt with...\n    // - child debug counts never get higher then '2' because even with the forced \"_l\" refinement of\n    //   the parent buckets against the \"empty\" shards we don't explicitly ask those shards to\n    //   evaluate the child buckets\n    // - perhaps we should reconsider the value of \"_l\" ?\n    //   - why aren't we just specifying all the buckets (and child buckets) chosen in phase#1 using \"_p\" ?\n    //   - or at the very least, if the purpose of \"_l\" is to give other buckets a chance to \"bubble up\"\n    //     in phase#2, then shouldn't a \"_l\" refinement requests still include the buckets choosen in\n    //     phase#1, and request that the shard fill them in in addition to returning it's own top buckets?\n    client.testJQ(params(\"q\", \"*:*\", \"rows\", \"0\", \"json.facet\", \"{\"\n                         + \"processEmpty:true,\"\n                         + \"parent:{ type:terms, field:parent_s, limit:2, overrequest:0, refine:true, facet:{\"\n                         + \"  processEmpty:true,\"\n                         + \"  debug:'debug(numShards)',\"\n                         + \"  child:{ type:terms, field:child_s, limit:2, overrequest:0, refine: true,\"\n                         + \"          facet:{ processEmpty:true, debug:'debug(numShards)' } }\"\n                         + \"} } }\")\n                  , \"facets=={ count: \"+numDocs+\",\"\n                  + \"  parent:{ buckets:[ \"\n                  + \"    { val:pY, count: 24,\"\n                  + \"      debug:\"+numClients+\", \"\n                  + \"      child:{ buckets:[ \"\n                  + \"                   {val:c1,count:3, debug:\"+numClients+\"},\"\n                  + \"                   {val:c0,count:1, debug:\"+numClients+\"},\"\n                  + \"      ] } },\"\n                  + \"    { val:pX, count: 13,\"\n                  + \"      debug:\"+numClients+\", \"\n                  + \"      child:{ buckets:[ \"\n                  + \"                   {val:c0,count:2, debug:\"+numClients+\"},\"\n                  + \"                   {val:c1,count:1, debug:\"+numClients+\"},\"\n                  + \"      ] } },\"\n                  + \"  ] } }\"\n                  );\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c342e04e879b5c549539944338f5ec0ff3000f3","date":1539630497,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testSortedSubFacetRefinementWhenParentOnlyReturnedByOneShardProcessEmpty().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testSortedSubFacetRefinementWhenParentOnlyReturnedByOneShardProcessEmpty().mjava","sourceNew":"  /** @see #testSortedSubFacetRefinementWhenParentOnlyReturnedByOneShard */\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12556\")\n  @Test\n  public void testSortedSubFacetRefinementWhenParentOnlyReturnedByOneShardProcessEmpty() throws Exception {\n    final int numDocs = initSomeDocsWhere1ShardHasOnlyParentFacetField();\n    final Client client = servers.getClient(random().nextInt());\n    final List<SolrClient> clients = client.getClientProvider().all();\n    final int numClients = clients.size();\n    \n    assertTrue(numClients >= 3); // we only use 2, but assert at least 3 to also test empty shard\n    final SolrClient c0 = clients.get(0);\n    final SolrClient c1 = clients.get(1);\n    \n    // if we do the same request as testSortedSubFacetRefinementWhenParentOnlyReturnedByOneShard,\n    // but with processEmpty:true, then ideally we should get the same buckets & counts as before,\n    // but the debug info should indicate that every shard contributed to every bucket (either initially,\n    // or during refinement)\n    //\n    // The problem comes in with how \"empty\" bucket lists are dealt with...\n    // - child debug counts never get higher then '2' because even with the forced \"_l\" refinement of\n    //   the parent buckets against the \"empty\" shards we don't explicitly ask those shards to\n    //   evaluate the child buckets\n    // - perhaps we should reconsider the value of \"_l\" ?\n    //   - why aren't we just specifying all the buckets (and child buckets) chosen in phase#1 using \"_p\" ?\n    //   - or at the very least, if the purpose of \"_l\" is to give other buckets a chance to \"bubble up\"\n    //     in phase#2, then shouldn't a \"_l\" refinement requests still include the buckets choosen in\n    //     phase#1, and request that the shard fill them in in addition to returning its own top buckets?\n    client.testJQ(params(\"q\", \"*:*\", \"rows\", \"0\", \"json.facet\", \"{\"\n                         + \"processEmpty:true,\"\n                         + \"parent:{ type:terms, field:parent_s, limit:2, overrequest:0, refine:true, facet:{\"\n                         + \"  processEmpty:true,\"\n                         + \"  debug:'debug(numShards)',\"\n                         + \"  child:{ type:terms, field:child_s, limit:2, overrequest:0, refine: true,\"\n                         + \"          facet:{ processEmpty:true, debug:'debug(numShards)' } }\"\n                         + \"} } }\")\n                  , \"facets=={ count: \"+numDocs+\",\"\n                  + \"  parent:{ buckets:[ \"\n                  + \"    { val:pY, count: 24,\"\n                  + \"      debug:\"+numClients+\", \"\n                  + \"      child:{ buckets:[ \"\n                  + \"                   {val:c1,count:3, debug:\"+numClients+\"},\"\n                  + \"                   {val:c0,count:1, debug:\"+numClients+\"},\"\n                  + \"      ] } },\"\n                  + \"    { val:pX, count: 13,\"\n                  + \"      debug:\"+numClients+\", \"\n                  + \"      child:{ buckets:[ \"\n                  + \"                   {val:c0,count:2, debug:\"+numClients+\"},\"\n                  + \"                   {val:c1,count:1, debug:\"+numClients+\"},\"\n                  + \"      ] } },\"\n                  + \"  ] } }\"\n                  );\n  }\n\n","sourceOld":"  /** @see #testSortedSubFacetRefinementWhenParentOnlyReturnedByOneShard */\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12556\")\n  @Test\n  public void testSortedSubFacetRefinementWhenParentOnlyReturnedByOneShardProcessEmpty() throws Exception {\n    final int numDocs = initSomeDocsWhere1ShardHasOnlyParentFacetField();\n    final Client client = servers.getClient(random().nextInt());\n    final List<SolrClient> clients = client.getClientProvider().all();\n    final int numClients = clients.size();\n    \n    assertTrue(numClients >= 3); // we only use 2, but assert at least 3 to also test empty shard\n    final SolrClient c0 = clients.get(0);\n    final SolrClient c1 = clients.get(1);\n    \n    // if we do the same request as testSortedSubFacetRefinementWhenParentOnlyReturnedByOneShard,\n    // but with processEmpty:true, then ideally we should get the same buckets & counts as before,\n    // but the debug info should indicate that every shard contributed to every bucket (either initially,\n    // or during refinement)\n    //\n    // The problem comes in with how \"empty\" bucket lists are dealt with...\n    // - child debug counts never get higher then '2' because even with the forced \"_l\" refinement of\n    //   the parent buckets against the \"empty\" shards we don't explicitly ask those shards to\n    //   evaluate the child buckets\n    // - perhaps we should reconsider the value of \"_l\" ?\n    //   - why aren't we just specifying all the buckets (and child buckets) chosen in phase#1 using \"_p\" ?\n    //   - or at the very least, if the purpose of \"_l\" is to give other buckets a chance to \"bubble up\"\n    //     in phase#2, then shouldn't a \"_l\" refinement requests still include the buckets choosen in\n    //     phase#1, and request that the shard fill them in in addition to returning it's own top buckets?\n    client.testJQ(params(\"q\", \"*:*\", \"rows\", \"0\", \"json.facet\", \"{\"\n                         + \"processEmpty:true,\"\n                         + \"parent:{ type:terms, field:parent_s, limit:2, overrequest:0, refine:true, facet:{\"\n                         + \"  processEmpty:true,\"\n                         + \"  debug:'debug(numShards)',\"\n                         + \"  child:{ type:terms, field:child_s, limit:2, overrequest:0, refine: true,\"\n                         + \"          facet:{ processEmpty:true, debug:'debug(numShards)' } }\"\n                         + \"} } }\")\n                  , \"facets=={ count: \"+numDocs+\",\"\n                  + \"  parent:{ buckets:[ \"\n                  + \"    { val:pY, count: 24,\"\n                  + \"      debug:\"+numClients+\", \"\n                  + \"      child:{ buckets:[ \"\n                  + \"                   {val:c1,count:3, debug:\"+numClients+\"},\"\n                  + \"                   {val:c0,count:1, debug:\"+numClients+\"},\"\n                  + \"      ] } },\"\n                  + \"    { val:pX, count: 13,\"\n                  + \"      debug:\"+numClients+\", \"\n                  + \"      child:{ buckets:[ \"\n                  + \"                   {val:c0,count:2, debug:\"+numClients+\"},\"\n                  + \"                   {val:c1,count:1, debug:\"+numClients+\"},\"\n                  + \"      ] } },\"\n                  + \"  ] } }\"\n                  );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"84a99d9041ffa5585158e5a283ea1736b6b8b473":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5c342e04e879b5c549539944338f5ec0ff3000f3":["84a99d9041ffa5585158e5a283ea1736b6b8b473"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5c342e04e879b5c549539944338f5ec0ff3000f3"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["84a99d9041ffa5585158e5a283ea1736b6b8b473"],"84a99d9041ffa5585158e5a283ea1736b6b8b473":["5c342e04e879b5c549539944338f5ec0ff3000f3"],"5c342e04e879b5c549539944338f5ec0ff3000f3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}