{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","commits":[{"id":"10b9c6c42133576daaccbd79bd04c88511b9caca","date":1455930223,"type":0,"author":"jbernste","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","pathOld":"/dev/null","sourceNew":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if(slices == null) {\n        //Try case insensitive match\n        for(String col : clusterState.getCollections()) {\n          if(col.equalsIgnoreCase(collection)) {\n            slices = clusterState.getActiveSlices(col);\n            break;\n          }\n        }\n\n        if(slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      params.put(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = params.get(\"fl\");\n      params.put(\"sort\", \"_version_ asc\");\n      fl += \",_version_\";\n      params.put(\"fl\", fl);\n\n      Random random = new Random();\n\n      for(Slice slice : slices) {\n        Map localParams = new HashMap();\n        localParams.putAll(params);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ab3f83fe809caa1d81a4ed52dfa5372723b348d","date":1458525918,"type":3,"author":"jbernste","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if(slices == null) {\n        //Try case insensitive match\n        for(String col : clusterState.getCollections()) {\n          if(col.equalsIgnoreCase(collection)) {\n            slices = clusterState.getActiveSlices(col);\n            break;\n          }\n        }\n\n        if(slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      params.put(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = params.get(\"fl\");\n      params.put(\"sort\", \"_version_ asc\");\n      if(!fl.contains(\"_version_\")) {\n        fl += \",_version_\";\n      }\n      params.put(\"fl\", fl);\n\n      Random random = new Random();\n\n      for(Slice slice : slices) {\n        Map localParams = new HashMap();\n        localParams.putAll(params);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if(slices == null) {\n        //Try case insensitive match\n        for(String col : clusterState.getCollections()) {\n          if(col.equalsIgnoreCase(collection)) {\n            slices = clusterState.getActiveSlices(col);\n            break;\n          }\n        }\n\n        if(slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      params.put(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = params.get(\"fl\");\n      params.put(\"sort\", \"_version_ asc\");\n      fl += \",_version_\";\n      params.put(\"fl\", fl);\n\n      Random random = new Random();\n\n      for(Slice slice : slices) {\n        Map localParams = new HashMap();\n        localParams.putAll(params);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9974f61802aea1d15849a1053f88f5e89fc32b4","date":1462405923,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if (slices == null) {\n        //Try case insensitive match\n        Map<String, DocCollection> collectionsMap = clusterState.getCollectionsMap();\n        for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n          if (entry.getKey().equalsIgnoreCase(collection)) {\n            slices = entry.getValue().getActiveSlices();\n            break;\n          }\n        }\n\n        if (slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      params.put(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = params.get(\"fl\");\n      params.put(\"sort\", \"_version_ asc\");\n      if(!fl.contains(\"_version_\")) {\n        fl += \",_version_\";\n      }\n      params.put(\"fl\", fl);\n\n      Random random = new Random();\n\n      for(Slice slice : slices) {\n        Map localParams = new HashMap();\n        localParams.putAll(params);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if(slices == null) {\n        //Try case insensitive match\n        for(String col : clusterState.getCollections()) {\n          if(col.equalsIgnoreCase(collection)) {\n            slices = clusterState.getActiveSlices(col);\n            break;\n          }\n        }\n\n        if(slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      params.put(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = params.get(\"fl\");\n      params.put(\"sort\", \"_version_ asc\");\n      if(!fl.contains(\"_version_\")) {\n        fl += \",_version_\";\n      }\n      params.put(\"fl\", fl);\n\n      Random random = new Random();\n\n      for(Slice slice : slices) {\n        Map localParams = new HashMap();\n        localParams.putAll(params);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73450c0955930295d34703e7ddbfc6973b7a121a","date":1462431925,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if (slices == null) {\n        //Try case insensitive match\n        Map<String, DocCollection> collectionsMap = clusterState.getCollectionsMap();\n        for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n          if (entry.getKey().equalsIgnoreCase(collection)) {\n            slices = entry.getValue().getActiveSlices();\n            break;\n          }\n        }\n\n        if (slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      params.put(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = params.get(\"fl\");\n      params.put(\"sort\", \"_version_ asc\");\n      if(!fl.contains(\"_version_\")) {\n        fl += \",_version_\";\n      }\n      params.put(\"fl\", fl);\n\n      Random random = new Random();\n\n      for(Slice slice : slices) {\n        Map localParams = new HashMap();\n        localParams.putAll(params);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if(slices == null) {\n        //Try case insensitive match\n        for(String col : clusterState.getCollections()) {\n          if(col.equalsIgnoreCase(collection)) {\n            slices = clusterState.getActiveSlices(col);\n            break;\n          }\n        }\n\n        if(slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      params.put(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = params.get(\"fl\");\n      params.put(\"sort\", \"_version_ asc\");\n      if(!fl.contains(\"_version_\")) {\n        fl += \",_version_\";\n      }\n      params.put(\"fl\", fl);\n\n      Random random = new Random();\n\n      for(Slice slice : slices) {\n        Map localParams = new HashMap();\n        localParams.putAll(params);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7dc08f02757dd10637b16a5c65eaaef839a91a9a","date":1462455462,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if (slices == null) {\n        //Try case insensitive match\n        Map<String, DocCollection> collectionsMap = clusterState.getCollectionsMap();\n        for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n          if (entry.getKey().equalsIgnoreCase(collection)) {\n            slices = entry.getValue().getActiveSlices();\n            break;\n          }\n        }\n\n        if (slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      params.put(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = params.get(\"fl\");\n      params.put(\"sort\", \"_version_ asc\");\n      if(!fl.contains(\"_version_\")) {\n        fl += \",_version_\";\n      }\n      params.put(\"fl\", fl);\n\n      Random random = new Random();\n\n      for(Slice slice : slices) {\n        Map localParams = new HashMap();\n        localParams.putAll(params);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if(slices == null) {\n        //Try case insensitive match\n        for(String col : clusterState.getCollections()) {\n          if(col.equalsIgnoreCase(collection)) {\n            slices = clusterState.getActiveSlices(col);\n            break;\n          }\n        }\n\n        if(slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      params.put(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = params.get(\"fl\");\n      params.put(\"sort\", \"_version_ asc\");\n      if(!fl.contains(\"_version_\")) {\n        fl += \",_version_\";\n      }\n      params.put(\"fl\", fl);\n\n      Random random = new Random();\n\n      for(Slice slice : slices) {\n        Map localParams = new HashMap();\n        localParams.putAll(params);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","date":1462576651,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if (slices == null) {\n        //Try case insensitive match\n        Map<String, DocCollection> collectionsMap = clusterState.getCollectionsMap();\n        for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n          if (entry.getKey().equalsIgnoreCase(collection)) {\n            slices = entry.getValue().getActiveSlices();\n            break;\n          }\n        }\n\n        if (slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      params.put(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = params.get(\"fl\");\n      params.put(\"sort\", \"_version_ asc\");\n      if(!fl.contains(\"_version_\")) {\n        fl += \",_version_\";\n      }\n      params.put(\"fl\", fl);\n\n      Random random = new Random();\n\n      for(Slice slice : slices) {\n        Map localParams = new HashMap();\n        localParams.putAll(params);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if(slices == null) {\n        //Try case insensitive match\n        for(String col : clusterState.getCollections()) {\n          if(col.equalsIgnoreCase(collection)) {\n            slices = clusterState.getActiveSlices(col);\n            break;\n          }\n        }\n\n        if(slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      params.put(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = params.get(\"fl\");\n      params.put(\"sort\", \"_version_ asc\");\n      if(!fl.contains(\"_version_\")) {\n        fl += \",_version_\";\n      }\n      params.put(\"fl\", fl);\n\n      Random random = new Random();\n\n      for(Slice slice : slices) {\n        Map localParams = new HashMap();\n        localParams.putAll(params);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"826d15444ddf61716dc768c229cd54b2c2ccce1c","date":1462822652,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if (slices == null) {\n        //Try case insensitive match\n        Map<String, DocCollection> collectionsMap = clusterState.getCollectionsMap();\n        for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n          if (entry.getKey().equalsIgnoreCase(collection)) {\n            slices = entry.getValue().getActiveSlices();\n            break;\n          }\n        }\n\n        if (slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params);\n      mParams.set(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = mParams.get(\"fl\");\n      mParams.set(\"sort\", \"_version_ asc\");\n      if(!fl.contains(\"_version_\")) {\n        fl += \",_version_\";\n      }\n      mParams.set(\"fl\", fl);\n\n      Random random = new Random();\n\n      for(Slice slice : slices) {\n        ModifiableSolrParams localParams = new ModifiableSolrParams(mParams);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if (slices == null) {\n        //Try case insensitive match\n        Map<String, DocCollection> collectionsMap = clusterState.getCollectionsMap();\n        for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n          if (entry.getKey().equalsIgnoreCase(collection)) {\n            slices = entry.getValue().getActiveSlices();\n            break;\n          }\n        }\n\n        if (slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      params.put(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = params.get(\"fl\");\n      params.put(\"sort\", \"_version_ asc\");\n      if(!fl.contains(\"_version_\")) {\n        fl += \",_version_\";\n      }\n      params.put(\"fl\", fl);\n\n      Random random = new Random();\n\n      for(Slice slice : slices) {\n        Map localParams = new HashMap();\n        localParams.putAll(params);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e66a459d38c1c4a2f97128433dab546f683a9fed","date":1462873476,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if (slices == null) {\n        //Try case insensitive match\n        Map<String, DocCollection> collectionsMap = clusterState.getCollectionsMap();\n        for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n          if (entry.getKey().equalsIgnoreCase(collection)) {\n            slices = entry.getValue().getActiveSlices();\n            break;\n          }\n        }\n\n        if (slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params);\n      mParams.set(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = mParams.get(\"fl\");\n      mParams.set(\"sort\", \"_version_ asc\");\n      if(!fl.contains(\"_version_\")) {\n        fl += \",_version_\";\n      }\n      mParams.set(\"fl\", fl);\n\n      Random random = new Random();\n\n      for(Slice slice : slices) {\n        ModifiableSolrParams localParams = new ModifiableSolrParams(mParams);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if (slices == null) {\n        //Try case insensitive match\n        Map<String, DocCollection> collectionsMap = clusterState.getCollectionsMap();\n        for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n          if (entry.getKey().equalsIgnoreCase(collection)) {\n            slices = entry.getValue().getActiveSlices();\n            break;\n          }\n        }\n\n        if (slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      params.put(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = params.get(\"fl\");\n      params.put(\"sort\", \"_version_ asc\");\n      if(!fl.contains(\"_version_\")) {\n        fl += \",_version_\";\n      }\n      params.put(\"fl\", fl);\n\n      Random random = new Random();\n\n      for(Slice slice : slices) {\n        Map localParams = new HashMap();\n        localParams.putAll(params);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if (slices == null) {\n        //Try case insensitive match\n        Map<String, DocCollection> collectionsMap = clusterState.getCollectionsMap();\n        for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n          if (entry.getKey().equalsIgnoreCase(collection)) {\n            slices = entry.getValue().getActiveSlices();\n            break;\n          }\n        }\n\n        if (slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params);\n      mParams.set(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = mParams.get(\"fl\");\n      mParams.set(\"sort\", \"_version_ asc\");\n      if(!fl.contains(\"_version_\")) {\n        fl += \",_version_\";\n      }\n      mParams.set(\"fl\", fl);\n\n      Random random = new Random();\n\n      for(Slice slice : slices) {\n        ModifiableSolrParams localParams = new ModifiableSolrParams(mParams);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if (slices == null) {\n        //Try case insensitive match\n        Map<String, DocCollection> collectionsMap = clusterState.getCollectionsMap();\n        for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n          if (entry.getKey().equalsIgnoreCase(collection)) {\n            slices = entry.getValue().getActiveSlices();\n            break;\n          }\n        }\n\n        if (slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      params.put(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = params.get(\"fl\");\n      params.put(\"sort\", \"_version_ asc\");\n      if(!fl.contains(\"_version_\")) {\n        fl += \",_version_\";\n      }\n      params.put(\"fl\", fl);\n\n      Random random = new Random();\n\n      for(Slice slice : slices) {\n        Map localParams = new HashMap();\n        localParams.putAll(params);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"915201312eef398482b3dffe8a297e1809f3b29a","date":1468722990,"type":3,"author":"jbernste","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if (slices == null) {\n        //Try case insensitive match\n        Map<String, DocCollection> collectionsMap = clusterState.getCollectionsMap();\n        for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n          if (entry.getKey().equalsIgnoreCase(collection)) {\n            slices = entry.getValue().getActiveSlices();\n            break;\n          }\n        }\n\n        if (slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n\n      Iterator<String> iterator = params.getParameterNamesIterator();\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params);\n      mParams.set(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = mParams.get(\"fl\");\n      mParams.set(\"sort\", \"_version_ asc\");\n      if(!fl.contains(\"_version_\")) {\n        fl += \",_version_\";\n      }\n      mParams.set(\"fl\", fl);\n\n      Random random = new Random();\n\n      for(Slice slice : slices) {\n        ModifiableSolrParams localParams = new ModifiableSolrParams(mParams);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if (slices == null) {\n        //Try case insensitive match\n        Map<String, DocCollection> collectionsMap = clusterState.getCollectionsMap();\n        for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n          if (entry.getKey().equalsIgnoreCase(collection)) {\n            slices = entry.getValue().getActiveSlices();\n            break;\n          }\n        }\n\n        if (slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params);\n      mParams.set(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = mParams.get(\"fl\");\n      mParams.set(\"sort\", \"_version_ asc\");\n      if(!fl.contains(\"_version_\")) {\n        fl += \",_version_\";\n      }\n      mParams.set(\"fl\", fl);\n\n      Random random = new Random();\n\n      for(Slice slice : slices) {\n        ModifiableSolrParams localParams = new ModifiableSolrParams(mParams);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7acafb1138acd128fde4037d3d5124b66eb07a04","date":1469176018,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n      if (slices == null) slices = getSlicesIgnoreCase(this.collection, clusterState);\n      if (slices == null) {\n        throw new Exception(\"Collection not found:\" + this.collection);\n      }\n\n\n      Iterator<String> iterator = params.getParameterNamesIterator();\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params);\n      mParams.set(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = mParams.get(\"fl\");\n      mParams.set(\"sort\", \"_version_ asc\");\n      if(!fl.contains(\"_version_\")) {\n        fl += \",_version_\";\n      }\n      mParams.set(\"fl\", fl);\n\n      Random random = new Random();\n\n      for(Slice slice : slices) {\n        ModifiableSolrParams localParams = new ModifiableSolrParams(mParams);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if (slices == null) {\n        //Try case insensitive match\n        Map<String, DocCollection> collectionsMap = clusterState.getCollectionsMap();\n        for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n          if (entry.getKey().equalsIgnoreCase(collection)) {\n            slices = entry.getValue().getActiveSlices();\n            break;\n          }\n        }\n\n        if (slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n\n      Iterator<String> iterator = params.getParameterNamesIterator();\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params);\n      mParams.set(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = mParams.get(\"fl\");\n      mParams.set(\"sort\", \"_version_ asc\");\n      if(!fl.contains(\"_version_\")) {\n        fl += \",_version_\";\n      }\n      mParams.set(\"fl\", fl);\n\n      Random random = new Random();\n\n      for(Slice slice : slices) {\n        ModifiableSolrParams localParams = new ModifiableSolrParams(mParams);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n      if (slices == null) slices = getSlicesIgnoreCase(this.collection, clusterState);\n      if (slices == null) {\n        throw new Exception(\"Collection not found:\" + this.collection);\n      }\n\n\n      Iterator<String> iterator = params.getParameterNamesIterator();\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params);\n      mParams.set(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = mParams.get(\"fl\");\n      mParams.set(\"sort\", \"_version_ asc\");\n      if(!fl.contains(\"_version_\")) {\n        fl += \",_version_\";\n      }\n      mParams.set(\"fl\", fl);\n\n      Random random = new Random();\n\n      for(Slice slice : slices) {\n        ModifiableSolrParams localParams = new ModifiableSolrParams(mParams);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n\n      if (slices == null) {\n        //Try case insensitive match\n        Map<String, DocCollection> collectionsMap = clusterState.getCollectionsMap();\n        for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n          if (entry.getKey().equalsIgnoreCase(collection)) {\n            slices = entry.getValue().getActiveSlices();\n            break;\n          }\n        }\n\n        if (slices == null) {\n          throw new Exception(\"Collection not found:\" + this.collection);\n        }\n      }\n\n      params.put(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = params.get(\"fl\");\n      params.put(\"sort\", \"_version_ asc\");\n      if(!fl.contains(\"_version_\")) {\n        fl += \",_version_\";\n      }\n      params.put(\"fl\", fl);\n\n      Random random = new Random();\n\n      for(Slice slice : slices) {\n        Map localParams = new HashMap();\n        localParams.putAll(params);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8c969f15cd04d31e520319c619a445ae21f02d72","date":1479263638,"type":3,"author":"Kevin Risden","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n    try {\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      Collection<Slice> slices = CloudSolrStream.getSlices(this.collection, zkStateReader, false);\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params);\n      mParams.set(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = mParams.get(\"fl\");\n      mParams.set(\"sort\", \"_version_ asc\");\n      if(!fl.contains(\"_version_\")) {\n        fl += \",_version_\";\n      }\n      mParams.set(\"fl\", fl);\n\n      Random random = new Random();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      for(Slice slice : slices) {\n        ModifiableSolrParams localParams = new ModifiableSolrParams(mParams);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList<>();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n      if (slices == null) slices = getSlicesIgnoreCase(this.collection, clusterState);\n      if (slices == null) {\n        throw new Exception(\"Collection not found:\" + this.collection);\n      }\n\n\n      Iterator<String> iterator = params.getParameterNamesIterator();\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params);\n      mParams.set(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = mParams.get(\"fl\");\n      mParams.set(\"sort\", \"_version_ asc\");\n      if(!fl.contains(\"_version_\")) {\n        fl += \",_version_\";\n      }\n      mParams.set(\"fl\", fl);\n\n      Random random = new Random();\n\n      for(Slice slice : slices) {\n        ModifiableSolrParams localParams = new ModifiableSolrParams(mParams);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a1ef55e1fff7ff44354432770ad8bc19be1fcc75","date":1479266056,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n    try {\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      Collection<Slice> slices = CloudSolrStream.getSlices(this.collection, zkStateReader, false);\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params);\n      mParams.set(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = mParams.get(\"fl\");\n      mParams.set(\"sort\", \"_version_ asc\");\n      if(!fl.contains(\"_version_\")) {\n        fl += \",_version_\";\n      }\n      mParams.set(\"fl\", fl);\n\n      Random random = new Random();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      for(Slice slice : slices) {\n        ModifiableSolrParams localParams = new ModifiableSolrParams(mParams);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList<>();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n\n    try {\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      //System.out.println(\"Connected to zk an got cluster state.\");\n\n      Collection<Slice> slices = clusterState.getActiveSlices(this.collection);\n      if (slices == null) slices = getSlicesIgnoreCase(this.collection, clusterState);\n      if (slices == null) {\n        throw new Exception(\"Collection not found:\" + this.collection);\n      }\n\n\n      Iterator<String> iterator = params.getParameterNamesIterator();\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params);\n      mParams.set(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = mParams.get(\"fl\");\n      mParams.set(\"sort\", \"_version_ asc\");\n      if(!fl.contains(\"_version_\")) {\n        fl += \",_version_\";\n      }\n      mParams.set(\"fl\", fl);\n\n      Random random = new Random();\n\n      for(Slice slice : slices) {\n        ModifiableSolrParams localParams = new ModifiableSolrParams(mParams);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6d2dadc1f5ca8703d8659f4964961f9967935d75","date":1490231750,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n    try {\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      Collection<Slice> slices = CloudSolrStream.getSlices(this.collection, zkStateReader, false);\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params);\n      mParams.set(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = mParams.get(\"fl\");\n      mParams.set(\"sort\", \"_version_ asc\");\n      if(!fl.contains(VERSION_FIELD)) {\n        fl += \",_version_\";\n      }\n      mParams.set(\"fl\", fl);\n\n      Random random = new Random();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      for(Slice slice : slices) {\n        ModifiableSolrParams localParams = new ModifiableSolrParams(mParams);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList<>();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n    try {\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      Collection<Slice> slices = CloudSolrStream.getSlices(this.collection, zkStateReader, false);\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params);\n      mParams.set(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = mParams.get(\"fl\");\n      mParams.set(\"sort\", \"_version_ asc\");\n      if(!fl.contains(\"_version_\")) {\n        fl += \",_version_\";\n      }\n      mParams.set(\"fl\", fl);\n\n      Random random = new Random();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      for(Slice slice : slices) {\n        ModifiableSolrParams localParams = new ModifiableSolrParams(mParams);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList<>();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"01624b85de12fb02335810bdf325124e59040772","date":1490254940,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n    try {\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      Collection<Slice> slices = CloudSolrStream.getSlices(this.collection, zkStateReader, false);\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params);\n      mParams.set(DISTRIB, \"false\"); // We are the aggregator.\n      String fl = mParams.get(\"fl\");\n      mParams.set(SORT, \"_version_ asc\");\n      if(!fl.contains(VERSION_FIELD)) {\n        fl += \",_version_\";\n      }\n      mParams.set(\"fl\", fl);\n\n      Random random = new Random();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      for(Slice slice : slices) {\n        ModifiableSolrParams localParams = new ModifiableSolrParams(mParams);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList<>();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n    try {\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      Collection<Slice> slices = CloudSolrStream.getSlices(this.collection, zkStateReader, false);\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params);\n      mParams.set(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = mParams.get(\"fl\");\n      mParams.set(\"sort\", \"_version_ asc\");\n      if(!fl.contains(VERSION_FIELD)) {\n        fl += \",_version_\";\n      }\n      mParams.set(\"fl\", fl);\n\n      Random random = new Random();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      for(Slice slice : slices) {\n        ModifiableSolrParams localParams = new ModifiableSolrParams(mParams);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList<>();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e5fa6615014cd2288fe930f8c8bb726f9504961d","date":1490280013,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n    try {\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      Collection<Slice> slices = CloudSolrStream.getSlices(this.collection, zkStateReader, false);\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params);\n      mParams.set(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = mParams.get(\"fl\");\n      mParams.set(\"sort\", \"_version_ asc\");\n      if(!fl.contains(VERSION_FIELD)) {\n        fl += \",_version_\";\n      }\n      mParams.set(\"fl\", fl);\n\n      Random random = new Random();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      for(Slice slice : slices) {\n        ModifiableSolrParams localParams = new ModifiableSolrParams(mParams);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList<>();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n    try {\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      Collection<Slice> slices = CloudSolrStream.getSlices(this.collection, zkStateReader, false);\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params);\n      mParams.set(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = mParams.get(\"fl\");\n      mParams.set(\"sort\", \"_version_ asc\");\n      if(!fl.contains(\"_version_\")) {\n        fl += \",_version_\";\n      }\n      mParams.set(\"fl\", fl);\n\n      Random random = new Random();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      for(Slice slice : slices) {\n        ModifiableSolrParams localParams = new ModifiableSolrParams(mParams);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList<>();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6f4c5d3859373c3a74734e85efa122b17514e3e8","date":1490280013,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n    try {\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      Collection<Slice> slices = CloudSolrStream.getSlices(this.collection, zkStateReader, false);\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params);\n      mParams.set(DISTRIB, \"false\"); // We are the aggregator.\n      String fl = mParams.get(\"fl\");\n      mParams.set(SORT, \"_version_ asc\");\n      if(!fl.contains(VERSION_FIELD)) {\n        fl += \",_version_\";\n      }\n      mParams.set(\"fl\", fl);\n\n      Random random = new Random();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      for(Slice slice : slices) {\n        ModifiableSolrParams localParams = new ModifiableSolrParams(mParams);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList<>();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n    try {\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      Collection<Slice> slices = CloudSolrStream.getSlices(this.collection, zkStateReader, false);\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params);\n      mParams.set(\"distrib\", \"false\"); // We are the aggregator.\n      String fl = mParams.get(\"fl\");\n      mParams.set(\"sort\", \"_version_ asc\");\n      if(!fl.contains(VERSION_FIELD)) {\n        fl += \",_version_\";\n      }\n      mParams.set(\"fl\", fl);\n\n      Random random = new Random();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      for(Slice slice : slices) {\n        ModifiableSolrParams localParams = new ModifiableSolrParams(mParams);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList<>();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c84df91ca6a2e8d6f26f185663112546a27f6b45","date":1536077760,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TopicStream#constructStreams().mjava","sourceNew":"  protected void constructStreams() throws IOException {\n    try {\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      Slice[] slices = CloudSolrStream.getSlices(this.collection, zkStateReader, false);\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params);\n      mParams.set(DISTRIB, \"false\"); // We are the aggregator.\n      String fl = mParams.get(\"fl\");\n      mParams.set(SORT, \"_version_ asc\");\n      if(!fl.contains(VERSION_FIELD)) {\n        fl += \",_version_\";\n      }\n      mParams.set(\"fl\", fl);\n\n      Random random = new Random();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      for(Slice slice : slices) {\n        ModifiableSolrParams localParams = new ModifiableSolrParams(mParams);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList<>();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  protected void constructStreams() throws IOException {\n    try {\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      Collection<Slice> slices = CloudSolrStream.getSlices(this.collection, zkStateReader, false);\n\n      ModifiableSolrParams mParams = new ModifiableSolrParams(params);\n      mParams.set(DISTRIB, \"false\"); // We are the aggregator.\n      String fl = mParams.get(\"fl\");\n      mParams.set(SORT, \"_version_ asc\");\n      if(!fl.contains(VERSION_FIELD)) {\n        fl += \",_version_\";\n      }\n      mParams.set(\"fl\", fl);\n\n      Random random = new Random();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      for(Slice slice : slices) {\n        ModifiableSolrParams localParams = new ModifiableSolrParams(mParams);\n        long checkpoint = checkpoints.get(slice.getName());\n\n        Collection<Replica> replicas = slice.getReplicas();\n        List<Replica> shuffler = new ArrayList<>();\n        for(Replica replica : replicas) {\n          if(replica.getState() == Replica.State.ACTIVE && liveNodes.contains(replica.getNodeName()))\n            shuffler.add(replica);\n        }\n\n        Replica rep = shuffler.get(random.nextInt(shuffler.size()));\n        ZkCoreNodeProps zkProps = new ZkCoreNodeProps(rep);\n        String url = zkProps.getCoreUrl();\n        SolrStream solrStream = new SolrStream(url, localParams);\n        solrStream.setSlice(slice.getName());\n        solrStream.setCheckpoint(checkpoint);\n        solrStream.setTrace(true);\n        if(streamContext != null) {\n          solrStream.setStreamContext(streamContext);\n        }\n        solrStreams.add(solrStream);\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"10b9c6c42133576daaccbd79bd04c88511b9caca":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c84df91ca6a2e8d6f26f185663112546a27f6b45":["01624b85de12fb02335810bdf325124e59040772"],"73450c0955930295d34703e7ddbfc6973b7a121a":["5ab3f83fe809caa1d81a4ed52dfa5372723b348d","e9974f61802aea1d15849a1053f88f5e89fc32b4"],"7dc08f02757dd10637b16a5c65eaaef839a91a9a":["5ab3f83fe809caa1d81a4ed52dfa5372723b348d","73450c0955930295d34703e7ddbfc6973b7a121a"],"6d2dadc1f5ca8703d8659f4964961f9967935d75":["8c969f15cd04d31e520319c619a445ae21f02d72"],"915201312eef398482b3dffe8a297e1809f3b29a":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"6f4c5d3859373c3a74734e85efa122b17514e3e8":["e5fa6615014cd2288fe930f8c8bb726f9504961d"],"01624b85de12fb02335810bdf325124e59040772":["6d2dadc1f5ca8703d8659f4964961f9967935d75"],"826d15444ddf61716dc768c229cd54b2c2ccce1c":["73450c0955930295d34703e7ddbfc6973b7a121a"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7dc08f02757dd10637b16a5c65eaaef839a91a9a","7acafb1138acd128fde4037d3d5124b66eb07a04"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["73450c0955930295d34703e7ddbfc6973b7a121a","826d15444ddf61716dc768c229cd54b2c2ccce1c"],"e5fa6615014cd2288fe930f8c8bb726f9504961d":["8c969f15cd04d31e520319c619a445ae21f02d72"],"7acafb1138acd128fde4037d3d5124b66eb07a04":["915201312eef398482b3dffe8a297e1809f3b29a"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":["5ab3f83fe809caa1d81a4ed52dfa5372723b348d","73450c0955930295d34703e7ddbfc6973b7a121a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a1ef55e1fff7ff44354432770ad8bc19be1fcc75":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","8c969f15cd04d31e520319c619a445ae21f02d72"],"5ab3f83fe809caa1d81a4ed52dfa5372723b348d":["10b9c6c42133576daaccbd79bd04c88511b9caca"],"e66a459d38c1c4a2f97128433dab546f683a9fed":["a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","826d15444ddf61716dc768c229cd54b2c2ccce1c"],"8c969f15cd04d31e520319c619a445ae21f02d72":["7acafb1138acd128fde4037d3d5124b66eb07a04"],"e9974f61802aea1d15849a1053f88f5e89fc32b4":["5ab3f83fe809caa1d81a4ed52dfa5372723b348d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c84df91ca6a2e8d6f26f185663112546a27f6b45"]},"commit2Childs":{"10b9c6c42133576daaccbd79bd04c88511b9caca":["5ab3f83fe809caa1d81a4ed52dfa5372723b348d"],"c84df91ca6a2e8d6f26f185663112546a27f6b45":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"73450c0955930295d34703e7ddbfc6973b7a121a":["7dc08f02757dd10637b16a5c65eaaef839a91a9a","826d15444ddf61716dc768c229cd54b2c2ccce1c","d470c8182e92b264680e34081b75e70a9f2b3c89","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904"],"7dc08f02757dd10637b16a5c65eaaef839a91a9a":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"6d2dadc1f5ca8703d8659f4964961f9967935d75":["01624b85de12fb02335810bdf325124e59040772"],"915201312eef398482b3dffe8a297e1809f3b29a":["7acafb1138acd128fde4037d3d5124b66eb07a04"],"6f4c5d3859373c3a74734e85efa122b17514e3e8":[],"01624b85de12fb02335810bdf325124e59040772":["c84df91ca6a2e8d6f26f185663112546a27f6b45"],"826d15444ddf61716dc768c229cd54b2c2ccce1c":["d470c8182e92b264680e34081b75e70a9f2b3c89","e66a459d38c1c4a2f97128433dab546f683a9fed"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a1ef55e1fff7ff44354432770ad8bc19be1fcc75"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["915201312eef398482b3dffe8a297e1809f3b29a"],"e5fa6615014cd2288fe930f8c8bb726f9504961d":["6f4c5d3859373c3a74734e85efa122b17514e3e8"],"7acafb1138acd128fde4037d3d5124b66eb07a04":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","8c969f15cd04d31e520319c619a445ae21f02d72"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":["e66a459d38c1c4a2f97128433dab546f683a9fed"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["10b9c6c42133576daaccbd79bd04c88511b9caca"],"a1ef55e1fff7ff44354432770ad8bc19be1fcc75":[],"5ab3f83fe809caa1d81a4ed52dfa5372723b348d":["73450c0955930295d34703e7ddbfc6973b7a121a","7dc08f02757dd10637b16a5c65eaaef839a91a9a","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","e9974f61802aea1d15849a1053f88f5e89fc32b4"],"e66a459d38c1c4a2f97128433dab546f683a9fed":[],"8c969f15cd04d31e520319c619a445ae21f02d72":["6d2dadc1f5ca8703d8659f4964961f9967935d75","e5fa6615014cd2288fe930f8c8bb726f9504961d","a1ef55e1fff7ff44354432770ad8bc19be1fcc75"],"e9974f61802aea1d15849a1053f88f5e89fc32b4":["73450c0955930295d34703e7ddbfc6973b7a121a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["6f4c5d3859373c3a74734e85efa122b17514e3e8","a1ef55e1fff7ff44354432770ad8bc19be1fcc75","e66a459d38c1c4a2f97128433dab546f683a9fed","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}