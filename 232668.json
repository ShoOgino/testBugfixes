{"path":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testNoLostDeletesOnDiskFull().mjava","commits":[{"id":"fe1d440a8af3adcf6846c5eac6dbf55ff5a2ead6","date":1381077139,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testNoLostDeletesOnDiskFull().mjava","pathOld":"/dev/null","sourceNew":"  // Make sure if we hit disk full, and then later disk\n  // frees up, and we successfully close IW or open an NRT\n  // reader, we don't lose any deletes:\n  public void testNoLostDeletesOnDiskFull() throws Exception {\n\n    int deleteCount = 0;\n    int idUpto = 0;\n    int docBase = 0;\n    int docCount = 0;\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    final AtomicBoolean shouldFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n\n          boolean failedAlready;\n\n          @Override\n          public void eval(MockDirectoryWrapper dir) throws IOException {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            if (shouldFail.get()) {\n              for (int i = 0; i < trace.length; i++) {\n                if (\"writeLiveDocs\".equals(trace[i].getMethodName())) {\n                  // Only sometimes throw the exc, so we get\n                  // it sometimes on creating the file, on\n                  // flushing buffer, on closing the file:\n                  if (random().nextInt(3) == 2) {\n                    if (VERBOSE) {\n                      System.out.println(\"TEST: now fail; exc:\");\n                      new Throwable().printStackTrace(System.out);\n                    }\n                    shouldFail.set(false);\n                    throw new IOException(\"now fail on purpose\");\n                  } else {\n                    break;\n                  }\n                }\n              }\n            }\n          }\n      });\n\n    for(int iter=0;iter<10*RANDOM_MULTIPLIER;iter++) {\n      int numDocs = atLeast(100);\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" numDocs=\" + numDocs + \" docBase=\" + docBase);\n      }\n      IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n      IndexWriter w = new IndexWriter(dir, iwc);\n      for(int i=0;i<numDocs;i++) {\n        Document doc = new Document();\n        doc.add(new StringField(\"id\", \"\"+(docBase+i), Field.Store.NO));\n        w.addDocument(doc);\n      }\n      docCount += numDocs;\n\n      // We should hit exc when trying to write the live\n      // docs, here:\n      IndexReader r = w.getReader();\n      assertEquals(docCount-deleteCount, r.numDocs());\n      r.close();\n\n      // TODO: we could also install an infoStream and try\n      // to fail in \"more evil\" places inside BDS\n\n      shouldFail.set(true);\n\n      try {\n\n        for(int i=0;i<numDocs;i++) {\n          if (random().nextInt(10) == 7) {\n            deleteCount++;\n            w.deleteDocuments(new Term(\"id\", \"\"+(docBase+i)));\n          }\n        }\n\n        w.close();\n      } catch (IOException ioe) {\n        // expected\n        if (VERBOSE) {\n          System.out.println(\"TEST: w.close() hit expected IOE\");\n        }\n        // No exception should happen here (we only fail once):\n        w.close();\n      }\n      shouldFail.set(false);\n\n      r = DirectoryReader.open(dir);\n      assertEquals(docCount-deleteCount, r.numDocs());\n      r.close();\n\n      docBase += numDocs;\n    }\n\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0410f464eabc01c2307f73efb86fe169fc022fef","date":1381080042,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testNoLostDeletesOnDiskFull().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testNoLostDeletesOnDiskFull().mjava","sourceNew":"  // Make sure if we hit disk full, and then later disk\n  // frees up, and we successfully close IW or open an NRT\n  // reader, we don't lose any deletes:\n  public void testNoLostDeletesOnDiskFull() throws Exception {\n\n    int deleteCount = 0;\n    int idUpto = 0;\n    int docBase = 0;\n    int docCount = 0;\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    final AtomicBoolean shouldFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n\n          boolean failedAlready;\n\n          @Override\n          public void eval(MockDirectoryWrapper dir) throws IOException {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            if (shouldFail.get()) {\n              for (int i = 0; i < trace.length; i++) {\n                if (\"writeLiveDocs\".equals(trace[i].getMethodName())) {\n                  // Only sometimes throw the exc, so we get\n                  // it sometimes on creating the file, on\n                  // flushing buffer, on closing the file:\n                  if (random().nextInt(3) == 2) {\n                    if (VERBOSE) {\n                      System.out.println(\"TEST: now fail; exc:\");\n                      new Throwable().printStackTrace(System.out);\n                    }\n                    shouldFail.set(false);\n                    throw new IOException(\"now fail on purpose\");\n                  } else {\n                    break;\n                  }\n                }\n              }\n            }\n          }\n      });\n\n    for(int iter=0;iter<10*RANDOM_MULTIPLIER;iter++) {\n      int numDocs = atLeast(100);\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" numDocs=\" + numDocs + \" docBase=\" + docBase);\n      }\n      IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n      IndexWriter w = new IndexWriter(dir, iwc);\n      for(int i=0;i<numDocs;i++) {\n        Document doc = new Document();\n        doc.add(new StringField(\"id\", \"\"+(docBase+i), Field.Store.NO));\n        w.addDocument(doc);\n      }\n      docCount += numDocs;\n\n      IndexReader r = w.getReader();\n      assertEquals(docCount-deleteCount, r.numDocs());\n      r.close();\n\n      // TODO: we could also install an infoStream and try\n      // to fail in \"more evil\" places inside BDS\n\n      shouldFail.set(true);\n\n      try {\n\n        for(int i=0;i<numDocs;i++) {\n          if (random().nextInt(10) == 7) {\n            deleteCount++;\n            w.deleteDocuments(new Term(\"id\", \"\"+(docBase+i)));\n          }\n        }\n\n        w.close();\n      } catch (IOException ioe) {\n        // expected\n        if (VERBOSE) {\n          System.out.println(\"TEST: w.close() hit expected IOE\");\n        }\n        // No exception should happen here (we only fail once):\n        w.close();\n      }\n      shouldFail.set(false);\n\n      r = DirectoryReader.open(dir);\n      assertEquals(docCount-deleteCount, r.numDocs());\n      r.close();\n\n      docBase += numDocs;\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  // Make sure if we hit disk full, and then later disk\n  // frees up, and we successfully close IW or open an NRT\n  // reader, we don't lose any deletes:\n  public void testNoLostDeletesOnDiskFull() throws Exception {\n\n    int deleteCount = 0;\n    int idUpto = 0;\n    int docBase = 0;\n    int docCount = 0;\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    final AtomicBoolean shouldFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n\n          boolean failedAlready;\n\n          @Override\n          public void eval(MockDirectoryWrapper dir) throws IOException {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            if (shouldFail.get()) {\n              for (int i = 0; i < trace.length; i++) {\n                if (\"writeLiveDocs\".equals(trace[i].getMethodName())) {\n                  // Only sometimes throw the exc, so we get\n                  // it sometimes on creating the file, on\n                  // flushing buffer, on closing the file:\n                  if (random().nextInt(3) == 2) {\n                    if (VERBOSE) {\n                      System.out.println(\"TEST: now fail; exc:\");\n                      new Throwable().printStackTrace(System.out);\n                    }\n                    shouldFail.set(false);\n                    throw new IOException(\"now fail on purpose\");\n                  } else {\n                    break;\n                  }\n                }\n              }\n            }\n          }\n      });\n\n    for(int iter=0;iter<10*RANDOM_MULTIPLIER;iter++) {\n      int numDocs = atLeast(100);\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" numDocs=\" + numDocs + \" docBase=\" + docBase);\n      }\n      IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n      IndexWriter w = new IndexWriter(dir, iwc);\n      for(int i=0;i<numDocs;i++) {\n        Document doc = new Document();\n        doc.add(new StringField(\"id\", \"\"+(docBase+i), Field.Store.NO));\n        w.addDocument(doc);\n      }\n      docCount += numDocs;\n\n      // We should hit exc when trying to write the live\n      // docs, here:\n      IndexReader r = w.getReader();\n      assertEquals(docCount-deleteCount, r.numDocs());\n      r.close();\n\n      // TODO: we could also install an infoStream and try\n      // to fail in \"more evil\" places inside BDS\n\n      shouldFail.set(true);\n\n      try {\n\n        for(int i=0;i<numDocs;i++) {\n          if (random().nextInt(10) == 7) {\n            deleteCount++;\n            w.deleteDocuments(new Term(\"id\", \"\"+(docBase+i)));\n          }\n        }\n\n        w.close();\n      } catch (IOException ioe) {\n        // expected\n        if (VERBOSE) {\n          System.out.println(\"TEST: w.close() hit expected IOE\");\n        }\n        // No exception should happen here (we only fail once):\n        w.close();\n      }\n      shouldFail.set(false);\n\n      r = DirectoryReader.open(dir);\n      assertEquals(docCount-deleteCount, r.numDocs());\n      r.close();\n\n      docBase += numDocs;\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"18657edd1527dccc17493ce2d5fcbb8d06456199","date":1381080429,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testNoLostDeletesOnDiskFull().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testNoLostDeletesOnDiskFull().mjava","sourceNew":"  // Make sure if we hit disk full, and then later disk\n  // frees up, and we successfully close IW or open an NRT\n  // reader, we don't lose any deletes:\n  public void testNoLostDeletesOnDiskFull() throws Exception {\n\n    int deleteCount = 0;\n    int idUpto = 0;\n    int docBase = 0;\n    int docCount = 0;\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    final AtomicBoolean shouldFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n\n          @Override\n          public void eval(MockDirectoryWrapper dir) throws IOException {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            if (shouldFail.get()) {\n              for (int i = 0; i < trace.length; i++) {\n                if (\"writeLiveDocs\".equals(trace[i].getMethodName())) {\n                  // Only sometimes throw the exc, so we get\n                  // it sometimes on creating the file, on\n                  // flushing buffer, on closing the file:\n                  if (random().nextInt(3) == 2) {\n                    if (VERBOSE) {\n                      System.out.println(\"TEST: now fail; exc:\");\n                      new Throwable().printStackTrace(System.out);\n                    }\n                    shouldFail.set(false);\n                    throw new FakeIOException();\n                  } else {\n                    break;\n                  }\n                }\n              }\n            }\n          }\n      });\n\n    for(int iter=0;iter<10*RANDOM_MULTIPLIER;iter++) {\n      int numDocs = atLeast(100);\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" numDocs=\" + numDocs + \" docBase=\" + docBase);\n      }\n      IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n      IndexWriter w = new IndexWriter(dir, iwc);\n      for(int i=0;i<numDocs;i++) {\n        Document doc = new Document();\n        doc.add(new StringField(\"id\", \"\"+(docBase+i), Field.Store.NO));\n        w.addDocument(doc);\n      }\n      docCount += numDocs;\n\n      IndexReader r = w.getReader();\n      assertEquals(docCount-deleteCount, r.numDocs());\n      r.close();\n\n      // TODO: we could also install an infoStream and try\n      // to fail in \"more evil\" places inside BDS\n\n      shouldFail.set(true);\n\n      try {\n\n        for(int i=0;i<numDocs;i++) {\n          if (random().nextInt(10) == 7) {\n            deleteCount++;\n            w.deleteDocuments(new Term(\"id\", \"\"+(docBase+i)));\n          }\n        }\n\n        w.close();\n      } catch (FakeIOException ioe) {\n        // expected\n        if (VERBOSE) {\n          System.out.println(\"TEST: w.close() hit expected IOE\");\n        }\n        // No exception should happen here (we only fail once):\n        w.close();\n      }\n      shouldFail.set(false);\n\n      r = DirectoryReader.open(dir);\n      assertEquals(docCount-deleteCount, r.numDocs());\n      r.close();\n\n      docBase += numDocs;\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  // Make sure if we hit disk full, and then later disk\n  // frees up, and we successfully close IW or open an NRT\n  // reader, we don't lose any deletes:\n  public void testNoLostDeletesOnDiskFull() throws Exception {\n\n    int deleteCount = 0;\n    int idUpto = 0;\n    int docBase = 0;\n    int docCount = 0;\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    final AtomicBoolean shouldFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n\n          boolean failedAlready;\n\n          @Override\n          public void eval(MockDirectoryWrapper dir) throws IOException {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            if (shouldFail.get()) {\n              for (int i = 0; i < trace.length; i++) {\n                if (\"writeLiveDocs\".equals(trace[i].getMethodName())) {\n                  // Only sometimes throw the exc, so we get\n                  // it sometimes on creating the file, on\n                  // flushing buffer, on closing the file:\n                  if (random().nextInt(3) == 2) {\n                    if (VERBOSE) {\n                      System.out.println(\"TEST: now fail; exc:\");\n                      new Throwable().printStackTrace(System.out);\n                    }\n                    shouldFail.set(false);\n                    throw new IOException(\"now fail on purpose\");\n                  } else {\n                    break;\n                  }\n                }\n              }\n            }\n          }\n      });\n\n    for(int iter=0;iter<10*RANDOM_MULTIPLIER;iter++) {\n      int numDocs = atLeast(100);\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" numDocs=\" + numDocs + \" docBase=\" + docBase);\n      }\n      IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n      IndexWriter w = new IndexWriter(dir, iwc);\n      for(int i=0;i<numDocs;i++) {\n        Document doc = new Document();\n        doc.add(new StringField(\"id\", \"\"+(docBase+i), Field.Store.NO));\n        w.addDocument(doc);\n      }\n      docCount += numDocs;\n\n      IndexReader r = w.getReader();\n      assertEquals(docCount-deleteCount, r.numDocs());\n      r.close();\n\n      // TODO: we could also install an infoStream and try\n      // to fail in \"more evil\" places inside BDS\n\n      shouldFail.set(true);\n\n      try {\n\n        for(int i=0;i<numDocs;i++) {\n          if (random().nextInt(10) == 7) {\n            deleteCount++;\n            w.deleteDocuments(new Term(\"id\", \"\"+(docBase+i)));\n          }\n        }\n\n        w.close();\n      } catch (IOException ioe) {\n        // expected\n        if (VERBOSE) {\n          System.out.println(\"TEST: w.close() hit expected IOE\");\n        }\n        // No exception should happen here (we only fail once):\n        w.close();\n      }\n      shouldFail.set(false);\n\n      r = DirectoryReader.open(dir);\n      assertEquals(docCount-deleteCount, r.numDocs());\n      r.close();\n\n      docBase += numDocs;\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e40e063ab7548a39715128407a8f36f7a963f62d","date":1381080650,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testNoLostDeletesOnDiskFull().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testNoLostDeletesOnDiskFull().mjava","sourceNew":"  // Make sure if we hit disk full, and then later disk\n  // frees up, and we successfully close IW or open an NRT\n  // reader, we don't lose any deletes:\n  public void testNoLostDeletesOnDiskFull() throws Exception {\n\n    int deleteCount = 0;\n    int docBase = 0;\n    int docCount = 0;\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    final AtomicBoolean shouldFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n\n          @Override\n          public void eval(MockDirectoryWrapper dir) throws IOException {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            if (shouldFail.get()) {\n              for (int i = 0; i < trace.length; i++) {\n                if (\"writeLiveDocs\".equals(trace[i].getMethodName())) {\n                  // Only sometimes throw the exc, so we get\n                  // it sometimes on creating the file, on\n                  // flushing buffer, on closing the file:\n                  if (random().nextInt(3) == 2) {\n                    if (VERBOSE) {\n                      System.out.println(\"TEST: now fail; exc:\");\n                      new Throwable().printStackTrace(System.out);\n                    }\n                    shouldFail.set(false);\n                    throw new FakeIOException();\n                  } else {\n                    break;\n                  }\n                }\n              }\n            }\n          }\n      });\n\n    for(int iter=0;iter<10*RANDOM_MULTIPLIER;iter++) {\n      int numDocs = atLeast(100);\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" numDocs=\" + numDocs + \" docBase=\" + docBase);\n      }\n      IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n      IndexWriter w = new IndexWriter(dir, iwc);\n      for(int i=0;i<numDocs;i++) {\n        Document doc = new Document();\n        doc.add(new StringField(\"id\", \"\"+(docBase+i), Field.Store.NO));\n        w.addDocument(doc);\n      }\n      docCount += numDocs;\n\n      IndexReader r = w.getReader();\n      assertEquals(docCount-deleteCount, r.numDocs());\n      r.close();\n\n      // TODO: we could also install an infoStream and try\n      // to fail in \"more evil\" places inside BDS\n\n      shouldFail.set(true);\n\n      try {\n\n        for(int i=0;i<numDocs;i++) {\n          if (random().nextInt(10) == 7) {\n            deleteCount++;\n            w.deleteDocuments(new Term(\"id\", \"\"+(docBase+i)));\n          }\n        }\n\n        w.close();\n      } catch (FakeIOException ioe) {\n        // expected\n        if (VERBOSE) {\n          System.out.println(\"TEST: w.close() hit expected IOE\");\n        }\n        // No exception should happen here (we only fail once):\n        w.close();\n      }\n      shouldFail.set(false);\n\n      r = DirectoryReader.open(dir);\n      assertEquals(docCount-deleteCount, r.numDocs());\n      r.close();\n\n      docBase += numDocs;\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  // Make sure if we hit disk full, and then later disk\n  // frees up, and we successfully close IW or open an NRT\n  // reader, we don't lose any deletes:\n  public void testNoLostDeletesOnDiskFull() throws Exception {\n\n    int deleteCount = 0;\n    int idUpto = 0;\n    int docBase = 0;\n    int docCount = 0;\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    final AtomicBoolean shouldFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n\n          @Override\n          public void eval(MockDirectoryWrapper dir) throws IOException {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            if (shouldFail.get()) {\n              for (int i = 0; i < trace.length; i++) {\n                if (\"writeLiveDocs\".equals(trace[i].getMethodName())) {\n                  // Only sometimes throw the exc, so we get\n                  // it sometimes on creating the file, on\n                  // flushing buffer, on closing the file:\n                  if (random().nextInt(3) == 2) {\n                    if (VERBOSE) {\n                      System.out.println(\"TEST: now fail; exc:\");\n                      new Throwable().printStackTrace(System.out);\n                    }\n                    shouldFail.set(false);\n                    throw new FakeIOException();\n                  } else {\n                    break;\n                  }\n                }\n              }\n            }\n          }\n      });\n\n    for(int iter=0;iter<10*RANDOM_MULTIPLIER;iter++) {\n      int numDocs = atLeast(100);\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" numDocs=\" + numDocs + \" docBase=\" + docBase);\n      }\n      IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n      IndexWriter w = new IndexWriter(dir, iwc);\n      for(int i=0;i<numDocs;i++) {\n        Document doc = new Document();\n        doc.add(new StringField(\"id\", \"\"+(docBase+i), Field.Store.NO));\n        w.addDocument(doc);\n      }\n      docCount += numDocs;\n\n      IndexReader r = w.getReader();\n      assertEquals(docCount-deleteCount, r.numDocs());\n      r.close();\n\n      // TODO: we could also install an infoStream and try\n      // to fail in \"more evil\" places inside BDS\n\n      shouldFail.set(true);\n\n      try {\n\n        for(int i=0;i<numDocs;i++) {\n          if (random().nextInt(10) == 7) {\n            deleteCount++;\n            w.deleteDocuments(new Term(\"id\", \"\"+(docBase+i)));\n          }\n        }\n\n        w.close();\n      } catch (FakeIOException ioe) {\n        // expected\n        if (VERBOSE) {\n          System.out.println(\"TEST: w.close() hit expected IOE\");\n        }\n        // No exception should happen here (we only fail once):\n        w.close();\n      }\n      shouldFail.set(false);\n\n      r = DirectoryReader.open(dir);\n      assertEquals(docCount-deleteCount, r.numDocs());\n      r.close();\n\n      docBase += numDocs;\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8da3c22a3b1a00ae6e2664f3ac0d82cfa3a8f666","date":1381263930,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testNoLostDeletesOnDiskFull().mjava","sourceNew":null,"sourceOld":"  // Make sure if we hit disk full, and then later disk\n  // frees up, and we successfully close IW or open an NRT\n  // reader, we don't lose any deletes:\n  public void testNoLostDeletesOnDiskFull() throws Exception {\n\n    int deleteCount = 0;\n    int docBase = 0;\n    int docCount = 0;\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    final AtomicBoolean shouldFail = new AtomicBoolean();\n    dir.failOn(new MockDirectoryWrapper.Failure() {\n\n          @Override\n          public void eval(MockDirectoryWrapper dir) throws IOException {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            if (shouldFail.get()) {\n              for (int i = 0; i < trace.length; i++) {\n                if (\"writeLiveDocs\".equals(trace[i].getMethodName())) {\n                  // Only sometimes throw the exc, so we get\n                  // it sometimes on creating the file, on\n                  // flushing buffer, on closing the file:\n                  if (random().nextInt(3) == 2) {\n                    if (VERBOSE) {\n                      System.out.println(\"TEST: now fail; exc:\");\n                      new Throwable().printStackTrace(System.out);\n                    }\n                    shouldFail.set(false);\n                    throw new FakeIOException();\n                  } else {\n                    break;\n                  }\n                }\n              }\n            }\n          }\n      });\n\n    for(int iter=0;iter<10*RANDOM_MULTIPLIER;iter++) {\n      int numDocs = atLeast(100);\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" numDocs=\" + numDocs + \" docBase=\" + docBase);\n      }\n      IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n      IndexWriter w = new IndexWriter(dir, iwc);\n      for(int i=0;i<numDocs;i++) {\n        Document doc = new Document();\n        doc.add(new StringField(\"id\", \"\"+(docBase+i), Field.Store.NO));\n        w.addDocument(doc);\n      }\n      docCount += numDocs;\n\n      IndexReader r = w.getReader();\n      assertEquals(docCount-deleteCount, r.numDocs());\n      r.close();\n\n      // TODO: we could also install an infoStream and try\n      // to fail in \"more evil\" places inside BDS\n\n      shouldFail.set(true);\n\n      try {\n\n        for(int i=0;i<numDocs;i++) {\n          if (random().nextInt(10) == 7) {\n            deleteCount++;\n            w.deleteDocuments(new Term(\"id\", \"\"+(docBase+i)));\n          }\n        }\n\n        w.close();\n      } catch (FakeIOException ioe) {\n        // expected\n        if (VERBOSE) {\n          System.out.println(\"TEST: w.close() hit expected IOE\");\n        }\n        // No exception should happen here (we only fail once):\n        w.close();\n      }\n      shouldFail.set(false);\n\n      r = DirectoryReader.open(dir);\n      assertEquals(docCount-deleteCount, r.numDocs());\n      r.close();\n\n      docBase += numDocs;\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8da3c22a3b1a00ae6e2664f3ac0d82cfa3a8f666":["e40e063ab7548a39715128407a8f36f7a963f62d"],"fe1d440a8af3adcf6846c5eac6dbf55ff5a2ead6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0410f464eabc01c2307f73efb86fe169fc022fef":["fe1d440a8af3adcf6846c5eac6dbf55ff5a2ead6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"18657edd1527dccc17493ce2d5fcbb8d06456199":["0410f464eabc01c2307f73efb86fe169fc022fef"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8da3c22a3b1a00ae6e2664f3ac0d82cfa3a8f666"],"e40e063ab7548a39715128407a8f36f7a963f62d":["18657edd1527dccc17493ce2d5fcbb8d06456199"]},"commit2Childs":{"8da3c22a3b1a00ae6e2664f3ac0d82cfa3a8f666":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fe1d440a8af3adcf6846c5eac6dbf55ff5a2ead6":["0410f464eabc01c2307f73efb86fe169fc022fef"],"0410f464eabc01c2307f73efb86fe169fc022fef":["18657edd1527dccc17493ce2d5fcbb8d06456199"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fe1d440a8af3adcf6846c5eac6dbf55ff5a2ead6"],"18657edd1527dccc17493ce2d5fcbb8d06456199":["e40e063ab7548a39715128407a8f36f7a963f62d"],"e40e063ab7548a39715128407a8f36f7a963f62d":["8da3c22a3b1a00ae6e2664f3ac0d82cfa3a8f666"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}