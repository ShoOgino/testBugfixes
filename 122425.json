{"path":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","commits":[{"id":"da888af1ab894358122a22229051215f58cf4d54","date":1384408702,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","pathOld":"/dev/null","sourceNew":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<Node>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (rule.getExpireAt() >= System.currentTimeMillis()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    if (nodes == null) nodes = new ArrayList<Node>();\n                    Collection<Slice> activeSlices = cstate.getActiveSlices(rule.getTargetCollectionName());\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    // it doesn't matter where we forward it so just choose the first one\n                    // todo this can be optimized\n                    Replica targetLeader = cstate.getLeader(rule.getTargetCollectionName(), activeSlices.iterator().next().getName());\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = ZkNodeProps.makeMap(Overseer.QUEUE_OPERATION, Overseer.REMOVE_ROUTING_RULE,\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreDescriptor().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getInQueue(zkClient);\n                      queue.offer(ZkStateReader.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["344b0840364d990b29b97467bfcc766ff8325d11"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ef0a91e147ef5c263ff965642f847b554b13ba2","date":1386676110,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","sourceNew":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<Node>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (rule.getExpireAt() >= System.currentTimeMillis()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    if (nodes == null) nodes = new ArrayList<Node>();\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = cstate.getLeader(rule.getTargetCollectionName(), activeSlices.iterator().next().getName());\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = ZkNodeProps.makeMap(Overseer.QUEUE_OPERATION, Overseer.REMOVE_ROUTING_RULE,\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreDescriptor().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getInQueue(zkClient);\n                      queue.offer(ZkStateReader.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<Node>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (rule.getExpireAt() >= System.currentTimeMillis()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    if (nodes == null) nodes = new ArrayList<Node>();\n                    Collection<Slice> activeSlices = cstate.getActiveSlices(rule.getTargetCollectionName());\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    // it doesn't matter where we forward it so just choose the first one\n                    // todo this can be optimized\n                    Replica targetLeader = cstate.getLeader(rule.getTargetCollectionName(), activeSlices.iterator().next().getName());\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = ZkNodeProps.makeMap(Overseer.QUEUE_OPERATION, Overseer.REMOVE_ROUTING_RULE,\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreDescriptor().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getInQueue(zkClient);\n                      queue.offer(ZkStateReader.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","sourceNew":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<Node>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (rule.getExpireAt() >= System.currentTimeMillis()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    if (nodes == null) nodes = new ArrayList<Node>();\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = cstate.getLeader(rule.getTargetCollectionName(), activeSlices.iterator().next().getName());\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = ZkNodeProps.makeMap(Overseer.QUEUE_OPERATION, Overseer.REMOVE_ROUTING_RULE,\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreDescriptor().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getInQueue(zkClient);\n                      queue.offer(ZkStateReader.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<Node>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (rule.getExpireAt() >= System.currentTimeMillis()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    if (nodes == null) nodes = new ArrayList<Node>();\n                    Collection<Slice> activeSlices = cstate.getActiveSlices(rule.getTargetCollectionName());\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    // it doesn't matter where we forward it so just choose the first one\n                    // todo this can be optimized\n                    Replica targetLeader = cstate.getLeader(rule.getTargetCollectionName(), activeSlices.iterator().next().getName());\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = ZkNodeProps.makeMap(Overseer.QUEUE_OPERATION, Overseer.REMOVE_ROUTING_RULE,\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreDescriptor().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getInQueue(zkClient);\n                      queue.offer(ZkStateReader.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd5bc858b8426d40bbe90b94120ead37c77d7954","date":1393812525,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","sourceNew":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<Node>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            // TODO: look at using nanoTime\n            if (rule.getExpireAt() >= System.currentTimeMillis()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    if (nodes == null) nodes = new ArrayList<Node>();\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = cstate.getLeader(rule.getTargetCollectionName(), activeSlices.iterator().next().getName());\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = ZkNodeProps.makeMap(Overseer.QUEUE_OPERATION, Overseer.REMOVE_ROUTING_RULE,\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreDescriptor().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getInQueue(zkClient);\n                      queue.offer(ZkStateReader.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<Node>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (rule.getExpireAt() >= System.currentTimeMillis()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    if (nodes == null) nodes = new ArrayList<Node>();\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = cstate.getLeader(rule.getTargetCollectionName(), activeSlices.iterator().next().getName());\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = ZkNodeProps.makeMap(Overseer.QUEUE_OPERATION, Overseer.REMOVE_ROUTING_RULE,\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreDescriptor().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getInQueue(zkClient);\n                      queue.offer(ZkStateReader.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","sourceNew":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            // TODO: look at using nanoTime\n            if (rule.getExpireAt() >= System.currentTimeMillis()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    if (nodes == null) nodes = new ArrayList<>();\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = cstate.getLeader(rule.getTargetCollectionName(), activeSlices.iterator().next().getName());\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = ZkNodeProps.makeMap(Overseer.QUEUE_OPERATION, Overseer.REMOVE_ROUTING_RULE,\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreDescriptor().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getInQueue(zkClient);\n                      queue.offer(ZkStateReader.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<Node>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            // TODO: look at using nanoTime\n            if (rule.getExpireAt() >= System.currentTimeMillis()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    if (nodes == null) nodes = new ArrayList<Node>();\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = cstate.getLeader(rule.getTargetCollectionName(), activeSlices.iterator().next().getName());\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = ZkNodeProps.makeMap(Overseer.QUEUE_OPERATION, Overseer.REMOVE_ROUTING_RULE,\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreDescriptor().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getInQueue(zkClient);\n                      queue.offer(ZkStateReader.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"30c688f7052130cef7bd419c85e3c5be214f7b9e","date":1411018984,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","sourceNew":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            // TODO: look at using nanoTime\n            if (rule.getExpireAt() >= System.currentTimeMillis()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    if (nodes == null) nodes = new ArrayList<>();\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = cstate.getLeader(rule.getTargetCollectionName(), activeSlices.iterator().next().getName());\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = ZkNodeProps.makeMap(Overseer.QUEUE_OPERATION, Overseer.OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreDescriptor().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getInQueue(zkClient);\n                      queue.offer(ZkStateReader.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            // TODO: look at using nanoTime\n            if (rule.getExpireAt() >= System.currentTimeMillis()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    if (nodes == null) nodes = new ArrayList<>();\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = cstate.getLeader(rule.getTargetCollectionName(), activeSlices.iterator().next().getName());\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = ZkNodeProps.makeMap(Overseer.QUEUE_OPERATION, Overseer.REMOVE_ROUTING_RULE,\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreDescriptor().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getInQueue(zkClient);\n                      queue.offer(ZkStateReader.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"24a5da2a0d397ff29f3de8f6cf451d3412c2509a","date":1417276391,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","sourceNew":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            // TODO: look at using nanoTime\n            if (rule.getExpireAt() >= System.currentTimeMillis()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    if (nodes == null) nodes = new ArrayList<>();\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = cstate.getLeader(rule.getTargetCollectionName(), activeSlices.iterator().next().getName());\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = ZkNodeProps.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreDescriptor().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getInQueue(zkClient);\n                      queue.offer(ZkStateReader.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            // TODO: look at using nanoTime\n            if (rule.getExpireAt() >= System.currentTimeMillis()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    if (nodes == null) nodes = new ArrayList<>();\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = cstate.getLeader(rule.getTargetCollectionName(), activeSlices.iterator().next().getName());\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = ZkNodeProps.makeMap(Overseer.QUEUE_OPERATION, Overseer.OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreDescriptor().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getInQueue(zkClient);\n                      queue.offer(ZkStateReader.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b693a83132c9e45afcd564fd65a25b60ed80388b","date":1436882146,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","sourceNew":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            // TODO: look at using nanoTime\n            if (rule.getExpireAt() >= System.currentTimeMillis()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    if (nodes == null) nodes = new ArrayList<>();\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = cstate.getLeader(rule.getTargetCollectionName(), activeSlices.iterator().next().getName());\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreDescriptor().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getInQueue(zkClient);\n                      queue.offer(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            // TODO: look at using nanoTime\n            if (rule.getExpireAt() >= System.currentTimeMillis()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    if (nodes == null) nodes = new ArrayList<>();\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = cstate.getLeader(rule.getTargetCollectionName(), activeSlices.iterator().next().getName());\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = ZkNodeProps.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreDescriptor().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getInQueue(zkClient);\n                      queue.offer(ZkStateReader.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bcf9886c8ff537aafde14de48ebf744f5673f08b","date":1439041198,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","sourceNew":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    if (nodes == null) nodes = new ArrayList<>();\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = cstate.getLeader(rule.getTargetCollectionName(), activeSlices.iterator().next().getName());\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreDescriptor().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getInQueue(zkClient);\n                      queue.offer(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            // TODO: look at using nanoTime\n            if (rule.getExpireAt() >= System.currentTimeMillis()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    if (nodes == null) nodes = new ArrayList<>();\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = cstate.getLeader(rule.getTargetCollectionName(), activeSlices.iterator().next().getName());\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreDescriptor().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getInQueue(zkClient);\n                      queue.offer(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7350fba633b826986454e97668c5ad03b46bcaca","date":1446484423,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","sourceNew":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = cstate.getLeader(rule.getTargetCollectionName(), activeSlices.iterator().next().getName());\n                    if (nodes == null) nodes = new ArrayList<>(1);\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreDescriptor().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getInQueue(zkClient);\n                      queue.offer(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    if (nodes == null) nodes = new ArrayList<>();\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = cstate.getLeader(rule.getTargetCollectionName(), activeSlices.iterator().next().getName());\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreDescriptor().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getInQueue(zkClient);\n                      queue.offer(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"19498030e0adab22f604f935cae3c03dcf0952a6","date":1456558851,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","sourceNew":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = cstate.getLeader(rule.getTargetCollectionName(), activeSlices.iterator().next().getName());\n                    if (nodes == null) nodes = new ArrayList<>(1);\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreDescriptor().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getStateUpdateQueue(zkClient);\n                      queue.offer(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = cstate.getLeader(rule.getTargetCollectionName(), activeSlices.iterator().next().getName());\n                    if (nodes == null) nodes = new ArrayList<>(1);\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreDescriptor().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getInQueue(zkClient);\n                      queue.offer(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","sourceNew":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = cstate.getLeader(rule.getTargetCollectionName(), activeSlices.iterator().next().getName());\n                    if (nodes == null) nodes = new ArrayList<>(1);\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreDescriptor().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getStateUpdateQueue(zkClient);\n                      queue.offer(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = cstate.getLeader(rule.getTargetCollectionName(), activeSlices.iterator().next().getName());\n                    if (nodes == null) nodes = new ArrayList<>(1);\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreDescriptor().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getInQueue(zkClient);\n                      queue.offer(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"04c8df3f10a676c3de5dbf390f17a2de2d45cacd","date":1461615626,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","sourceNew":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = targetColl.getLeader(activeSlices.iterator().next().getName());\n                    nodes = new ArrayList<>(1);\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreDescriptor().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getStateUpdateQueue(zkClient);\n                      queue.offer(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = cstate.getLeader(rule.getTargetCollectionName(), activeSlices.iterator().next().getName());\n                    if (nodes == null) nodes = new ArrayList<>(1);\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreDescriptor().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getStateUpdateQueue(zkClient);\n                      queue.offer(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f7f901826e47f75f810d7aae24b0455d21ea1fe2","date":1461678892,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","sourceNew":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = targetColl.getLeader(activeSlices.iterator().next().getName());\n                    nodes = new ArrayList<>(1);\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreDescriptor().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getStateUpdateQueue(zkClient);\n                      queue.offer(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = cstate.getLeader(rule.getTargetCollectionName(), activeSlices.iterator().next().getName());\n                    if (nodes == null) nodes = new ArrayList<>(1);\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreDescriptor().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getStateUpdateQueue(zkClient);\n                      queue.offer(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"729cb470f975115d4c60517b2cb7c42e37a7a2e1","date":1492041760,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","sourceNew":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = targetColl.getLeader(activeSlices.iterator().next().getName());\n                    nodes = new ArrayList<>(1);\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getStateUpdateQueue(zkClient);\n                      queue.offer(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = targetColl.getLeader(activeSlices.iterator().next().getName());\n                    nodes = new ArrayList<>(1);\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreDescriptor().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getStateUpdateQueue(zkClient);\n                      queue.offer(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","sourceNew":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = targetColl.getLeader(activeSlices.iterator().next().getName());\n                    nodes = new ArrayList<>(1);\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getStateUpdateQueue(zkClient);\n                      queue.offer(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = targetColl.getLeader(activeSlices.iterator().next().getName());\n                    nodes = new ArrayList<>(1);\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreDescriptor().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getStateUpdateQueue(zkClient);\n                      queue.offer(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"344b0840364d990b29b97467bfcc766ff8325d11","date":1501574100,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","sourceNew":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            final DocCollection docCollection = cstate.getCollectionOrNull(targetCollectionName);\n            if (docCollection != null && docCollection.getActiveSlices() != null && !docCollection.getActiveSlices().isEmpty()) {\n              final Collection<Slice> activeSlices = docCollection.getActiveSlices();\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = targetColl.getLeader(activeSlices.iterator().next().getName());\n                    nodes = new ArrayList<>(1);\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getStateUpdateQueue(zkClient);\n                      queue.offer(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = targetColl.getLeader(activeSlices.iterator().next().getName());\n                    nodes = new ArrayList<>(1);\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getStateUpdateQueue(zkClient);\n                      queue.offer(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","bugFix":["da888af1ab894358122a22229051215f58cf4d54"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","sourceNew":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            final DocCollection docCollection = cstate.getCollectionOrNull(targetCollectionName);\n            if (docCollection != null && docCollection.getActiveSlices() != null && !docCollection.getActiveSlices().isEmpty()) {\n              final Collection<Slice> activeSlices = docCollection.getActiveSlices();\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = targetColl.getLeader(activeSlices.iterator().next().getName());\n                    nodes = new ArrayList<>(1);\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getStateUpdateQueue(zkClient);\n                      queue.offer(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            Collection<Slice> activeSlices = cstate.getActiveSlices(targetCollectionName);\n            if (activeSlices != null && !activeSlices.isEmpty()) {\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = targetColl.getLeader(activeSlices.iterator().next().getName());\n                    nodes = new ArrayList<>(1);\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getStateUpdateQueue(zkClient);\n                      queue.offer(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"601f914e4448cab7640fecfb5d15f8f2e2af0bf6","date":1508947828,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","sourceNew":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = cloudDesc.getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            final DocCollection docCollection = cstate.getCollectionOrNull(targetCollectionName);\n            if (docCollection != null && docCollection.getActiveSlices() != null && !docCollection.getActiveSlices().isEmpty()) {\n              final Collection<Slice> activeSlices = docCollection.getActiveSlices();\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = targetColl.getLeader(activeSlices.iterator().next().getName());\n                    nodes = new ArrayList<>(1);\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getStateUpdateQueue(zkClient);\n                      queue.offer(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            final DocCollection docCollection = cstate.getCollectionOrNull(targetCollectionName);\n            if (docCollection != null && docCollection.getActiveSlices() != null && !docCollection.getActiveSlices().isEmpty()) {\n              final Collection<Slice> activeSlices = docCollection.getActiveSlices();\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = targetColl.getLeader(activeSlices.iterator().next().getName());\n                    nodes = new ArrayList<>(1);\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getStateUpdateQueue(zkClient);\n                      queue.offer(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad55ff45b3a5483090d87a63019d0e6a8d4b5a65","date":1509551229,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","sourceNew":"  /** For {@link CollectionParams.CollectionAction#MIGRATE} */\n  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = cloudDesc.getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            final DocCollection docCollection = cstate.getCollectionOrNull(targetCollectionName);\n            if (docCollection != null && docCollection.getActiveSlices() != null && !docCollection.getActiveSlices().isEmpty()) {\n              final Collection<Slice> activeSlices = docCollection.getActiveSlices();\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = targetColl.getLeader(activeSlices.iterator().next().getName());\n                    nodes = new ArrayList<>(1);\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = zkController.getZkClient();\n                      DistributedQueue queue = Overseer.getStateUpdateQueue(zkClient);\n                      queue.offer(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":"  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = cloudDesc.getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            final DocCollection docCollection = cstate.getCollectionOrNull(targetCollectionName);\n            if (docCollection != null && docCollection.getActiveSlices() != null && !docCollection.getActiveSlices().isEmpty()) {\n              final Collection<Slice> activeSlices = docCollection.getActiveSlices();\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = targetColl.getLeader(activeSlices.iterator().next().getName());\n                    nodes = new ArrayList<>(1);\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = req.getCore().getCoreContainer().getZkController().getZkClient();\n                      DistributedQueue queue = Overseer.getStateUpdateQueue(zkClient);\n                      queue.offer(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c3f27bd66feacd34399839572de1b2e927d4f367","date":1509582546,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","sourceNew":"  /** For {@link org.apache.solr.common.params.CollectionParams.CollectionAction#MIGRATE} */\n  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = cloudDesc.getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            final DocCollection docCollection = cstate.getCollectionOrNull(targetCollectionName);\n            if (docCollection != null && docCollection.getActiveSlices() != null && !docCollection.getActiveSlices().isEmpty()) {\n              final Collection<Slice> activeSlices = docCollection.getActiveSlices();\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = targetColl.getLeader(activeSlices.iterator().next().getName());\n                    nodes = new ArrayList<>(1);\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = zkController.getZkClient();\n                      DistributedQueue queue = Overseer.getStateUpdateQueue(zkClient);\n                      queue.offer(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":"  /** For {@link CollectionParams.CollectionAction#MIGRATE} */\n  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = cloudDesc.getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            final DocCollection docCollection = cstate.getCollectionOrNull(targetCollectionName);\n            if (docCollection != null && docCollection.getActiveSlices() != null && !docCollection.getActiveSlices().isEmpty()) {\n              final Collection<Slice> activeSlices = docCollection.getActiveSlices();\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = targetColl.getLeader(activeSlices.iterator().next().getName());\n                    nodes = new ArrayList<>(1);\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = zkController.getZkClient();\n                      DistributedQueue queue = Overseer.getStateUpdateQueue(zkClient);\n                      queue.offer(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c84df91ca6a2e8d6f26f185663112546a27f6b45","date":1536077760,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","sourceNew":"  /** For {@link org.apache.solr.common.params.CollectionParams.CollectionAction#MIGRATE} */\n  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = cloudDesc.getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            final DocCollection docCollection = cstate.getCollectionOrNull(targetCollectionName);\n            if (docCollection != null && docCollection.getActiveSlicesArr().length > 0) {\n              final Slice[] activeSlices = docCollection.getActiveSlicesArr();\n              Slice any = activeSlices[0];\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = targetColl.getLeader(activeSlices.iterator().next().getName());\n                    nodes = new ArrayList<>(1);\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = zkController.getZkClient();\n                      DistributedQueue queue = Overseer.getStateUpdateQueue(zkClient);\n                      queue.offer(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":"  /** For {@link org.apache.solr.common.params.CollectionParams.CollectionAction#MIGRATE} */\n  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = cloudDesc.getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            final DocCollection docCollection = cstate.getCollectionOrNull(targetCollectionName);\n            if (docCollection != null && docCollection.getActiveSlices() != null && !docCollection.getActiveSlices().isEmpty()) {\n              final Collection<Slice> activeSlices = docCollection.getActiveSlices();\n              Slice any = activeSlices.iterator().next();\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = targetColl.getLeader(activeSlices.iterator().next().getName());\n                    nodes = new ArrayList<>(1);\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = zkController.getZkClient();\n                      DistributedQueue queue = Overseer.getStateUpdateQueue(zkClient);\n                      queue.offer(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","sourceNew":"  /** For {@link org.apache.solr.common.params.CollectionParams.CollectionAction#MIGRATE} */\n  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = cloudDesc.getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            final DocCollection docCollection = cstate.getCollectionOrNull(targetCollectionName);\n            if (docCollection != null && docCollection.getActiveSlicesArr().length > 0) {\n              final Slice[] activeSlices = docCollection.getActiveSlicesArr();\n              Slice any = activeSlices[0];\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = targetColl.getLeader(activeSlices.iterator().next().getName());\n                    nodes = new ArrayList<>(1);\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = zkController.getZkClient();\n                      zkController.getOverseer().offerStateUpdate(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":"  /** For {@link org.apache.solr.common.params.CollectionParams.CollectionAction#MIGRATE} */\n  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = cloudDesc.getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            final DocCollection docCollection = cstate.getCollectionOrNull(targetCollectionName);\n            if (docCollection != null && docCollection.getActiveSlicesArr().length > 0) {\n              final Slice[] activeSlices = docCollection.getActiveSlicesArr();\n              Slice any = activeSlices[0];\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = targetColl.getLeader(activeSlices.iterator().next().getName());\n                    nodes = new ArrayList<>(1);\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = zkController.getZkClient();\n                      DistributedQueue queue = Overseer.getStateUpdateQueue(zkClient);\n                      queue.offer(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","bugFix":["b693a83132c9e45afcd564fd65a25b60ed80388b","19498030e0adab22f604f935cae3c03dcf0952a6"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b25c66490468a167b569a0466630020b7ffbb76","date":1549481515,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","sourceNew":"  /** For {@link org.apache.solr.common.params.CollectionParams.CollectionAction#MIGRATE} */\n  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = cloudDesc.getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            final DocCollection docCollection = cstate.getCollectionOrNull(targetCollectionName);\n            if (docCollection != null && docCollection.getActiveSlicesArr().length > 0) {\n              final Slice[] activeSlices = docCollection.getActiveSlicesArr();\n              Slice any = activeSlices[0];\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = targetColl.getLeader(activeSlices.iterator().next().getName());\n                    nodes = new ArrayList<>(1);\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      zkController.getOverseer().offerStateUpdate(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":"  /** For {@link org.apache.solr.common.params.CollectionParams.CollectionAction#MIGRATE} */\n  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = cloudDesc.getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            final DocCollection docCollection = cstate.getCollectionOrNull(targetCollectionName);\n            if (docCollection != null && docCollection.getActiveSlicesArr().length > 0) {\n              final Slice[] activeSlices = docCollection.getActiveSlicesArr();\n              Slice any = activeSlices[0];\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = targetColl.getLeader(activeSlices.iterator().next().getName());\n                    nodes = new ArrayList<>(1);\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      SolrZkClient zkClient = zkController.getZkClient();\n                      zkController.getOverseer().offerStateUpdate(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9d70e774cb25c8a8d2c3e5e84200f235f9168d87","date":1553016391,"type":5,"author":"Bar Rotstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedZkUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getNodesByRoutingRules(ClusterState,DocCollection,String,SolrInputDocument).mjava","sourceNew":"  /** For {@link org.apache.solr.common.params.CollectionParams.CollectionAction#MIGRATE} */\n  protected List<SolrCmdDistributor.Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<SolrCmdDistributor.Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = cloudDesc.getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Map.Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            final DocCollection docCollection = cstate.getCollectionOrNull(targetCollectionName);\n            if (docCollection != null && docCollection.getActiveSlicesArr().length > 0) {\n              final Slice[] activeSlices = docCollection.getActiveSlicesArr();\n              Slice any = activeSlices[0];\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new SolrCmdDistributor.StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = targetColl.getLeader(activeSlices.iterator().next().getName());\n                    nodes = new ArrayList<>(1);\n                    nodes.add(new SolrCmdDistributor.StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      zkController.getOverseer().offerStateUpdate(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","sourceOld":"  /** For {@link org.apache.solr.common.params.CollectionParams.CollectionAction#MIGRATE} */\n  private List<Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = cloudDesc.getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n\n        // delete by query case\n        if (id == null) {\n          for (Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            final DocCollection docCollection = cstate.getCollectionOrNull(targetCollectionName);\n            if (docCollection != null && docCollection.getActiveSlicesArr().length > 0) {\n              final Slice[] activeSlices = docCollection.getActiveSlicesArr();\n              Slice any = activeSlices[0];\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = targetColl.getLeader(activeSlices.iterator().next().getName());\n                    nodes = new ArrayList<>(1);\n                    nodes.add(new StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      zkController.getOverseer().offerStateUpdate(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"af2638813028b254a88b418ebeafb541afb49653":["7350fba633b826986454e97668c5ad03b46bcaca","19498030e0adab22f604f935cae3c03dcf0952a6"],"c84df91ca6a2e8d6f26f185663112546a27f6b45":["c3f27bd66feacd34399839572de1b2e927d4f367"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["c84df91ca6a2e8d6f26f185663112546a27f6b45"],"ad55ff45b3a5483090d87a63019d0e6a8d4b5a65":["601f914e4448cab7640fecfb5d15f8f2e2af0bf6"],"344b0840364d990b29b97467bfcc766ff8325d11":["729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["af2638813028b254a88b418ebeafb541afb49653","04c8df3f10a676c3de5dbf390f17a2de2d45cacd"],"30c688f7052130cef7bd419c85e3c5be214f7b9e":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"fd5bc858b8426d40bbe90b94120ead37c77d7954":["5ef0a91e147ef5c263ff965642f847b554b13ba2"],"5ef0a91e147ef5c263ff965642f847b554b13ba2":["da888af1ab894358122a22229051215f58cf4d54"],"24a5da2a0d397ff29f3de8f6cf451d3412c2509a":["30c688f7052130cef7bd419c85e3c5be214f7b9e"],"601f914e4448cab7640fecfb5d15f8f2e2af0bf6":["344b0840364d990b29b97467bfcc766ff8325d11"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c3f27bd66feacd34399839572de1b2e927d4f367":["ad55ff45b3a5483090d87a63019d0e6a8d4b5a65"],"7350fba633b826986454e97668c5ad03b46bcaca":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["fd5bc858b8426d40bbe90b94120ead37c77d7954"],"b693a83132c9e45afcd564fd65a25b60ed80388b":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"04c8df3f10a676c3de5dbf390f17a2de2d45cacd":["af2638813028b254a88b418ebeafb541afb49653"],"da888af1ab894358122a22229051215f58cf4d54":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"19498030e0adab22f604f935cae3c03dcf0952a6":["7350fba633b826986454e97668c5ad03b46bcaca"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","344b0840364d990b29b97467bfcc766ff8325d11"],"6b25c66490468a167b569a0466630020b7ffbb76":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["da888af1ab894358122a22229051215f58cf4d54","5ef0a91e147ef5c263ff965642f847b554b13ba2"],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["b693a83132c9e45afcd564fd65a25b60ed80388b"],"9d70e774cb25c8a8d2c3e5e84200f235f9168d87":["6b25c66490468a167b569a0466630020b7ffbb76"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9d70e774cb25c8a8d2c3e5e84200f235f9168d87"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"af2638813028b254a88b418ebeafb541afb49653":["f7f901826e47f75f810d7aae24b0455d21ea1fe2","04c8df3f10a676c3de5dbf390f17a2de2d45cacd"],"c84df91ca6a2e8d6f26f185663112546a27f6b45":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["6b25c66490468a167b569a0466630020b7ffbb76"],"ad55ff45b3a5483090d87a63019d0e6a8d4b5a65":["c3f27bd66feacd34399839572de1b2e927d4f367"],"344b0840364d990b29b97467bfcc766ff8325d11":["601f914e4448cab7640fecfb5d15f8f2e2af0bf6","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"30c688f7052130cef7bd419c85e3c5be214f7b9e":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a"],"fd5bc858b8426d40bbe90b94120ead37c77d7954":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"5ef0a91e147ef5c263ff965642f847b554b13ba2":["fd5bc858b8426d40bbe90b94120ead37c77d7954","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"24a5da2a0d397ff29f3de8f6cf451d3412c2509a":["b693a83132c9e45afcd564fd65a25b60ed80388b"],"601f914e4448cab7640fecfb5d15f8f2e2af0bf6":["ad55ff45b3a5483090d87a63019d0e6a8d4b5a65"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["da888af1ab894358122a22229051215f58cf4d54"],"7350fba633b826986454e97668c5ad03b46bcaca":["af2638813028b254a88b418ebeafb541afb49653","19498030e0adab22f604f935cae3c03dcf0952a6"],"c3f27bd66feacd34399839572de1b2e927d4f367":["c84df91ca6a2e8d6f26f185663112546a27f6b45"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["30c688f7052130cef7bd419c85e3c5be214f7b9e"],"b693a83132c9e45afcd564fd65a25b60ed80388b":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["344b0840364d990b29b97467bfcc766ff8325d11"],"04c8df3f10a676c3de5dbf390f17a2de2d45cacd":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"da888af1ab894358122a22229051215f58cf4d54":["5ef0a91e147ef5c263ff965642f847b554b13ba2","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"19498030e0adab22f604f935cae3c03dcf0952a6":["af2638813028b254a88b418ebeafb541afb49653"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":[],"6b25c66490468a167b569a0466630020b7ffbb76":["9d70e774cb25c8a8d2c3e5e84200f235f9168d87"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["7350fba633b826986454e97668c5ad03b46bcaca"],"9d70e774cb25c8a8d2c3e5e84200f235f9168d87":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}