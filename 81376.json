{"path":"lucene/core/src/java/org/apache/lucene/util/RamUsageEstimator#adjustForField(long,Field).mjava","commits":[{"id":"10cd47aac3c4e8c583740a750335f8aab14555b3","date":1332522358,"type":1,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/RamUsageEstimator#adjustForField(long,Field).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/RamUsageEstimator#reflectFieldSize(long,Field).mjava","sourceNew":"  /**\n   * This method returns the maximum representation size of an object. <code>sizeSoFar</code>\n   * is the object's size measured so far. <code>f</code> is the field being probed.\n   * \n   * <p>The returned offset will be the maximum of whatever was measured so far and \n   * <code>f</code> field's offset and representation size (unaligned).\n   */\n  private static long adjustForField(long sizeSoFar, final Field f) {\n    final Class<?> type = f.getType();\n    final int fsize = type.isPrimitive() ? primitiveSizes.get(type) : NUM_BYTES_OBJECT_REF;\n    if (objectFieldOffsetMethod != null) {\n      try {\n        final long offsetPlusSize =\n          ((Number) objectFieldOffsetMethod.invoke(theUnsafe, f)).longValue() + fsize;\n        return Math.max(sizeSoFar, offsetPlusSize);\n      } catch (IllegalAccessException ex) {\n        throw new RuntimeException(\"Access problem with sun.misc.Unsafe\", ex);\n      } catch (InvocationTargetException ite) {\n        final Throwable cause = ite.getCause();\n        if (cause instanceof RuntimeException)\n          throw (RuntimeException) cause;\n        if (cause instanceof Error)\n          throw (Error) cause;\n        // this should never happen (Unsafe does not declare\n        // checked Exceptions for this method), but who knows?\n        throw new RuntimeException(\"Call to Unsafe's objectFieldOffset() throwed \"+\n          \"checked Exception when accessing field \" +\n          f.getDeclaringClass().getName() + \"#\" + f.getName(), cause);\n      }\n    } else {\n      // TODO: No alignments based on field type/ subclass fields alignments?\n      return sizeSoFar + fsize;\n    }\n  }\n\n","sourceOld":"  private static long reflectFieldSize(long size, final Field f) {\n    final Class<?> type = f.getType();\n    final int fsize = type.isPrimitive() ? primitiveSizes.get(type) : NUM_BYTES_OBJECT_REF;\n    if (useUnsafe) {\n      try {\n        final long offsetPlusSize =\n          ((Number) objectFieldOffsetMethod.invoke(theUnsafe, f)).longValue() + fsize;\n        return Math.max(size, offsetPlusSize);\n      } catch (IllegalAccessException ex) {\n        throw new RuntimeException(\"Access problem with sun.misc.Unsafe\", ex);\n      } catch (InvocationTargetException ite) {\n        final Throwable cause = ite.getCause();\n        if (cause instanceof RuntimeException)\n          throw (RuntimeException) cause;\n        if (cause instanceof Error)\n          throw (Error) cause;\n        // this should never happen (Unsafe does not declare\n        // checked Exceptions for this method), but who knows?\n        throw new RuntimeException(\"Call to Unsafe's objectFieldOffset() throwed \"+\n          \"checked Exception when accessing field \" +\n          f.getDeclaringClass().getName() + \"#\" + f.getName(), cause);\n      }\n    } else {\n      return size + fsize;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e1eb6b3ce884c0b9e064e112da158013ec33cd91","date":1402692077,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/RamUsageEstimator#adjustForField(long,Field).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/RamUsageEstimator#adjustForField(long,Field).mjava","sourceNew":"  /**\n   * This method returns the maximum representation size of an object. <code>sizeSoFar</code>\n   * is the object's size measured so far. <code>f</code> is the field being probed.\n   * \n   * <p>The returned offset will be the maximum of whatever was measured so far and \n   * <code>f</code> field's offset and representation size (unaligned).\n   */\n  static long adjustForField(long sizeSoFar, final Field f) {\n    final Class<?> type = f.getType();\n    final int fsize = type.isPrimitive() ? primitiveSizes.get(type) : NUM_BYTES_OBJECT_REF;\n    if (objectFieldOffsetMethod != null) {\n      try {\n        final long offsetPlusSize =\n          ((Number) objectFieldOffsetMethod.invoke(theUnsafe, f)).longValue() + fsize;\n        return Math.max(sizeSoFar, offsetPlusSize);\n      } catch (IllegalAccessException ex) {\n        throw new RuntimeException(\"Access problem with sun.misc.Unsafe\", ex);\n      } catch (InvocationTargetException ite) {\n        final Throwable cause = ite.getCause();\n        if (cause instanceof RuntimeException)\n          throw (RuntimeException) cause;\n        if (cause instanceof Error)\n          throw (Error) cause;\n        // this should never happen (Unsafe does not declare\n        // checked Exceptions for this method), but who knows?\n        throw new RuntimeException(\"Call to Unsafe's objectFieldOffset() throwed \"+\n          \"checked Exception when accessing field \" +\n          f.getDeclaringClass().getName() + \"#\" + f.getName(), cause);\n      }\n    } else {\n      // TODO: No alignments based on field type/ subclass fields alignments?\n      return sizeSoFar + fsize;\n    }\n  }\n\n","sourceOld":"  /**\n   * This method returns the maximum representation size of an object. <code>sizeSoFar</code>\n   * is the object's size measured so far. <code>f</code> is the field being probed.\n   * \n   * <p>The returned offset will be the maximum of whatever was measured so far and \n   * <code>f</code> field's offset and representation size (unaligned).\n   */\n  private static long adjustForField(long sizeSoFar, final Field f) {\n    final Class<?> type = f.getType();\n    final int fsize = type.isPrimitive() ? primitiveSizes.get(type) : NUM_BYTES_OBJECT_REF;\n    if (objectFieldOffsetMethod != null) {\n      try {\n        final long offsetPlusSize =\n          ((Number) objectFieldOffsetMethod.invoke(theUnsafe, f)).longValue() + fsize;\n        return Math.max(sizeSoFar, offsetPlusSize);\n      } catch (IllegalAccessException ex) {\n        throw new RuntimeException(\"Access problem with sun.misc.Unsafe\", ex);\n      } catch (InvocationTargetException ite) {\n        final Throwable cause = ite.getCause();\n        if (cause instanceof RuntimeException)\n          throw (RuntimeException) cause;\n        if (cause instanceof Error)\n          throw (Error) cause;\n        // this should never happen (Unsafe does not declare\n        // checked Exceptions for this method), but who knows?\n        throw new RuntimeException(\"Call to Unsafe's objectFieldOffset() throwed \"+\n          \"checked Exception when accessing field \" +\n          f.getDeclaringClass().getName() + \"#\" + f.getName(), cause);\n      }\n    } else {\n      // TODO: No alignments based on field type/ subclass fields alignments?\n      return sizeSoFar + fsize;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c6f080a2ab37c464dd98db173f6cbf10dc74f211","date":1402946779,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/RamUsageEstimator#adjustForField(long,Field).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/RamUsageEstimator#adjustForField(long,Field).mjava","sourceNew":"  /**\n   * This method returns the maximum representation size of an object. <code>sizeSoFar</code>\n   * is the object's size measured so far. <code>f</code> is the field being probed.\n   * \n   * <p>The returned offset will be the maximum of whatever was measured so far and \n   * <code>f</code> field's offset and representation size (unaligned).\n   */\n  static long adjustForField(long sizeSoFar, final Field f) {\n    final Class<?> type = f.getType();\n    final int fsize = type.isPrimitive() ? primitiveSizes.get(type) : NUM_BYTES_OBJECT_REF;\n    if (objectFieldOffsetMethod != null) {\n      try {\n        final long offsetPlusSize =\n          ((Number) objectFieldOffsetMethod.invoke(theUnsafe, f)).longValue() + fsize;\n        return Math.max(sizeSoFar, offsetPlusSize);\n      } catch (IllegalAccessException ex) {\n        throw new RuntimeException(\"Access problem with sun.misc.Unsafe\", ex);\n      } catch (InvocationTargetException ite) {\n        final Throwable cause = ite.getCause();\n        if (cause instanceof RuntimeException)\n          throw (RuntimeException) cause;\n        if (cause instanceof Error)\n          throw (Error) cause;\n        // this should never happen (Unsafe does not declare\n        // checked Exceptions for this method), but who knows?\n        throw new RuntimeException(\"Call to Unsafe's objectFieldOffset() throwed \"+\n          \"checked Exception when accessing field \" +\n          f.getDeclaringClass().getName() + \"#\" + f.getName(), cause);\n      }\n    } else {\n      // TODO: No alignments based on field type/ subclass fields alignments?\n      return sizeSoFar + fsize;\n    }\n  }\n\n","sourceOld":"  /**\n   * This method returns the maximum representation size of an object. <code>sizeSoFar</code>\n   * is the object's size measured so far. <code>f</code> is the field being probed.\n   * \n   * <p>The returned offset will be the maximum of whatever was measured so far and \n   * <code>f</code> field's offset and representation size (unaligned).\n   */\n  private static long adjustForField(long sizeSoFar, final Field f) {\n    final Class<?> type = f.getType();\n    final int fsize = type.isPrimitive() ? primitiveSizes.get(type) : NUM_BYTES_OBJECT_REF;\n    if (objectFieldOffsetMethod != null) {\n      try {\n        final long offsetPlusSize =\n          ((Number) objectFieldOffsetMethod.invoke(theUnsafe, f)).longValue() + fsize;\n        return Math.max(sizeSoFar, offsetPlusSize);\n      } catch (IllegalAccessException ex) {\n        throw new RuntimeException(\"Access problem with sun.misc.Unsafe\", ex);\n      } catch (InvocationTargetException ite) {\n        final Throwable cause = ite.getCause();\n        if (cause instanceof RuntimeException)\n          throw (RuntimeException) cause;\n        if (cause instanceof Error)\n          throw (Error) cause;\n        // this should never happen (Unsafe does not declare\n        // checked Exceptions for this method), but who knows?\n        throw new RuntimeException(\"Call to Unsafe's objectFieldOffset() throwed \"+\n          \"checked Exception when accessing field \" +\n          f.getDeclaringClass().getName() + \"#\" + f.getName(), cause);\n      }\n    } else {\n      // TODO: No alignments based on field type/ subclass fields alignments?\n      return sizeSoFar + fsize;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9139c54cd548a746e88dfa944497dccef7629321","date":1423758024,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/RamUsageEstimator#adjustForField(long,Field).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/RamUsageEstimator#adjustForField(long,Field).mjava","sourceNew":"  /**\n   * This method returns the maximum representation size of an object. <code>sizeSoFar</code>\n   * is the object's size measured so far. <code>f</code> is the field being probed.\n   * \n   * <p>The returned offset will be the maximum of whatever was measured so far and \n   * <code>f</code> field's offset and representation size (unaligned).\n   */\n  static long adjustForField(long sizeSoFar, final Field f) {\n    final Class<?> type = f.getType();\n    final int fsize = type.isPrimitive() ? primitiveSizes.get(type) : NUM_BYTES_OBJECT_REF;\n    // TODO: No alignments based on field type/ subclass fields alignments?\n    return sizeSoFar + fsize;\n  }\n\n","sourceOld":"  /**\n   * This method returns the maximum representation size of an object. <code>sizeSoFar</code>\n   * is the object's size measured so far. <code>f</code> is the field being probed.\n   * \n   * <p>The returned offset will be the maximum of whatever was measured so far and \n   * <code>f</code> field's offset and representation size (unaligned).\n   */\n  static long adjustForField(long sizeSoFar, final Field f) {\n    final Class<?> type = f.getType();\n    final int fsize = type.isPrimitive() ? primitiveSizes.get(type) : NUM_BYTES_OBJECT_REF;\n    if (objectFieldOffsetMethod != null) {\n      try {\n        final long offsetPlusSize =\n          ((Number) objectFieldOffsetMethod.invoke(theUnsafe, f)).longValue() + fsize;\n        return Math.max(sizeSoFar, offsetPlusSize);\n      } catch (IllegalAccessException ex) {\n        throw new RuntimeException(\"Access problem with sun.misc.Unsafe\", ex);\n      } catch (InvocationTargetException ite) {\n        final Throwable cause = ite.getCause();\n        if (cause instanceof RuntimeException)\n          throw (RuntimeException) cause;\n        if (cause instanceof Error)\n          throw (Error) cause;\n        // this should never happen (Unsafe does not declare\n        // checked Exceptions for this method), but who knows?\n        throw new RuntimeException(\"Call to Unsafe's objectFieldOffset() throwed \"+\n          \"checked Exception when accessing field \" +\n          f.getDeclaringClass().getName() + \"#\" + f.getName(), cause);\n      }\n    } else {\n      // TODO: No alignments based on field type/ subclass fields alignments?\n      return sizeSoFar + fsize;\n    }\n  }\n\n","bugFix":["10cd47aac3c4e8c583740a750335f8aab14555b3","dd6c9e9b1251473f465b0443b56046b2658402da"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9139c54cd548a746e88dfa944497dccef7629321":["e1eb6b3ce884c0b9e064e112da158013ec33cd91"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":["10cd47aac3c4e8c583740a750335f8aab14555b3","e1eb6b3ce884c0b9e064e112da158013ec33cd91"],"e1eb6b3ce884c0b9e064e112da158013ec33cd91":["10cd47aac3c4e8c583740a750335f8aab14555b3"],"10cd47aac3c4e8c583740a750335f8aab14555b3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9139c54cd548a746e88dfa944497dccef7629321"]},"commit2Childs":{"9139c54cd548a746e88dfa944497dccef7629321":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["10cd47aac3c4e8c583740a750335f8aab14555b3"],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":[],"e1eb6b3ce884c0b9e064e112da158013ec33cd91":["9139c54cd548a746e88dfa944497dccef7629321","c6f080a2ab37c464dd98db173f6cbf10dc74f211"],"10cd47aac3c4e8c583740a750335f8aab14555b3":["c6f080a2ab37c464dd98db173f6cbf10dc74f211","e1eb6b3ce884c0b9e064e112da158013ec33cd91"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c6f080a2ab37c464dd98db173f6cbf10dc74f211","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}