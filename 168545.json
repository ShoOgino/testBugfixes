{"path":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","commits":[{"id":"933fa8f09adfcd1a858cd0fc7912e21ee993b7fc","date":1342989037,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"/dev/null","sourceNew":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateCloudState(true);\n      CloudState cloudState = zkStateReader.getCloudState();\n      Map<String,Slice> slices = cloudState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,ZkNodeProps> shards = entry.getValue().getShards();\n        for (Map.Entry<String,ZkNodeProps> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().get(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().get(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","date":1343059585,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"/dev/null","sourceNew":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateCloudState(true);\n      CloudState cloudState = zkStateReader.getCloudState();\n      Map<String,Slice> slices = cloudState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,ZkNodeProps> shards = entry.getValue().getShards();\n        for (Map.Entry<String,ZkNodeProps> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().get(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().get(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"/dev/null","sourceNew":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateCloudState(true);\n      CloudState cloudState = zkStateReader.getCloudState();\n      Map<String,Slice> slices = cloudState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,ZkNodeProps> shards = entry.getValue().getShards();\n        for (Map.Entry<String,ZkNodeProps> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().get(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().get(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f767f8c99eaedb984df754fe61f21c5de260f94","date":1344105153,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,ZkNodeProps> shards = entry.getValue().getShards();\n        for (Map.Entry<String,ZkNodeProps> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().get(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().get(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","sourceOld":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateCloudState(true);\n      CloudState cloudState = zkStateReader.getCloudState();\n      Map<String,Slice> slices = cloudState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,ZkNodeProps> shards = entry.getValue().getShards();\n        for (Map.Entry<String,ZkNodeProps> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().get(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().get(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8fd5be977c105554c6a7b68afcdbc511439723ab","date":1344115570,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,ZkNodeProps> shards = entry.getValue().getShards();\n        for (Map.Entry<String,ZkNodeProps> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().get(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().get(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","sourceOld":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateCloudState(true);\n      CloudState cloudState = zkStateReader.getCloudState();\n      Map<String,Slice> slices = cloudState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,ZkNodeProps> shards = entry.getValue().getShards();\n        for (Map.Entry<String,ZkNodeProps> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().get(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().get(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c30e4c1cee08b3b229a77991882594fe7250b66","date":1344448871,"type":5,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,ZkNodeProps> shards = entry.getValue().getShards();\n        for (Map.Entry<String,ZkNodeProps> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().get(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().get(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","sourceOld":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,ZkNodeProps> shards = entry.getValue().getShards();\n        for (Map.Entry<String,ZkNodeProps> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().get(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().get(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":4,"author":"Uwe Schindler","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":null,"sourceOld":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateCloudState(true);\n      CloudState cloudState = zkStateReader.getCloudState();\n      Map<String,Slice> slices = cloudState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,ZkNodeProps> shards = entry.getValue().getShards();\n        for (Map.Entry<String,ZkNodeProps> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().get(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().get(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && cloudState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":5,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,ZkNodeProps> shards = entry.getValue().getShards();\n        for (Map.Entry<String,ZkNodeProps> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().get(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().get(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","sourceOld":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,ZkNodeProps> shards = entry.getValue().getShards();\n        for (Map.Entry<String,ZkNodeProps> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().get(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().get(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3f767f8c99eaedb984df754fe61f21c5de260f94":["933fa8f09adfcd1a858cd0fc7912e21ee993b7fc"],"933fa8f09adfcd1a858cd0fc7912e21ee993b7fc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["8fd5be977c105554c6a7b68afcdbc511439723ab","2c30e4c1cee08b3b229a77991882594fe7250b66"],"aba371508186796cc6151d8223a5b4e16d02e26e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","933fa8f09adfcd1a858cd0fc7912e21ee993b7fc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["aba371508186796cc6151d8223a5b4e16d02e26e","2c30e4c1cee08b3b229a77991882594fe7250b66"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","933fa8f09adfcd1a858cd0fc7912e21ee993b7fc"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","3f767f8c99eaedb984df754fe61f21c5de260f94"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2c30e4c1cee08b3b229a77991882594fe7250b66"],"2c30e4c1cee08b3b229a77991882594fe7250b66":["3f767f8c99eaedb984df754fe61f21c5de260f94"]},"commit2Childs":{"3f767f8c99eaedb984df754fe61f21c5de260f94":["8fd5be977c105554c6a7b68afcdbc511439723ab","2c30e4c1cee08b3b229a77991882594fe7250b66"],"933fa8f09adfcd1a858cd0fc7912e21ee993b7fc":["3f767f8c99eaedb984df754fe61f21c5de260f94","aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":[],"aba371508186796cc6151d8223a5b4e16d02e26e":["d6f074e73200c07d54f242d3880a8da5a35ff97b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["933fa8f09adfcd1a858cd0fc7912e21ee993b7fc","aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["8fd5be977c105554c6a7b68afcdbc511439723ab"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["c7869f64c874ebf7f317d22c00baf2b6857797a6"],"2c30e4c1cee08b3b229a77991882594fe7250b66":["c7869f64c874ebf7f317d22c00baf2b6857797a6","d6f074e73200c07d54f242d3880a8da5a35ff97b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c7869f64c874ebf7f317d22c00baf2b6857797a6","d6f074e73200c07d54f242d3880a8da5a35ff97b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}