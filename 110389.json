{"path":"src/java/org/apache/solr/request/DisMaxRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","commits":[{"id":"e4b5867a57b32674ce740e66e6a7da8db3d4dd33","date":1148163441,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/request/DisMaxRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"/dev/null","sourceNew":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n        \n    try {\n            \n      SolrIndexSearcher s = req.getSearcher();\n      IndexSchema schema = req.getSchema();\n            \n      Map<String,Float> queryFields =\n        U.parseFieldBoosts(U.getParam(req, params.QF, params.qf));\n      Map<String,Float> phraseFields =\n        U.parseFieldBoosts(U.getParam(req, params.PF, params.pf));\n\n      float tiebreaker = U.getNumberParam\n        (req, params.TIE, params.tiebreaker).floatValue();\n            \n      int pslop = U.getNumberParam(req, params.PS, params.pslop).intValue();\n\n      /* a generic parser for parsing regular lucene queries */\n      QueryParser p = new SolrQueryParser(schema, null);\n\n      /* a parser for dealing with user input, which will convert\n       * things to DisjunctionMaxQueries\n       */\n      U.DisjunctionMaxQueryParser up =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, queryFields);\n\n      /* for parsing slopy phrases using DisjunctionMaxQueries */\n      U.DisjunctionMaxQueryParser pp =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, phraseFields);\n      pp.setPhraseSlop(pslop);\n            \n            \n      /* * * Main User Query * * */\n\n      String userQuery = U.partialEscape\n        (U.stripUnbalancedQuotes(req.getQueryString())).toString();\n            \n      /* the main query we will execute.  we disable the coord because\n       * this query is an artificial construct\n       */\n      BooleanQuery query = new BooleanQuery(true);\n\n      String minShouldMatch = U.getParam(req, params.MM, params.mm);\n            \n      Query dis = up.parse(userQuery);\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        U.flatenBooleanQuery(t, (BooleanQuery)dis);\n\n        U.setMinShouldMatch(t, minShouldMatch);\n                \n        query.add(t, Occur.MUST);\n      } else {\n        query.add(dis, Occur.MUST);\n      }\n\n      /* * * Add on Phrases for the Query * * */\n            \n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, stip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, Occur.SHOULD);\n      }\n            \n      /* * * Boosting Query * * */\n\n      String boostQuery = U.getParam(req, params.BQ, params.bq);\n      if (null != boostQuery && !boostQuery.equals(\"\")) {\n        Query tmp = p.parse(boostQuery);\n        /* if the default boost was used, and we've got a BooleanQuery\n         * extract the subqueries out and use them directly\n         */\n        if (1.0f == tmp.getBoost() && tmp instanceof BooleanQuery) {\n          for (BooleanClause c : ((BooleanQuery)tmp).getClauses()) {\n            query.add(c);\n          }\n        } else {\n          query.add(tmp, BooleanClause.Occur.SHOULD);\n        }\n      }\n\n      /* * * Boosting Functions * * */\n\n      String boostFunc = U.getParam(req, params.BF, params.bf);\n      if (null != boostFunc && !boostFunc.equals(\"\")) {\n        List<Query> funcs = U.parseFuncs(schema, boostFunc);\n        for (Query f : funcs) {\n          query.add(f, Occur.SHOULD);\n        }\n      }\n            \n      /* * * Restrict Results * * */\n\n      List<Query> restrictions = new ArrayList<Query>(1);\n            \n      /* User Restriction */\n      String filterQueryString = U.getParam(req, params.FQ, params.fq);\n      Query filterQuery = null;\n      if (null != filterQueryString && !filterQueryString.equals(\"\")) {\n        filterQuery = p.parse(filterQueryString);\n        restrictions.add(filterQuery);\n      }\n            \n      /* * * Generate Main Results * * */\n\n      DocList results = s.getDocList(query, restrictions,\n                                     SolrPluginUtils.getSort(req),\n                                     req.getStart(), req.getLimit(),\n                                     SolrIndexSearcher.GET_SCORES);\n      rsp.add(\"search-results\",results);\n\n      U.setReturnFields(U.getParam(req, params.FL, params.fl), rsp);\n\n            \n      /* * * Debugging Info * * */\n\n      try {\n        NamedList debug = U.doStandardDebug(req, userQuery, query, results);\n        if (null != debug) {\n          debug.add(\"boostquery\", boostQuery);\n          debug.add(\"boostfunc\", boostFunc);\n\n          debug.add(\"filterquery\", filterQueryString);\n          if (null != filterQuery) {\n            debug.add(\"parsedfilterquery\",\n                      QueryParsing.toString(filterQuery, schema));\n          }\n                    \n          rsp.add(\"debug\", debug);\n        }\n\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log,\n                              \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n            \n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0452863ee588101738d341e6e97eb87eb010052a","date":1152814944,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/request/DisMaxRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/request/DisMaxRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n        \n    try {\n\n      int flags = 0;\n      SolrIndexSearcher s = req.getSearcher();\n      IndexSchema schema = req.getSchema();\n            \n      Map<String,Float> queryFields =\n        U.parseFieldBoosts(U.getParam(req, params.QF, params.qf));\n      Map<String,Float> phraseFields =\n        U.parseFieldBoosts(U.getParam(req, params.PF, params.pf));\n\n      float tiebreaker = U.getNumberParam\n        (req, params.TIE, params.tiebreaker).floatValue();\n            \n      int pslop = U.getNumberParam(req, params.PS, params.pslop).intValue();\n\n      /* a generic parser for parsing regular lucene queries */\n      QueryParser p = new SolrQueryParser(schema, null);\n\n      /* a parser for dealing with user input, which will convert\n       * things to DisjunctionMaxQueries\n       */\n      U.DisjunctionMaxQueryParser up =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, queryFields);\n\n      /* for parsing slopy phrases using DisjunctionMaxQueries */\n      U.DisjunctionMaxQueryParser pp =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, phraseFields);\n      pp.setPhraseSlop(pslop);\n            \n            \n      /* * * Main User Query * * */\n\n      String userQuery = U.partialEscape\n        (U.stripUnbalancedQuotes(req.getQueryString())).toString();\n            \n      /* the main query we will execute.  we disable the coord because\n       * this query is an artificial construct\n       */\n      BooleanQuery query = new BooleanQuery(true);\n\n      String minShouldMatch = U.getParam(req, params.MM, params.mm);\n            \n      Query dis = up.parse(userQuery);\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        U.flattenBooleanQuery(t, (BooleanQuery)dis);\n\n        U.setMinShouldMatch(t, minShouldMatch);\n                \n        query.add(t, Occur.MUST);\n      } else {\n        query.add(dis, Occur.MUST);\n      }\n\n      /* * * Add on Phrases for the Query * * */\n            \n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, stip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, Occur.SHOULD);\n      }\n            \n      /* * * Boosting Query * * */\n\n      String boostQuery = U.getParam(req, params.BQ, params.bq);\n      if (null != boostQuery && !boostQuery.equals(\"\")) {\n        Query tmp = p.parse(boostQuery);\n        /* if the default boost was used, and we've got a BooleanQuery\n         * extract the subqueries out and use them directly\n         */\n        if (1.0f == tmp.getBoost() && tmp instanceof BooleanQuery) {\n          for (BooleanClause c : ((BooleanQuery)tmp).getClauses()) {\n            query.add(c);\n          }\n        } else {\n          query.add(tmp, BooleanClause.Occur.SHOULD);\n        }\n      }\n\n      /* * * Boosting Functions * * */\n\n      String boostFunc = U.getParam(req, params.BF, params.bf);\n      if (null != boostFunc && !boostFunc.equals(\"\")) {\n        List<Query> funcs = U.parseFuncs(schema, boostFunc);\n        for (Query f : funcs) {\n          query.add(f, Occur.SHOULD);\n        }\n      }\n            \n      /* * * Restrict Results * * */\n\n      List<Query> restrictions = new ArrayList<Query>(1);\n            \n      /* User Restriction */\n      String filterQueryString = U.getParam(req, params.FQ, params.fq);\n      Query filterQuery = null;\n      if (null != filterQueryString && !filterQueryString.equals(\"\")) {\n        filterQuery = p.parse(filterQueryString);\n        restrictions.add(filterQuery);\n      }\n            \n      /* * * Generate Main Results * * */\n\n      flags |= U.setReturnFields(U.getParam(req, params.FL, params.fl), rsp);\n      DocList results = s.getDocList(query, restrictions,\n                                     SolrPluginUtils.getSort(req),\n                                     req.getStart(), req.getLimit(),\n                                     flags);\n      rsp.add(\"search-results\",results);\n\n\n            \n      /* * * Debugging Info * * */\n\n      try {\n        NamedList debug = U.doStandardDebug(req, userQuery, query, results, params);\n        if (null != debug) {\n          debug.add(\"boostquery\", boostQuery);\n          debug.add(\"boostfunc\", boostFunc);\n\n          debug.add(\"filterquery\", filterQueryString);\n          if (null != filterQuery) {\n            debug.add(\"parsedfilterquery\",\n                      QueryParsing.toString(filterQuery, schema));\n          }\n                    \n          rsp.add(\"debug\", debug);\n        }\n\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log,\n                              \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      /* * * Highlighting/Summarizing  * * */\n      if(U.getBooleanParam(req, params.HIGHLIGHT, params.highlight)) {\n\n        BooleanQuery highlightQuery = new BooleanQuery();\n        U.flattenBooleanQuery(highlightQuery, query);\n        NamedList sumData = U.doStandardHighlighting(results, highlightQuery, \n                                                     req, params, \n                                                     queryFields.keySet().toArray(new String[0]));\n        if(sumData != null)\n          rsp.add(\"highlighting\", sumData);\n      }\n            \n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n    }\n  }\n\n","sourceOld":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n        \n    try {\n            \n      SolrIndexSearcher s = req.getSearcher();\n      IndexSchema schema = req.getSchema();\n            \n      Map<String,Float> queryFields =\n        U.parseFieldBoosts(U.getParam(req, params.QF, params.qf));\n      Map<String,Float> phraseFields =\n        U.parseFieldBoosts(U.getParam(req, params.PF, params.pf));\n\n      float tiebreaker = U.getNumberParam\n        (req, params.TIE, params.tiebreaker).floatValue();\n            \n      int pslop = U.getNumberParam(req, params.PS, params.pslop).intValue();\n\n      /* a generic parser for parsing regular lucene queries */\n      QueryParser p = new SolrQueryParser(schema, null);\n\n      /* a parser for dealing with user input, which will convert\n       * things to DisjunctionMaxQueries\n       */\n      U.DisjunctionMaxQueryParser up =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, queryFields);\n\n      /* for parsing slopy phrases using DisjunctionMaxQueries */\n      U.DisjunctionMaxQueryParser pp =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, phraseFields);\n      pp.setPhraseSlop(pslop);\n            \n            \n      /* * * Main User Query * * */\n\n      String userQuery = U.partialEscape\n        (U.stripUnbalancedQuotes(req.getQueryString())).toString();\n            \n      /* the main query we will execute.  we disable the coord because\n       * this query is an artificial construct\n       */\n      BooleanQuery query = new BooleanQuery(true);\n\n      String minShouldMatch = U.getParam(req, params.MM, params.mm);\n            \n      Query dis = up.parse(userQuery);\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        U.flatenBooleanQuery(t, (BooleanQuery)dis);\n\n        U.setMinShouldMatch(t, minShouldMatch);\n                \n        query.add(t, Occur.MUST);\n      } else {\n        query.add(dis, Occur.MUST);\n      }\n\n      /* * * Add on Phrases for the Query * * */\n            \n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, stip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, Occur.SHOULD);\n      }\n            \n      /* * * Boosting Query * * */\n\n      String boostQuery = U.getParam(req, params.BQ, params.bq);\n      if (null != boostQuery && !boostQuery.equals(\"\")) {\n        Query tmp = p.parse(boostQuery);\n        /* if the default boost was used, and we've got a BooleanQuery\n         * extract the subqueries out and use them directly\n         */\n        if (1.0f == tmp.getBoost() && tmp instanceof BooleanQuery) {\n          for (BooleanClause c : ((BooleanQuery)tmp).getClauses()) {\n            query.add(c);\n          }\n        } else {\n          query.add(tmp, BooleanClause.Occur.SHOULD);\n        }\n      }\n\n      /* * * Boosting Functions * * */\n\n      String boostFunc = U.getParam(req, params.BF, params.bf);\n      if (null != boostFunc && !boostFunc.equals(\"\")) {\n        List<Query> funcs = U.parseFuncs(schema, boostFunc);\n        for (Query f : funcs) {\n          query.add(f, Occur.SHOULD);\n        }\n      }\n            \n      /* * * Restrict Results * * */\n\n      List<Query> restrictions = new ArrayList<Query>(1);\n            \n      /* User Restriction */\n      String filterQueryString = U.getParam(req, params.FQ, params.fq);\n      Query filterQuery = null;\n      if (null != filterQueryString && !filterQueryString.equals(\"\")) {\n        filterQuery = p.parse(filterQueryString);\n        restrictions.add(filterQuery);\n      }\n            \n      /* * * Generate Main Results * * */\n\n      DocList results = s.getDocList(query, restrictions,\n                                     SolrPluginUtils.getSort(req),\n                                     req.getStart(), req.getLimit(),\n                                     SolrIndexSearcher.GET_SCORES);\n      rsp.add(\"search-results\",results);\n\n      U.setReturnFields(U.getParam(req, params.FL, params.fl), rsp);\n\n            \n      /* * * Debugging Info * * */\n\n      try {\n        NamedList debug = U.doStandardDebug(req, userQuery, query, results);\n        if (null != debug) {\n          debug.add(\"boostquery\", boostQuery);\n          debug.add(\"boostfunc\", boostFunc);\n\n          debug.add(\"filterquery\", filterQueryString);\n          if (null != filterQuery) {\n            debug.add(\"parsedfilterquery\",\n                      QueryParsing.toString(filterQuery, schema));\n          }\n                    \n          rsp.add(\"debug\", debug);\n        }\n\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log,\n                              \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n            \n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"44f497c313977be641ddf24aab74b30e6de834d8","date":1156361697,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/request/DisMaxRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/request/DisMaxRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n        \n    try {\n\n      int flags = 0;\n      SolrIndexSearcher s = req.getSearcher();\n      IndexSchema schema = req.getSchema();\n            \n      Map<String,Float> queryFields =\n        U.parseFieldBoosts(U.getParam(req, params.QF, params.qf));\n      Map<String,Float> phraseFields =\n        U.parseFieldBoosts(U.getParam(req, params.PF, params.pf));\n\n      float tiebreaker = U.getNumberParam\n        (req, params.TIE, params.tiebreaker).floatValue();\n            \n      int pslop = U.getNumberParam(req, params.PS, params.pslop).intValue();\n\n      /* a generic parser for parsing regular lucene queries */\n      QueryParser p = new SolrQueryParser(schema, null);\n\n      /* a parser for dealing with user input, which will convert\n       * things to DisjunctionMaxQueries\n       */\n      U.DisjunctionMaxQueryParser up =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, queryFields);\n\n      /* for parsing slopy phrases using DisjunctionMaxQueries */\n      U.DisjunctionMaxQueryParser pp =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, phraseFields);\n      pp.setPhraseSlop(pslop);\n            \n            \n      /* * * Main User Query * * */\n\n      String userQuery = U.partialEscape\n        (U.stripUnbalancedQuotes(req.getQueryString())).toString();\n            \n      /* the main query we will execute.  we disable the coord because\n       * this query is an artificial construct\n       */\n      BooleanQuery query = new BooleanQuery(true);\n\n      String minShouldMatch = U.getParam(req, params.MM, params.mm);\n            \n      Query dis = up.parse(userQuery);\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        U.flattenBooleanQuery(t, (BooleanQuery)dis);\n\n        U.setMinShouldMatch(t, minShouldMatch);\n                \n        query.add(t, Occur.MUST);\n      } else {\n        query.add(dis, Occur.MUST);\n      }\n\n      /* * * Add on Phrases for the Query * * */\n            \n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, stip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, Occur.SHOULD);\n      }\n            \n      /* * * Boosting Query * * */\n\n      String boostQuery = U.getParam(req, params.BQ, params.bq);\n      if (null != boostQuery && !boostQuery.equals(\"\")) {\n        Query tmp = p.parse(boostQuery);\n        /* if the default boost was used, and we've got a BooleanQuery\n         * extract the subqueries out and use them directly\n         */\n        if (1.0f == tmp.getBoost() && tmp instanceof BooleanQuery) {\n          for (BooleanClause c : ((BooleanQuery)tmp).getClauses()) {\n            query.add(c);\n          }\n        } else {\n          query.add(tmp, BooleanClause.Occur.SHOULD);\n        }\n      }\n\n      /* * * Boosting Functions * * */\n\n      String boostFunc = U.getParam(req, params.BF, params.bf);\n      if (null != boostFunc && !boostFunc.equals(\"\")) {\n        List<Query> funcs = U.parseFuncs(schema, boostFunc);\n        for (Query f : funcs) {\n          query.add(f, Occur.SHOULD);\n        }\n      }\n            \n      /* * * Restrict Results * * */\n\n      List<Query> restrictions = new ArrayList<Query>(1);\n            \n      /* User Restriction */\n      String filterQueryString = U.getParam(req, params.FQ, params.fq);\n      Query filterQuery = null;\n      if (null != filterQueryString && !filterQueryString.equals(\"\")) {\n        filterQuery = p.parse(filterQueryString);\n        restrictions.add(filterQuery);\n      }\n            \n      /* * * Generate Main Results * * */\n\n      flags |= U.setReturnFields(U.getParam(req, SolrParams.FL, params.fl), rsp);\n      DocList results = s.getDocList(query, restrictions,\n                                     SolrPluginUtils.getSort(req),\n                                     req.getStart(), req.getLimit(),\n                                     flags);\n      rsp.add(\"search-results\",results);\n\n\n            \n      /* * * Debugging Info * * */\n\n      try {\n        NamedList debug = U.doStandardDebug(req, userQuery, query, results, params);\n        if (null != debug) {\n          debug.add(\"boostquery\", boostQuery);\n          debug.add(\"boostfunc\", boostFunc);\n\n          debug.add(\"filterquery\", filterQueryString);\n          if (null != filterQuery) {\n            debug.add(\"parsedfilterquery\",\n                      QueryParsing.toString(filterQuery, schema));\n          }\n                    \n          rsp.add(\"debug\", debug);\n        }\n\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log,\n                              \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      /* * * Highlighting/Summarizing  * * */\n      if(U.getBooleanParam(req, SolrParams.HIGHLIGHT, params.highlight)) {\n\n        BooleanQuery highlightQuery = new BooleanQuery();\n        U.flattenBooleanQuery(highlightQuery, query);\n        NamedList sumData = U.doStandardHighlighting(results, highlightQuery, \n                                                     req, params, \n                                                     queryFields.keySet().toArray(new String[0]));\n        if(sumData != null)\n          rsp.add(\"highlighting\", sumData);\n      }\n            \n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n    }\n  }\n\n","sourceOld":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n        \n    try {\n\n      int flags = 0;\n      SolrIndexSearcher s = req.getSearcher();\n      IndexSchema schema = req.getSchema();\n            \n      Map<String,Float> queryFields =\n        U.parseFieldBoosts(U.getParam(req, params.QF, params.qf));\n      Map<String,Float> phraseFields =\n        U.parseFieldBoosts(U.getParam(req, params.PF, params.pf));\n\n      float tiebreaker = U.getNumberParam\n        (req, params.TIE, params.tiebreaker).floatValue();\n            \n      int pslop = U.getNumberParam(req, params.PS, params.pslop).intValue();\n\n      /* a generic parser for parsing regular lucene queries */\n      QueryParser p = new SolrQueryParser(schema, null);\n\n      /* a parser for dealing with user input, which will convert\n       * things to DisjunctionMaxQueries\n       */\n      U.DisjunctionMaxQueryParser up =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, queryFields);\n\n      /* for parsing slopy phrases using DisjunctionMaxQueries */\n      U.DisjunctionMaxQueryParser pp =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, phraseFields);\n      pp.setPhraseSlop(pslop);\n            \n            \n      /* * * Main User Query * * */\n\n      String userQuery = U.partialEscape\n        (U.stripUnbalancedQuotes(req.getQueryString())).toString();\n            \n      /* the main query we will execute.  we disable the coord because\n       * this query is an artificial construct\n       */\n      BooleanQuery query = new BooleanQuery(true);\n\n      String minShouldMatch = U.getParam(req, params.MM, params.mm);\n            \n      Query dis = up.parse(userQuery);\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        U.flattenBooleanQuery(t, (BooleanQuery)dis);\n\n        U.setMinShouldMatch(t, minShouldMatch);\n                \n        query.add(t, Occur.MUST);\n      } else {\n        query.add(dis, Occur.MUST);\n      }\n\n      /* * * Add on Phrases for the Query * * */\n            \n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, stip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, Occur.SHOULD);\n      }\n            \n      /* * * Boosting Query * * */\n\n      String boostQuery = U.getParam(req, params.BQ, params.bq);\n      if (null != boostQuery && !boostQuery.equals(\"\")) {\n        Query tmp = p.parse(boostQuery);\n        /* if the default boost was used, and we've got a BooleanQuery\n         * extract the subqueries out and use them directly\n         */\n        if (1.0f == tmp.getBoost() && tmp instanceof BooleanQuery) {\n          for (BooleanClause c : ((BooleanQuery)tmp).getClauses()) {\n            query.add(c);\n          }\n        } else {\n          query.add(tmp, BooleanClause.Occur.SHOULD);\n        }\n      }\n\n      /* * * Boosting Functions * * */\n\n      String boostFunc = U.getParam(req, params.BF, params.bf);\n      if (null != boostFunc && !boostFunc.equals(\"\")) {\n        List<Query> funcs = U.parseFuncs(schema, boostFunc);\n        for (Query f : funcs) {\n          query.add(f, Occur.SHOULD);\n        }\n      }\n            \n      /* * * Restrict Results * * */\n\n      List<Query> restrictions = new ArrayList<Query>(1);\n            \n      /* User Restriction */\n      String filterQueryString = U.getParam(req, params.FQ, params.fq);\n      Query filterQuery = null;\n      if (null != filterQueryString && !filterQueryString.equals(\"\")) {\n        filterQuery = p.parse(filterQueryString);\n        restrictions.add(filterQuery);\n      }\n            \n      /* * * Generate Main Results * * */\n\n      flags |= U.setReturnFields(U.getParam(req, params.FL, params.fl), rsp);\n      DocList results = s.getDocList(query, restrictions,\n                                     SolrPluginUtils.getSort(req),\n                                     req.getStart(), req.getLimit(),\n                                     flags);\n      rsp.add(\"search-results\",results);\n\n\n            \n      /* * * Debugging Info * * */\n\n      try {\n        NamedList debug = U.doStandardDebug(req, userQuery, query, results, params);\n        if (null != debug) {\n          debug.add(\"boostquery\", boostQuery);\n          debug.add(\"boostfunc\", boostFunc);\n\n          debug.add(\"filterquery\", filterQueryString);\n          if (null != filterQuery) {\n            debug.add(\"parsedfilterquery\",\n                      QueryParsing.toString(filterQuery, schema));\n          }\n                    \n          rsp.add(\"debug\", debug);\n        }\n\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log,\n                              \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      /* * * Highlighting/Summarizing  * * */\n      if(U.getBooleanParam(req, params.HIGHLIGHT, params.highlight)) {\n\n        BooleanQuery highlightQuery = new BooleanQuery();\n        U.flattenBooleanQuery(highlightQuery, query);\n        NamedList sumData = U.doStandardHighlighting(results, highlightQuery, \n                                                     req, params, \n                                                     queryFields.keySet().toArray(new String[0]));\n        if(sumData != null)\n          rsp.add(\"highlighting\", sumData);\n      }\n            \n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af09a11446184597ca824554260a98704507f8a7","date":1157138567,"type":3,"author":"Mike Klaas","isMerge":false,"pathNew":"src/java/org/apache/solr/request/DisMaxRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/request/DisMaxRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n        \n    try {\n\n      int flags = 0;\n      SolrIndexSearcher s = req.getSearcher();\n      IndexSchema schema = req.getSchema();\n            \n      Map<String,Float> queryFields =\n        U.parseFieldBoosts(U.getParam(req, params.QF, params.qf));\n      Map<String,Float> phraseFields =\n        U.parseFieldBoosts(U.getParam(req, params.PF, params.pf));\n\n      float tiebreaker = U.getNumberParam\n        (req, params.TIE, params.tiebreaker).floatValue();\n            \n      int pslop = U.getNumberParam(req, params.PS, params.pslop).intValue();\n\n      /* a generic parser for parsing regular lucene queries */\n      QueryParser p = new SolrQueryParser(schema, null);\n\n      /* a parser for dealing with user input, which will convert\n       * things to DisjunctionMaxQueries\n       */\n      U.DisjunctionMaxQueryParser up =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, queryFields);\n\n      /* for parsing slopy phrases using DisjunctionMaxQueries */\n      U.DisjunctionMaxQueryParser pp =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, phraseFields);\n      pp.setPhraseSlop(pslop);\n            \n            \n      /* * * Main User Query * * */\n\n      String userQuery = U.partialEscape\n        (U.stripUnbalancedQuotes(req.getQueryString())).toString();\n            \n      /* the main query we will execute.  we disable the coord because\n       * this query is an artificial construct\n       */\n      BooleanQuery query = new BooleanQuery(true);\n\n      String minShouldMatch = U.getParam(req, params.MM, params.mm);\n            \n      Query dis = up.parse(userQuery);\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        U.flattenBooleanQuery(t, (BooleanQuery)dis);\n\n        U.setMinShouldMatch(t, minShouldMatch);\n                \n        query.add(t, Occur.MUST);\n      } else {\n        query.add(dis, Occur.MUST);\n      }\n\n      /* * * Add on Phrases for the Query * * */\n            \n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, stip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, Occur.SHOULD);\n      }\n            \n      /* * * Boosting Query * * */\n\n      String boostQuery = U.getParam(req, params.BQ, params.bq);\n      if (null != boostQuery && !boostQuery.equals(\"\")) {\n        Query tmp = p.parse(boostQuery);\n        /* if the default boost was used, and we've got a BooleanQuery\n         * extract the subqueries out and use them directly\n         */\n        if (1.0f == tmp.getBoost() && tmp instanceof BooleanQuery) {\n          for (BooleanClause c : ((BooleanQuery)tmp).getClauses()) {\n            query.add(c);\n          }\n        } else {\n          query.add(tmp, BooleanClause.Occur.SHOULD);\n        }\n      }\n\n      /* * * Boosting Functions * * */\n\n      String boostFunc = U.getParam(req, params.BF, params.bf);\n      if (null != boostFunc && !boostFunc.equals(\"\")) {\n        List<Query> funcs = U.parseFuncs(schema, boostFunc);\n        for (Query f : funcs) {\n          query.add(f, Occur.SHOULD);\n        }\n      }\n            \n      /* * * Restrict Results * * */\n\n      List<Query> restrictions = new ArrayList<Query>(1);\n            \n      /* User Restriction */\n      String filterQueryString = U.getParam(req, params.FQ, params.fq);\n      Query filterQuery = null;\n      if (null != filterQueryString && !filterQueryString.equals(\"\")) {\n        filterQuery = p.parse(filterQueryString);\n        restrictions.add(filterQuery);\n      }\n            \n      /* * * Generate Main Results * * */\n\n      flags |= U.setReturnFields(U.getParam(req, SolrParams.FL, params.fl), rsp);\n      DocList results = s.getDocList(query, restrictions,\n                                     SolrPluginUtils.getSort(req),\n                                     req.getStart(), req.getLimit(),\n                                     flags);\n      rsp.add(\"search-results\",results);\n\n\n            \n      /* * * Debugging Info * * */\n\n      try {\n        NamedList debug = U.doStandardDebug(req, userQuery, query, results, params);\n        if (null != debug) {\n          debug.add(\"boostquery\", boostQuery);\n          debug.add(\"boostfunc\", boostFunc);\n\n          debug.add(\"filterquery\", filterQueryString);\n          if (null != filterQuery) {\n            debug.add(\"parsedfilterquery\",\n                      QueryParsing.toString(filterQuery, schema));\n          }\n                    \n          rsp.add(\"debug\", debug);\n        }\n\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log,\n                              \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      /* * * Highlighting/Summarizing  * * */\n      if(HighlightingUtils.isHighlightingEnabled(req)) {\n\n        BooleanQuery highlightQuery = new BooleanQuery();\n        U.flattenBooleanQuery(highlightQuery, query);\n        NamedList sumData = HighlightingUtils.doHighlighting(results, highlightQuery, \n                                                     req, queryFields.keySet().toArray(new String[0]));\n        if(sumData != null)\n          rsp.add(\"highlighting\", sumData);\n      }\n            \n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n    }\n  }\n\n","sourceOld":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n        \n    try {\n\n      int flags = 0;\n      SolrIndexSearcher s = req.getSearcher();\n      IndexSchema schema = req.getSchema();\n            \n      Map<String,Float> queryFields =\n        U.parseFieldBoosts(U.getParam(req, params.QF, params.qf));\n      Map<String,Float> phraseFields =\n        U.parseFieldBoosts(U.getParam(req, params.PF, params.pf));\n\n      float tiebreaker = U.getNumberParam\n        (req, params.TIE, params.tiebreaker).floatValue();\n            \n      int pslop = U.getNumberParam(req, params.PS, params.pslop).intValue();\n\n      /* a generic parser for parsing regular lucene queries */\n      QueryParser p = new SolrQueryParser(schema, null);\n\n      /* a parser for dealing with user input, which will convert\n       * things to DisjunctionMaxQueries\n       */\n      U.DisjunctionMaxQueryParser up =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, queryFields);\n\n      /* for parsing slopy phrases using DisjunctionMaxQueries */\n      U.DisjunctionMaxQueryParser pp =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, phraseFields);\n      pp.setPhraseSlop(pslop);\n            \n            \n      /* * * Main User Query * * */\n\n      String userQuery = U.partialEscape\n        (U.stripUnbalancedQuotes(req.getQueryString())).toString();\n            \n      /* the main query we will execute.  we disable the coord because\n       * this query is an artificial construct\n       */\n      BooleanQuery query = new BooleanQuery(true);\n\n      String minShouldMatch = U.getParam(req, params.MM, params.mm);\n            \n      Query dis = up.parse(userQuery);\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        U.flattenBooleanQuery(t, (BooleanQuery)dis);\n\n        U.setMinShouldMatch(t, minShouldMatch);\n                \n        query.add(t, Occur.MUST);\n      } else {\n        query.add(dis, Occur.MUST);\n      }\n\n      /* * * Add on Phrases for the Query * * */\n            \n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, stip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, Occur.SHOULD);\n      }\n            \n      /* * * Boosting Query * * */\n\n      String boostQuery = U.getParam(req, params.BQ, params.bq);\n      if (null != boostQuery && !boostQuery.equals(\"\")) {\n        Query tmp = p.parse(boostQuery);\n        /* if the default boost was used, and we've got a BooleanQuery\n         * extract the subqueries out and use them directly\n         */\n        if (1.0f == tmp.getBoost() && tmp instanceof BooleanQuery) {\n          for (BooleanClause c : ((BooleanQuery)tmp).getClauses()) {\n            query.add(c);\n          }\n        } else {\n          query.add(tmp, BooleanClause.Occur.SHOULD);\n        }\n      }\n\n      /* * * Boosting Functions * * */\n\n      String boostFunc = U.getParam(req, params.BF, params.bf);\n      if (null != boostFunc && !boostFunc.equals(\"\")) {\n        List<Query> funcs = U.parseFuncs(schema, boostFunc);\n        for (Query f : funcs) {\n          query.add(f, Occur.SHOULD);\n        }\n      }\n            \n      /* * * Restrict Results * * */\n\n      List<Query> restrictions = new ArrayList<Query>(1);\n            \n      /* User Restriction */\n      String filterQueryString = U.getParam(req, params.FQ, params.fq);\n      Query filterQuery = null;\n      if (null != filterQueryString && !filterQueryString.equals(\"\")) {\n        filterQuery = p.parse(filterQueryString);\n        restrictions.add(filterQuery);\n      }\n            \n      /* * * Generate Main Results * * */\n\n      flags |= U.setReturnFields(U.getParam(req, SolrParams.FL, params.fl), rsp);\n      DocList results = s.getDocList(query, restrictions,\n                                     SolrPluginUtils.getSort(req),\n                                     req.getStart(), req.getLimit(),\n                                     flags);\n      rsp.add(\"search-results\",results);\n\n\n            \n      /* * * Debugging Info * * */\n\n      try {\n        NamedList debug = U.doStandardDebug(req, userQuery, query, results, params);\n        if (null != debug) {\n          debug.add(\"boostquery\", boostQuery);\n          debug.add(\"boostfunc\", boostFunc);\n\n          debug.add(\"filterquery\", filterQueryString);\n          if (null != filterQuery) {\n            debug.add(\"parsedfilterquery\",\n                      QueryParsing.toString(filterQuery, schema));\n          }\n                    \n          rsp.add(\"debug\", debug);\n        }\n\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log,\n                              \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      /* * * Highlighting/Summarizing  * * */\n      if(U.getBooleanParam(req, SolrParams.HIGHLIGHT, params.highlight)) {\n\n        BooleanQuery highlightQuery = new BooleanQuery();\n        U.flattenBooleanQuery(highlightQuery, query);\n        NamedList sumData = U.doStandardHighlighting(results, highlightQuery, \n                                                     req, params, \n                                                     queryFields.keySet().toArray(new String[0]));\n        if(sumData != null)\n          rsp.add(\"highlighting\", sumData);\n      }\n            \n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0907819f524a744c3377371e616839271317ac6","date":1157570948,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/request/DisMaxRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/request/DisMaxRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n        \n    try {\n      U.setDefaults(req,defaults);\n      SolrParams params = req.getParams();\n      \n      int flags = 0;\n      \n      SolrIndexSearcher s = req.getSearcher();\n      IndexSchema schema = req.getSchema();\n            \n      Map<String,Float> queryFields = U.parseFieldBoosts(params.get(DMP.QF));\n      Map<String,Float> phraseFields = U.parseFieldBoosts(params.get(DMP.PF));\n\n      float tiebreaker = params.getFloat(DMP.TIE, 0.0f);\n            \n      int pslop = params.getInt(DMP.PS, 0);\n\n      /* a generic parser for parsing regular lucene queries */\n      QueryParser p = new SolrQueryParser(schema, null);\n\n      /* a parser for dealing with user input, which will convert\n       * things to DisjunctionMaxQueries\n       */\n      U.DisjunctionMaxQueryParser up =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, queryFields);\n\n      /* for parsing slopy phrases using DisjunctionMaxQueries */\n      U.DisjunctionMaxQueryParser pp =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, phraseFields);\n      pp.setPhraseSlop(pslop);\n            \n            \n      /* * * Main User Query * * */\n\n      String userQuery = U.partialEscape\n        (U.stripUnbalancedQuotes(params.get(Q))).toString();\n            \n      /* the main query we will execute.  we disable the coord because\n       * this query is an artificial construct\n       */\n      BooleanQuery query = new BooleanQuery(true);\n\n      String minShouldMatch = params.get(DMP.MM, \"100%\");\n            \n      Query dis = up.parse(userQuery);\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        U.flattenBooleanQuery(t, (BooleanQuery)dis);\n\n        U.setMinShouldMatch(t, minShouldMatch);\n                \n        query.add(t, Occur.MUST);\n      } else {\n        query.add(dis, Occur.MUST);\n      }\n\n      /* * * Add on Phrases for the Query * * */\n            \n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, stip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, Occur.SHOULD);\n      }\n            \n      /* * * Boosting Query * * */\n\n      String boostQuery = params.get(DMP.BQ);\n      if (null != boostQuery && !boostQuery.equals(\"\")) {\n        Query tmp = p.parse(boostQuery);\n        /* if the default boost was used, and we've got a BooleanQuery\n         * extract the subqueries out and use them directly\n         */\n        if (1.0f == tmp.getBoost() && tmp instanceof BooleanQuery) {\n          for (BooleanClause c : ((BooleanQuery)tmp).getClauses()) {\n            query.add(c);\n          }\n        } else {\n          query.add(tmp, BooleanClause.Occur.SHOULD);\n        }\n      }\n\n      /* * * Boosting Functions * * */\n\n      String boostFunc = params.get(DMP.BF);\n      if (null != boostFunc && !boostFunc.equals(\"\")) {\n        List<Query> funcs = U.parseFuncs(schema, boostFunc);\n        for (Query f : funcs) {\n          query.add(f, Occur.SHOULD);\n        }\n      }\n            \n      /* * * Restrict Results * * */\n\n      List<Query> restrictions = new ArrayList<Query>(1);\n            \n      /* User Restriction */\n      String filterQueryString = params.get(DMP.FQ);\n      Query filterQuery = null;\n      if (null != filterQueryString && !filterQueryString.equals(\"\")) {\n        filterQuery = p.parse(filterQueryString);\n        restrictions.add(filterQuery);\n      }\n            \n      /* * * Generate Main Results * * */\n\n      flags |= U.setReturnFields(req,rsp);\n      DocList results = s.getDocList(query, restrictions,\n                                     SolrPluginUtils.getSort(req),\n                                     req.getStart(), req.getLimit(),\n                                     flags);\n      rsp.add(\"search-results\",results);\n\n\n            \n      /* * * Debugging Info * * */\n\n      try {\n        NamedList debug = U.doStandardDebug(req, userQuery, query, results);\n        if (null != debug) {\n          debug.add(\"boostquery\", boostQuery);\n          debug.add(\"boostfunc\", boostFunc);\n\n          debug.add(\"filterquery\", filterQueryString);\n          if (null != filterQuery) {\n            debug.add(\"parsedfilterquery\",\n                      QueryParsing.toString(filterQuery, schema));\n          }\n                    \n          rsp.add(\"debug\", debug);\n        }\n\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log,\n                              \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      /* * * Highlighting/Summarizing  * * */\n      if(HighlightingUtils.isHighlightingEnabled(req)) {\n\n        BooleanQuery highlightQuery = new BooleanQuery();\n        U.flattenBooleanQuery(highlightQuery, query);\n        NamedList sumData = HighlightingUtils.doHighlighting(results, highlightQuery, \n                                                     req, queryFields.keySet().toArray(new String[0]));\n        if(sumData != null)\n          rsp.add(\"highlighting\", sumData);\n      }\n            \n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n    }\n  }\n\n","sourceOld":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n        \n    try {\n\n      int flags = 0;\n      SolrIndexSearcher s = req.getSearcher();\n      IndexSchema schema = req.getSchema();\n            \n      Map<String,Float> queryFields =\n        U.parseFieldBoosts(U.getParam(req, params.QF, params.qf));\n      Map<String,Float> phraseFields =\n        U.parseFieldBoosts(U.getParam(req, params.PF, params.pf));\n\n      float tiebreaker = U.getNumberParam\n        (req, params.TIE, params.tiebreaker).floatValue();\n            \n      int pslop = U.getNumberParam(req, params.PS, params.pslop).intValue();\n\n      /* a generic parser for parsing regular lucene queries */\n      QueryParser p = new SolrQueryParser(schema, null);\n\n      /* a parser for dealing with user input, which will convert\n       * things to DisjunctionMaxQueries\n       */\n      U.DisjunctionMaxQueryParser up =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, queryFields);\n\n      /* for parsing slopy phrases using DisjunctionMaxQueries */\n      U.DisjunctionMaxQueryParser pp =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, phraseFields);\n      pp.setPhraseSlop(pslop);\n            \n            \n      /* * * Main User Query * * */\n\n      String userQuery = U.partialEscape\n        (U.stripUnbalancedQuotes(req.getQueryString())).toString();\n            \n      /* the main query we will execute.  we disable the coord because\n       * this query is an artificial construct\n       */\n      BooleanQuery query = new BooleanQuery(true);\n\n      String minShouldMatch = U.getParam(req, params.MM, params.mm);\n            \n      Query dis = up.parse(userQuery);\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        U.flattenBooleanQuery(t, (BooleanQuery)dis);\n\n        U.setMinShouldMatch(t, minShouldMatch);\n                \n        query.add(t, Occur.MUST);\n      } else {\n        query.add(dis, Occur.MUST);\n      }\n\n      /* * * Add on Phrases for the Query * * */\n            \n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, stip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, Occur.SHOULD);\n      }\n            \n      /* * * Boosting Query * * */\n\n      String boostQuery = U.getParam(req, params.BQ, params.bq);\n      if (null != boostQuery && !boostQuery.equals(\"\")) {\n        Query tmp = p.parse(boostQuery);\n        /* if the default boost was used, and we've got a BooleanQuery\n         * extract the subqueries out and use them directly\n         */\n        if (1.0f == tmp.getBoost() && tmp instanceof BooleanQuery) {\n          for (BooleanClause c : ((BooleanQuery)tmp).getClauses()) {\n            query.add(c);\n          }\n        } else {\n          query.add(tmp, BooleanClause.Occur.SHOULD);\n        }\n      }\n\n      /* * * Boosting Functions * * */\n\n      String boostFunc = U.getParam(req, params.BF, params.bf);\n      if (null != boostFunc && !boostFunc.equals(\"\")) {\n        List<Query> funcs = U.parseFuncs(schema, boostFunc);\n        for (Query f : funcs) {\n          query.add(f, Occur.SHOULD);\n        }\n      }\n            \n      /* * * Restrict Results * * */\n\n      List<Query> restrictions = new ArrayList<Query>(1);\n            \n      /* User Restriction */\n      String filterQueryString = U.getParam(req, params.FQ, params.fq);\n      Query filterQuery = null;\n      if (null != filterQueryString && !filterQueryString.equals(\"\")) {\n        filterQuery = p.parse(filterQueryString);\n        restrictions.add(filterQuery);\n      }\n            \n      /* * * Generate Main Results * * */\n\n      flags |= U.setReturnFields(U.getParam(req, SolrParams.FL, params.fl), rsp);\n      DocList results = s.getDocList(query, restrictions,\n                                     SolrPluginUtils.getSort(req),\n                                     req.getStart(), req.getLimit(),\n                                     flags);\n      rsp.add(\"search-results\",results);\n\n\n            \n      /* * * Debugging Info * * */\n\n      try {\n        NamedList debug = U.doStandardDebug(req, userQuery, query, results, params);\n        if (null != debug) {\n          debug.add(\"boostquery\", boostQuery);\n          debug.add(\"boostfunc\", boostFunc);\n\n          debug.add(\"filterquery\", filterQueryString);\n          if (null != filterQuery) {\n            debug.add(\"parsedfilterquery\",\n                      QueryParsing.toString(filterQuery, schema));\n          }\n                    \n          rsp.add(\"debug\", debug);\n        }\n\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log,\n                              \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      /* * * Highlighting/Summarizing  * * */\n      if(HighlightingUtils.isHighlightingEnabled(req)) {\n\n        BooleanQuery highlightQuery = new BooleanQuery();\n        U.flattenBooleanQuery(highlightQuery, query);\n        NamedList sumData = HighlightingUtils.doHighlighting(results, highlightQuery, \n                                                     req, queryFields.keySet().toArray(new String[0]));\n        if(sumData != null)\n          rsp.add(\"highlighting\", sumData);\n      }\n            \n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d1b4f9f023bf5098df34505adf1ed91daa67c239","date":1157655314,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/request/DisMaxRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/request/DisMaxRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n        \n    try {\n      U.setDefaults(req,defaults);\n      SolrParams params = req.getParams();\n      \n      int flags = 0;\n      \n      SolrIndexSearcher s = req.getSearcher();\n      IndexSchema schema = req.getSchema();\n            \n      Map<String,Float> queryFields = U.parseFieldBoosts(params.get(DMP.QF));\n      Map<String,Float> phraseFields = U.parseFieldBoosts(params.get(DMP.PF));\n\n      float tiebreaker = params.getFloat(DMP.TIE, 0.0f);\n            \n      int pslop = params.getInt(DMP.PS, 0);\n\n      /* a generic parser for parsing regular lucene queries */\n      QueryParser p = new SolrQueryParser(schema, null);\n\n      /* a parser for dealing with user input, which will convert\n       * things to DisjunctionMaxQueries\n       */\n      U.DisjunctionMaxQueryParser up =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, queryFields);\n\n      /* for parsing slopy phrases using DisjunctionMaxQueries */\n      U.DisjunctionMaxQueryParser pp =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, phraseFields);\n      pp.setPhraseSlop(pslop);\n            \n            \n      /* * * Main User Query * * */\n\n      String userQuery = U.partialEscape\n        (U.stripUnbalancedQuotes(params.get(Q))).toString();\n            \n      /* the main query we will execute.  we disable the coord because\n       * this query is an artificial construct\n       */\n      BooleanQuery query = new BooleanQuery(true);\n\n      String minShouldMatch = params.get(DMP.MM, \"100%\");\n            \n      Query dis = up.parse(userQuery);\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        U.flattenBooleanQuery(t, (BooleanQuery)dis);\n\n        U.setMinShouldMatch(t, minShouldMatch);\n                \n        query.add(t, Occur.MUST);\n      } else {\n        query.add(dis, Occur.MUST);\n      }\n\n      /* * * Add on Phrases for the Query * * */\n            \n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, stip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, Occur.SHOULD);\n      }\n            \n      /* * * Boosting Query * * */\n\n      String boostQuery = params.get(DMP.BQ);\n      if (null != boostQuery && !boostQuery.equals(\"\")) {\n        Query tmp = p.parse(boostQuery);\n        /* if the default boost was used, and we've got a BooleanQuery\n         * extract the subqueries out and use them directly\n         */\n        if (1.0f == tmp.getBoost() && tmp instanceof BooleanQuery) {\n          for (BooleanClause c : ((BooleanQuery)tmp).getClauses()) {\n            query.add(c);\n          }\n        } else {\n          query.add(tmp, BooleanClause.Occur.SHOULD);\n        }\n      }\n\n      /* * * Boosting Functions * * */\n\n      String boostFunc = params.get(DMP.BF);\n      if (null != boostFunc && !boostFunc.equals(\"\")) {\n        List<Query> funcs = U.parseFuncs(schema, boostFunc);\n        for (Query f : funcs) {\n          query.add(f, Occur.SHOULD);\n        }\n      }\n            \n      /* * * Restrict Results * * */\n\n      List<Query> restrictions = U.parseFilterQueries(req);\n            \n      /* * * Generate Main Results * * */\n\n      flags |= U.setReturnFields(req,rsp);\n      \n      DocListAndSet results = new DocListAndSet();\n      NamedList facetInfo = null;\n      if (params.getBool(FACET,false)) {\n        results = s.getDocListAndSet(query, restrictions,\n                                     SolrPluginUtils.getSort(req),\n                                     req.getStart(), req.getLimit(),\n                                     flags);\n        facetInfo = getFacetInfo(req, rsp, results.docSet);\n      } else {\n        results.docList = s.getDocList(query, restrictions,\n                                       SolrPluginUtils.getSort(req),\n                                       req.getStart(), req.getLimit(),\n                                       flags);\n      }\n      rsp.add(\"search-results\",results.docList);\n      \n      if (null != facetInfo) rsp.add(\"facet_counts\", facetInfo);\n\n\n            \n      /* * * Debugging Info * * */\n\n      try {\n        NamedList debug = U.doStandardDebug(req, userQuery, query, results.docList);\n        if (null != debug) {\n          debug.add(\"boostquery\", boostQuery);\n          debug.add(\"boostfunc\", boostFunc);\n          if (null != restrictions) {\n            debug.add(\"filter_queries\", params.getParams(FQ));\n            List<String> fqs = new ArrayList<String>(restrictions.size());\n            for (Query fq : restrictions) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            debug.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", debug);\n        }\n\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log,\n                              \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      /* * * Highlighting/Summarizing  * * */\n      if(HighlightingUtils.isHighlightingEnabled(req)) {\n\n        BooleanQuery highlightQuery = new BooleanQuery();\n        U.flattenBooleanQuery(highlightQuery, query);\n        String[] highFields = queryFields.keySet().toArray(new String[0]);\n        NamedList sumData =\n          HighlightingUtils.doHighlighting(results.docList, highlightQuery, \n                                           req, highFields);\n        if(sumData != null)\n          rsp.add(\"highlighting\", sumData);\n      }\n            \n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n    }\n  }\n\n","sourceOld":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n        \n    try {\n      U.setDefaults(req,defaults);\n      SolrParams params = req.getParams();\n      \n      int flags = 0;\n      \n      SolrIndexSearcher s = req.getSearcher();\n      IndexSchema schema = req.getSchema();\n            \n      Map<String,Float> queryFields = U.parseFieldBoosts(params.get(DMP.QF));\n      Map<String,Float> phraseFields = U.parseFieldBoosts(params.get(DMP.PF));\n\n      float tiebreaker = params.getFloat(DMP.TIE, 0.0f);\n            \n      int pslop = params.getInt(DMP.PS, 0);\n\n      /* a generic parser for parsing regular lucene queries */\n      QueryParser p = new SolrQueryParser(schema, null);\n\n      /* a parser for dealing with user input, which will convert\n       * things to DisjunctionMaxQueries\n       */\n      U.DisjunctionMaxQueryParser up =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, queryFields);\n\n      /* for parsing slopy phrases using DisjunctionMaxQueries */\n      U.DisjunctionMaxQueryParser pp =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, phraseFields);\n      pp.setPhraseSlop(pslop);\n            \n            \n      /* * * Main User Query * * */\n\n      String userQuery = U.partialEscape\n        (U.stripUnbalancedQuotes(params.get(Q))).toString();\n            \n      /* the main query we will execute.  we disable the coord because\n       * this query is an artificial construct\n       */\n      BooleanQuery query = new BooleanQuery(true);\n\n      String minShouldMatch = params.get(DMP.MM, \"100%\");\n            \n      Query dis = up.parse(userQuery);\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        U.flattenBooleanQuery(t, (BooleanQuery)dis);\n\n        U.setMinShouldMatch(t, minShouldMatch);\n                \n        query.add(t, Occur.MUST);\n      } else {\n        query.add(dis, Occur.MUST);\n      }\n\n      /* * * Add on Phrases for the Query * * */\n            \n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, stip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, Occur.SHOULD);\n      }\n            \n      /* * * Boosting Query * * */\n\n      String boostQuery = params.get(DMP.BQ);\n      if (null != boostQuery && !boostQuery.equals(\"\")) {\n        Query tmp = p.parse(boostQuery);\n        /* if the default boost was used, and we've got a BooleanQuery\n         * extract the subqueries out and use them directly\n         */\n        if (1.0f == tmp.getBoost() && tmp instanceof BooleanQuery) {\n          for (BooleanClause c : ((BooleanQuery)tmp).getClauses()) {\n            query.add(c);\n          }\n        } else {\n          query.add(tmp, BooleanClause.Occur.SHOULD);\n        }\n      }\n\n      /* * * Boosting Functions * * */\n\n      String boostFunc = params.get(DMP.BF);\n      if (null != boostFunc && !boostFunc.equals(\"\")) {\n        List<Query> funcs = U.parseFuncs(schema, boostFunc);\n        for (Query f : funcs) {\n          query.add(f, Occur.SHOULD);\n        }\n      }\n            \n      /* * * Restrict Results * * */\n\n      List<Query> restrictions = new ArrayList<Query>(1);\n            \n      /* User Restriction */\n      String filterQueryString = params.get(DMP.FQ);\n      Query filterQuery = null;\n      if (null != filterQueryString && !filterQueryString.equals(\"\")) {\n        filterQuery = p.parse(filterQueryString);\n        restrictions.add(filterQuery);\n      }\n            \n      /* * * Generate Main Results * * */\n\n      flags |= U.setReturnFields(req,rsp);\n      DocList results = s.getDocList(query, restrictions,\n                                     SolrPluginUtils.getSort(req),\n                                     req.getStart(), req.getLimit(),\n                                     flags);\n      rsp.add(\"search-results\",results);\n\n\n            \n      /* * * Debugging Info * * */\n\n      try {\n        NamedList debug = U.doStandardDebug(req, userQuery, query, results);\n        if (null != debug) {\n          debug.add(\"boostquery\", boostQuery);\n          debug.add(\"boostfunc\", boostFunc);\n\n          debug.add(\"filterquery\", filterQueryString);\n          if (null != filterQuery) {\n            debug.add(\"parsedfilterquery\",\n                      QueryParsing.toString(filterQuery, schema));\n          }\n                    \n          rsp.add(\"debug\", debug);\n        }\n\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log,\n                              \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      /* * * Highlighting/Summarizing  * * */\n      if(HighlightingUtils.isHighlightingEnabled(req)) {\n\n        BooleanQuery highlightQuery = new BooleanQuery();\n        U.flattenBooleanQuery(highlightQuery, query);\n        NamedList sumData = HighlightingUtils.doHighlighting(results, highlightQuery, \n                                                     req, queryFields.keySet().toArray(new String[0]));\n        if(sumData != null)\n          rsp.add(\"highlighting\", sumData);\n      }\n            \n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"48f9527d950de8054d6fd72b138e94bc70fd63b4","date":1158101406,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/request/DisMaxRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/request/DisMaxRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n        \n    try {\n      U.setDefaults(req,defaults,appends,invariants);\n      SolrParams params = req.getParams();\n      \n      int flags = 0;\n      \n      SolrIndexSearcher s = req.getSearcher();\n      IndexSchema schema = req.getSchema();\n            \n      Map<String,Float> queryFields = U.parseFieldBoosts(params.get(DMP.QF));\n      Map<String,Float> phraseFields = U.parseFieldBoosts(params.get(DMP.PF));\n\n      float tiebreaker = params.getFloat(DMP.TIE, 0.0f);\n            \n      int pslop = params.getInt(DMP.PS, 0);\n\n      /* a generic parser for parsing regular lucene queries */\n      QueryParser p = new SolrQueryParser(schema, null);\n\n      /* a parser for dealing with user input, which will convert\n       * things to DisjunctionMaxQueries\n       */\n      U.DisjunctionMaxQueryParser up =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, queryFields);\n\n      /* for parsing slopy phrases using DisjunctionMaxQueries */\n      U.DisjunctionMaxQueryParser pp =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, phraseFields);\n      pp.setPhraseSlop(pslop);\n            \n            \n      /* * * Main User Query * * */\n\n      String userQuery = U.partialEscape\n        (U.stripUnbalancedQuotes(params.get(Q))).toString();\n            \n      /* the main query we will execute.  we disable the coord because\n       * this query is an artificial construct\n       */\n      BooleanQuery query = new BooleanQuery(true);\n\n      String minShouldMatch = params.get(DMP.MM, \"100%\");\n            \n      Query dis = up.parse(userQuery);\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        U.flattenBooleanQuery(t, (BooleanQuery)dis);\n\n        U.setMinShouldMatch(t, minShouldMatch);\n                \n        query.add(t, Occur.MUST);\n      } else {\n        query.add(dis, Occur.MUST);\n      }\n\n      /* * * Add on Phrases for the Query * * */\n            \n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, stip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, Occur.SHOULD);\n      }\n            \n      /* * * Boosting Query * * */\n\n      String boostQuery = params.get(DMP.BQ);\n      if (null != boostQuery && !boostQuery.equals(\"\")) {\n        Query tmp = p.parse(boostQuery);\n        /* if the default boost was used, and we've got a BooleanQuery\n         * extract the subqueries out and use them directly\n         */\n        if (1.0f == tmp.getBoost() && tmp instanceof BooleanQuery) {\n          for (BooleanClause c : ((BooleanQuery)tmp).getClauses()) {\n            query.add(c);\n          }\n        } else {\n          query.add(tmp, BooleanClause.Occur.SHOULD);\n        }\n      }\n\n      /* * * Boosting Functions * * */\n\n      String boostFunc = params.get(DMP.BF);\n      if (null != boostFunc && !boostFunc.equals(\"\")) {\n        List<Query> funcs = U.parseFuncs(schema, boostFunc);\n        for (Query f : funcs) {\n          query.add(f, Occur.SHOULD);\n        }\n      }\n            \n      /* * * Restrict Results * * */\n\n      List<Query> restrictions = U.parseFilterQueries(req);\n            \n      /* * * Generate Main Results * * */\n\n      flags |= U.setReturnFields(req,rsp);\n      \n      DocListAndSet results = new DocListAndSet();\n      NamedList facetInfo = null;\n      if (params.getBool(FACET,false)) {\n        results = s.getDocListAndSet(query, restrictions,\n                                     SolrPluginUtils.getSort(req),\n                                     req.getStart(), req.getLimit(),\n                                     flags);\n        facetInfo = getFacetInfo(req, rsp, results.docSet);\n      } else {\n        results.docList = s.getDocList(query, restrictions,\n                                       SolrPluginUtils.getSort(req),\n                                       req.getStart(), req.getLimit(),\n                                       flags);\n      }\n      rsp.add(\"search-results\",results.docList);\n      \n      if (null != facetInfo) rsp.add(\"facet_counts\", facetInfo);\n\n\n            \n      /* * * Debugging Info * * */\n\n      try {\n        NamedList debug = U.doStandardDebug(req, userQuery, query, results.docList);\n        if (null != debug) {\n          debug.add(\"boostquery\", boostQuery);\n          debug.add(\"boostfunc\", boostFunc);\n          if (null != restrictions) {\n            debug.add(\"filter_queries\", params.getParams(FQ));\n            List<String> fqs = new ArrayList<String>(restrictions.size());\n            for (Query fq : restrictions) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            debug.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", debug);\n        }\n\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log,\n                              \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      /* * * Highlighting/Summarizing  * * */\n      if(HighlightingUtils.isHighlightingEnabled(req)) {\n\n        BooleanQuery highlightQuery = new BooleanQuery();\n        U.flattenBooleanQuery(highlightQuery, query);\n        String[] highFields = queryFields.keySet().toArray(new String[0]);\n        NamedList sumData =\n          HighlightingUtils.doHighlighting(results.docList, highlightQuery, \n                                           req, highFields);\n        if(sumData != null)\n          rsp.add(\"highlighting\", sumData);\n      }\n            \n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n    }\n  }\n\n","sourceOld":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n        \n    try {\n      U.setDefaults(req,defaults);\n      SolrParams params = req.getParams();\n      \n      int flags = 0;\n      \n      SolrIndexSearcher s = req.getSearcher();\n      IndexSchema schema = req.getSchema();\n            \n      Map<String,Float> queryFields = U.parseFieldBoosts(params.get(DMP.QF));\n      Map<String,Float> phraseFields = U.parseFieldBoosts(params.get(DMP.PF));\n\n      float tiebreaker = params.getFloat(DMP.TIE, 0.0f);\n            \n      int pslop = params.getInt(DMP.PS, 0);\n\n      /* a generic parser for parsing regular lucene queries */\n      QueryParser p = new SolrQueryParser(schema, null);\n\n      /* a parser for dealing with user input, which will convert\n       * things to DisjunctionMaxQueries\n       */\n      U.DisjunctionMaxQueryParser up =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, queryFields);\n\n      /* for parsing slopy phrases using DisjunctionMaxQueries */\n      U.DisjunctionMaxQueryParser pp =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, phraseFields);\n      pp.setPhraseSlop(pslop);\n            \n            \n      /* * * Main User Query * * */\n\n      String userQuery = U.partialEscape\n        (U.stripUnbalancedQuotes(params.get(Q))).toString();\n            \n      /* the main query we will execute.  we disable the coord because\n       * this query is an artificial construct\n       */\n      BooleanQuery query = new BooleanQuery(true);\n\n      String minShouldMatch = params.get(DMP.MM, \"100%\");\n            \n      Query dis = up.parse(userQuery);\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        U.flattenBooleanQuery(t, (BooleanQuery)dis);\n\n        U.setMinShouldMatch(t, minShouldMatch);\n                \n        query.add(t, Occur.MUST);\n      } else {\n        query.add(dis, Occur.MUST);\n      }\n\n      /* * * Add on Phrases for the Query * * */\n            \n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, stip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, Occur.SHOULD);\n      }\n            \n      /* * * Boosting Query * * */\n\n      String boostQuery = params.get(DMP.BQ);\n      if (null != boostQuery && !boostQuery.equals(\"\")) {\n        Query tmp = p.parse(boostQuery);\n        /* if the default boost was used, and we've got a BooleanQuery\n         * extract the subqueries out and use them directly\n         */\n        if (1.0f == tmp.getBoost() && tmp instanceof BooleanQuery) {\n          for (BooleanClause c : ((BooleanQuery)tmp).getClauses()) {\n            query.add(c);\n          }\n        } else {\n          query.add(tmp, BooleanClause.Occur.SHOULD);\n        }\n      }\n\n      /* * * Boosting Functions * * */\n\n      String boostFunc = params.get(DMP.BF);\n      if (null != boostFunc && !boostFunc.equals(\"\")) {\n        List<Query> funcs = U.parseFuncs(schema, boostFunc);\n        for (Query f : funcs) {\n          query.add(f, Occur.SHOULD);\n        }\n      }\n            \n      /* * * Restrict Results * * */\n\n      List<Query> restrictions = U.parseFilterQueries(req);\n            \n      /* * * Generate Main Results * * */\n\n      flags |= U.setReturnFields(req,rsp);\n      \n      DocListAndSet results = new DocListAndSet();\n      NamedList facetInfo = null;\n      if (params.getBool(FACET,false)) {\n        results = s.getDocListAndSet(query, restrictions,\n                                     SolrPluginUtils.getSort(req),\n                                     req.getStart(), req.getLimit(),\n                                     flags);\n        facetInfo = getFacetInfo(req, rsp, results.docSet);\n      } else {\n        results.docList = s.getDocList(query, restrictions,\n                                       SolrPluginUtils.getSort(req),\n                                       req.getStart(), req.getLimit(),\n                                       flags);\n      }\n      rsp.add(\"search-results\",results.docList);\n      \n      if (null != facetInfo) rsp.add(\"facet_counts\", facetInfo);\n\n\n            \n      /* * * Debugging Info * * */\n\n      try {\n        NamedList debug = U.doStandardDebug(req, userQuery, query, results.docList);\n        if (null != debug) {\n          debug.add(\"boostquery\", boostQuery);\n          debug.add(\"boostfunc\", boostFunc);\n          if (null != restrictions) {\n            debug.add(\"filter_queries\", params.getParams(FQ));\n            List<String> fqs = new ArrayList<String>(restrictions.size());\n            for (Query fq : restrictions) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            debug.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", debug);\n        }\n\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log,\n                              \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      /* * * Highlighting/Summarizing  * * */\n      if(HighlightingUtils.isHighlightingEnabled(req)) {\n\n        BooleanQuery highlightQuery = new BooleanQuery();\n        U.flattenBooleanQuery(highlightQuery, query);\n        String[] highFields = queryFields.keySet().toArray(new String[0]);\n        NamedList sumData =\n          HighlightingUtils.doHighlighting(results.docList, highlightQuery, \n                                           req, highFields);\n        if(sumData != null)\n          rsp.add(\"highlighting\", sumData);\n      }\n            \n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7276fb3ba9d75a3d0099bfd9a0df6b5b067fb12a","date":1164667221,"type":3,"author":"Mike Klaas","isMerge":false,"pathNew":"src/java/org/apache/solr/request/DisMaxRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/request/DisMaxRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n        \n    try {\n      U.setDefaults(req,defaults,appends,invariants);\n      SolrParams params = req.getParams();\n      \n      int flags = 0;\n      \n      SolrIndexSearcher s = req.getSearcher();\n      IndexSchema schema = req.getSchema();\n            \n      Map<String,Float> queryFields = U.parseFieldBoosts(params.get(DMP.QF));\n      Map<String,Float> phraseFields = U.parseFieldBoosts(params.get(DMP.PF));\n\n      float tiebreaker = params.getFloat(DMP.TIE, 0.0f);\n            \n      int pslop = params.getInt(DMP.PS, 0);\n\n      /* a generic parser for parsing regular lucene queries */\n      QueryParser p = new SolrQueryParser(schema, null);\n\n      /* a parser for dealing with user input, which will convert\n       * things to DisjunctionMaxQueries\n       */\n      U.DisjunctionMaxQueryParser up =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, queryFields);\n\n      /* for parsing slopy phrases using DisjunctionMaxQueries */\n      U.DisjunctionMaxQueryParser pp =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, phraseFields);\n      pp.setPhraseSlop(pslop);\n            \n            \n      /* * * Main User Query * * */\n\n      String userQuery = U.partialEscape\n        (U.stripUnbalancedQuotes(params.get(Q))).toString();\n            \n      /* the main query we will execute.  we disable the coord because\n       * this query is an artificial construct\n       */\n      BooleanQuery query = new BooleanQuery(true);\n\n      String minShouldMatch = params.get(DMP.MM, \"100%\");\n            \n      Query dis = up.parse(userQuery);\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        U.flattenBooleanQuery(t, (BooleanQuery)dis);\n\n        U.setMinShouldMatch(t, minShouldMatch);\n                \n        query.add(t, Occur.MUST);\n      } else {\n        query.add(dis, Occur.MUST);\n      }\n\n      /* * * Add on Phrases for the Query * * */\n            \n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, stip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, Occur.SHOULD);\n      }\n            \n      /* * * Boosting Query * * */\n\n      String boostQuery = params.get(DMP.BQ);\n      if (null != boostQuery && !boostQuery.equals(\"\")) {\n        Query tmp = p.parse(boostQuery);\n        /* if the default boost was used, and we've got a BooleanQuery\n         * extract the subqueries out and use them directly\n         */\n        if (1.0f == tmp.getBoost() && tmp instanceof BooleanQuery) {\n          for (BooleanClause c : ((BooleanQuery)tmp).getClauses()) {\n            query.add(c);\n          }\n        } else {\n          query.add(tmp, BooleanClause.Occur.SHOULD);\n        }\n      }\n\n      /* * * Boosting Functions * * */\n\n      String boostFunc = params.get(DMP.BF);\n      if (null != boostFunc && !boostFunc.equals(\"\")) {\n        List<Query> funcs = U.parseFuncs(schema, boostFunc);\n        for (Query f : funcs) {\n          query.add(f, Occur.SHOULD);\n        }\n      }\n            \n      /* * * Restrict Results * * */\n\n      List<Query> restrictions = U.parseFilterQueries(req);\n            \n      /* * * Generate Main Results * * */\n\n      flags |= U.setReturnFields(req,rsp);\n      \n      DocListAndSet results = new DocListAndSet();\n      NamedList facetInfo = null;\n      if (params.getBool(FACET,false)) {\n        results = s.getDocListAndSet(query, restrictions,\n                                     SolrPluginUtils.getSort(req),\n                                     req.getStart(), req.getLimit(),\n                                     flags);\n        facetInfo = getFacetInfo(req, rsp, results.docSet);\n      } else {\n        results.docList = s.getDocList(query, restrictions,\n                                       SolrPluginUtils.getSort(req),\n                                       req.getStart(), req.getLimit(),\n                                       flags);\n      }\n      rsp.add(\"search-results\",results.docList);\n      // pre-fetch returned documents\n      U.optimizePreFetchDocs(results.docList, query, req, rsp);\n\n      \n      if (null != facetInfo) rsp.add(\"facet_counts\", facetInfo);\n\n\n            \n      /* * * Debugging Info * * */\n\n      try {\n        NamedList debug = U.doStandardDebug(req, userQuery, query, results.docList);\n        if (null != debug) {\n          debug.add(\"boostquery\", boostQuery);\n          debug.add(\"boostfunc\", boostFunc);\n          if (null != restrictions) {\n            debug.add(\"filter_queries\", params.getParams(FQ));\n            List<String> fqs = new ArrayList<String>(restrictions.size());\n            for (Query fq : restrictions) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            debug.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", debug);\n        }\n\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log,\n                              \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      /* * * Highlighting/Summarizing  * * */\n      if(HighlightingUtils.isHighlightingEnabled(req)) {\n\n        BooleanQuery highlightQuery = new BooleanQuery();\n        U.flattenBooleanQuery(highlightQuery, query);\n        String[] highFields = queryFields.keySet().toArray(new String[0]);\n        NamedList sumData =\n          HighlightingUtils.doHighlighting(results.docList, highlightQuery, \n                                           req, highFields);\n        if(sumData != null)\n          rsp.add(\"highlighting\", sumData);\n      }\n            \n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n    }\n  }\n\n","sourceOld":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n        \n    try {\n      U.setDefaults(req,defaults,appends,invariants);\n      SolrParams params = req.getParams();\n      \n      int flags = 0;\n      \n      SolrIndexSearcher s = req.getSearcher();\n      IndexSchema schema = req.getSchema();\n            \n      Map<String,Float> queryFields = U.parseFieldBoosts(params.get(DMP.QF));\n      Map<String,Float> phraseFields = U.parseFieldBoosts(params.get(DMP.PF));\n\n      float tiebreaker = params.getFloat(DMP.TIE, 0.0f);\n            \n      int pslop = params.getInt(DMP.PS, 0);\n\n      /* a generic parser for parsing regular lucene queries */\n      QueryParser p = new SolrQueryParser(schema, null);\n\n      /* a parser for dealing with user input, which will convert\n       * things to DisjunctionMaxQueries\n       */\n      U.DisjunctionMaxQueryParser up =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, queryFields);\n\n      /* for parsing slopy phrases using DisjunctionMaxQueries */\n      U.DisjunctionMaxQueryParser pp =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, phraseFields);\n      pp.setPhraseSlop(pslop);\n            \n            \n      /* * * Main User Query * * */\n\n      String userQuery = U.partialEscape\n        (U.stripUnbalancedQuotes(params.get(Q))).toString();\n            \n      /* the main query we will execute.  we disable the coord because\n       * this query is an artificial construct\n       */\n      BooleanQuery query = new BooleanQuery(true);\n\n      String minShouldMatch = params.get(DMP.MM, \"100%\");\n            \n      Query dis = up.parse(userQuery);\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        U.flattenBooleanQuery(t, (BooleanQuery)dis);\n\n        U.setMinShouldMatch(t, minShouldMatch);\n                \n        query.add(t, Occur.MUST);\n      } else {\n        query.add(dis, Occur.MUST);\n      }\n\n      /* * * Add on Phrases for the Query * * */\n            \n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, stip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, Occur.SHOULD);\n      }\n            \n      /* * * Boosting Query * * */\n\n      String boostQuery = params.get(DMP.BQ);\n      if (null != boostQuery && !boostQuery.equals(\"\")) {\n        Query tmp = p.parse(boostQuery);\n        /* if the default boost was used, and we've got a BooleanQuery\n         * extract the subqueries out and use them directly\n         */\n        if (1.0f == tmp.getBoost() && tmp instanceof BooleanQuery) {\n          for (BooleanClause c : ((BooleanQuery)tmp).getClauses()) {\n            query.add(c);\n          }\n        } else {\n          query.add(tmp, BooleanClause.Occur.SHOULD);\n        }\n      }\n\n      /* * * Boosting Functions * * */\n\n      String boostFunc = params.get(DMP.BF);\n      if (null != boostFunc && !boostFunc.equals(\"\")) {\n        List<Query> funcs = U.parseFuncs(schema, boostFunc);\n        for (Query f : funcs) {\n          query.add(f, Occur.SHOULD);\n        }\n      }\n            \n      /* * * Restrict Results * * */\n\n      List<Query> restrictions = U.parseFilterQueries(req);\n            \n      /* * * Generate Main Results * * */\n\n      flags |= U.setReturnFields(req,rsp);\n      \n      DocListAndSet results = new DocListAndSet();\n      NamedList facetInfo = null;\n      if (params.getBool(FACET,false)) {\n        results = s.getDocListAndSet(query, restrictions,\n                                     SolrPluginUtils.getSort(req),\n                                     req.getStart(), req.getLimit(),\n                                     flags);\n        facetInfo = getFacetInfo(req, rsp, results.docSet);\n      } else {\n        results.docList = s.getDocList(query, restrictions,\n                                       SolrPluginUtils.getSort(req),\n                                       req.getStart(), req.getLimit(),\n                                       flags);\n      }\n      rsp.add(\"search-results\",results.docList);\n      \n      if (null != facetInfo) rsp.add(\"facet_counts\", facetInfo);\n\n\n            \n      /* * * Debugging Info * * */\n\n      try {\n        NamedList debug = U.doStandardDebug(req, userQuery, query, results.docList);\n        if (null != debug) {\n          debug.add(\"boostquery\", boostQuery);\n          debug.add(\"boostfunc\", boostFunc);\n          if (null != restrictions) {\n            debug.add(\"filter_queries\", params.getParams(FQ));\n            List<String> fqs = new ArrayList<String>(restrictions.size());\n            for (Query fq : restrictions) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            debug.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", debug);\n        }\n\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log,\n                              \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      /* * * Highlighting/Summarizing  * * */\n      if(HighlightingUtils.isHighlightingEnabled(req)) {\n\n        BooleanQuery highlightQuery = new BooleanQuery();\n        U.flattenBooleanQuery(highlightQuery, query);\n        String[] highFields = queryFields.keySet().toArray(new String[0]);\n        NamedList sumData =\n          HighlightingUtils.doHighlighting(results.docList, highlightQuery, \n                                           req, highFields);\n        if(sumData != null)\n          rsp.add(\"highlighting\", sumData);\n      }\n            \n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7aef5adbca53f7820aa6289dda74f595ed816ac7","date":1166101420,"type":3,"author":"Bertrand Delacretaz","isMerge":false,"pathNew":"src/java/org/apache/solr/request/DisMaxRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/request/DisMaxRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n        \n    try {\n      U.setDefaults(req,defaults,appends,invariants);\n      SolrParams params = req.getParams();\n      \n      int flags = 0;\n      \n      SolrIndexSearcher s = req.getSearcher();\n      IndexSchema schema = req.getSchema();\n            \n      Map<String,Float> queryFields = U.parseFieldBoosts(params.get(DMP.QF));\n      Map<String,Float> phraseFields = U.parseFieldBoosts(params.get(DMP.PF));\n\n      float tiebreaker = params.getFloat(DMP.TIE, 0.0f);\n            \n      int pslop = params.getInt(DMP.PS, 0);\n\n      /* a generic parser for parsing regular lucene queries */\n      QueryParser p = new SolrQueryParser(schema, null);\n\n      /* a parser for dealing with user input, which will convert\n       * things to DisjunctionMaxQueries\n       */\n      U.DisjunctionMaxQueryParser up =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, queryFields);\n\n      /* for parsing slopy phrases using DisjunctionMaxQueries */\n      U.DisjunctionMaxQueryParser pp =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, phraseFields);\n      pp.setPhraseSlop(pslop);\n            \n            \n      /* * * Main User Query * * */\n\n      String userQuery = U.partialEscape\n        (U.stripUnbalancedQuotes(params.get(Q))).toString();\n            \n      /* the main query we will execute.  we disable the coord because\n       * this query is an artificial construct\n       */\n      BooleanQuery query = new BooleanQuery(true);\n\n      String minShouldMatch = params.get(DMP.MM, \"100%\");\n            \n      Query dis = up.parse(userQuery);\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        U.flattenBooleanQuery(t, (BooleanQuery)dis);\n\n        U.setMinShouldMatch(t, minShouldMatch);\n                \n        query.add(t, Occur.MUST);\n      } else {\n        query.add(dis, Occur.MUST);\n      }\n\n      /* * * Add on Phrases for the Query * * */\n            \n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, stip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, Occur.SHOULD);\n      }\n            \n      /* * * Boosting Query * * */\n\n      String boostQuery = params.get(DMP.BQ);\n      if (null != boostQuery && !boostQuery.equals(\"\")) {\n        Query tmp = p.parse(boostQuery);\n        /* if the default boost was used, and we've got a BooleanQuery\n         * extract the subqueries out and use them directly\n         */\n        if (1.0f == tmp.getBoost() && tmp instanceof BooleanQuery) {\n          for (BooleanClause c : ((BooleanQuery)tmp).getClauses()) {\n            query.add(c);\n          }\n        } else {\n          query.add(tmp, BooleanClause.Occur.SHOULD);\n        }\n      }\n\n      /* * * Boosting Functions * * */\n\n      String boostFunc = params.get(DMP.BF);\n      if (null != boostFunc && !boostFunc.equals(\"\")) {\n        List<Query> funcs = U.parseFuncs(schema, boostFunc);\n        for (Query f : funcs) {\n          query.add(f, Occur.SHOULD);\n        }\n      }\n            \n      /* * * Restrict Results * * */\n\n      List<Query> restrictions = U.parseFilterQueries(req);\n            \n      /* * * Generate Main Results * * */\n\n      flags |= U.setReturnFields(req,rsp);\n      \n      DocListAndSet results = new DocListAndSet();\n      NamedList facetInfo = null;\n      if (params.getBool(FACET,false)) {\n        results = s.getDocListAndSet(query, restrictions,\n                                     SolrPluginUtils.getSort(req),\n                                     req.getStart(), req.getLimit(),\n                                     flags);\n        facetInfo = getFacetInfo(req, rsp, results.docSet);\n      } else {\n        results.docList = s.getDocList(query, restrictions,\n                                       SolrPluginUtils.getSort(req),\n                                       req.getStart(), req.getLimit(),\n                                       flags);\n      }\n      rsp.add(\"response\",results.docList);\n      // pre-fetch returned documents\n      U.optimizePreFetchDocs(results.docList, query, req, rsp);\n\n      \n      if (null != facetInfo) rsp.add(\"facet_counts\", facetInfo);\n\n\n            \n      /* * * Debugging Info * * */\n\n      try {\n        NamedList debug = U.doStandardDebug(req, userQuery, query, results.docList);\n        if (null != debug) {\n          debug.add(\"boostquery\", boostQuery);\n          debug.add(\"boostfunc\", boostFunc);\n          if (null != restrictions) {\n            debug.add(\"filter_queries\", params.getParams(FQ));\n            List<String> fqs = new ArrayList<String>(restrictions.size());\n            for (Query fq : restrictions) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            debug.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", debug);\n        }\n\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log,\n                              \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      /* * * Highlighting/Summarizing  * * */\n      if(HighlightingUtils.isHighlightingEnabled(req)) {\n\n        BooleanQuery highlightQuery = new BooleanQuery();\n        U.flattenBooleanQuery(highlightQuery, query);\n        String[] highFields = queryFields.keySet().toArray(new String[0]);\n        NamedList sumData =\n          HighlightingUtils.doHighlighting(results.docList, highlightQuery, \n                                           req, highFields);\n        if(sumData != null)\n          rsp.add(\"highlighting\", sumData);\n      }\n            \n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n    }\n  }\n\n","sourceOld":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n        \n    try {\n      U.setDefaults(req,defaults,appends,invariants);\n      SolrParams params = req.getParams();\n      \n      int flags = 0;\n      \n      SolrIndexSearcher s = req.getSearcher();\n      IndexSchema schema = req.getSchema();\n            \n      Map<String,Float> queryFields = U.parseFieldBoosts(params.get(DMP.QF));\n      Map<String,Float> phraseFields = U.parseFieldBoosts(params.get(DMP.PF));\n\n      float tiebreaker = params.getFloat(DMP.TIE, 0.0f);\n            \n      int pslop = params.getInt(DMP.PS, 0);\n\n      /* a generic parser for parsing regular lucene queries */\n      QueryParser p = new SolrQueryParser(schema, null);\n\n      /* a parser for dealing with user input, which will convert\n       * things to DisjunctionMaxQueries\n       */\n      U.DisjunctionMaxQueryParser up =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, queryFields);\n\n      /* for parsing slopy phrases using DisjunctionMaxQueries */\n      U.DisjunctionMaxQueryParser pp =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, phraseFields);\n      pp.setPhraseSlop(pslop);\n            \n            \n      /* * * Main User Query * * */\n\n      String userQuery = U.partialEscape\n        (U.stripUnbalancedQuotes(params.get(Q))).toString();\n            \n      /* the main query we will execute.  we disable the coord because\n       * this query is an artificial construct\n       */\n      BooleanQuery query = new BooleanQuery(true);\n\n      String minShouldMatch = params.get(DMP.MM, \"100%\");\n            \n      Query dis = up.parse(userQuery);\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        U.flattenBooleanQuery(t, (BooleanQuery)dis);\n\n        U.setMinShouldMatch(t, minShouldMatch);\n                \n        query.add(t, Occur.MUST);\n      } else {\n        query.add(dis, Occur.MUST);\n      }\n\n      /* * * Add on Phrases for the Query * * */\n            \n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, stip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, Occur.SHOULD);\n      }\n            \n      /* * * Boosting Query * * */\n\n      String boostQuery = params.get(DMP.BQ);\n      if (null != boostQuery && !boostQuery.equals(\"\")) {\n        Query tmp = p.parse(boostQuery);\n        /* if the default boost was used, and we've got a BooleanQuery\n         * extract the subqueries out and use them directly\n         */\n        if (1.0f == tmp.getBoost() && tmp instanceof BooleanQuery) {\n          for (BooleanClause c : ((BooleanQuery)tmp).getClauses()) {\n            query.add(c);\n          }\n        } else {\n          query.add(tmp, BooleanClause.Occur.SHOULD);\n        }\n      }\n\n      /* * * Boosting Functions * * */\n\n      String boostFunc = params.get(DMP.BF);\n      if (null != boostFunc && !boostFunc.equals(\"\")) {\n        List<Query> funcs = U.parseFuncs(schema, boostFunc);\n        for (Query f : funcs) {\n          query.add(f, Occur.SHOULD);\n        }\n      }\n            \n      /* * * Restrict Results * * */\n\n      List<Query> restrictions = U.parseFilterQueries(req);\n            \n      /* * * Generate Main Results * * */\n\n      flags |= U.setReturnFields(req,rsp);\n      \n      DocListAndSet results = new DocListAndSet();\n      NamedList facetInfo = null;\n      if (params.getBool(FACET,false)) {\n        results = s.getDocListAndSet(query, restrictions,\n                                     SolrPluginUtils.getSort(req),\n                                     req.getStart(), req.getLimit(),\n                                     flags);\n        facetInfo = getFacetInfo(req, rsp, results.docSet);\n      } else {\n        results.docList = s.getDocList(query, restrictions,\n                                       SolrPluginUtils.getSort(req),\n                                       req.getStart(), req.getLimit(),\n                                       flags);\n      }\n      rsp.add(\"search-results\",results.docList);\n      // pre-fetch returned documents\n      U.optimizePreFetchDocs(results.docList, query, req, rsp);\n\n      \n      if (null != facetInfo) rsp.add(\"facet_counts\", facetInfo);\n\n\n            \n      /* * * Debugging Info * * */\n\n      try {\n        NamedList debug = U.doStandardDebug(req, userQuery, query, results.docList);\n        if (null != debug) {\n          debug.add(\"boostquery\", boostQuery);\n          debug.add(\"boostfunc\", boostFunc);\n          if (null != restrictions) {\n            debug.add(\"filter_queries\", params.getParams(FQ));\n            List<String> fqs = new ArrayList<String>(restrictions.size());\n            for (Query fq : restrictions) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            debug.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", debug);\n        }\n\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log,\n                              \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      /* * * Highlighting/Summarizing  * * */\n      if(HighlightingUtils.isHighlightingEnabled(req)) {\n\n        BooleanQuery highlightQuery = new BooleanQuery();\n        U.flattenBooleanQuery(highlightQuery, query);\n        String[] highFields = queryFields.keySet().toArray(new String[0]);\n        NamedList sumData =\n          HighlightingUtils.doHighlighting(results.docList, highlightQuery, \n                                           req, highFields);\n        if(sumData != null)\n          rsp.add(\"highlighting\", sumData);\n      }\n            \n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa7fe44278811b3571eee535c2695912d7fda5de","date":1167950874,"type":3,"author":"Mike Klaas","isMerge":false,"pathNew":"src/java/org/apache/solr/request/DisMaxRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/request/DisMaxRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n        \n    try {\n      U.setDefaults(req,defaults,appends,invariants);\n      SolrParams params = req.getParams();\n      \n      int flags = 0;\n      \n      SolrIndexSearcher s = req.getSearcher();\n      IndexSchema schema = req.getSchema();\n            \n      Map<String,Float> queryFields = U.parseFieldBoosts(params.get(DMP.QF));\n      Map<String,Float> phraseFields = U.parseFieldBoosts(params.get(DMP.PF));\n\n      float tiebreaker = params.getFloat(DMP.TIE, 0.0f);\n            \n      int pslop = params.getInt(DMP.PS, 0);\n\n      /* a generic parser for parsing regular lucene queries */\n      QueryParser p = new SolrQueryParser(schema, null);\n\n      /* a parser for dealing with user input, which will convert\n       * things to DisjunctionMaxQueries\n       */\n      U.DisjunctionMaxQueryParser up =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, queryFields);\n\n      /* for parsing slopy phrases using DisjunctionMaxQueries */\n      U.DisjunctionMaxQueryParser pp =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, phraseFields);\n      pp.setPhraseSlop(pslop);\n            \n            \n      /* * * Main User Query * * */\n\n      String userQuery = U.partialEscape\n        (U.stripUnbalancedQuotes(params.get(Q))).toString();\n            \n      /* the main query we will execute.  we disable the coord because\n       * this query is an artificial construct\n       */\n      BooleanQuery query = new BooleanQuery(true);\n\n      String minShouldMatch = params.get(DMP.MM, \"100%\");\n      Query dis = up.parse(userQuery);\n      Query parsedUserQuery = dis;\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        U.flattenBooleanQuery(t, (BooleanQuery)dis);\n        U.setMinShouldMatch(t, minShouldMatch);                \n        parsedUserQuery = t;\n      } \n      query.add(parsedUserQuery, Occur.MUST);\n\n      /* * * Add on Phrases for the Query * * */\n            \n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, stip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, Occur.SHOULD);\n      }\n            \n      /* * * Boosting Query * * */\n\n      String boostQuery = params.get(DMP.BQ);\n      if (null != boostQuery && !boostQuery.equals(\"\")) {\n        Query tmp = p.parse(boostQuery);\n        /* if the default boost was used, and we've got a BooleanQuery\n         * extract the subqueries out and use them directly\n         */\n        if (1.0f == tmp.getBoost() && tmp instanceof BooleanQuery) {\n          for (BooleanClause c : ((BooleanQuery)tmp).getClauses()) {\n            query.add(c);\n          }\n        } else {\n          query.add(tmp, BooleanClause.Occur.SHOULD);\n        }\n      }\n\n      /* * * Boosting Functions * * */\n\n      String boostFunc = params.get(DMP.BF);\n      if (null != boostFunc && !boostFunc.equals(\"\")) {\n        List<Query> funcs = U.parseFuncs(schema, boostFunc);\n        for (Query f : funcs) {\n          query.add(f, Occur.SHOULD);\n        }\n      }\n            \n      /* * * Restrict Results * * */\n\n      List<Query> restrictions = U.parseFilterQueries(req);\n            \n      /* * * Generate Main Results * * */\n\n      flags |= U.setReturnFields(req,rsp);\n      \n      DocListAndSet results = new DocListAndSet();\n      NamedList facetInfo = null;\n      if (params.getBool(FACET,false)) {\n        results = s.getDocListAndSet(query, restrictions,\n                                     SolrPluginUtils.getSort(req),\n                                     req.getStart(), req.getLimit(),\n                                     flags);\n        facetInfo = getFacetInfo(req, rsp, results.docSet);\n      } else {\n        results.docList = s.getDocList(query, restrictions,\n                                       SolrPluginUtils.getSort(req),\n                                       req.getStart(), req.getLimit(),\n                                       flags);\n      }\n      rsp.add(\"response\",results.docList);\n      // pre-fetch returned documents\n      U.optimizePreFetchDocs(results.docList, query, req, rsp);\n\n      \n      if (null != facetInfo) rsp.add(\"facet_counts\", facetInfo);\n\n\n            \n      /* * * Debugging Info * * */\n\n      try {\n        NamedList debug = U.doStandardDebug(req, userQuery, query, results.docList);\n        if (null != debug) {\n          debug.add(\"boostquery\", boostQuery);\n          debug.add(\"boostfunc\", boostFunc);\n          if (null != restrictions) {\n            debug.add(\"filter_queries\", params.getParams(FQ));\n            List<String> fqs = new ArrayList<String>(restrictions.size());\n            for (Query fq : restrictions) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            debug.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", debug);\n        }\n\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log,\n                              \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      /* * * Highlighting/Summarizing  * * */\n      if(HighlightingUtils.isHighlightingEnabled(req)) {\n        String[] highFields = queryFields.keySet().toArray(new String[0]);\n        NamedList sumData =\n          HighlightingUtils.doHighlighting(results.docList, parsedUserQuery, \n                                           req, highFields);\n        if(sumData != null)\n          rsp.add(\"highlighting\", sumData);\n      }\n            \n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n    }\n  }\n\n","sourceOld":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n        \n    try {\n      U.setDefaults(req,defaults,appends,invariants);\n      SolrParams params = req.getParams();\n      \n      int flags = 0;\n      \n      SolrIndexSearcher s = req.getSearcher();\n      IndexSchema schema = req.getSchema();\n            \n      Map<String,Float> queryFields = U.parseFieldBoosts(params.get(DMP.QF));\n      Map<String,Float> phraseFields = U.parseFieldBoosts(params.get(DMP.PF));\n\n      float tiebreaker = params.getFloat(DMP.TIE, 0.0f);\n            \n      int pslop = params.getInt(DMP.PS, 0);\n\n      /* a generic parser for parsing regular lucene queries */\n      QueryParser p = new SolrQueryParser(schema, null);\n\n      /* a parser for dealing with user input, which will convert\n       * things to DisjunctionMaxQueries\n       */\n      U.DisjunctionMaxQueryParser up =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, queryFields);\n\n      /* for parsing slopy phrases using DisjunctionMaxQueries */\n      U.DisjunctionMaxQueryParser pp =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, phraseFields);\n      pp.setPhraseSlop(pslop);\n            \n            \n      /* * * Main User Query * * */\n\n      String userQuery = U.partialEscape\n        (U.stripUnbalancedQuotes(params.get(Q))).toString();\n            \n      /* the main query we will execute.  we disable the coord because\n       * this query is an artificial construct\n       */\n      BooleanQuery query = new BooleanQuery(true);\n\n      String minShouldMatch = params.get(DMP.MM, \"100%\");\n            \n      Query dis = up.parse(userQuery);\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        U.flattenBooleanQuery(t, (BooleanQuery)dis);\n\n        U.setMinShouldMatch(t, minShouldMatch);\n                \n        query.add(t, Occur.MUST);\n      } else {\n        query.add(dis, Occur.MUST);\n      }\n\n      /* * * Add on Phrases for the Query * * */\n            \n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, stip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, Occur.SHOULD);\n      }\n            \n      /* * * Boosting Query * * */\n\n      String boostQuery = params.get(DMP.BQ);\n      if (null != boostQuery && !boostQuery.equals(\"\")) {\n        Query tmp = p.parse(boostQuery);\n        /* if the default boost was used, and we've got a BooleanQuery\n         * extract the subqueries out and use them directly\n         */\n        if (1.0f == tmp.getBoost() && tmp instanceof BooleanQuery) {\n          for (BooleanClause c : ((BooleanQuery)tmp).getClauses()) {\n            query.add(c);\n          }\n        } else {\n          query.add(tmp, BooleanClause.Occur.SHOULD);\n        }\n      }\n\n      /* * * Boosting Functions * * */\n\n      String boostFunc = params.get(DMP.BF);\n      if (null != boostFunc && !boostFunc.equals(\"\")) {\n        List<Query> funcs = U.parseFuncs(schema, boostFunc);\n        for (Query f : funcs) {\n          query.add(f, Occur.SHOULD);\n        }\n      }\n            \n      /* * * Restrict Results * * */\n\n      List<Query> restrictions = U.parseFilterQueries(req);\n            \n      /* * * Generate Main Results * * */\n\n      flags |= U.setReturnFields(req,rsp);\n      \n      DocListAndSet results = new DocListAndSet();\n      NamedList facetInfo = null;\n      if (params.getBool(FACET,false)) {\n        results = s.getDocListAndSet(query, restrictions,\n                                     SolrPluginUtils.getSort(req),\n                                     req.getStart(), req.getLimit(),\n                                     flags);\n        facetInfo = getFacetInfo(req, rsp, results.docSet);\n      } else {\n        results.docList = s.getDocList(query, restrictions,\n                                       SolrPluginUtils.getSort(req),\n                                       req.getStart(), req.getLimit(),\n                                       flags);\n      }\n      rsp.add(\"response\",results.docList);\n      // pre-fetch returned documents\n      U.optimizePreFetchDocs(results.docList, query, req, rsp);\n\n      \n      if (null != facetInfo) rsp.add(\"facet_counts\", facetInfo);\n\n\n            \n      /* * * Debugging Info * * */\n\n      try {\n        NamedList debug = U.doStandardDebug(req, userQuery, query, results.docList);\n        if (null != debug) {\n          debug.add(\"boostquery\", boostQuery);\n          debug.add(\"boostfunc\", boostFunc);\n          if (null != restrictions) {\n            debug.add(\"filter_queries\", params.getParams(FQ));\n            List<String> fqs = new ArrayList<String>(restrictions.size());\n            for (Query fq : restrictions) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            debug.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", debug);\n        }\n\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log,\n                              \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      /* * * Highlighting/Summarizing  * * */\n      if(HighlightingUtils.isHighlightingEnabled(req)) {\n\n        BooleanQuery highlightQuery = new BooleanQuery();\n        U.flattenBooleanQuery(highlightQuery, query);\n        String[] highFields = queryFields.keySet().toArray(new String[0]);\n        NamedList sumData =\n          HighlightingUtils.doHighlighting(results.docList, highlightQuery, \n                                           req, highFields);\n        if(sumData != null)\n          rsp.add(\"highlighting\", sumData);\n      }\n            \n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d80013b5e260def972025c93a0b08524f9c38f49","date":1170102801,"type":5,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/request/DisMaxRequestHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/request/DisMaxRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n      SolrParams params = req.getParams();\n      \n      int flags = 0;\n      \n      SolrIndexSearcher s = req.getSearcher();\n      IndexSchema schema = req.getSchema();\n            \n      Map<String,Float> queryFields = U.parseFieldBoosts(params.get(DMP.QF));\n      Map<String,Float> phraseFields = U.parseFieldBoosts(params.get(DMP.PF));\n\n      float tiebreaker = params.getFloat(DMP.TIE, 0.0f);\n            \n      int pslop = params.getInt(DMP.PS, 0);\n\n      /* a generic parser for parsing regular lucene queries */\n      QueryParser p = new SolrQueryParser(schema, null);\n\n      /* a parser for dealing with user input, which will convert\n       * things to DisjunctionMaxQueries\n       */\n      U.DisjunctionMaxQueryParser up =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, queryFields);\n\n      /* for parsing slopy phrases using DisjunctionMaxQueries */\n      U.DisjunctionMaxQueryParser pp =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, phraseFields);\n      pp.setPhraseSlop(pslop);\n            \n            \n      /* * * Main User Query * * */\n\n      String userQuery = U.partialEscape\n        (U.stripUnbalancedQuotes(params.get(Q))).toString();\n            \n      /* the main query we will execute.  we disable the coord because\n       * this query is an artificial construct\n       */\n      BooleanQuery query = new BooleanQuery(true);\n\n      String minShouldMatch = params.get(DMP.MM, \"100%\");\n      Query dis = up.parse(userQuery);\n      Query parsedUserQuery = dis;\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        U.flattenBooleanQuery(t, (BooleanQuery)dis);\n        U.setMinShouldMatch(t, minShouldMatch);                \n        parsedUserQuery = t;\n      } \n      query.add(parsedUserQuery, Occur.MUST);\n\n      /* * * Add on Phrases for the Query * * */\n            \n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, stip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, Occur.SHOULD);\n      }\n            \n      /* * * Boosting Query * * */\n\n      String boostQuery = params.get(DMP.BQ);\n      if (null != boostQuery && !boostQuery.equals(\"\")) {\n        Query tmp = p.parse(boostQuery);\n        /* if the default boost was used, and we've got a BooleanQuery\n         * extract the subqueries out and use them directly\n         */\n        if (1.0f == tmp.getBoost() && tmp instanceof BooleanQuery) {\n          for (BooleanClause c : ((BooleanQuery)tmp).getClauses()) {\n            query.add(c);\n          }\n        } else {\n          query.add(tmp, BooleanClause.Occur.SHOULD);\n        }\n      }\n\n      /* * * Boosting Functions * * */\n\n      String boostFunc = params.get(DMP.BF);\n      if (null != boostFunc && !boostFunc.equals(\"\")) {\n        List<Query> funcs = U.parseFuncs(schema, boostFunc);\n        for (Query f : funcs) {\n          query.add(f, Occur.SHOULD);\n        }\n      }\n            \n      /* * * Restrict Results * * */\n\n      List<Query> restrictions = U.parseFilterQueries(req);\n            \n      /* * * Generate Main Results * * */\n\n      flags |= U.setReturnFields(req,rsp);\n      \n      DocListAndSet results = new DocListAndSet();\n      NamedList facetInfo = null;\n      if (params.getBool(FACET,false)) {\n        results = s.getDocListAndSet(query, restrictions,\n                                     SolrPluginUtils.getSort(req),\n                                     req.getStart(), req.getLimit(),\n                                     flags);\n        facetInfo = getFacetInfo(req, rsp, results.docSet);\n      } else {\n        results.docList = s.getDocList(query, restrictions,\n                                       SolrPluginUtils.getSort(req),\n                                       req.getStart(), req.getLimit(),\n                                       flags);\n      }\n      rsp.add(\"response\",results.docList);\n      // pre-fetch returned documents\n      U.optimizePreFetchDocs(results.docList, query, req, rsp);\n\n      \n      if (null != facetInfo) rsp.add(\"facet_counts\", facetInfo);\n\n\n            \n      /* * * Debugging Info * * */\n\n      try {\n        NamedList debug = U.doStandardDebug(req, userQuery, query, results.docList);\n        if (null != debug) {\n          debug.add(\"boostquery\", boostQuery);\n          debug.add(\"boostfunc\", boostFunc);\n          if (null != restrictions) {\n            debug.add(\"filter_queries\", params.getParams(FQ));\n            List<String> fqs = new ArrayList<String>(restrictions.size());\n            for (Query fq : restrictions) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            debug.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", debug);\n        }\n\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log,\n                              \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      /* * * Highlighting/Summarizing  * * */\n      if(HighlightingUtils.isHighlightingEnabled(req)) {\n        String[] highFields = queryFields.keySet().toArray(new String[0]);\n        NamedList sumData =\n          HighlightingUtils.doHighlighting(results.docList, parsedUserQuery, \n                                           req, highFields);\n        if(sumData != null)\n          rsp.add(\"highlighting\", sumData);\n      }\n  }\n\n","sourceOld":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n        \n    try {\n      U.setDefaults(req,defaults,appends,invariants);\n      SolrParams params = req.getParams();\n      \n      int flags = 0;\n      \n      SolrIndexSearcher s = req.getSearcher();\n      IndexSchema schema = req.getSchema();\n            \n      Map<String,Float> queryFields = U.parseFieldBoosts(params.get(DMP.QF));\n      Map<String,Float> phraseFields = U.parseFieldBoosts(params.get(DMP.PF));\n\n      float tiebreaker = params.getFloat(DMP.TIE, 0.0f);\n            \n      int pslop = params.getInt(DMP.PS, 0);\n\n      /* a generic parser for parsing regular lucene queries */\n      QueryParser p = new SolrQueryParser(schema, null);\n\n      /* a parser for dealing with user input, which will convert\n       * things to DisjunctionMaxQueries\n       */\n      U.DisjunctionMaxQueryParser up =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, queryFields);\n\n      /* for parsing slopy phrases using DisjunctionMaxQueries */\n      U.DisjunctionMaxQueryParser pp =\n        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);\n      pp.addAlias(IMPOSSIBLE_FIELD_NAME,\n                  tiebreaker, phraseFields);\n      pp.setPhraseSlop(pslop);\n            \n            \n      /* * * Main User Query * * */\n\n      String userQuery = U.partialEscape\n        (U.stripUnbalancedQuotes(params.get(Q))).toString();\n            \n      /* the main query we will execute.  we disable the coord because\n       * this query is an artificial construct\n       */\n      BooleanQuery query = new BooleanQuery(true);\n\n      String minShouldMatch = params.get(DMP.MM, \"100%\");\n      Query dis = up.parse(userQuery);\n      Query parsedUserQuery = dis;\n\n      if (dis instanceof BooleanQuery) {\n        BooleanQuery t = new BooleanQuery();\n        U.flattenBooleanQuery(t, (BooleanQuery)dis);\n        U.setMinShouldMatch(t, minShouldMatch);                \n        parsedUserQuery = t;\n      } \n      query.add(parsedUserQuery, Occur.MUST);\n\n      /* * * Add on Phrases for the Query * * */\n            \n      /* build up phrase boosting queries */\n\n      /* if the userQuery already has some quotes, stip them out.\n       * we've already done the phrases they asked for in the main\n       * part of the query, this is to boost docs that may not have\n       * matched those phrases but do match looser phrases.\n       */\n      String userPhraseQuery = userQuery.replace(\"\\\"\",\"\");\n      Query phrase = pp.parse(\"\\\"\" + userPhraseQuery + \"\\\"\");\n      if (null != phrase) {\n        query.add(phrase, Occur.SHOULD);\n      }\n            \n      /* * * Boosting Query * * */\n\n      String boostQuery = params.get(DMP.BQ);\n      if (null != boostQuery && !boostQuery.equals(\"\")) {\n        Query tmp = p.parse(boostQuery);\n        /* if the default boost was used, and we've got a BooleanQuery\n         * extract the subqueries out and use them directly\n         */\n        if (1.0f == tmp.getBoost() && tmp instanceof BooleanQuery) {\n          for (BooleanClause c : ((BooleanQuery)tmp).getClauses()) {\n            query.add(c);\n          }\n        } else {\n          query.add(tmp, BooleanClause.Occur.SHOULD);\n        }\n      }\n\n      /* * * Boosting Functions * * */\n\n      String boostFunc = params.get(DMP.BF);\n      if (null != boostFunc && !boostFunc.equals(\"\")) {\n        List<Query> funcs = U.parseFuncs(schema, boostFunc);\n        for (Query f : funcs) {\n          query.add(f, Occur.SHOULD);\n        }\n      }\n            \n      /* * * Restrict Results * * */\n\n      List<Query> restrictions = U.parseFilterQueries(req);\n            \n      /* * * Generate Main Results * * */\n\n      flags |= U.setReturnFields(req,rsp);\n      \n      DocListAndSet results = new DocListAndSet();\n      NamedList facetInfo = null;\n      if (params.getBool(FACET,false)) {\n        results = s.getDocListAndSet(query, restrictions,\n                                     SolrPluginUtils.getSort(req),\n                                     req.getStart(), req.getLimit(),\n                                     flags);\n        facetInfo = getFacetInfo(req, rsp, results.docSet);\n      } else {\n        results.docList = s.getDocList(query, restrictions,\n                                       SolrPluginUtils.getSort(req),\n                                       req.getStart(), req.getLimit(),\n                                       flags);\n      }\n      rsp.add(\"response\",results.docList);\n      // pre-fetch returned documents\n      U.optimizePreFetchDocs(results.docList, query, req, rsp);\n\n      \n      if (null != facetInfo) rsp.add(\"facet_counts\", facetInfo);\n\n\n            \n      /* * * Debugging Info * * */\n\n      try {\n        NamedList debug = U.doStandardDebug(req, userQuery, query, results.docList);\n        if (null != debug) {\n          debug.add(\"boostquery\", boostQuery);\n          debug.add(\"boostfunc\", boostFunc);\n          if (null != restrictions) {\n            debug.add(\"filter_queries\", params.getParams(FQ));\n            List<String> fqs = new ArrayList<String>(restrictions.size());\n            for (Query fq : restrictions) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            debug.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", debug);\n        }\n\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log,\n                              \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      /* * * Highlighting/Summarizing  * * */\n      if(HighlightingUtils.isHighlightingEnabled(req)) {\n        String[] highFields = queryFields.keySet().toArray(new String[0]);\n        NamedList sumData =\n          HighlightingUtils.doHighlighting(results.docList, parsedUserQuery, \n                                           req, highFields);\n        if(sumData != null)\n          rsp.add(\"highlighting\", sumData);\n      }\n            \n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d1b4f9f023bf5098df34505adf1ed91daa67c239":["c0907819f524a744c3377371e616839271317ac6"],"44f497c313977be641ddf24aab74b30e6de834d8":["0452863ee588101738d341e6e97eb87eb010052a"],"7276fb3ba9d75a3d0099bfd9a0df6b5b067fb12a":["48f9527d950de8054d6fd72b138e94bc70fd63b4"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"af09a11446184597ca824554260a98704507f8a7":["44f497c313977be641ddf24aab74b30e6de834d8"],"c0907819f524a744c3377371e616839271317ac6":["af09a11446184597ca824554260a98704507f8a7"],"d80013b5e260def972025c93a0b08524f9c38f49":["fa7fe44278811b3571eee535c2695912d7fda5de"],"e4b5867a57b32674ce740e66e6a7da8db3d4dd33":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"0452863ee588101738d341e6e97eb87eb010052a":["e4b5867a57b32674ce740e66e6a7da8db3d4dd33"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fa7fe44278811b3571eee535c2695912d7fda5de":["7aef5adbca53f7820aa6289dda74f595ed816ac7"],"7aef5adbca53f7820aa6289dda74f595ed816ac7":["7276fb3ba9d75a3d0099bfd9a0df6b5b067fb12a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"48f9527d950de8054d6fd72b138e94bc70fd63b4":["d1b4f9f023bf5098df34505adf1ed91daa67c239"]},"commit2Childs":{"d1b4f9f023bf5098df34505adf1ed91daa67c239":["48f9527d950de8054d6fd72b138e94bc70fd63b4"],"44f497c313977be641ddf24aab74b30e6de834d8":["af09a11446184597ca824554260a98704507f8a7"],"7276fb3ba9d75a3d0099bfd9a0df6b5b067fb12a":["7aef5adbca53f7820aa6289dda74f595ed816ac7"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["e4b5867a57b32674ce740e66e6a7da8db3d4dd33"],"af09a11446184597ca824554260a98704507f8a7":["c0907819f524a744c3377371e616839271317ac6"],"c0907819f524a744c3377371e616839271317ac6":["d1b4f9f023bf5098df34505adf1ed91daa67c239"],"d80013b5e260def972025c93a0b08524f9c38f49":[],"e4b5867a57b32674ce740e66e6a7da8db3d4dd33":["0452863ee588101738d341e6e97eb87eb010052a"],"0452863ee588101738d341e6e97eb87eb010052a":["44f497c313977be641ddf24aab74b30e6de834d8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fa7fe44278811b3571eee535c2695912d7fda5de":["d80013b5e260def972025c93a0b08524f9c38f49"],"7aef5adbca53f7820aa6289dda74f595ed816ac7":["fa7fe44278811b3571eee535c2695912d7fda5de"],"48f9527d950de8054d6fd72b138e94bc70fd63b4":["7276fb3ba9d75a3d0099bfd9a0df6b5b067fb12a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d80013b5e260def972025c93a0b08524f9c38f49","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}