{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,IOContext).mjava","commits":[{"id":"23ab146d336df02e9a396ea060f8f4b114dc33a6","date":1344450994,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName, IOContext context)\n      throws IOException {\n    \n    // note: we don't really need this fis (its copied), but we load it up\n    // so we don't pass a null value to the si writer\n    FieldInfos fis = getFieldInfos(info.info);\n    \n    final Map<String,String> attributes;\n    // copy the attributes map, we might modify it below.\n    // also we need to ensure its read-write, since we will invoke the SIwriter (which might want to set something).\n    if (info.info.attributes() == null) {\n      attributes = new HashMap<String,String>();\n    } else {\n      attributes = new HashMap<String,String>(info.info.attributes());\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n    // Same SI as before but we change directory and name\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), attributes);\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      newFileName = segName + IndexFileNames.stripSegmentName(file);\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references segment name in its list of files, etc\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n\n    newInfo.getCodec().segmentInfoFormat().getSegmentInfoWriter().write(trackingDir, newInfo, fis, context);\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName = segName + IndexFileNames.stripSegmentName(file);\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  // TODO: this can be substantially simplified now that 3.x support/shared docstores is removed!\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    final String dsName = info.info.name;\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n\n    // note: we don't really need this fis (its copied), but we load it up\n    // so we don't pass a null value to the si writer\n    FieldInfos fis = getFieldInfos(info.info);\n    \n    final Map<String,String> attributes;\n    // copy the attributes map, we might modify it below.\n    // also we need to ensure its read-write, since we will invoke the SIwriter (which might want to set something).\n    if (info.info.attributes() == null) {\n      attributes = new HashMap<String,String>();\n    } else {\n      attributes = new HashMap<String,String>(info.info.attributes());\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), attributes);\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      newFileName = segName + IndexFileNames.stripSegmentName(file);\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n    try {\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfoWriter().write(trackingDir, newInfo, fis, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName = segName + IndexFileNames.stripSegmentName(file);\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,IOContext).mjava","pathOld":"/dev/null","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName, IOContext context)\n      throws IOException {\n    \n    // note: we don't really need this fis (its copied), but we load it up\n    // so we don't pass a null value to the si writer\n    FieldInfos fis = getFieldInfos(info.info);\n    \n    final Map<String,String> attributes;\n    // copy the attributes map, we might modify it below.\n    // also we need to ensure its read-write, since we will invoke the SIwriter (which might want to set something).\n    if (info.info.attributes() == null) {\n      attributes = new HashMap<String,String>();\n    } else {\n      attributes = new HashMap<String,String>(info.info.attributes());\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n    // Same SI as before but we change directory and name\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), attributes);\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      newFileName = segName + IndexFileNames.stripSegmentName(file);\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references segment name in its list of files, etc\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n\n    newInfo.getCodec().segmentInfoFormat().getSegmentInfoWriter().write(trackingDir, newInfo, fis, context);\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName = segName + IndexFileNames.stripSegmentName(file);\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":1,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,Map[String,String],Set[String],IOContext,Set[String]).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName, IOContext context)\n      throws IOException {\n    \n    // note: we don't really need this fis (its copied), but we load it up\n    // so we don't pass a null value to the si writer\n    FieldInfos fis = getFieldInfos(info.info);\n    \n    final Map<String,String> attributes;\n    // copy the attributes map, we might modify it below.\n    // also we need to ensure its read-write, since we will invoke the SIwriter (which might want to set something).\n    if (info.info.attributes() == null) {\n      attributes = new HashMap<String,String>();\n    } else {\n      attributes = new HashMap<String,String>(info.info.attributes());\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n    // Same SI as before but we change directory and name\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), attributes);\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      newFileName = segName + IndexFileNames.stripSegmentName(file);\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references segment name in its list of files, etc\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n\n    newInfo.getCodec().segmentInfoFormat().getSegmentInfoWriter().write(trackingDir, newInfo, fis, context);\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName = segName + IndexFileNames.stripSegmentName(file);\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  // TODO: this can be substantially simplified now that 3.x support/shared docstores is removed!\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName,\n                                               Map<String, String> dsNames, Set<String> dsFilesCopied, IOContext context,\n                                               Set<String> copiedFiles)\n      throws IOException {\n    // Determine if the doc store of this segment needs to be copied. It's\n    // only relevant for segments that share doc store with others,\n    // because the DS might have been copied already, in which case we\n    // just want to update the DS name of this SegmentInfo.\n    final String dsName = info.info.name;\n    assert dsName != null;\n    final String newDsName;\n    if (dsNames.containsKey(dsName)) {\n      newDsName = dsNames.get(dsName);\n    } else {\n      dsNames.put(dsName, segName);\n      newDsName = segName;\n    }\n\n    // note: we don't really need this fis (its copied), but we load it up\n    // so we don't pass a null value to the si writer\n    FieldInfos fis = getFieldInfos(info.info);\n    \n    final Map<String,String> attributes;\n    // copy the attributes map, we might modify it below.\n    // also we need to ensure its read-write, since we will invoke the SIwriter (which might want to set something).\n    if (info.info.attributes() == null) {\n      attributes = new HashMap<String,String>();\n    } else {\n      attributes = new HashMap<String,String>(info.info.attributes());\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n    // Same SI as before but we change directory, name and docStoreSegment:\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), attributes);\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      newFileName = segName + IndexFileNames.stripSegmentName(file);\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references\n    // segment name (its own name, if its 3.x, and doc\n    // store segment name):\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n    try {\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfoWriter().write(trackingDir, newInfo, fis, context);\n    } catch (UnsupportedOperationException uoe) {\n      // OK: 3x codec cannot write a new SI file;\n      // SegmentInfos will write this on commit\n    }\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName = segName + IndexFileNames.stripSegmentName(file);\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n      assert !copiedFiles.contains(file): \"file \\\"\" + file + \"\\\" is being copied more than once\";\n      copiedFiles.add(file);\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9eae2a56dc810a17cf807d831f720dec931a03de","date":1349262073,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,IOContext).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName, IOContext context)\n      throws IOException {\n    \n    // note: we don't really need this fis (its copied), but we load it up\n    // so we don't pass a null value to the si writer\n    FieldInfos fis = getFieldInfos(info.info);\n    \n    final Map<String,String> attributes;\n    // copy the attributes map, we might modify it below.\n    // also we need to ensure its read-write, since we will invoke the SIwriter (which might want to set something).\n    if (info.info.attributes() == null) {\n      attributes = new HashMap<String,String>();\n    } else {\n      attributes = new HashMap<String,String>(info.info.attributes());\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n    // Same SI as before but we change directory and name\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), attributes);\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      newFileName = segName + IndexFileNames.stripSegmentName(file);\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references segment name in its list of files, etc\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n\n    boolean success = false;\n\n    try {\n\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfoWriter().write(trackingDir, newInfo, fis, context);\n\n      final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n      // Copy the segment's files\n      for (String file: info.files()) {\n\n        final String newFileName = segName + IndexFileNames.stripSegmentName(file);\n\n        if (siFiles.contains(newFileName)) {\n          // We already rewrote this above\n          continue;\n        }\n\n        assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n\n        info.info.dir.copy(directory, file, newFileName, context);\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        for(String file : newInfo.files()) {\n          try {\n            directory.deleteFile(file);\n          } catch (Throwable t) {\n          }\n        }\n      }\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName, IOContext context)\n      throws IOException {\n    \n    // note: we don't really need this fis (its copied), but we load it up\n    // so we don't pass a null value to the si writer\n    FieldInfos fis = getFieldInfos(info.info);\n    \n    final Map<String,String> attributes;\n    // copy the attributes map, we might modify it below.\n    // also we need to ensure its read-write, since we will invoke the SIwriter (which might want to set something).\n    if (info.info.attributes() == null) {\n      attributes = new HashMap<String,String>();\n    } else {\n      attributes = new HashMap<String,String>(info.info.attributes());\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n    // Same SI as before but we change directory and name\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), attributes);\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      newFileName = segName + IndexFileNames.stripSegmentName(file);\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references segment name in its list of files, etc\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n\n    newInfo.getCodec().segmentInfoFormat().getSegmentInfoWriter().write(trackingDir, newInfo, fis, context);\n\n    final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n    // Copy the segment's files\n    for (String file: info.files()) {\n\n      final String newFileName = segName + IndexFileNames.stripSegmentName(file);\n\n      if (siFiles.contains(newFileName)) {\n        // We already rewrote this above\n        continue;\n      }\n\n      assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n\n      info.info.dir.copy(directory, file, newFileName, context);\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","bugFix":null,"bugIntro":["5f6bd27530a2846413fe2d00030493c0e2d3a072"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e072d0b1fc19e0533d8ce432eed245196bca6fde","date":1379265112,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,IOContext).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName, IOContext context)\n      throws IOException {\n    \n    // note: we don't really need this fis (its copied), but we load it up\n    // so we don't pass a null value to the si writer\n    FieldInfos fis = getFieldInfos(info.info);\n    \n    final Map<String,String> attributes;\n    // copy the attributes map, we might modify it below.\n    // also we need to ensure its read-write, since we will invoke the SIwriter (which might want to set something).\n    if (info.info.attributes() == null) {\n      attributes = new HashMap<String,String>();\n    } else {\n      attributes = new HashMap<String,String>(info.info.attributes());\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n    // Same SI as before but we change directory and name\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), attributes);\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen(), info.getDocValuesGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      newFileName = segName + IndexFileNames.stripSegmentName(file);\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references segment name in its list of files, etc\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n\n    boolean success = false;\n\n    try {\n\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfoWriter().write(trackingDir, newInfo, fis, context);\n\n      final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n      // Copy the segment's files\n      for (String file: info.files()) {\n\n        final String newFileName = segName + IndexFileNames.stripSegmentName(file);\n\n        if (siFiles.contains(newFileName)) {\n          // We already rewrote this above\n          continue;\n        }\n\n        assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n\n        info.info.dir.copy(directory, file, newFileName, context);\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        for(String file : newInfo.files()) {\n          try {\n            directory.deleteFile(file);\n          } catch (Throwable t) {\n          }\n        }\n      }\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName, IOContext context)\n      throws IOException {\n    \n    // note: we don't really need this fis (its copied), but we load it up\n    // so we don't pass a null value to the si writer\n    FieldInfos fis = getFieldInfos(info.info);\n    \n    final Map<String,String> attributes;\n    // copy the attributes map, we might modify it below.\n    // also we need to ensure its read-write, since we will invoke the SIwriter (which might want to set something).\n    if (info.info.attributes() == null) {\n      attributes = new HashMap<String,String>();\n    } else {\n      attributes = new HashMap<String,String>(info.info.attributes());\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n    // Same SI as before but we change directory and name\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), attributes);\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      newFileName = segName + IndexFileNames.stripSegmentName(file);\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references segment name in its list of files, etc\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n\n    boolean success = false;\n\n    try {\n\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfoWriter().write(trackingDir, newInfo, fis, context);\n\n      final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n      // Copy the segment's files\n      for (String file: info.files()) {\n\n        final String newFileName = segName + IndexFileNames.stripSegmentName(file);\n\n        if (siFiles.contains(newFileName)) {\n          // We already rewrote this above\n          continue;\n        }\n\n        assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n\n        info.info.dir.copy(directory, file, newFileName, context);\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        for(String file : newInfo.files()) {\n          try {\n            directory.deleteFile(file);\n          } catch (Throwable t) {\n          }\n        }\n      }\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8435160e9702b19398118ddf76b61c846612b6a4","date":1380349140,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,IOContext).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName, IOContext context)\n      throws IOException {\n    \n    // note: we don't really need this fis (its copied), but we load it up\n    // so we don't pass a null value to the si writer\n    FieldInfos fis = SegmentReader.readFieldInfos(info);\n    \n    final Map<String,String> attributes;\n    // copy the attributes map, we might modify it below.\n    // also we need to ensure its read-write, since we will invoke the SIwriter (which might want to set something).\n    if (info.info.attributes() == null) {\n      attributes = new HashMap<String,String>();\n    } else {\n      attributes = new HashMap<String,String>(info.info.attributes());\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n    // Same SI as before but we change directory and name\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), attributes);\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen(), info.getFieldInfosGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      newFileName = segName + IndexFileNames.stripSegmentName(file);\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references segment name in its list of files, etc\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n\n    boolean success = false;\n\n    try {\n\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfoWriter().write(trackingDir, newInfo, fis, context);\n\n      final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n      // Copy the segment's files\n      for (String file: info.files()) {\n\n        final String newFileName = segName + IndexFileNames.stripSegmentName(file);\n\n        if (siFiles.contains(newFileName)) {\n          // We already rewrote this above\n          continue;\n        }\n\n        assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n\n        info.info.dir.copy(directory, file, newFileName, context);\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        for(String file : newInfo.files()) {\n          try {\n            directory.deleteFile(file);\n          } catch (Throwable t) {\n          }\n        }\n      }\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName, IOContext context)\n      throws IOException {\n    \n    // note: we don't really need this fis (its copied), but we load it up\n    // so we don't pass a null value to the si writer\n    FieldInfos fis = getFieldInfos(info.info);\n    \n    final Map<String,String> attributes;\n    // copy the attributes map, we might modify it below.\n    // also we need to ensure its read-write, since we will invoke the SIwriter (which might want to set something).\n    if (info.info.attributes() == null) {\n      attributes = new HashMap<String,String>();\n    } else {\n      attributes = new HashMap<String,String>(info.info.attributes());\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n    // Same SI as before but we change directory and name\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), attributes);\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen(), info.getDocValuesGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      newFileName = segName + IndexFileNames.stripSegmentName(file);\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references segment name in its list of files, etc\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n\n    boolean success = false;\n\n    try {\n\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfoWriter().write(trackingDir, newInfo, fis, context);\n\n      final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n      // Copy the segment's files\n      for (String file: info.files()) {\n\n        final String newFileName = segName + IndexFileNames.stripSegmentName(file);\n\n        if (siFiles.contains(newFileName)) {\n          // We already rewrote this above\n          continue;\n        }\n\n        assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n\n        info.info.dir.copy(directory, file, newFileName, context);\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        for(String file : newInfo.files()) {\n          try {\n            directory.deleteFile(file);\n          } catch (Throwable t) {\n          }\n        }\n      }\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","bugFix":null,"bugIntro":["5f6bd27530a2846413fe2d00030493c0e2d3a072"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"77f264c55cbf75404f8601ae7290d69157273a56","date":1380484282,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,IOContext).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName, IOContext context)\n      throws IOException {\n    \n    // note: we don't really need this fis (its copied), but we load it up\n    // so we don't pass a null value to the si writer\n    FieldInfos fis = SegmentReader.readFieldInfos(info);\n    \n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n    // Same SI as before but we change directory and name\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getUseCompoundFile(), info.info.getCodec(), \n                                          info.info.getDiagnostics());\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen(), info.getFieldInfosGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      newFileName = segName + IndexFileNames.stripSegmentName(file);\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references segment name in its list of files, etc\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n\n    boolean success = false;\n\n    try {\n\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfoWriter().write(trackingDir, newInfo, fis, context);\n\n      final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n      // Copy the segment's files\n      for (String file: info.files()) {\n\n        final String newFileName = segName + IndexFileNames.stripSegmentName(file);\n\n        if (siFiles.contains(newFileName)) {\n          // We already rewrote this above\n          continue;\n        }\n\n        assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n\n        info.info.dir.copy(directory, file, newFileName, context);\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        for(String file : newInfo.files()) {\n          try {\n            directory.deleteFile(file);\n          } catch (Throwable t) {\n          }\n        }\n      }\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName, IOContext context)\n      throws IOException {\n    \n    // note: we don't really need this fis (its copied), but we load it up\n    // so we don't pass a null value to the si writer\n    FieldInfos fis = SegmentReader.readFieldInfos(info);\n    \n    final Map<String,String> attributes;\n    // copy the attributes map, we might modify it below.\n    // also we need to ensure its read-write, since we will invoke the SIwriter (which might want to set something).\n    if (info.info.attributes() == null) {\n      attributes = new HashMap<String,String>();\n    } else {\n      attributes = new HashMap<String,String>(info.info.attributes());\n    }\n\n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n    // Same SI as before but we change directory and name\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getUseCompoundFile(),\n                                          info.info.getCodec(), info.info.getDiagnostics(), attributes);\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen(), info.getFieldInfosGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      newFileName = segName + IndexFileNames.stripSegmentName(file);\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references segment name in its list of files, etc\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n\n    boolean success = false;\n\n    try {\n\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfoWriter().write(trackingDir, newInfo, fis, context);\n\n      final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n      // Copy the segment's files\n      for (String file: info.files()) {\n\n        final String newFileName = segName + IndexFileNames.stripSegmentName(file);\n\n        if (siFiles.contains(newFileName)) {\n          // We already rewrote this above\n          continue;\n        }\n\n        assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n\n        info.info.dir.copy(directory, file, newFileName, context);\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        for(String file : newInfo.files()) {\n          try {\n            directory.deleteFile(file);\n          } catch (Throwable t) {\n          }\n        }\n      }\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","date":1383367127,"type":5,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentCommitInfo,String,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#copySegmentAsIs(SegmentInfoPerCommit,String,IOContext).mjava","sourceNew":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentCommitInfo copySegmentAsIs(SegmentCommitInfo info, String segName, IOContext context)\n      throws IOException {\n    \n    // note: we don't really need this fis (its copied), but we load it up\n    // so we don't pass a null value to the si writer\n    FieldInfos fis = SegmentReader.readFieldInfos(info);\n    \n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n    // Same SI as before but we change directory and name\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getUseCompoundFile(), info.info.getCodec(), \n                                          info.info.getDiagnostics());\n    SegmentCommitInfo newInfoPerCommit = new SegmentCommitInfo(newInfo, info.getDelCount(), info.getDelGen(), info.getFieldInfosGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      newFileName = segName + IndexFileNames.stripSegmentName(file);\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references segment name in its list of files, etc\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n\n    boolean success = false;\n\n    try {\n\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfoWriter().write(trackingDir, newInfo, fis, context);\n\n      final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n      // Copy the segment's files\n      for (String file: info.files()) {\n\n        final String newFileName = segName + IndexFileNames.stripSegmentName(file);\n\n        if (siFiles.contains(newFileName)) {\n          // We already rewrote this above\n          continue;\n        }\n\n        assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n\n        info.info.dir.copy(directory, file, newFileName, context);\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        for(String file : newInfo.files()) {\n          try {\n            directory.deleteFile(file);\n          } catch (Throwable t) {\n          }\n        }\n      }\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","sourceOld":"  /** Copies the segment files as-is into the IndexWriter's directory. */\n  private SegmentInfoPerCommit copySegmentAsIs(SegmentInfoPerCommit info, String segName, IOContext context)\n      throws IOException {\n    \n    // note: we don't really need this fis (its copied), but we load it up\n    // so we don't pass a null value to the si writer\n    FieldInfos fis = SegmentReader.readFieldInfos(info);\n    \n    //System.out.println(\"copy seg=\" + info.info.name + \" version=\" + info.info.getVersion());\n    // Same SI as before but we change directory and name\n    SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),\n                                          info.info.getUseCompoundFile(), info.info.getCodec(), \n                                          info.info.getDiagnostics());\n    SegmentInfoPerCommit newInfoPerCommit = new SegmentInfoPerCommit(newInfo, info.getDelCount(), info.getDelGen(), info.getFieldInfosGen());\n\n    Set<String> segFiles = new HashSet<String>();\n\n    // Build up new segment's file names.  Must do this\n    // before writing SegmentInfo:\n    for (String file: info.files()) {\n      final String newFileName;\n      newFileName = segName + IndexFileNames.stripSegmentName(file);\n      segFiles.add(newFileName);\n    }\n    newInfo.setFiles(segFiles);\n\n    // We must rewrite the SI file because it references segment name in its list of files, etc\n    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);\n\n    boolean success = false;\n\n    try {\n\n      newInfo.getCodec().segmentInfoFormat().getSegmentInfoWriter().write(trackingDir, newInfo, fis, context);\n\n      final Collection<String> siFiles = trackingDir.getCreatedFiles();\n\n      // Copy the segment's files\n      for (String file: info.files()) {\n\n        final String newFileName = segName + IndexFileNames.stripSegmentName(file);\n\n        if (siFiles.contains(newFileName)) {\n          // We already rewrote this above\n          continue;\n        }\n\n        assert !directory.fileExists(newFileName): \"file \\\"\" + newFileName + \"\\\" already exists; siFiles=\" + siFiles;\n\n        info.info.dir.copy(directory, file, newFileName, context);\n      }\n      success = true;\n    } finally {\n      if (!success) {\n        for(String file : newInfo.files()) {\n          try {\n            directory.deleteFile(file);\n          } catch (Throwable t) {\n          }\n        }\n      }\n    }\n    \n    return newInfoPerCommit;\n  }\n\n","bugFix":null,"bugIntro":["5f6bd27530a2846413fe2d00030493c0e2d3a072","0567bdc5c86c94ced64201187cfcef2417d76dda"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"e072d0b1fc19e0533d8ce432eed245196bca6fde":["9eae2a56dc810a17cf807d831f720dec931a03de"],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["77f264c55cbf75404f8601ae7290d69157273a56"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","23ab146d336df02e9a396ea060f8f4b114dc33a6"],"9eae2a56dc810a17cf807d831f720dec931a03de":["23ab146d336df02e9a396ea060f8f4b114dc33a6"],"23ab146d336df02e9a396ea060f8f4b114dc33a6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8435160e9702b19398118ddf76b61c846612b6a4":["e072d0b1fc19e0533d8ce432eed245196bca6fde"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","23ab146d336df02e9a396ea060f8f4b114dc33a6"],"77f264c55cbf75404f8601ae7290d69157273a56":["8435160e9702b19398118ddf76b61c846612b6a4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"]},"commit2Childs":{"e072d0b1fc19e0533d8ce432eed245196bca6fde":["8435160e9702b19398118ddf76b61c846612b6a4"],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":[],"9eae2a56dc810a17cf807d831f720dec931a03de":["e072d0b1fc19e0533d8ce432eed245196bca6fde"],"23ab146d336df02e9a396ea060f8f4b114dc33a6":["c7869f64c874ebf7f317d22c00baf2b6857797a6","9eae2a56dc810a17cf807d831f720dec931a03de","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c7869f64c874ebf7f317d22c00baf2b6857797a6","23ab146d336df02e9a396ea060f8f4b114dc33a6","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"8435160e9702b19398118ddf76b61c846612b6a4":["77f264c55cbf75404f8601ae7290d69157273a56"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"77f264c55cbf75404f8601ae7290d69157273a56":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c7869f64c874ebf7f317d22c00baf2b6857797a6","d6f074e73200c07d54f242d3880a8da5a35ff97b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}