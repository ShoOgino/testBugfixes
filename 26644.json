{"path":"solr/solrj/src/java/org/apache/solr/common/util/Utils#getReflectData(Class).mjava","commits":[{"id":"940c75fcb0bf7bc85eff175ced7f2d3e08868105","date":1593753958,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/Utils#getReflectData(Class).mjava","pathOld":"/dev/null","sourceNew":"  @SuppressWarnings(\"rawtypes\")\n  private static List<FieldWriter> getReflectData(Class c) throws IllegalAccessException {\n    boolean sameClassLoader = c.getClassLoader() == Utils.class.getClassLoader();\n    //we should not cache the class references of objects loaded from packages because they will not get garbage collected\n    //TODO fix that later\n    List<FieldWriter> reflectData = sameClassLoader ? storedReflectData.get(c): null;\n    if(reflectData == null) {\n      ArrayList<FieldWriter> l = new ArrayList<>();\n      MethodHandles.Lookup lookup = MethodHandles.publicLookup();\n      for (Field field : lookup.accessClass(c).getFields()) {\n        JsonProperty prop = field.getAnnotation(JsonProperty.class);\n        if (prop == null) continue;\n        int modifiers = field.getModifiers();\n        if (Modifier.isPublic(modifiers) && !Modifier.isStatic(modifiers)) {\n          String fname = prop.value().isEmpty() ? field.getName() : prop.value();\n          final VarHandle vhandle = lookup.unreflectVarHandle(field);\n          if (field.getType() == int.class) {\n            l.add((ew, inst) -> ew.put(fname, (int) vhandle.get(inst)));\n          } else if (field.getType() == long.class) {\n            l.add((ew, inst) -> ew.put(fname, (long) vhandle.get(inst)));\n          } else if (field.getType() == boolean.class) {\n            l.add((ew, inst) -> ew.put(fname, (boolean) vhandle.get(inst)));\n          } else if (field.getType() == double.class) {\n            l.add((ew, inst) -> ew.put(fname, (double) vhandle.get(inst)));\n          } else if (field.getType() == float.class) {\n            l.add((ew, inst) -> ew.put(fname, (float) vhandle.get(inst)));\n          } else {\n            l.add((ew, inst) -> ew.put(fname, vhandle.get(inst)));\n          }\n        }}\n\n      if(sameClassLoader){\n        storedReflectData.put(c, reflectData = Collections.unmodifiableList(new ArrayList<>(l)));\n      }\n    }\n    return reflectData;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"75f02fb3e11aab47cb88dbe1d07dc2a64ec80c05","date":1594282102,"type":3,"author":"noblepaul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/Utils#getReflectData(Class).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/Utils#getReflectData(Class).mjava","sourceNew":"  @SuppressWarnings(\"rawtypes\")\n  private static List<FieldWriter> getReflectData(Class c) throws IllegalAccessException {\n    boolean sameClassLoader = c.getClassLoader() == Utils.class.getClassLoader();\n    //we should not cache the class references of objects loaded from packages because they will not get garbage collected\n    //TODO fix that later\n    List<FieldWriter> reflectData = sameClassLoader ? storedReflectData.get(c): null;\n    if(reflectData == null) {\n      ArrayList<FieldWriter> l = new ArrayList<>();\n      MethodHandles.Lookup lookup = MethodHandles.publicLookup();\n      for (Field field : lookup.accessClass(c).getFields()) {\n        JsonProperty prop = field.getAnnotation(JsonProperty.class);\n        if (prop == null) continue;\n        int modifiers = field.getModifiers();\n        if (Modifier.isPublic(modifiers) && !Modifier.isStatic(modifiers)) {\n          String fname = prop.value().isEmpty() ? field.getName() : prop.value();\n          try {\n            if (field.getType() == int.class) {\n              MethodHandle mh = lookup.findGetter(c, field.getName(), int.class);\n              l.add((ew, inst) -> ew.put(fname, (int) mh.invoke(inst)));\n            } else if (field.getType() == long.class) {\n              MethodHandle mh = lookup.findGetter(c, field.getName(), long.class);\n              l.add((ew, inst) -> ew.put(fname, (long) mh.invoke(inst)));\n            } else if (field.getType() == boolean.class) {\n              MethodHandle mh = lookup.findGetter(c, field.getName(), boolean.class);\n              l.add((ew, inst) -> ew.put(fname, (boolean) mh.invoke(inst)));\n            } else if (field.getType() == double.class) {\n              MethodHandle mh = lookup.findGetter(c, field.getName(), double.class);\n              l.add((ew, inst) -> ew.put(fname, (double) mh.invoke(inst)));\n            } else if (field.getType() == float.class) {\n              MethodHandle mh = lookup.findGetter(c, field.getName(), float.class);\n              l.add((ew, inst) -> ew.put(fname, (float) mh.invoke(inst)));\n            } else {\n              MethodHandle mh = lookup.findGetter(c, field.getName(), field.getType());\n              l.add((ew, inst) -> ew.put(fname, mh.invoke(inst)));\n            }\n          } catch (NoSuchFieldException e) {\n            //this is unlikely\n            throw new RuntimeException(e);\n          }\n        }}\n\n      if(sameClassLoader){\n        storedReflectData.put(c, reflectData = Collections.unmodifiableList(new ArrayList<>(l)));\n      }\n    }\n    return reflectData;\n  }\n\n","sourceOld":"  @SuppressWarnings(\"rawtypes\")\n  private static List<FieldWriter> getReflectData(Class c) throws IllegalAccessException {\n    boolean sameClassLoader = c.getClassLoader() == Utils.class.getClassLoader();\n    //we should not cache the class references of objects loaded from packages because they will not get garbage collected\n    //TODO fix that later\n    List<FieldWriter> reflectData = sameClassLoader ? storedReflectData.get(c): null;\n    if(reflectData == null) {\n      ArrayList<FieldWriter> l = new ArrayList<>();\n      MethodHandles.Lookup lookup = MethodHandles.publicLookup();\n      for (Field field : lookup.accessClass(c).getFields()) {\n        JsonProperty prop = field.getAnnotation(JsonProperty.class);\n        if (prop == null) continue;\n        int modifiers = field.getModifiers();\n        if (Modifier.isPublic(modifiers) && !Modifier.isStatic(modifiers)) {\n          String fname = prop.value().isEmpty() ? field.getName() : prop.value();\n          final VarHandle vhandle = lookup.unreflectVarHandle(field);\n          if (field.getType() == int.class) {\n            l.add((ew, inst) -> ew.put(fname, (int) vhandle.get(inst)));\n          } else if (field.getType() == long.class) {\n            l.add((ew, inst) -> ew.put(fname, (long) vhandle.get(inst)));\n          } else if (field.getType() == boolean.class) {\n            l.add((ew, inst) -> ew.put(fname, (boolean) vhandle.get(inst)));\n          } else if (field.getType() == double.class) {\n            l.add((ew, inst) -> ew.put(fname, (double) vhandle.get(inst)));\n          } else if (field.getType() == float.class) {\n            l.add((ew, inst) -> ew.put(fname, (float) vhandle.get(inst)));\n          } else {\n            l.add((ew, inst) -> ew.put(fname, vhandle.get(inst)));\n          }\n        }}\n\n      if(sameClassLoader){\n        storedReflectData.put(c, reflectData = Collections.unmodifiableList(new ArrayList<>(l)));\n      }\n    }\n    return reflectData;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0b6680904fafe5905f847812d32dc7ad79c96a0","date":1600243603,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/Utils#getReflectData(Class).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/Utils#getReflectData(Class).mjava","sourceNew":"  @SuppressWarnings(\"rawtypes\")\n  private static List<FieldWriter> getReflectData(Class c) throws IllegalAccessException {\n    boolean sameClassLoader = c.getClassLoader() == Utils.class.getClassLoader();\n    //we should not cache the class references of objects loaded from packages because they will not get garbage collected\n    //TODO fix that later\n    List<FieldWriter> reflectData = sameClassLoader ? storedReflectData.get(c): null;\n    if(reflectData == null) {\n      ArrayList<FieldWriter> l = new ArrayList<>();\n      MethodHandles.Lookup lookup = MethodHandles.publicLookup();\n      for (Field field : lookup.accessClass(c).getFields()) {\n        JsonProperty prop = field.getAnnotation(JsonProperty.class);\n        if (prop == null) continue;\n        int modifiers = field.getModifiers();\n        if (Modifier.isPublic(modifiers) && !Modifier.isStatic(modifiers)) {\n          String fname = prop.value().isEmpty() ? field.getName() : prop.value();\n          try {\n            if (field.getType() == int.class) {\n              MethodHandle mh = lookup.findGetter(c, field.getName(), int.class);\n              l.add((ew, inst) -> ew.put(fname, (int) mh.invoke(inst)));\n            } else if (field.getType() == long.class) {\n              MethodHandle mh = lookup.findGetter(c, field.getName(), long.class);\n              l.add((ew, inst) -> ew.put(fname, (long) mh.invoke(inst)));\n            } else if (field.getType() == boolean.class) {\n              MethodHandle mh = lookup.findGetter(c, field.getName(), boolean.class);\n              l.add((ew, inst) -> ew.put(fname, (boolean) mh.invoke(inst)));\n            } else if (field.getType() == double.class) {\n              MethodHandle mh = lookup.findGetter(c, field.getName(), double.class);\n              l.add((ew, inst) -> ew.put(fname, (double) mh.invoke(inst)));\n            } else if (field.getType() == float.class) {\n              MethodHandle mh = lookup.findGetter(c, field.getName(), float.class);\n              l.add((ew, inst) -> ew.put(fname, (float) mh.invoke(inst)));\n            } else {\n              MethodHandle mh = lookup.findGetter(c, field.getName(), field.getType());\n              l.add((ew, inst) -> ew.putIfNotNull(fname, mh.invoke(inst)));\n            }\n          } catch (NoSuchFieldException e) {\n            //this is unlikely\n            throw new RuntimeException(e);\n          }\n        }}\n\n      if(sameClassLoader){\n        storedReflectData.put(c, reflectData = Collections.unmodifiableList(new ArrayList<>(l)));\n      }\n    }\n    return reflectData;\n  }\n\n","sourceOld":"  @SuppressWarnings(\"rawtypes\")\n  private static List<FieldWriter> getReflectData(Class c) throws IllegalAccessException {\n    boolean sameClassLoader = c.getClassLoader() == Utils.class.getClassLoader();\n    //we should not cache the class references of objects loaded from packages because they will not get garbage collected\n    //TODO fix that later\n    List<FieldWriter> reflectData = sameClassLoader ? storedReflectData.get(c): null;\n    if(reflectData == null) {\n      ArrayList<FieldWriter> l = new ArrayList<>();\n      MethodHandles.Lookup lookup = MethodHandles.publicLookup();\n      for (Field field : lookup.accessClass(c).getFields()) {\n        JsonProperty prop = field.getAnnotation(JsonProperty.class);\n        if (prop == null) continue;\n        int modifiers = field.getModifiers();\n        if (Modifier.isPublic(modifiers) && !Modifier.isStatic(modifiers)) {\n          String fname = prop.value().isEmpty() ? field.getName() : prop.value();\n          try {\n            if (field.getType() == int.class) {\n              MethodHandle mh = lookup.findGetter(c, field.getName(), int.class);\n              l.add((ew, inst) -> ew.put(fname, (int) mh.invoke(inst)));\n            } else if (field.getType() == long.class) {\n              MethodHandle mh = lookup.findGetter(c, field.getName(), long.class);\n              l.add((ew, inst) -> ew.put(fname, (long) mh.invoke(inst)));\n            } else if (field.getType() == boolean.class) {\n              MethodHandle mh = lookup.findGetter(c, field.getName(), boolean.class);\n              l.add((ew, inst) -> ew.put(fname, (boolean) mh.invoke(inst)));\n            } else if (field.getType() == double.class) {\n              MethodHandle mh = lookup.findGetter(c, field.getName(), double.class);\n              l.add((ew, inst) -> ew.put(fname, (double) mh.invoke(inst)));\n            } else if (field.getType() == float.class) {\n              MethodHandle mh = lookup.findGetter(c, field.getName(), float.class);\n              l.add((ew, inst) -> ew.put(fname, (float) mh.invoke(inst)));\n            } else {\n              MethodHandle mh = lookup.findGetter(c, field.getName(), field.getType());\n              l.add((ew, inst) -> ew.put(fname, mh.invoke(inst)));\n            }\n          } catch (NoSuchFieldException e) {\n            //this is unlikely\n            throw new RuntimeException(e);\n          }\n        }}\n\n      if(sameClassLoader){\n        storedReflectData.put(c, reflectData = Collections.unmodifiableList(new ArrayList<>(l)));\n      }\n    }\n    return reflectData;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"680b6449f09827f58fe987aff279e014c311d966","date":1600247985,"type":3,"author":"noblepaul","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/Utils#getReflectData(Class).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/Utils#getReflectData(Class).mjava","sourceNew":"  @SuppressWarnings(\"rawtypes\")\n  private static List<FieldWriter> getReflectData(Class c) throws IllegalAccessException {\n    boolean sameClassLoader = c.getClassLoader() == Utils.class.getClassLoader();\n    //we should not cache the class references of objects loaded from packages because they will not get garbage collected\n    //TODO fix that later\n    List<FieldWriter> reflectData = sameClassLoader ? storedReflectData.get(c): null;\n    if(reflectData == null) {\n      ArrayList<FieldWriter> l = new ArrayList<>();\n      MethodHandles.Lookup lookup = MethodHandles.publicLookup();\n      for (Field field : lookup.accessClass(c).getFields()) {\n        JsonProperty prop = field.getAnnotation(JsonProperty.class);\n        if (prop == null) continue;\n        int modifiers = field.getModifiers();\n        if (Modifier.isPublic(modifiers) && !Modifier.isStatic(modifiers)) {\n          String fname = prop.value().isEmpty() ? field.getName() : prop.value();\n          try {\n            if (field.getType() == int.class) {\n              MethodHandle mh = lookup.findGetter(c, field.getName(), int.class);\n              l.add((ew, inst) -> ew.put(fname, (int) mh.invoke(inst)));\n            } else if (field.getType() == long.class) {\n              MethodHandle mh = lookup.findGetter(c, field.getName(), long.class);\n              l.add((ew, inst) -> ew.put(fname, (long) mh.invoke(inst)));\n            } else if (field.getType() == boolean.class) {\n              MethodHandle mh = lookup.findGetter(c, field.getName(), boolean.class);\n              l.add((ew, inst) -> ew.put(fname, (boolean) mh.invoke(inst)));\n            } else if (field.getType() == double.class) {\n              MethodHandle mh = lookup.findGetter(c, field.getName(), double.class);\n              l.add((ew, inst) -> ew.put(fname, (double) mh.invoke(inst)));\n            } else if (field.getType() == float.class) {\n              MethodHandle mh = lookup.findGetter(c, field.getName(), float.class);\n              l.add((ew, inst) -> ew.put(fname, (float) mh.invoke(inst)));\n            } else {\n              MethodHandle mh = lookup.findGetter(c, field.getName(), field.getType());\n              l.add((ew, inst) -> ew.putIfNotNull(fname, mh.invoke(inst)));\n            }\n          } catch (NoSuchFieldException e) {\n            //this is unlikely\n            throw new RuntimeException(e);\n          }\n        }}\n\n      if(sameClassLoader){\n        storedReflectData.put(c, reflectData = Collections.unmodifiableList(new ArrayList<>(l)));\n      }\n    }\n    return reflectData;\n  }\n\n","sourceOld":"  @SuppressWarnings(\"rawtypes\")\n  private static List<FieldWriter> getReflectData(Class c) throws IllegalAccessException {\n    boolean sameClassLoader = c.getClassLoader() == Utils.class.getClassLoader();\n    //we should not cache the class references of objects loaded from packages because they will not get garbage collected\n    //TODO fix that later\n    List<FieldWriter> reflectData = sameClassLoader ? storedReflectData.get(c): null;\n    if(reflectData == null) {\n      ArrayList<FieldWriter> l = new ArrayList<>();\n      MethodHandles.Lookup lookup = MethodHandles.publicLookup();\n      for (Field field : lookup.accessClass(c).getFields()) {\n        JsonProperty prop = field.getAnnotation(JsonProperty.class);\n        if (prop == null) continue;\n        int modifiers = field.getModifiers();\n        if (Modifier.isPublic(modifiers) && !Modifier.isStatic(modifiers)) {\n          String fname = prop.value().isEmpty() ? field.getName() : prop.value();\n          try {\n            if (field.getType() == int.class) {\n              MethodHandle mh = lookup.findGetter(c, field.getName(), int.class);\n              l.add((ew, inst) -> ew.put(fname, (int) mh.invoke(inst)));\n            } else if (field.getType() == long.class) {\n              MethodHandle mh = lookup.findGetter(c, field.getName(), long.class);\n              l.add((ew, inst) -> ew.put(fname, (long) mh.invoke(inst)));\n            } else if (field.getType() == boolean.class) {\n              MethodHandle mh = lookup.findGetter(c, field.getName(), boolean.class);\n              l.add((ew, inst) -> ew.put(fname, (boolean) mh.invoke(inst)));\n            } else if (field.getType() == double.class) {\n              MethodHandle mh = lookup.findGetter(c, field.getName(), double.class);\n              l.add((ew, inst) -> ew.put(fname, (double) mh.invoke(inst)));\n            } else if (field.getType() == float.class) {\n              MethodHandle mh = lookup.findGetter(c, field.getName(), float.class);\n              l.add((ew, inst) -> ew.put(fname, (float) mh.invoke(inst)));\n            } else {\n              MethodHandle mh = lookup.findGetter(c, field.getName(), field.getType());\n              l.add((ew, inst) -> ew.put(fname, mh.invoke(inst)));\n            }\n          } catch (NoSuchFieldException e) {\n            //this is unlikely\n            throw new RuntimeException(e);\n          }\n        }}\n\n      if(sameClassLoader){\n        storedReflectData.put(c, reflectData = Collections.unmodifiableList(new ArrayList<>(l)));\n      }\n    }\n    return reflectData;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"680b6449f09827f58fe987aff279e014c311d966":["75f02fb3e11aab47cb88dbe1d07dc2a64ec80c05","c0b6680904fafe5905f847812d32dc7ad79c96a0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c0b6680904fafe5905f847812d32dc7ad79c96a0":["75f02fb3e11aab47cb88dbe1d07dc2a64ec80c05"],"75f02fb3e11aab47cb88dbe1d07dc2a64ec80c05":["940c75fcb0bf7bc85eff175ced7f2d3e08868105"],"940c75fcb0bf7bc85eff175ced7f2d3e08868105":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["680b6449f09827f58fe987aff279e014c311d966"]},"commit2Childs":{"680b6449f09827f58fe987aff279e014c311d966":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["940c75fcb0bf7bc85eff175ced7f2d3e08868105"],"c0b6680904fafe5905f847812d32dc7ad79c96a0":["680b6449f09827f58fe987aff279e014c311d966"],"75f02fb3e11aab47cb88dbe1d07dc2a64ec80c05":["680b6449f09827f58fe987aff279e014c311d966","c0b6680904fafe5905f847812d32dc7ad79c96a0"],"940c75fcb0bf7bc85eff175ced7f2d3e08868105":["75f02fb3e11aab47cb88dbe1d07dc2a64ec80c05"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}