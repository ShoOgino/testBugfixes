{"path":"solr/core/src/test/org/apache/solr/cloud/TriLevelCompositeIdRoutingTest#doTriLevelHashingTest().mjava","commits":[{"id":"f7623716022a9a68898e329e8ffe6c36d168fba7","date":1384524101,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TriLevelCompositeIdRoutingTest#doTriLevelHashingTest().mjava","pathOld":"/dev/null","sourceNew":"  private void doTriLevelHashingTest() throws Exception {\n    log.info(\"### STARTING doTriLevelHashingTest\");\n    // for now,  we know how ranges will be distributed to shards.\n    // may have to look it up in clusterstate if that assumption changes.\n\n    Random r = new Random();\n\n    for (int i=0;i < NUM_DOCS;i++) {\n      int appId = r.nextInt(NUM_APPS) + 1;\n      int userId = r.nextInt(NUM_USERS) + 1;\n\n      String id = \"app\" + appId + \"!\" + \"user\" + userId + \"!\" + \"doc\" + r.nextInt(100);\n      doAddDoc(id);\n\n    }\n\n    commit();\n\n    HashMap<String, Integer> idMap = new HashMap<String, Integer>();\n\n    for(int i=1;i<=sliceCount;i++) {\n\n      Set<String> ids = doQueryGetUniqueIdKeys(\"q\", \"*:*\", \"shards\", \"shard\" + i);\n      for(String id:ids) {\n        assertFalse(\"Found the same route key [\" + id + \"] in 2 shards.\", idMap.containsKey(id));\n        idMap.put(getKey(id), i);\n      }\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8acea81aba1fc014206342150f41de3396ce64fc","date":1384534141,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TriLevelCompositeIdRoutingTest#doTriLevelHashingTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TriLevelCompositeIdRoutingTest#doTriLevelHashingTest().mjava","sourceNew":"  private void doTriLevelHashingTest() throws Exception {\n    log.info(\"### STARTING doTriLevelHashingTest\");\n    // for now,  we know how ranges will be distributed to shards.\n    // may have to look it up in clusterstate if that assumption changes.\n\n    for (int i=0;i < NUM_DOCS;i++) {\n      int appId = r.nextInt(NUM_APPS) + 1;\n      int userId = r.nextInt(NUM_USERS) + 1;\n\n      String id = \"app\" + appId + \"!\" + \"user\" + userId + \"!\" + \"doc\" + r.nextInt(100);\n      doAddDoc(id);\n\n    }\n\n    commit();\n\n    HashMap<String, Integer> idMap = new HashMap<String, Integer>();\n\n    for(int i=1;i<=sliceCount;i++) {\n\n      Set<String> ids = doQueryGetUniqueIdKeys(\"q\", \"*:*\", \"shards\", \"shard\" + i);\n      for(String id:ids) {\n        assertFalse(\"Found the same route key [\" + id + \"] in 2 shards.\", idMap.containsKey(id));\n        idMap.put(getKey(id), i);\n      }\n    }\n\n  }\n\n","sourceOld":"  private void doTriLevelHashingTest() throws Exception {\n    log.info(\"### STARTING doTriLevelHashingTest\");\n    // for now,  we know how ranges will be distributed to shards.\n    // may have to look it up in clusterstate if that assumption changes.\n\n    Random r = new Random();\n\n    for (int i=0;i < NUM_DOCS;i++) {\n      int appId = r.nextInt(NUM_APPS) + 1;\n      int userId = r.nextInt(NUM_USERS) + 1;\n\n      String id = \"app\" + appId + \"!\" + \"user\" + userId + \"!\" + \"doc\" + r.nextInt(100);\n      doAddDoc(id);\n\n    }\n\n    commit();\n\n    HashMap<String, Integer> idMap = new HashMap<String, Integer>();\n\n    for(int i=1;i<=sliceCount;i++) {\n\n      Set<String> ids = doQueryGetUniqueIdKeys(\"q\", \"*:*\", \"shards\", \"shard\" + i);\n      for(String id:ids) {\n        assertFalse(\"Found the same route key [\" + id + \"] in 2 shards.\", idMap.containsKey(id));\n        idMap.put(getKey(id), i);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c69c8a70590c37c628ba74e14c0ffd0b4d89f7fe","date":1384867512,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TriLevelCompositeIdRoutingTest#doTriLevelHashingTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TriLevelCompositeIdRoutingTest#doTriLevelHashingTest().mjava","sourceNew":"  private void doTriLevelHashingTest() throws Exception {\n    log.info(\"### STARTING doTriLevelHashingTest\");\n    // for now,  we know how ranges will be distributed to shards.\n    // may have to look it up in clusterstate if that assumption changes.\n\n    for (int i = 0; i < NUM_DOCS; i++) {\n      int appId = r.nextInt(NUM_APPS) + 1;\n      int userId = r.nextInt(NUM_USERS) + 1;\n\n      String id = \"app\" + appId + \"!\" + \"user\" + userId + \"!\" + \"doc\" + r.nextInt(100);\n      doAddDoc(id);\n\n    }\n\n    commit();\n\n    HashMap<String, Integer> idMap = new HashMap<String, Integer>();\n\n    for (int i = 1; i <= sliceCount; i++) {\n\n      Set<String> ids = doQueryGetUniqueIdKeys(\"q\", \"*:*\", \"shards\", \"shard\" + i);\n      for (String id : ids) {\n        assertFalse(\"Found the same route key [\" + id + \"] in 2 shards.\", idMap.containsKey(id));\n        idMap.put(getKey(id), i);\n      }\n    }\n\n  }\n\n","sourceOld":"  private void doTriLevelHashingTest() throws Exception {\n    log.info(\"### STARTING doTriLevelHashingTest\");\n    // for now,  we know how ranges will be distributed to shards.\n    // may have to look it up in clusterstate if that assumption changes.\n\n    for (int i=0;i < NUM_DOCS;i++) {\n      int appId = r.nextInt(NUM_APPS) + 1;\n      int userId = r.nextInt(NUM_USERS) + 1;\n\n      String id = \"app\" + appId + \"!\" + \"user\" + userId + \"!\" + \"doc\" + r.nextInt(100);\n      doAddDoc(id);\n\n    }\n\n    commit();\n\n    HashMap<String, Integer> idMap = new HashMap<String, Integer>();\n\n    for(int i=1;i<=sliceCount;i++) {\n\n      Set<String> ids = doQueryGetUniqueIdKeys(\"q\", \"*:*\", \"shards\", \"shard\" + i);\n      for(String id:ids) {\n        assertFalse(\"Found the same route key [\" + id + \"] in 2 shards.\", idMap.containsKey(id));\n        idMap.put(getKey(id), i);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TriLevelCompositeIdRoutingTest#doTriLevelHashingTest().mjava","pathOld":"/dev/null","sourceNew":"  private void doTriLevelHashingTest() throws Exception {\n    log.info(\"### STARTING doTriLevelHashingTest\");\n    // for now,  we know how ranges will be distributed to shards.\n    // may have to look it up in clusterstate if that assumption changes.\n\n    for (int i = 0; i < NUM_DOCS; i++) {\n      int appId = r.nextInt(NUM_APPS) + 1;\n      int userId = r.nextInt(NUM_USERS) + 1;\n\n      String id = \"app\" + appId + \"!\" + \"user\" + userId + \"!\" + \"doc\" + r.nextInt(100);\n      doAddDoc(id);\n\n    }\n\n    commit();\n\n    HashMap<String, Integer> idMap = new HashMap<String, Integer>();\n\n    for (int i = 1; i <= sliceCount; i++) {\n\n      Set<String> ids = doQueryGetUniqueIdKeys(\"q\", \"*:*\", \"shards\", \"shard\" + i);\n      for (String id : ids) {\n        assertFalse(\"Found the same route key [\" + id + \"] in 2 shards.\", idMap.containsKey(id));\n        idMap.put(getKey(id), i);\n      }\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TriLevelCompositeIdRoutingTest#doTriLevelHashingTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TriLevelCompositeIdRoutingTest#doTriLevelHashingTest().mjava","sourceNew":"  private void doTriLevelHashingTest() throws Exception {\n    log.info(\"### STARTING doTriLevelHashingTest\");\n    // for now,  we know how ranges will be distributed to shards.\n    // may have to look it up in clusterstate if that assumption changes.\n\n    for (int i = 0; i < NUM_DOCS; i++) {\n      int appId = r.nextInt(NUM_APPS) + 1;\n      int userId = r.nextInt(NUM_USERS) + 1;\n\n      String id = \"app\" + appId + \"!\" + \"user\" + userId + \"!\" + \"doc\" + r.nextInt(100);\n      doAddDoc(id);\n\n    }\n\n    commit();\n\n    HashMap<String, Integer> idMap = new HashMap<>();\n\n    for (int i = 1; i <= sliceCount; i++) {\n\n      Set<String> ids = doQueryGetUniqueIdKeys(\"q\", \"*:*\", \"shards\", \"shard\" + i);\n      for (String id : ids) {\n        assertFalse(\"Found the same route key [\" + id + \"] in 2 shards.\", idMap.containsKey(id));\n        idMap.put(getKey(id), i);\n      }\n    }\n\n  }\n\n","sourceOld":"  private void doTriLevelHashingTest() throws Exception {\n    log.info(\"### STARTING doTriLevelHashingTest\");\n    // for now,  we know how ranges will be distributed to shards.\n    // may have to look it up in clusterstate if that assumption changes.\n\n    for (int i = 0; i < NUM_DOCS; i++) {\n      int appId = r.nextInt(NUM_APPS) + 1;\n      int userId = r.nextInt(NUM_USERS) + 1;\n\n      String id = \"app\" + appId + \"!\" + \"user\" + userId + \"!\" + \"doc\" + r.nextInt(100);\n      doAddDoc(id);\n\n    }\n\n    commit();\n\n    HashMap<String, Integer> idMap = new HashMap<String, Integer>();\n\n    for (int i = 1; i <= sliceCount; i++) {\n\n      Set<String> ids = doQueryGetUniqueIdKeys(\"q\", \"*:*\", \"shards\", \"shard\" + i);\n      for (String id : ids) {\n        assertFalse(\"Found the same route key [\" + id + \"] in 2 shards.\", idMap.containsKey(id));\n        idMap.put(getKey(id), i);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0949f20e74c954865e5cfd653de9059bfc1a9aca","date":1548956712,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TriLevelCompositeIdRoutingTest#doTriLevelHashingTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TriLevelCompositeIdRoutingTest#doTriLevelHashingTest().mjava","sourceNew":"  private void doTriLevelHashingTest() throws Exception {\n    log.info(\"### STARTING doTriLevelHashingTest\");\n    // for now,  we know how ranges will be distributed to shards.\n    // may have to look it up in clusterstate if that assumption changes.\n\n    for (int i = 0; i < NUM_DOCS; i++) {\n      int appId = r.nextInt(NUM_APPS) + 1;\n      int userId = r.nextInt(NUM_USERS) + 1;\n\n      String id = \"app\" + appId + \"!\" + \"user\" + userId + \"!\" + \"doc\" + r.nextInt(100);\n      doAddDoc(id);\n\n    }\n\n    commit();\n\n    HashMap<String, Integer> idMap = new HashMap<>();\n\n    for (int i = 1; i <= sliceCount; i++) {\n\n      Set<String> ids = doQueryGetUniqueIdKeys(\"q\", \"*:*\", \"rows\", \"\"+NUM_DOCS, \"shards\", \"shard\" + i);\n      for (String id : ids) {\n        assertFalse(\"Found the same route key [\" + id + \"] in 2 shards.\", idMap.containsKey(id));\n        idMap.put(getKey(id), i);\n      }\n    }\n\n  }\n\n","sourceOld":"  private void doTriLevelHashingTest() throws Exception {\n    log.info(\"### STARTING doTriLevelHashingTest\");\n    // for now,  we know how ranges will be distributed to shards.\n    // may have to look it up in clusterstate if that assumption changes.\n\n    for (int i = 0; i < NUM_DOCS; i++) {\n      int appId = r.nextInt(NUM_APPS) + 1;\n      int userId = r.nextInt(NUM_USERS) + 1;\n\n      String id = \"app\" + appId + \"!\" + \"user\" + userId + \"!\" + \"doc\" + r.nextInt(100);\n      doAddDoc(id);\n\n    }\n\n    commit();\n\n    HashMap<String, Integer> idMap = new HashMap<>();\n\n    for (int i = 1; i <= sliceCount; i++) {\n\n      Set<String> ids = doQueryGetUniqueIdKeys(\"q\", \"*:*\", \"shards\", \"shard\" + i);\n      for (String id : ids) {\n        assertFalse(\"Found the same route key [\" + id + \"] in 2 shards.\", idMap.containsKey(id));\n        idMap.put(getKey(id), i);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06e68e6090ed0bd8f1f9b96e03328d9a4591e451","date":1549489350,"type":4,"author":"Chris Hostetter","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/TriLevelCompositeIdRoutingTest#doTriLevelHashingTest().mjava","sourceNew":null,"sourceOld":"  private void doTriLevelHashingTest() throws Exception {\n    log.info(\"### STARTING doTriLevelHashingTest\");\n    // for now,  we know how ranges will be distributed to shards.\n    // may have to look it up in clusterstate if that assumption changes.\n\n    for (int i = 0; i < NUM_DOCS; i++) {\n      int appId = r.nextInt(NUM_APPS) + 1;\n      int userId = r.nextInt(NUM_USERS) + 1;\n\n      String id = \"app\" + appId + \"!\" + \"user\" + userId + \"!\" + \"doc\" + r.nextInt(100);\n      doAddDoc(id);\n\n    }\n\n    commit();\n\n    HashMap<String, Integer> idMap = new HashMap<>();\n\n    for (int i = 1; i <= sliceCount; i++) {\n\n      Set<String> ids = doQueryGetUniqueIdKeys(\"q\", \"*:*\", \"rows\", \"\"+NUM_DOCS, \"shards\", \"shard\" + i);\n      for (String id : ids) {\n        assertFalse(\"Found the same route key [\" + id + \"] in 2 shards.\", idMap.containsKey(id));\n        idMap.put(getKey(id), i);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["c69c8a70590c37c628ba74e14c0ffd0b4d89f7fe"],"8acea81aba1fc014206342150f41de3396ce64fc":["f7623716022a9a68898e329e8ffe6c36d168fba7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c69c8a70590c37c628ba74e14c0ffd0b4d89f7fe"],"c69c8a70590c37c628ba74e14c0ffd0b4d89f7fe":["8acea81aba1fc014206342150f41de3396ce64fc"],"0949f20e74c954865e5cfd653de9059bfc1a9aca":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"06e68e6090ed0bd8f1f9b96e03328d9a4591e451":["0949f20e74c954865e5cfd653de9059bfc1a9aca"],"f7623716022a9a68898e329e8ffe6c36d168fba7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["06e68e6090ed0bd8f1f9b96e03328d9a4591e451"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["0949f20e74c954865e5cfd653de9059bfc1a9aca"],"8acea81aba1fc014206342150f41de3396ce64fc":["c69c8a70590c37c628ba74e14c0ffd0b4d89f7fe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","f7623716022a9a68898e329e8ffe6c36d168fba7"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"c69c8a70590c37c628ba74e14c0ffd0b4d89f7fe":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"0949f20e74c954865e5cfd653de9059bfc1a9aca":["06e68e6090ed0bd8f1f9b96e03328d9a4591e451"],"f7623716022a9a68898e329e8ffe6c36d168fba7":["8acea81aba1fc014206342150f41de3396ce64fc"],"06e68e6090ed0bd8f1f9b96e03328d9a4591e451":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}