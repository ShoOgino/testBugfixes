{"path":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    final CharsRef spare = new CharsRef();\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = searcher.weightSort(rb.getSortSpec().getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      Field field = new Field(\"dummy\", \"\", Field.Store.YES, Field.Index.NO); // a dummy Field\n      ReaderContext topReaderContext = searcher.getTopReaderContext();\n      AtomicReaderContext[] leaves = ReaderUtil.leaves(topReaderContext);\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.length==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves[0];\n        leaves=null;\n      }\n\n      for (SortField sortField: sortFields) {\n        SortField.Type type = sortField.getType();\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n        FieldComparator comparators[] = (leaves==null) ? null : new FieldComparator[leaves.length];\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n\n        int idx = 0;\n\n        while(it.hasNext()) {\n          int doc = it.nextDoc();\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves[idx];\n            comparator = comparators[idx];\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n            if (comparators != null)\n              comparators[idx] = comparator;\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          // Must do the same conversion when sorting by a\n          // String field in Lucene, which returns the terms\n          // data as BytesRef:\n          if (val instanceof BytesRef) {\n            field.setValue(((BytesRef)val).utf8ToChars(spare).toString());\n            val = ft.toObject(field);\n          }\n\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","sourceOld":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    final CharsRef spare = new CharsRef();\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = searcher.weightSort(rb.getSortSpec().getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      Field field = new Field(\"dummy\", \"\", Field.Store.YES, Field.Index.NO); // a dummy Field\n      ReaderContext topReaderContext = searcher.getTopReaderContext();\n      AtomicReaderContext[] leaves = ReaderUtil.leaves(topReaderContext);\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.length==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves[0];\n        leaves=null;\n      }\n\n      for (SortField sortField: sortFields) {\n        SortField.Type type = sortField.getType();\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n        FieldComparator comparators[] = (leaves==null) ? null : new FieldComparator[leaves.length];\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n\n        int idx = 0;\n\n        while(it.hasNext()) {\n          int doc = it.nextDoc();\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves[idx];\n            comparator = comparators[idx];\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n            if (comparators != null)\n              comparators[idx] = comparator;\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          // Must do the same conversion when sorting by a\n          // String field in Lucene, which returns the terms\n          // data as BytesRef:\n          if (val instanceof BytesRef) {\n            field.setValue(((BytesRef)val).utf8ToChars(spare).toString());\n            val = ft.toObject(field);\n          }\n\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    final CharsRef spare = new CharsRef();\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = searcher.weightSort(rb.getSortSpec().getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      Field field = new Field(\"dummy\", \"\", Field.Store.YES, Field.Index.NO); // a dummy Field\n      ReaderContext topReaderContext = searcher.getTopReaderContext();\n      AtomicReaderContext[] leaves = ReaderUtil.leaves(topReaderContext);\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.length==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves[0];\n        leaves=null;\n      }\n\n      for (SortField sortField: sortFields) {\n        SortField.Type type = sortField.getType();\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n        FieldComparator comparators[] = (leaves==null) ? null : new FieldComparator[leaves.length];\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n\n        int idx = 0;\n\n        while(it.hasNext()) {\n          int doc = it.nextDoc();\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves[idx];\n            comparator = comparators[idx];\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n            if (comparators != null)\n              comparators[idx] = comparator;\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          // Must do the same conversion when sorting by a\n          // String field in Lucene, which returns the terms\n          // data as BytesRef:\n          if (val instanceof BytesRef) {\n            field.setValue(((BytesRef)val).utf8ToChars(spare).toString());\n            val = ft.toObject(field);\n          }\n\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","sourceOld":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    final CharsRef spare = new CharsRef();\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = searcher.weightSort(rb.getSortSpec().getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      Field field = new Field(\"dummy\", \"\", Field.Store.YES, Field.Index.NO); // a dummy Field\n      ReaderContext topReaderContext = searcher.getTopReaderContext();\n      AtomicReaderContext[] leaves = ReaderUtil.leaves(topReaderContext);\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.length==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves[0];\n        leaves=null;\n      }\n\n      for (SortField sortField: sortFields) {\n        SortField.Type type = sortField.getType();\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n        FieldComparator comparators[] = (leaves==null) ? null : new FieldComparator[leaves.length];\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n\n        int idx = 0;\n\n        while(it.hasNext()) {\n          int doc = it.nextDoc();\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves[idx];\n            comparator = comparators[idx];\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n            if (comparators != null)\n              comparators[idx] = comparator;\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          // Must do the same conversion when sorting by a\n          // String field in Lucene, which returns the terms\n          // data as BytesRef:\n          if (val instanceof BytesRef) {\n            field.setValue(((BytesRef)val).utf8ToChars(spare).toString());\n            val = ft.toObject(field);\n          }\n\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    final CharsRef spare = new CharsRef();\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = searcher.weightSort(rb.getSortSpec().getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      Field field = new Field(\"dummy\", \"\", Field.Store.YES, Field.Index.NO); // a dummy Field\n      ReaderContext topReaderContext = searcher.getTopReaderContext();\n      AtomicReaderContext[] leaves = ReaderUtil.leaves(topReaderContext);\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.length==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves[0];\n        leaves=null;\n      }\n\n      for (SortField sortField: sortFields) {\n        SortField.Type type = sortField.getType();\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n        FieldComparator comparators[] = (leaves==null) ? null : new FieldComparator[leaves.length];\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n\n        int idx = 0;\n\n        while(it.hasNext()) {\n          int doc = it.nextDoc();\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves[idx];\n            comparator = comparators[idx];\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n            if (comparators != null)\n              comparators[idx] = comparator;\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          // Must do the same conversion when sorting by a\n          // String field in Lucene, which returns the terms\n          // data as BytesRef:\n          if (val instanceof BytesRef) {\n            field.setValue(((BytesRef)val).utf8ToChars(spare).toString());\n            val = ft.toObject(field);\n          }\n\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","sourceOld":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    final CharsRef spare = new CharsRef();\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = searcher.weightSort(rb.getSortSpec().getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      Field field = new Field(\"dummy\", \"\", Field.Store.YES, Field.Index.NO); // a dummy Field\n      ReaderContext topReaderContext = searcher.getTopReaderContext();\n      AtomicReaderContext[] leaves = ReaderUtil.leaves(topReaderContext);\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.length==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves[0];\n        leaves=null;\n      }\n\n      for (SortField sortField: sortFields) {\n        SortField.Type type = sortField.getType();\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n        FieldComparator comparators[] = (leaves==null) ? null : new FieldComparator[leaves.length];\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n\n        int idx = 0;\n\n        while(it.hasNext()) {\n          int doc = it.nextDoc();\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves[idx];\n            comparator = comparators[idx];\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n            if (comparators != null)\n              comparators[idx] = comparator;\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          // Must do the same conversion when sorting by a\n          // String field in Lucene, which returns the terms\n          // data as BytesRef:\n          if (val instanceof BytesRef) {\n            field.setValue(((BytesRef)val).utf8ToChars(spare).toString());\n            val = ft.toObject(field);\n          }\n\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1509f151d7692d84fae414b2b799ac06ba60fcb4","date":1314451621,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    final CharsRef spare = new CharsRef();\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = searcher.weightSort(rb.getSortSpec().getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      Field field = new StringField(\"dummy\", \"\"); // a dummy Field\n      ReaderContext topReaderContext = searcher.getTopReaderContext();\n      AtomicReaderContext[] leaves = ReaderUtil.leaves(topReaderContext);\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.length==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves[0];\n        leaves=null;\n      }\n\n      for (SortField sortField: sortFields) {\n        SortField.Type type = sortField.getType();\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n        FieldComparator comparators[] = (leaves==null) ? null : new FieldComparator[leaves.length];\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n\n        int idx = 0;\n\n        while(it.hasNext()) {\n          int doc = it.nextDoc();\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves[idx];\n            comparator = comparators[idx];\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n            if (comparators != null)\n              comparators[idx] = comparator;\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          // Must do the same conversion when sorting by a\n          // String field in Lucene, which returns the terms\n          // data as BytesRef:\n          if (val instanceof BytesRef) {\n            field.setValue(((BytesRef)val).utf8ToChars(spare).toString());\n            val = ft.toObject(field);\n          }\n\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","sourceOld":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    final CharsRef spare = new CharsRef();\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = searcher.weightSort(rb.getSortSpec().getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      Field field = new Field(\"dummy\", \"\", Field.Store.YES, Field.Index.NO); // a dummy Field\n      ReaderContext topReaderContext = searcher.getTopReaderContext();\n      AtomicReaderContext[] leaves = ReaderUtil.leaves(topReaderContext);\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.length==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves[0];\n        leaves=null;\n      }\n\n      for (SortField sortField: sortFields) {\n        SortField.Type type = sortField.getType();\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n        FieldComparator comparators[] = (leaves==null) ? null : new FieldComparator[leaves.length];\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n\n        int idx = 0;\n\n        while(it.hasNext()) {\n          int doc = it.nextDoc();\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves[idx];\n            comparator = comparators[idx];\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n            if (comparators != null)\n              comparators[idx] = comparator;\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          // Must do the same conversion when sorting by a\n          // String field in Lucene, which returns the terms\n          // data as BytesRef:\n          if (val instanceof BytesRef) {\n            field.setValue(((BytesRef)val).utf8ToChars(spare).toString());\n            val = ft.toObject(field);\n          }\n\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","bugFix":null,"bugIntro":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ccc08aa684aee4964baee0644a6ba047bfd70829","date":1316263707,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    final CharsRef spare = new CharsRef();\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = searcher.weightSort(rb.getSortSpec().getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList<List> sortVals = new NamedList<List>(); // order is important for the sort fields\n      Field field = new StringField(\"dummy\", \"\"); // a dummy Field\n      ReaderContext topReaderContext = searcher.getTopReaderContext();\n      AtomicReaderContext[] leaves = ReaderUtil.leaves(topReaderContext);\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.length==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves[0];\n        leaves=null;\n      }\n\n      for (SortField sortField: sortFields) {\n        SortField.Type type = sortField.getType();\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n        FieldComparator comparators[] = (leaves==null) ? null : new FieldComparator[leaves.length];\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        DocList docList = rb.getResults().docList;\n        List<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n\n        int idx = 0;\n\n        while(it.hasNext()) {\n          int doc = it.nextDoc();\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves[idx];\n            comparator = comparators[idx];\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n            if (comparators != null)\n              comparators[idx] = comparator;\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          // Must do the same conversion when sorting by a\n          // String field in Lucene, which returns the terms\n          // data as BytesRef:\n          if (val instanceof BytesRef) {\n            field.setValue(((BytesRef)val).utf8ToChars(spare).toString());\n            val = ft.toObject(field);\n          }\n\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","sourceOld":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    final CharsRef spare = new CharsRef();\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = searcher.weightSort(rb.getSortSpec().getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      Field field = new StringField(\"dummy\", \"\"); // a dummy Field\n      ReaderContext topReaderContext = searcher.getTopReaderContext();\n      AtomicReaderContext[] leaves = ReaderUtil.leaves(topReaderContext);\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.length==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves[0];\n        leaves=null;\n      }\n\n      for (SortField sortField: sortFields) {\n        SortField.Type type = sortField.getType();\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n        FieldComparator comparators[] = (leaves==null) ? null : new FieldComparator[leaves.length];\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n\n        int idx = 0;\n\n        while(it.hasNext()) {\n          int doc = it.nextDoc();\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves[idx];\n            comparator = comparators[idx];\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n            if (comparators != null)\n              comparators[idx] = comparator;\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          // Must do the same conversion when sorting by a\n          // String field in Lucene, which returns the terms\n          // data as BytesRef:\n          if (val instanceof BytesRef) {\n            field.setValue(((BytesRef)val).utf8ToChars(spare).toString());\n            val = ft.toObject(field);\n          }\n\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"da6c07e76d701edbcc45c3e83ad8464a5e44a4c0","date":1322229341,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    final CharsRef spare = new CharsRef();\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = searcher.weightSort(rb.getSortSpec().getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList<List> sortVals = new NamedList<List>(); // order is important for the sort fields\n      Field field = new StringField(\"dummy\", \"\"); // a dummy Field\n      ReaderContext topReaderContext = searcher.getTopReaderContext();\n      AtomicReaderContext[] leaves = ReaderUtil.leaves(topReaderContext);\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.length==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves[0];\n        leaves=null;\n      }\n\n      for (SortField sortField: sortFields) {\n        SortField.Type type = sortField.getType();\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n        FieldComparator comparators[] = (leaves==null) ? null : new FieldComparator[leaves.length];\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        DocList docList = rb.getResults().docList;\n        List<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n\n        int idx = 0;\n\n        while(it.hasNext()) {\n          int doc = it.nextDoc();\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves[idx];\n            comparator = comparators[idx];\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n            if (comparators != null)\n              comparators[idx] = comparator;\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          // Must do the same conversion when sorting by a\n          // String field in Lucene, which returns the terms\n          // data as BytesRef:\n          if (val instanceof BytesRef) {\n            UnicodeUtil.UTF8toUTF16((BytesRef)val, spare);\n            field.setValue(spare.toString());\n            val = ft.toObject(field);\n          }\n\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","sourceOld":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    final CharsRef spare = new CharsRef();\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = searcher.weightSort(rb.getSortSpec().getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList<List> sortVals = new NamedList<List>(); // order is important for the sort fields\n      Field field = new StringField(\"dummy\", \"\"); // a dummy Field\n      ReaderContext topReaderContext = searcher.getTopReaderContext();\n      AtomicReaderContext[] leaves = ReaderUtil.leaves(topReaderContext);\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.length==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves[0];\n        leaves=null;\n      }\n\n      for (SortField sortField: sortFields) {\n        SortField.Type type = sortField.getType();\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n        FieldComparator comparators[] = (leaves==null) ? null : new FieldComparator[leaves.length];\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        DocList docList = rb.getResults().docList;\n        List<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n\n        int idx = 0;\n\n        while(it.hasNext()) {\n          int doc = it.nextDoc();\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves[idx];\n            comparator = comparators[idx];\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n            if (comparators != null)\n              comparators[idx] = comparator;\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          // Must do the same conversion when sorting by a\n          // String field in Lucene, which returns the terms\n          // data as BytesRef:\n          if (val instanceof BytesRef) {\n            field.setValue(((BytesRef)val).utf8ToChars(spare).toString());\n            val = ft.toObject(field);\n          }\n\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","bugFix":null,"bugIntro":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8493985e6883b3fa8231d172694d2aa3a85cb182","date":1327920390,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    final CharsRef spare = new CharsRef();\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = searcher.weightSort(rb.getSortSpec().getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList<List> sortVals = new NamedList<List>(); // order is important for the sort fields\n      Field field = new StringField(\"dummy\", \"\"); // a dummy Field\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      AtomicReaderContext[] leaves = ReaderUtil.leaves(topReaderContext);\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.length==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves[0];\n        leaves=null;\n      }\n\n      for (SortField sortField: sortFields) {\n        SortField.Type type = sortField.getType();\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n        FieldComparator comparators[] = (leaves==null) ? null : new FieldComparator[leaves.length];\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        DocList docList = rb.getResults().docList;\n        List<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n\n        int idx = 0;\n\n        while(it.hasNext()) {\n          int doc = it.nextDoc();\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves[idx];\n            comparator = comparators[idx];\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n            if (comparators != null)\n              comparators[idx] = comparator;\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          // Must do the same conversion when sorting by a\n          // String field in Lucene, which returns the terms\n          // data as BytesRef:\n          if (val instanceof BytesRef) {\n            UnicodeUtil.UTF8toUTF16((BytesRef)val, spare);\n            field.setValue(spare.toString());\n            val = ft.toObject(field);\n          }\n\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","sourceOld":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    final CharsRef spare = new CharsRef();\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = searcher.weightSort(rb.getSortSpec().getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList<List> sortVals = new NamedList<List>(); // order is important for the sort fields\n      Field field = new StringField(\"dummy\", \"\"); // a dummy Field\n      ReaderContext topReaderContext = searcher.getTopReaderContext();\n      AtomicReaderContext[] leaves = ReaderUtil.leaves(topReaderContext);\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.length==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves[0];\n        leaves=null;\n      }\n\n      for (SortField sortField: sortFields) {\n        SortField.Type type = sortField.getType();\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n        FieldComparator comparators[] = (leaves==null) ? null : new FieldComparator[leaves.length];\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        DocList docList = rb.getResults().docList;\n        List<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n\n        int idx = 0;\n\n        while(it.hasNext()) {\n          int doc = it.nextDoc();\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves[idx];\n            comparator = comparators[idx];\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n            if (comparators != null)\n              comparators[idx] = comparator;\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          // Must do the same conversion when sorting by a\n          // String field in Lucene, which returns the terms\n          // data as BytesRef:\n          if (val instanceof BytesRef) {\n            UnicodeUtil.UTF8toUTF16((BytesRef)val, spare);\n            field.setValue(spare.toString());\n            val = ft.toObject(field);\n          }\n\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    final CharsRef spare = new CharsRef();\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = searcher.weightSort(rb.getSortSpec().getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList<List> sortVals = new NamedList<List>(); // order is important for the sort fields\n      Field field = new StringField(\"dummy\", \"\"); // a dummy Field\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      AtomicReaderContext[] leaves = ReaderUtil.leaves(topReaderContext);\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.length==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves[0];\n        leaves=null;\n      }\n\n      for (SortField sortField: sortFields) {\n        SortField.Type type = sortField.getType();\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n        FieldComparator comparators[] = (leaves==null) ? null : new FieldComparator[leaves.length];\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        DocList docList = rb.getResults().docList;\n        List<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n\n        int idx = 0;\n\n        while(it.hasNext()) {\n          int doc = it.nextDoc();\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves[idx];\n            comparator = comparators[idx];\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n            if (comparators != null)\n              comparators[idx] = comparator;\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          // Must do the same conversion when sorting by a\n          // String field in Lucene, which returns the terms\n          // data as BytesRef:\n          if (val instanceof BytesRef) {\n            UnicodeUtil.UTF8toUTF16((BytesRef)val, spare);\n            field.setValue(spare.toString());\n            val = ft.toObject(field);\n          }\n\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","sourceOld":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    final CharsRef spare = new CharsRef();\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = searcher.weightSort(rb.getSortSpec().getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList<List> sortVals = new NamedList<List>(); // order is important for the sort fields\n      Field field = new StringField(\"dummy\", \"\"); // a dummy Field\n      ReaderContext topReaderContext = searcher.getTopReaderContext();\n      AtomicReaderContext[] leaves = ReaderUtil.leaves(topReaderContext);\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.length==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves[0];\n        leaves=null;\n      }\n\n      for (SortField sortField: sortFields) {\n        SortField.Type type = sortField.getType();\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n        FieldComparator comparators[] = (leaves==null) ? null : new FieldComparator[leaves.length];\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        DocList docList = rb.getResults().docList;\n        List<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n\n        int idx = 0;\n\n        while(it.hasNext()) {\n          int doc = it.nextDoc();\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves[idx];\n            comparator = comparators[idx];\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n            if (comparators != null)\n              comparators[idx] = comparator;\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          // Must do the same conversion when sorting by a\n          // String field in Lucene, which returns the terms\n          // data as BytesRef:\n          if (val instanceof BytesRef) {\n            UnicodeUtil.UTF8toUTF16((BytesRef)val, spare);\n            field.setValue(spare.toString());\n            val = ft.toObject(field);\n          }\n\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a311f7ac72ff006bb02172c40f62062b35cb6a2a","date":1328637714,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    final CharsRef spare = new CharsRef();\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = searcher.weightSort(rb.getSortSpec().getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList<Object[]> sortVals = new NamedList<Object[]>(); // order is important for the sort fields\n      Field field = new StringField(\"dummy\", \"\"); // a dummy Field\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      AtomicReaderContext[] leaves = ReaderUtil.leaves(topReaderContext);\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.length==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves[0];\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      long[] sortedIds = new long[nDocs];\n      DocIterator it = rb.getResults().docList.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n      }\n      Arrays.sort(sortedIds);\n\n\n      for (SortField sortField: sortFields) {\n        SortField.Type type = sortField.getType();\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        Object[] vals = new Object[nDocs];\n        \n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (long idAndPos : sortedIds) {\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves[idx];\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          // Must do the same conversion when sorting by a\n          // String field in Lucene, which returns the terms\n          // data as BytesRef:\n          if (val instanceof BytesRef) {\n            UnicodeUtil.UTF8toUTF16((BytesRef)val, spare);\n            field.setValue(spare.toString());\n            val = ft.toObject(field);\n          }\n\n          vals[position] = val;\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","sourceOld":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    final CharsRef spare = new CharsRef();\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = searcher.weightSort(rb.getSortSpec().getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList<List> sortVals = new NamedList<List>(); // order is important for the sort fields\n      Field field = new StringField(\"dummy\", \"\"); // a dummy Field\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      AtomicReaderContext[] leaves = ReaderUtil.leaves(topReaderContext);\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.length==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves[0];\n        leaves=null;\n      }\n\n      for (SortField sortField: sortFields) {\n        SortField.Type type = sortField.getType();\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n        FieldComparator comparators[] = (leaves==null) ? null : new FieldComparator[leaves.length];\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        DocList docList = rb.getResults().docList;\n        List<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n\n        int idx = 0;\n\n        while(it.hasNext()) {\n          int doc = it.nextDoc();\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves[idx];\n            comparator = comparators[idx];\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n            if (comparators != null)\n              comparators[idx] = comparator;\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          // Must do the same conversion when sorting by a\n          // String field in Lucene, which returns the terms\n          // data as BytesRef:\n          if (val instanceof BytesRef) {\n            UnicodeUtil.UTF8toUTF16((BytesRef)val, spare);\n            field.setValue(spare.toString());\n            val = ft.toObject(field);\n          }\n\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","bugFix":null,"bugIntro":["0a18eb901f731cd8fa21582194fb07b0754fe389","a3584d3db8b472772e3329d9d95d584b68ae997e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0d4602ca2700dfd2f6159ad1499e5b6d1f3b92a8","date":1328775259,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    final CharsRef spare = new CharsRef();\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = searcher.weightSort(rb.getSortSpec().getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList<Object[]> sortVals = new NamedList<Object[]>(); // order is important for the sort fields\n      Field field = new StringField(\"dummy\", \"\"); // a dummy Field\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      AtomicReaderContext[] leaves = topReaderContext.leaves();\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.length==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves[0];\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      long[] sortedIds = new long[nDocs];\n      DocIterator it = rb.getResults().docList.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n      }\n      Arrays.sort(sortedIds);\n\n\n      for (SortField sortField: sortFields) {\n        SortField.Type type = sortField.getType();\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        Object[] vals = new Object[nDocs];\n        \n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (long idAndPos : sortedIds) {\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves[idx];\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          // Must do the same conversion when sorting by a\n          // String field in Lucene, which returns the terms\n          // data as BytesRef:\n          if (val instanceof BytesRef) {\n            UnicodeUtil.UTF8toUTF16((BytesRef)val, spare);\n            field.setValue(spare.toString());\n            val = ft.toObject(field);\n          }\n\n          vals[position] = val;\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","sourceOld":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    final CharsRef spare = new CharsRef();\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = searcher.weightSort(rb.getSortSpec().getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList<Object[]> sortVals = new NamedList<Object[]>(); // order is important for the sort fields\n      Field field = new StringField(\"dummy\", \"\"); // a dummy Field\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      AtomicReaderContext[] leaves = ReaderUtil.leaves(topReaderContext);\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.length==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves[0];\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      long[] sortedIds = new long[nDocs];\n      DocIterator it = rb.getResults().docList.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n      }\n      Arrays.sort(sortedIds);\n\n\n      for (SortField sortField: sortFields) {\n        SortField.Type type = sortField.getType();\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        Object[] vals = new Object[nDocs];\n        \n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (long idAndPos : sortedIds) {\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves[idx];\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          // Must do the same conversion when sorting by a\n          // String field in Lucene, which returns the terms\n          // data as BytesRef:\n          if (val instanceof BytesRef) {\n            UnicodeUtil.UTF8toUTF16((BytesRef)val, spare);\n            field.setValue(spare.toString());\n            val = ft.toObject(field);\n          }\n\n          vals[position] = val;\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a78a90fc9701e511308346ea29f4f5e548bb39fe","date":1329489995,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    final CharsRef spare = new CharsRef();\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = searcher.weightSort(rb.getSortSpec().getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList<Object[]> sortVals = new NamedList<Object[]>(); // order is important for the sort fields\n      Field field = new StringField(\"dummy\", \"\"); // a dummy Field\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      AtomicReaderContext[] leaves = topReaderContext.leaves();\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.length==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves[0];\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      long[] sortedIds = new long[nDocs];\n      DocIterator it = rb.getResults().docList.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n      }\n      Arrays.sort(sortedIds);\n\n\n      for (SortField sortField: sortFields) {\n        SortField.Type type = sortField.getType();\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        Object[] vals = new Object[nDocs];\n        \n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (long idAndPos : sortedIds) {\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves[idx];\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setStringValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          // Must do the same conversion when sorting by a\n          // String field in Lucene, which returns the terms\n          // data as BytesRef:\n          if (val instanceof BytesRef) {\n            UnicodeUtil.UTF8toUTF16((BytesRef)val, spare);\n            field.setStringValue(spare.toString());\n            val = ft.toObject(field);\n          }\n\n          vals[position] = val;\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","sourceOld":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    final CharsRef spare = new CharsRef();\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = searcher.weightSort(rb.getSortSpec().getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList<Object[]> sortVals = new NamedList<Object[]>(); // order is important for the sort fields\n      Field field = new StringField(\"dummy\", \"\"); // a dummy Field\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      AtomicReaderContext[] leaves = topReaderContext.leaves();\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.length==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves[0];\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      long[] sortedIds = new long[nDocs];\n      DocIterator it = rb.getResults().docList.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n      }\n      Arrays.sort(sortedIds);\n\n\n      for (SortField sortField: sortFields) {\n        SortField.Type type = sortField.getType();\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        Object[] vals = new Object[nDocs];\n        \n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (long idAndPos : sortedIds) {\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves[idx];\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          // Must do the same conversion when sorting by a\n          // String field in Lucene, which returns the terms\n          // data as BytesRef:\n          if (val instanceof BytesRef) {\n            UnicodeUtil.UTF8toUTF16((BytesRef)val, spare);\n            field.setValue(spare.toString());\n            val = ft.toObject(field);\n          }\n\n          vals[position] = val;\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","bugFix":["da6c07e76d701edbcc45c3e83ad8464a5e44a4c0","9b240c33c89713e9821af46e867f4710eb811864"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"04f07771a2a7dd3a395700665ed839c3dae2def2","date":1339350139,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    final CharsRef spare = new CharsRef();\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = searcher.weightSort(rb.getSortSpec().getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList<Object[]> sortVals = new NamedList<Object[]>(); // order is important for the sort fields\n      Field field = new StringField(\"dummy\", \"\", Field.Store.NO); // a dummy Field\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      AtomicReaderContext[] leaves = topReaderContext.leaves();\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.length==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves[0];\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      long[] sortedIds = new long[nDocs];\n      DocIterator it = rb.getResults().docList.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n      }\n      Arrays.sort(sortedIds);\n\n\n      for (SortField sortField: sortFields) {\n        SortField.Type type = sortField.getType();\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        Object[] vals = new Object[nDocs];\n        \n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (long idAndPos : sortedIds) {\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves[idx];\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setStringValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          // Must do the same conversion when sorting by a\n          // String field in Lucene, which returns the terms\n          // data as BytesRef:\n          if (val instanceof BytesRef) {\n            UnicodeUtil.UTF8toUTF16((BytesRef)val, spare);\n            field.setStringValue(spare.toString());\n            val = ft.toObject(field);\n          }\n\n          vals[position] = val;\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","sourceOld":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    final CharsRef spare = new CharsRef();\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = searcher.weightSort(rb.getSortSpec().getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList<Object[]> sortVals = new NamedList<Object[]>(); // order is important for the sort fields\n      Field field = new StringField(\"dummy\", \"\"); // a dummy Field\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      AtomicReaderContext[] leaves = topReaderContext.leaves();\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.length==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves[0];\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      long[] sortedIds = new long[nDocs];\n      DocIterator it = rb.getResults().docList.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n      }\n      Arrays.sort(sortedIds);\n\n\n      for (SortField sortField: sortFields) {\n        SortField.Type type = sortField.getType();\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        Object[] vals = new Object[nDocs];\n        \n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (long idAndPos : sortedIds) {\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves[idx];\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setStringValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          // Must do the same conversion when sorting by a\n          // String field in Lucene, which returns the terms\n          // data as BytesRef:\n          if (val instanceof BytesRef) {\n            UnicodeUtil.UTF8toUTF16((BytesRef)val, spare);\n            field.setStringValue(spare.toString());\n            val = ft.toObject(field);\n          }\n\n          vals[position] = val;\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","bugFix":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","date":1340090669,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    final CharsRef spare = new CharsRef();\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = searcher.weightSort(rb.getSortSpec().getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList<Object[]> sortVals = new NamedList<Object[]>(); // order is important for the sort fields\n      Field field = new StringField(\"dummy\", \"\", Field.Store.NO); // a dummy Field\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<AtomicReaderContext> leaves = topReaderContext.leaves();\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      long[] sortedIds = new long[nDocs];\n      DocIterator it = rb.getResults().docList.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n      }\n      Arrays.sort(sortedIds);\n\n\n      for (SortField sortField: sortFields) {\n        SortField.Type type = sortField.getType();\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        Object[] vals = new Object[nDocs];\n        \n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (long idAndPos : sortedIds) {\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setStringValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          // Must do the same conversion when sorting by a\n          // String field in Lucene, which returns the terms\n          // data as BytesRef:\n          if (val instanceof BytesRef) {\n            UnicodeUtil.UTF8toUTF16((BytesRef)val, spare);\n            field.setStringValue(spare.toString());\n            val = ft.toObject(field);\n          }\n\n          vals[position] = val;\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","sourceOld":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    final CharsRef spare = new CharsRef();\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = searcher.weightSort(rb.getSortSpec().getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList<Object[]> sortVals = new NamedList<Object[]>(); // order is important for the sort fields\n      Field field = new StringField(\"dummy\", \"\", Field.Store.NO); // a dummy Field\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      AtomicReaderContext[] leaves = topReaderContext.leaves();\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.length==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves[0];\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      long[] sortedIds = new long[nDocs];\n      DocIterator it = rb.getResults().docList.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n      }\n      Arrays.sort(sortedIds);\n\n\n      for (SortField sortField: sortFields) {\n        SortField.Type type = sortField.getType();\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        Object[] vals = new Object[nDocs];\n        \n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (long idAndPos : sortedIds) {\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves[idx];\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setStringValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          // Must do the same conversion when sorting by a\n          // String field in Lucene, which returns the terms\n          // data as BytesRef:\n          if (val instanceof BytesRef) {\n            UnicodeUtil.UTF8toUTF16((BytesRef)val, spare);\n            field.setStringValue(spare.toString());\n            val = ft.toObject(field);\n          }\n\n          vals[position] = val;\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"08970e5b8411182a29412c177eff67ec1110095b","date":1366640815,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    final CharsRef spare = new CharsRef();\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = searcher.weightSort(rb.getSortSpec().getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList<Object[]> sortVals = new NamedList<Object[]>(); // order is important for the sort fields\n      Field field = new StringField(\"dummy\", \"\", Field.Store.NO); // a dummy Field\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<AtomicReaderContext> leaves = topReaderContext.leaves();\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      long[] sortedIds = new long[nDocs];\n      DocIterator it = rb.getResults().docList.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n      }\n      Arrays.sort(sortedIds);\n\n\n      for (SortField sortField: sortFields) {\n        SortField.Type type = sortField.getType();\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : searcher.getSchema().getFieldTypeNoEx(fieldname);\n\n        Object[] vals = new Object[nDocs];\n        \n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (long idAndPos : sortedIds) {\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setStringValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          // Must do the same conversion when sorting by a\n          // String field in Lucene, which returns the terms\n          // data as BytesRef:\n          if (val instanceof BytesRef) {\n            UnicodeUtil.UTF8toUTF16((BytesRef)val, spare);\n            field.setStringValue(spare.toString());\n            val = ft.toObject(field);\n          }\n\n          vals[position] = val;\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","sourceOld":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    final CharsRef spare = new CharsRef();\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = searcher.weightSort(rb.getSortSpec().getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList<Object[]> sortVals = new NamedList<Object[]>(); // order is important for the sort fields\n      Field field = new StringField(\"dummy\", \"\", Field.Store.NO); // a dummy Field\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<AtomicReaderContext> leaves = topReaderContext.leaves();\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      long[] sortedIds = new long[nDocs];\n      DocIterator it = rb.getResults().docList.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n      }\n      Arrays.sort(sortedIds);\n\n\n      for (SortField sortField: sortFields) {\n        SortField.Type type = sortField.getType();\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        Object[] vals = new Object[nDocs];\n        \n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (long idAndPos : sortedIds) {\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setStringValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          // Must do the same conversion when sorting by a\n          // String field in Lucene, which returns the terms\n          // data as BytesRef:\n          if (val instanceof BytesRef) {\n            UnicodeUtil.UTF8toUTF16((BytesRef)val, spare);\n            field.setStringValue(spare.toString());\n            val = ft.toObject(field);\n          }\n\n          vals[position] = val;\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"faff74992839549208db29d95b9ad4a1d3846c79","date":1385672428,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = searcher.weightSort(rb.getSortSpec().getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList<Object[]> sortVals = new NamedList<Object[]>(); // order is important for the sort fields\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<AtomicReaderContext> leaves = topReaderContext.leaves();\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      long[] sortedIds = new long[nDocs];\n      DocIterator it = rb.getResults().docList.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n      }\n      Arrays.sort(sortedIds);\n\n\n      for (SortField sortField: sortFields) {\n        SortField.Type type = sortField.getType();\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : searcher.getSchema().getFieldTypeNoEx(fieldname);\n\n        Object[] vals = new Object[nDocs];\n        \n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (long idAndPos : sortedIds) {\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n          if (null != ft) val = ft.marshalSortValue(val); \n          vals[position] = val;\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","sourceOld":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    final CharsRef spare = new CharsRef();\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = searcher.weightSort(rb.getSortSpec().getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList<Object[]> sortVals = new NamedList<Object[]>(); // order is important for the sort fields\n      Field field = new StringField(\"dummy\", \"\", Field.Store.NO); // a dummy Field\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<AtomicReaderContext> leaves = topReaderContext.leaves();\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      long[] sortedIds = new long[nDocs];\n      DocIterator it = rb.getResults().docList.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n      }\n      Arrays.sort(sortedIds);\n\n\n      for (SortField sortField: sortFields) {\n        SortField.Type type = sortField.getType();\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : searcher.getSchema().getFieldTypeNoEx(fieldname);\n\n        Object[] vals = new Object[nDocs];\n        \n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (long idAndPos : sortedIds) {\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setStringValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          // Must do the same conversion when sorting by a\n          // String field in Lucene, which returns the terms\n          // data as BytesRef:\n          if (val instanceof BytesRef) {\n            UnicodeUtil.UTF8toUTF16((BytesRef)val, spare);\n            field.setStringValue(spare.toString());\n            val = ft.toObject(field);\n          }\n\n          vals[position] = val;\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"02453e8d9fe1bde22dc7676145ad809cb1dbfcad","date":1386084179,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      NamedList<Object[]> sortVals = new NamedList<Object[]>(); // order is important for the sort fields\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<AtomicReaderContext> leaves = topReaderContext.leaves();\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      long[] sortedIds = new long[nDocs];\n      DocIterator it = rb.getResults().docList.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n      }\n      Arrays.sort(sortedIds);\n\n      SortSpec sortSpec = rb.getSortSpec();\n      Sort sort = searcher.weightSort(sortSpec.getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n      for (int fld = 0; fld < schemaFields.size(); fld++) {\n        SchemaField schemaField = schemaFields.get(fld);\n        FieldType ft = null == schemaField? null : schemaField.getType();\n        SortField sortField = sortFields[fld];\n\n        SortField.Type type = sortField.getType();\n        // :TODO: would be simpler to always serialize every position of SortField[]\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n        Object[] vals = new Object[nDocs];\n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (long idAndPos : sortedIds) {\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n          if (null != ft) val = ft.marshalSortValue(val); \n          vals[position] = val;\n        }\n\n        sortVals.add(sortField.getField(), vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","sourceOld":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = searcher.weightSort(rb.getSortSpec().getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList<Object[]> sortVals = new NamedList<Object[]>(); // order is important for the sort fields\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<AtomicReaderContext> leaves = topReaderContext.leaves();\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      long[] sortedIds = new long[nDocs];\n      DocIterator it = rb.getResults().docList.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n      }\n      Arrays.sort(sortedIds);\n\n\n      for (SortField sortField: sortFields) {\n        SortField.Type type = sortField.getType();\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : searcher.getSchema().getFieldTypeNoEx(fieldname);\n\n        Object[] vals = new Object[nDocs];\n        \n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (long idAndPos : sortedIds) {\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n          if (null != ft) val = ft.marshalSortValue(val); \n          vals[position] = val;\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      NamedList<Object[]> sortVals = new NamedList<Object[]>(); // order is important for the sort fields\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<AtomicReaderContext> leaves = topReaderContext.leaves();\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      long[] sortedIds = new long[nDocs];\n      DocIterator it = rb.getResults().docList.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n      }\n      Arrays.sort(sortedIds);\n\n      SortSpec sortSpec = rb.getSortSpec();\n      Sort sort = searcher.weightSort(sortSpec.getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n      for (int fld = 0; fld < schemaFields.size(); fld++) {\n        SchemaField schemaField = schemaFields.get(fld);\n        FieldType ft = null == schemaField? null : schemaField.getType();\n        SortField sortField = sortFields[fld];\n\n        SortField.Type type = sortField.getType();\n        // :TODO: would be simpler to always serialize every position of SortField[]\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n        Object[] vals = new Object[nDocs];\n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (long idAndPos : sortedIds) {\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n          if (null != ft) val = ft.marshalSortValue(val); \n          vals[position] = val;\n        }\n\n        sortVals.add(sortField.getField(), vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","sourceOld":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    final CharsRef spare = new CharsRef();\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = searcher.weightSort(rb.getSortSpec().getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList<Object[]> sortVals = new NamedList<Object[]>(); // order is important for the sort fields\n      Field field = new StringField(\"dummy\", \"\", Field.Store.NO); // a dummy Field\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<AtomicReaderContext> leaves = topReaderContext.leaves();\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      long[] sortedIds = new long[nDocs];\n      DocIterator it = rb.getResults().docList.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n      }\n      Arrays.sort(sortedIds);\n\n\n      for (SortField sortField: sortFields) {\n        SortField.Type type = sortField.getType();\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : searcher.getSchema().getFieldTypeNoEx(fieldname);\n\n        Object[] vals = new Object[nDocs];\n        \n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (long idAndPos : sortedIds) {\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setStringValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          // Must do the same conversion when sorting by a\n          // String field in Lucene, which returns the terms\n          // data as BytesRef:\n          if (val instanceof BytesRef) {\n            UnicodeUtil.UTF8toUTF16((BytesRef)val, spare);\n            field.setStringValue(spare.toString());\n            val = ft.toObject(field);\n          }\n\n          vals[position] = val;\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d5bc8e25f59990525f5beb14afe9c96240dcf4a2","date":1389042945,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    //\n    // TODO: See SOLR-5595\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      NamedList<Object[]> sortVals = new NamedList<Object[]>(); // order is important for the sort fields\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<AtomicReaderContext> leaves = topReaderContext.leaves();\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      long[] sortedIds = new long[nDocs];\n      DocIterator it = rb.getResults().docList.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n      }\n      Arrays.sort(sortedIds);\n\n      SortSpec sortSpec = rb.getSortSpec();\n      Sort sort = searcher.weightSort(sortSpec.getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n      for (int fld = 0; fld < schemaFields.size(); fld++) {\n        SchemaField schemaField = schemaFields.get(fld);\n        FieldType ft = null == schemaField? null : schemaField.getType();\n        SortField sortField = sortFields[fld];\n\n        SortField.Type type = sortField.getType();\n        // :TODO: would be simpler to always serialize every position of SortField[]\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n        Object[] vals = new Object[nDocs];\n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (long idAndPos : sortedIds) {\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n          if (null != ft) val = ft.marshalSortValue(val); \n          vals[position] = val;\n        }\n\n        sortVals.add(sortField.getField(), vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","sourceOld":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      NamedList<Object[]> sortVals = new NamedList<Object[]>(); // order is important for the sort fields\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<AtomicReaderContext> leaves = topReaderContext.leaves();\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      long[] sortedIds = new long[nDocs];\n      DocIterator it = rb.getResults().docList.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n      }\n      Arrays.sort(sortedIds);\n\n      SortSpec sortSpec = rb.getSortSpec();\n      Sort sort = searcher.weightSort(sortSpec.getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n      for (int fld = 0; fld < schemaFields.size(); fld++) {\n        SchemaField schemaField = schemaFields.get(fld);\n        FieldType ft = null == schemaField? null : schemaField.getType();\n        SortField sortField = sortFields[fld];\n\n        SortField.Type type = sortField.getType();\n        // :TODO: would be simpler to always serialize every position of SortField[]\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n        Object[] vals = new Object[nDocs];\n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (long idAndPos : sortedIds) {\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n          if (null != ft) val = ft.marshalSortValue(val); \n          vals[position] = val;\n        }\n\n        sortVals.add(sortField.getField(), vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"65e2bf06d895fdda62d42fc57fbfc20de7156a0e","date":1394215312,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    //\n    // TODO: See SOLR-5595\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      NamedList<Object[]> sortVals = new NamedList<Object[]>(); // order is important for the sort fields\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<AtomicReaderContext> leaves = topReaderContext.leaves();\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      final long[] sortedIds = new long[nDocs];\n      final float[] scores = new float[nDocs]; // doc scores, parallel to sortedIds\n      DocList docs = rb.getResults().docList;\n      DocIterator it = docs.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n        scores[i] = docs.hasScores() ? it.score() : Float.NaN;\n      }\n\n      // sort ids and scores together\n      new InPlaceMergeSorter() {\n        @Override\n        protected void swap(int i, int j) {\n          long tmpId = sortedIds[i];\n          float tmpScore = scores[i];\n          sortedIds[i] = sortedIds[j];\n          scores[i] = scores[j];\n          sortedIds[j] = tmpId;\n          scores[j] = tmpScore;\n        }\n\n        @Override\n        protected int compare(int i, int j) {\n          return Long.compare(sortedIds[i], sortedIds[j]);\n        }\n      }.sort(0, sortedIds.length);\n\n      SortSpec sortSpec = rb.getSortSpec();\n      Sort sort = searcher.weightSort(sortSpec.getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n      for (int fld = 0; fld < schemaFields.size(); fld++) {\n        SchemaField schemaField = schemaFields.get(fld);\n        FieldType ft = null == schemaField? null : schemaField.getType();\n        SortField sortField = sortFields[fld];\n\n        SortField.Type type = sortField.getType();\n        // :TODO: would be simpler to always serialize every position of SortField[]\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n        Object[] vals = new Object[nDocs];\n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (int i = 0; i < sortedIds.length; ++i) {\n          long idAndPos = sortedIds[i];\n          float score = scores[i];\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.setScorer(new FakeScorer(doc, score));\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n          if (null != ft) val = ft.marshalSortValue(val); \n          vals[position] = val;\n        }\n\n        sortVals.add(sortField.getField(), vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","sourceOld":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    //\n    // TODO: See SOLR-5595\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      NamedList<Object[]> sortVals = new NamedList<Object[]>(); // order is important for the sort fields\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<AtomicReaderContext> leaves = topReaderContext.leaves();\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      long[] sortedIds = new long[nDocs];\n      DocIterator it = rb.getResults().docList.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n      }\n      Arrays.sort(sortedIds);\n\n      SortSpec sortSpec = rb.getSortSpec();\n      Sort sort = searcher.weightSort(sortSpec.getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n      for (int fld = 0; fld < schemaFields.size(); fld++) {\n        SchemaField schemaField = schemaFields.get(fld);\n        FieldType ft = null == schemaField? null : schemaField.getType();\n        SortField sortField = sortFields[fld];\n\n        SortField.Type type = sortField.getType();\n        // :TODO: would be simpler to always serialize every position of SortField[]\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n        Object[] vals = new Object[nDocs];\n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (long idAndPos : sortedIds) {\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n          if (null != ft) val = ft.marshalSortValue(val); \n          vals[position] = val;\n        }\n\n        sortVals.add(sortField.getField(), vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","bugFix":null,"bugIntro":["a3584d3db8b472772e3329d9d95d584b68ae997e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"96ea64d994d340044e0d57aeb6a5871539d10ca5","date":1394225445,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    //\n    // TODO: See SOLR-5595\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      NamedList<Object[]> sortVals = new NamedList<Object[]>(); // order is important for the sort fields\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<AtomicReaderContext> leaves = topReaderContext.leaves();\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      final long[] sortedIds = new long[nDocs];\n      final float[] scores = new float[nDocs]; // doc scores, parallel to sortedIds\n      DocList docs = rb.getResults().docList;\n      DocIterator it = docs.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n        scores[i] = docs.hasScores() ? it.score() : Float.NaN;\n      }\n\n      // sort ids and scores together\n      new InPlaceMergeSorter() {\n        @Override\n        protected void swap(int i, int j) {\n          long tmpId = sortedIds[i];\n          float tmpScore = scores[i];\n          sortedIds[i] = sortedIds[j];\n          scores[i] = scores[j];\n          sortedIds[j] = tmpId;\n          scores[j] = tmpScore;\n        }\n\n        @Override\n        protected int compare(int i, int j) {\n          return Long.compare(sortedIds[i], sortedIds[j]);\n        }\n      }.sort(0, sortedIds.length);\n\n      SortSpec sortSpec = rb.getSortSpec();\n      Sort sort = searcher.weightSort(sortSpec.getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n      for (int fld = 0; fld < schemaFields.size(); fld++) {\n        SchemaField schemaField = schemaFields.get(fld);\n        FieldType ft = null == schemaField? null : schemaField.getType();\n        SortField sortField = sortFields[fld];\n\n        SortField.Type type = sortField.getType();\n        // :TODO: would be simpler to always serialize every position of SortField[]\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n        Object[] vals = new Object[nDocs];\n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (int i = 0; i < sortedIds.length; ++i) {\n          long idAndPos = sortedIds[i];\n          float score = scores[i];\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.setScorer(new FakeScorer(doc, score));\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n          if (null != ft) val = ft.marshalSortValue(val); \n          vals[position] = val;\n        }\n\n        sortVals.add(sortField.getField(), vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","sourceOld":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    //\n    // TODO: See SOLR-5595\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      NamedList<Object[]> sortVals = new NamedList<Object[]>(); // order is important for the sort fields\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<AtomicReaderContext> leaves = topReaderContext.leaves();\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      long[] sortedIds = new long[nDocs];\n      DocIterator it = rb.getResults().docList.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n      }\n      Arrays.sort(sortedIds);\n\n      SortSpec sortSpec = rb.getSortSpec();\n      Sort sort = searcher.weightSort(sortSpec.getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n      for (int fld = 0; fld < schemaFields.size(); fld++) {\n        SchemaField schemaField = schemaFields.get(fld);\n        FieldType ft = null == schemaField? null : schemaField.getType();\n        SortField sortField = sortFields[fld];\n\n        SortField.Type type = sortField.getType();\n        // :TODO: would be simpler to always serialize every position of SortField[]\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n        Object[] vals = new Object[nDocs];\n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (long idAndPos : sortedIds) {\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n          if (null != ft) val = ft.marshalSortValue(val); \n          vals[position] = val;\n        }\n\n        sortVals.add(sortField.getField(), vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    //\n    // TODO: See SOLR-5595\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      NamedList<Object[]> sortVals = new NamedList<>(); // order is important for the sort fields\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<AtomicReaderContext> leaves = topReaderContext.leaves();\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      final long[] sortedIds = new long[nDocs];\n      final float[] scores = new float[nDocs]; // doc scores, parallel to sortedIds\n      DocList docs = rb.getResults().docList;\n      DocIterator it = docs.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n        scores[i] = docs.hasScores() ? it.score() : Float.NaN;\n      }\n\n      // sort ids and scores together\n      new InPlaceMergeSorter() {\n        @Override\n        protected void swap(int i, int j) {\n          long tmpId = sortedIds[i];\n          float tmpScore = scores[i];\n          sortedIds[i] = sortedIds[j];\n          scores[i] = scores[j];\n          sortedIds[j] = tmpId;\n          scores[j] = tmpScore;\n        }\n\n        @Override\n        protected int compare(int i, int j) {\n          return Long.compare(sortedIds[i], sortedIds[j]);\n        }\n      }.sort(0, sortedIds.length);\n\n      SortSpec sortSpec = rb.getSortSpec();\n      Sort sort = searcher.weightSort(sortSpec.getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n      for (int fld = 0; fld < schemaFields.size(); fld++) {\n        SchemaField schemaField = schemaFields.get(fld);\n        FieldType ft = null == schemaField? null : schemaField.getType();\n        SortField sortField = sortFields[fld];\n\n        SortField.Type type = sortField.getType();\n        // :TODO: would be simpler to always serialize every position of SortField[]\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n        Object[] vals = new Object[nDocs];\n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (int i = 0; i < sortedIds.length; ++i) {\n          long idAndPos = sortedIds[i];\n          float score = scores[i];\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.setScorer(new FakeScorer(doc, score));\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n          if (null != ft) val = ft.marshalSortValue(val); \n          vals[position] = val;\n        }\n\n        sortVals.add(sortField.getField(), vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","sourceOld":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    //\n    // TODO: See SOLR-5595\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      NamedList<Object[]> sortVals = new NamedList<Object[]>(); // order is important for the sort fields\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<AtomicReaderContext> leaves = topReaderContext.leaves();\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      final long[] sortedIds = new long[nDocs];\n      final float[] scores = new float[nDocs]; // doc scores, parallel to sortedIds\n      DocList docs = rb.getResults().docList;\n      DocIterator it = docs.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n        scores[i] = docs.hasScores() ? it.score() : Float.NaN;\n      }\n\n      // sort ids and scores together\n      new InPlaceMergeSorter() {\n        @Override\n        protected void swap(int i, int j) {\n          long tmpId = sortedIds[i];\n          float tmpScore = scores[i];\n          sortedIds[i] = sortedIds[j];\n          scores[i] = scores[j];\n          sortedIds[j] = tmpId;\n          scores[j] = tmpScore;\n        }\n\n        @Override\n        protected int compare(int i, int j) {\n          return Long.compare(sortedIds[i], sortedIds[j]);\n        }\n      }.sort(0, sortedIds.length);\n\n      SortSpec sortSpec = rb.getSortSpec();\n      Sort sort = searcher.weightSort(sortSpec.getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n      for (int fld = 0; fld < schemaFields.size(); fld++) {\n        SchemaField schemaField = schemaFields.get(fld);\n        FieldType ft = null == schemaField? null : schemaField.getType();\n        SortField sortField = sortFields[fld];\n\n        SortField.Type type = sortField.getType();\n        // :TODO: would be simpler to always serialize every position of SortField[]\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n        Object[] vals = new Object[nDocs];\n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (int i = 0; i < sortedIds.length; ++i) {\n          long idAndPos = sortedIds[i];\n          float score = scores[i];\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.setScorer(new FakeScorer(doc, score));\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n          if (null != ft) val = ft.marshalSortValue(val); \n          vals[position] = val;\n        }\n\n        sortVals.add(sortField.getField(), vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ba39ba201a572fd944ed71d888de0cd4f2957af","date":1404307334,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    //\n    // TODO: See SOLR-5595\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      NamedList<Object[]> sortVals = new NamedList<>(); // order is important for the sort fields\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<AtomicReaderContext> leaves = topReaderContext.leaves();\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      final long[] sortedIds = new long[nDocs];\n      final float[] scores = new float[nDocs]; // doc scores, parallel to sortedIds\n      DocList docs = rb.getResults().docList;\n      DocIterator it = docs.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n        scores[i] = docs.hasScores() ? it.score() : Float.NaN;\n      }\n\n      // sort ids and scores together\n      new InPlaceMergeSorter() {\n        @Override\n        protected void swap(int i, int j) {\n          long tmpId = sortedIds[i];\n          float tmpScore = scores[i];\n          sortedIds[i] = sortedIds[j];\n          scores[i] = scores[j];\n          sortedIds[j] = tmpId;\n          scores[j] = tmpScore;\n        }\n\n        @Override\n        protected int compare(int i, int j) {\n          return Long.compare(sortedIds[i], sortedIds[j]);\n        }\n      }.sort(0, sortedIds.length);\n\n      SortSpec sortSpec = rb.getSortSpec();\n      Sort sort = searcher.weightSort(sortSpec.getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n      for (int fld = 0; fld < schemaFields.size(); fld++) {\n        SchemaField schemaField = schemaFields.get(fld);\n        FieldType ft = null == schemaField? null : schemaField.getType();\n        SortField sortField = sortFields[fld];\n\n        SortField.Type type = sortField.getType();\n        // :TODO: would be simpler to always serialize every position of SortField[]\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n        Object[] vals = new Object[nDocs];\n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (int i = 0; i < sortedIds.length; ++i) {\n          long idAndPos = sortedIds[i];\n          float score = scores[i];\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.setScorer(new FakeScorer(doc, score));\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n          if (null != ft) val = ft.marshalSortValue(val);\n          vals[position] = val;\n        }\n\n        sortVals.add(sortField.getField(), vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","sourceOld":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    //\n    // TODO: See SOLR-5595\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      NamedList<Object[]> sortVals = new NamedList<>(); // order is important for the sort fields\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<AtomicReaderContext> leaves = topReaderContext.leaves();\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      final long[] sortedIds = new long[nDocs];\n      final float[] scores = new float[nDocs]; // doc scores, parallel to sortedIds\n      DocList docs = rb.getResults().docList;\n      DocIterator it = docs.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n        scores[i] = docs.hasScores() ? it.score() : Float.NaN;\n      }\n\n      // sort ids and scores together\n      new InPlaceMergeSorter() {\n        @Override\n        protected void swap(int i, int j) {\n          long tmpId = sortedIds[i];\n          float tmpScore = scores[i];\n          sortedIds[i] = sortedIds[j];\n          scores[i] = scores[j];\n          sortedIds[j] = tmpId;\n          scores[j] = tmpScore;\n        }\n\n        @Override\n        protected int compare(int i, int j) {\n          return Long.compare(sortedIds[i], sortedIds[j]);\n        }\n      }.sort(0, sortedIds.length);\n\n      SortSpec sortSpec = rb.getSortSpec();\n      Sort sort = searcher.weightSort(sortSpec.getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n      for (int fld = 0; fld < schemaFields.size(); fld++) {\n        SchemaField schemaField = schemaFields.get(fld);\n        FieldType ft = null == schemaField? null : schemaField.getType();\n        SortField sortField = sortFields[fld];\n\n        SortField.Type type = sortField.getType();\n        // :TODO: would be simpler to always serialize every position of SortField[]\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n        Object[] vals = new Object[nDocs];\n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (int i = 0; i < sortedIds.length; ++i) {\n          long idAndPos = sortedIds[i];\n          float score = scores[i];\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.setScorer(new FakeScorer(doc, score));\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n          if (null != ft) val = ft.marshalSortValue(val); \n          vals[position] = val;\n        }\n\n        sortVals.add(sortField.getField(), vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    //\n    // TODO: See SOLR-5595\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      NamedList<Object[]> sortVals = new NamedList<>(); // order is important for the sort fields\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<LeafReaderContext> leaves = topReaderContext.leaves();\n      LeafReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      final long[] sortedIds = new long[nDocs];\n      final float[] scores = new float[nDocs]; // doc scores, parallel to sortedIds\n      DocList docs = rb.getResults().docList;\n      DocIterator it = docs.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n        scores[i] = docs.hasScores() ? it.score() : Float.NaN;\n      }\n\n      // sort ids and scores together\n      new InPlaceMergeSorter() {\n        @Override\n        protected void swap(int i, int j) {\n          long tmpId = sortedIds[i];\n          float tmpScore = scores[i];\n          sortedIds[i] = sortedIds[j];\n          scores[i] = scores[j];\n          sortedIds[j] = tmpId;\n          scores[j] = tmpScore;\n        }\n\n        @Override\n        protected int compare(int i, int j) {\n          return Long.compare(sortedIds[i], sortedIds[j]);\n        }\n      }.sort(0, sortedIds.length);\n\n      SortSpec sortSpec = rb.getSortSpec();\n      Sort sort = searcher.weightSort(sortSpec.getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n      for (int fld = 0; fld < schemaFields.size(); fld++) {\n        SchemaField schemaField = schemaFields.get(fld);\n        FieldType ft = null == schemaField? null : schemaField.getType();\n        SortField sortField = sortFields[fld];\n\n        SortField.Type type = sortField.getType();\n        // :TODO: would be simpler to always serialize every position of SortField[]\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n        Object[] vals = new Object[nDocs];\n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (int i = 0; i < sortedIds.length; ++i) {\n          long idAndPos = sortedIds[i];\n          float score = scores[i];\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.setScorer(new FakeScorer(doc, score));\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n          if (null != ft) val = ft.marshalSortValue(val);\n          vals[position] = val;\n        }\n\n        sortVals.add(sortField.getField(), vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","sourceOld":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    //\n    // TODO: See SOLR-5595\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      NamedList<Object[]> sortVals = new NamedList<>(); // order is important for the sort fields\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<AtomicReaderContext> leaves = topReaderContext.leaves();\n      AtomicReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      final long[] sortedIds = new long[nDocs];\n      final float[] scores = new float[nDocs]; // doc scores, parallel to sortedIds\n      DocList docs = rb.getResults().docList;\n      DocIterator it = docs.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n        scores[i] = docs.hasScores() ? it.score() : Float.NaN;\n      }\n\n      // sort ids and scores together\n      new InPlaceMergeSorter() {\n        @Override\n        protected void swap(int i, int j) {\n          long tmpId = sortedIds[i];\n          float tmpScore = scores[i];\n          sortedIds[i] = sortedIds[j];\n          scores[i] = scores[j];\n          sortedIds[j] = tmpId;\n          scores[j] = tmpScore;\n        }\n\n        @Override\n        protected int compare(int i, int j) {\n          return Long.compare(sortedIds[i], sortedIds[j]);\n        }\n      }.sort(0, sortedIds.length);\n\n      SortSpec sortSpec = rb.getSortSpec();\n      Sort sort = searcher.weightSort(sortSpec.getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n      for (int fld = 0; fld < schemaFields.size(); fld++) {\n        SchemaField schemaField = schemaFields.get(fld);\n        FieldType ft = null == schemaField? null : schemaField.getType();\n        SortField sortField = sortFields[fld];\n\n        SortField.Type type = sortField.getType();\n        // :TODO: would be simpler to always serialize every position of SortField[]\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n        Object[] vals = new Object[nDocs];\n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (int i = 0; i < sortedIds.length; ++i) {\n          long idAndPos = sortedIds[i];\n          float score = scores[i];\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.setScorer(new FakeScorer(doc, score));\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n          if (null != ft) val = ft.marshalSortValue(val);\n          vals[position] = val;\n        }\n\n        sortVals.add(sortField.getField(), vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"901e951cec2e6af4e503209a6721c8834db23279","date":1420556599,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    //\n    // TODO: See SOLR-5595\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      NamedList<Object[]> sortVals = new NamedList<>(); // order is important for the sort fields\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<LeafReaderContext> leaves = topReaderContext.leaves();\n      LeafReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      final long[] sortedIds = new long[nDocs];\n      final float[] scores = new float[nDocs]; // doc scores, parallel to sortedIds\n      DocList docs = rb.getResults().docList;\n      DocIterator it = docs.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n        scores[i] = docs.hasScores() ? it.score() : Float.NaN;\n      }\n\n      // sort ids and scores together\n      new InPlaceMergeSorter() {\n        @Override\n        protected void swap(int i, int j) {\n          long tmpId = sortedIds[i];\n          float tmpScore = scores[i];\n          sortedIds[i] = sortedIds[j];\n          scores[i] = scores[j];\n          sortedIds[j] = tmpId;\n          scores[j] = tmpScore;\n        }\n\n        @Override\n        protected int compare(int i, int j) {\n          return Long.compare(sortedIds[i], sortedIds[j]);\n        }\n      }.sort(0, sortedIds.length);\n\n      SortSpec sortSpec = rb.getSortSpec();\n      Sort sort = searcher.weightSort(sortSpec.getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n      for (int fld = 0; fld < schemaFields.size(); fld++) {\n        SchemaField schemaField = schemaFields.get(fld);\n        FieldType ft = null == schemaField? null : schemaField.getType();\n        SortField sortField = sortFields[fld];\n\n        SortField.Type type = sortField.getType();\n        // :TODO: would be simpler to always serialize every position of SortField[]\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator<?> comparator = null;\n        LeafFieldComparator leafComparator = null;\n        Object[] vals = new Object[nDocs];\n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (int i = 0; i < sortedIds.length; ++i) {\n          long idAndPos = sortedIds[i];\n          float score = scores[i];\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            leafComparator = comparator.getLeafComparator(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          leafComparator.setScorer(new FakeScorer(doc, score));\n          leafComparator.copy(0, doc);\n          Object val = comparator.value(0);\n          if (null != ft) val = ft.marshalSortValue(val);\n          vals[position] = val;\n        }\n\n        sortVals.add(sortField.getField(), vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","sourceOld":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    //\n    // TODO: See SOLR-5595\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      NamedList<Object[]> sortVals = new NamedList<>(); // order is important for the sort fields\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<LeafReaderContext> leaves = topReaderContext.leaves();\n      LeafReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      final long[] sortedIds = new long[nDocs];\n      final float[] scores = new float[nDocs]; // doc scores, parallel to sortedIds\n      DocList docs = rb.getResults().docList;\n      DocIterator it = docs.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n        scores[i] = docs.hasScores() ? it.score() : Float.NaN;\n      }\n\n      // sort ids and scores together\n      new InPlaceMergeSorter() {\n        @Override\n        protected void swap(int i, int j) {\n          long tmpId = sortedIds[i];\n          float tmpScore = scores[i];\n          sortedIds[i] = sortedIds[j];\n          scores[i] = scores[j];\n          sortedIds[j] = tmpId;\n          scores[j] = tmpScore;\n        }\n\n        @Override\n        protected int compare(int i, int j) {\n          return Long.compare(sortedIds[i], sortedIds[j]);\n        }\n      }.sort(0, sortedIds.length);\n\n      SortSpec sortSpec = rb.getSortSpec();\n      Sort sort = searcher.weightSort(sortSpec.getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n      for (int fld = 0; fld < schemaFields.size(); fld++) {\n        SchemaField schemaField = schemaFields.get(fld);\n        FieldType ft = null == schemaField? null : schemaField.getType();\n        SortField sortField = sortFields[fld];\n\n        SortField.Type type = sortField.getType();\n        // :TODO: would be simpler to always serialize every position of SortField[]\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator comparator = null;\n        Object[] vals = new Object[nDocs];\n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (int i = 0; i < sortedIds.length; ++i) {\n          long idAndPos = sortedIds[i];\n          float score = scores[i];\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator = comparator.setNextReader(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          comparator.setScorer(new FakeScorer(doc, score));\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n          if (null != ft) val = ft.marshalSortValue(val);\n          vals[position] = val;\n        }\n\n        sortVals.add(sortField.getField(), vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","bugFix":null,"bugIntro":["0a18eb901f731cd8fa21582194fb07b0754fe389"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0a18eb901f731cd8fa21582194fb07b0754fe389","date":1479398197,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    //\n    // TODO: See SOLR-5595\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      NamedList<Object[]> sortVals = new NamedList<>(); // order is important for the sort fields\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<LeafReaderContext> leaves = topReaderContext.leaves();\n      LeafReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      final long[] sortedIds = new long[nDocs];\n      final float[] scores = new float[nDocs]; // doc scores, parallel to sortedIds\n      DocList docs = rb.getResults().docList;\n      DocIterator it = docs.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n        scores[i] = docs.hasScores() ? it.score() : Float.NaN;\n      }\n\n      // sort ids and scores together\n      new InPlaceMergeSorter() {\n        @Override\n        protected void swap(int i, int j) {\n          long tmpId = sortedIds[i];\n          float tmpScore = scores[i];\n          sortedIds[i] = sortedIds[j];\n          scores[i] = scores[j];\n          sortedIds[j] = tmpId;\n          scores[j] = tmpScore;\n        }\n\n        @Override\n        protected int compare(int i, int j) {\n          return Long.compare(sortedIds[i], sortedIds[j]);\n        }\n      }.sort(0, sortedIds.length);\n\n      SortSpec sortSpec = rb.getSortSpec();\n      Sort sort = searcher.weightSort(sortSpec.getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n      for (int fld = 0; fld < schemaFields.size(); fld++) {\n        SchemaField schemaField = schemaFields.get(fld);\n        FieldType ft = null == schemaField? null : schemaField.getType();\n        SortField sortField = sortFields[fld];\n\n        SortField.Type type = sortField.getType();\n        // :TODO: would be simpler to always serialize every position of SortField[]\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator<?> comparator = sortField.getComparator(1,0);\n        LeafFieldComparator leafComparator = null;\n        Object[] vals = new Object[nDocs];\n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (int i = 0; i < sortedIds.length; ++i) {\n          long idAndPos = sortedIds[i];\n          float score = scores[i];\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate leafComparator.\n              lastIdx = idx;\n              leafComparator = null;\n            }\n          }\n\n          if (leafComparator == null) {\n            leafComparator = comparator.getLeafComparator(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          leafComparator.setScorer(new FakeScorer(doc, score));\n          leafComparator.copy(0, doc);\n          Object val = comparator.value(0);\n          if (null != ft) val = ft.marshalSortValue(val);\n          vals[position] = val;\n        }\n\n        sortVals.add(sortField.getField(), vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","sourceOld":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    //\n    // TODO: See SOLR-5595\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      NamedList<Object[]> sortVals = new NamedList<>(); // order is important for the sort fields\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<LeafReaderContext> leaves = topReaderContext.leaves();\n      LeafReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      final long[] sortedIds = new long[nDocs];\n      final float[] scores = new float[nDocs]; // doc scores, parallel to sortedIds\n      DocList docs = rb.getResults().docList;\n      DocIterator it = docs.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n        scores[i] = docs.hasScores() ? it.score() : Float.NaN;\n      }\n\n      // sort ids and scores together\n      new InPlaceMergeSorter() {\n        @Override\n        protected void swap(int i, int j) {\n          long tmpId = sortedIds[i];\n          float tmpScore = scores[i];\n          sortedIds[i] = sortedIds[j];\n          scores[i] = scores[j];\n          sortedIds[j] = tmpId;\n          scores[j] = tmpScore;\n        }\n\n        @Override\n        protected int compare(int i, int j) {\n          return Long.compare(sortedIds[i], sortedIds[j]);\n        }\n      }.sort(0, sortedIds.length);\n\n      SortSpec sortSpec = rb.getSortSpec();\n      Sort sort = searcher.weightSort(sortSpec.getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n      for (int fld = 0; fld < schemaFields.size(); fld++) {\n        SchemaField schemaField = schemaFields.get(fld);\n        FieldType ft = null == schemaField? null : schemaField.getType();\n        SortField sortField = sortFields[fld];\n\n        SortField.Type type = sortField.getType();\n        // :TODO: would be simpler to always serialize every position of SortField[]\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator<?> comparator = null;\n        LeafFieldComparator leafComparator = null;\n        Object[] vals = new Object[nDocs];\n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (int i = 0; i < sortedIds.length; ++i) {\n          long idAndPos = sortedIds[i];\n          float score = scores[i];\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            leafComparator = comparator.getLeafComparator(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          leafComparator.setScorer(new FakeScorer(doc, score));\n          leafComparator.copy(0, doc);\n          Object val = comparator.value(0);\n          if (null != ft) val = ft.marshalSortValue(val);\n          vals[position] = val;\n        }\n\n        sortVals.add(sortField.getField(), vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","bugFix":["a311f7ac72ff006bb02172c40f62062b35cb6a2a","901e951cec2e6af4e503209a6721c8834db23279","9b240c33c89713e9821af46e867f4710eb811864"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2e859e664a65796dadf8aaf65db6f66f3a885368","date":1479487334,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    //\n    // TODO: See SOLR-5595\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      NamedList<Object[]> sortVals = new NamedList<>(); // order is important for the sort fields\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<LeafReaderContext> leaves = topReaderContext.leaves();\n      LeafReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      final long[] sortedIds = new long[nDocs];\n      final float[] scores = new float[nDocs]; // doc scores, parallel to sortedIds\n      DocList docs = rb.getResults().docList;\n      DocIterator it = docs.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n        scores[i] = docs.hasScores() ? it.score() : Float.NaN;\n      }\n\n      // sort ids and scores together\n      new InPlaceMergeSorter() {\n        @Override\n        protected void swap(int i, int j) {\n          long tmpId = sortedIds[i];\n          float tmpScore = scores[i];\n          sortedIds[i] = sortedIds[j];\n          scores[i] = scores[j];\n          sortedIds[j] = tmpId;\n          scores[j] = tmpScore;\n        }\n\n        @Override\n        protected int compare(int i, int j) {\n          return Long.compare(sortedIds[i], sortedIds[j]);\n        }\n      }.sort(0, sortedIds.length);\n\n      SortSpec sortSpec = rb.getSortSpec();\n      Sort sort = searcher.weightSort(sortSpec.getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n      for (int fld = 0; fld < schemaFields.size(); fld++) {\n        SchemaField schemaField = schemaFields.get(fld);\n        FieldType ft = null == schemaField? null : schemaField.getType();\n        SortField sortField = sortFields[fld];\n\n        SortField.Type type = sortField.getType();\n        // :TODO: would be simpler to always serialize every position of SortField[]\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator<?> comparator = sortField.getComparator(1,0);\n        LeafFieldComparator leafComparator = null;\n        Object[] vals = new Object[nDocs];\n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (int i = 0; i < sortedIds.length; ++i) {\n          long idAndPos = sortedIds[i];\n          float score = scores[i];\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate leafComparator.\n              lastIdx = idx;\n              leafComparator = null;\n            }\n          }\n\n          if (leafComparator == null) {\n            leafComparator = comparator.getLeafComparator(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          leafComparator.setScorer(new FakeScorer(doc, score));\n          leafComparator.copy(0, doc);\n          Object val = comparator.value(0);\n          if (null != ft) val = ft.marshalSortValue(val);\n          vals[position] = val;\n        }\n\n        sortVals.add(sortField.getField(), vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","sourceOld":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    //\n    // TODO: See SOLR-5595\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      NamedList<Object[]> sortVals = new NamedList<>(); // order is important for the sort fields\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<LeafReaderContext> leaves = topReaderContext.leaves();\n      LeafReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      final long[] sortedIds = new long[nDocs];\n      final float[] scores = new float[nDocs]; // doc scores, parallel to sortedIds\n      DocList docs = rb.getResults().docList;\n      DocIterator it = docs.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n        scores[i] = docs.hasScores() ? it.score() : Float.NaN;\n      }\n\n      // sort ids and scores together\n      new InPlaceMergeSorter() {\n        @Override\n        protected void swap(int i, int j) {\n          long tmpId = sortedIds[i];\n          float tmpScore = scores[i];\n          sortedIds[i] = sortedIds[j];\n          scores[i] = scores[j];\n          sortedIds[j] = tmpId;\n          scores[j] = tmpScore;\n        }\n\n        @Override\n        protected int compare(int i, int j) {\n          return Long.compare(sortedIds[i], sortedIds[j]);\n        }\n      }.sort(0, sortedIds.length);\n\n      SortSpec sortSpec = rb.getSortSpec();\n      Sort sort = searcher.weightSort(sortSpec.getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n      for (int fld = 0; fld < schemaFields.size(); fld++) {\n        SchemaField schemaField = schemaFields.get(fld);\n        FieldType ft = null == schemaField? null : schemaField.getType();\n        SortField sortField = sortFields[fld];\n\n        SortField.Type type = sortField.getType();\n        // :TODO: would be simpler to always serialize every position of SortField[]\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator<?> comparator = null;\n        LeafFieldComparator leafComparator = null;\n        Object[] vals = new Object[nDocs];\n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (int i = 0; i < sortedIds.length; ++i) {\n          long idAndPos = sortedIds[i];\n          float score = scores[i];\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate comparator.\n              comparator = null;\n            }\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            leafComparator = comparator.getLeafComparator(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          leafComparator.setScorer(new FakeScorer(doc, score));\n          leafComparator.copy(0, doc);\n          Object val = comparator.value(0);\n          if (null != ft) val = ft.marshalSortValue(val);\n          vals[position] = val;\n        }\n\n        sortVals.add(sortField.getField(), vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6dbd758f2776b0129f6b3641b6490ddc68d7b0f3","date":1536316907,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    //\n    // TODO: See SOLR-5595\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      NamedList<Object[]> sortVals = new NamedList<>(); // order is important for the sort fields\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<LeafReaderContext> leaves = topReaderContext.leaves();\n      LeafReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      final long[] sortedIds = new long[nDocs];\n      final float[] scores = new float[nDocs]; // doc scores, parallel to sortedIds\n      DocList docs = rb.getResults().docList;\n      DocIterator it = docs.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n        scores[i] = docs.hasScores() ? it.score() : Float.NaN;\n      }\n\n      // sort ids and scores together\n      new InPlaceMergeSorter() {\n        @Override\n        protected void swap(int i, int j) {\n          long tmpId = sortedIds[i];\n          float tmpScore = scores[i];\n          sortedIds[i] = sortedIds[j];\n          scores[i] = scores[j];\n          sortedIds[j] = tmpId;\n          scores[j] = tmpScore;\n        }\n\n        @Override\n        protected int compare(int i, int j) {\n          return Long.compare(sortedIds[i], sortedIds[j]);\n        }\n      }.sort(0, sortedIds.length);\n\n      SortSpec sortSpec = rb.getSortSpec();\n      Sort sort = searcher.weightSort(sortSpec.getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n      for (int fld = 0; fld < schemaFields.size(); fld++) {\n        SchemaField schemaField = schemaFields.get(fld);\n        FieldType ft = null == schemaField? null : schemaField.getType();\n        SortField sortField = sortFields[fld];\n\n        SortField.Type type = sortField.getType();\n        // :TODO: would be simpler to always serialize every position of SortField[]\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator<?> comparator = sortField.getComparator(1,0);\n        LeafFieldComparator leafComparator = null;\n        Object[] vals = new Object[nDocs];\n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (int i = 0; i < sortedIds.length; ++i) {\n          long idAndPos = sortedIds[i];\n          float score = scores[i];\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate leafComparator.\n              lastIdx = idx;\n              leafComparator = null;\n            }\n          }\n\n          if (leafComparator == null) {\n            leafComparator = comparator.getLeafComparator(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          leafComparator.setScorer(new ScoreAndDoc(doc, score));\n          leafComparator.copy(0, doc);\n          Object val = comparator.value(0);\n          if (null != ft) val = ft.marshalSortValue(val);\n          vals[position] = val;\n        }\n\n        sortVals.add(sortField.getField(), vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","sourceOld":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    //\n    // TODO: See SOLR-5595\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      NamedList<Object[]> sortVals = new NamedList<>(); // order is important for the sort fields\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<LeafReaderContext> leaves = topReaderContext.leaves();\n      LeafReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      final long[] sortedIds = new long[nDocs];\n      final float[] scores = new float[nDocs]; // doc scores, parallel to sortedIds\n      DocList docs = rb.getResults().docList;\n      DocIterator it = docs.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n        scores[i] = docs.hasScores() ? it.score() : Float.NaN;\n      }\n\n      // sort ids and scores together\n      new InPlaceMergeSorter() {\n        @Override\n        protected void swap(int i, int j) {\n          long tmpId = sortedIds[i];\n          float tmpScore = scores[i];\n          sortedIds[i] = sortedIds[j];\n          scores[i] = scores[j];\n          sortedIds[j] = tmpId;\n          scores[j] = tmpScore;\n        }\n\n        @Override\n        protected int compare(int i, int j) {\n          return Long.compare(sortedIds[i], sortedIds[j]);\n        }\n      }.sort(0, sortedIds.length);\n\n      SortSpec sortSpec = rb.getSortSpec();\n      Sort sort = searcher.weightSort(sortSpec.getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n      for (int fld = 0; fld < schemaFields.size(); fld++) {\n        SchemaField schemaField = schemaFields.get(fld);\n        FieldType ft = null == schemaField? null : schemaField.getType();\n        SortField sortField = sortFields[fld];\n\n        SortField.Type type = sortField.getType();\n        // :TODO: would be simpler to always serialize every position of SortField[]\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator<?> comparator = sortField.getComparator(1,0);\n        LeafFieldComparator leafComparator = null;\n        Object[] vals = new Object[nDocs];\n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (int i = 0; i < sortedIds.length; ++i) {\n          long idAndPos = sortedIds[i];\n          float score = scores[i];\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate leafComparator.\n              lastIdx = idx;\n              leafComparator = null;\n            }\n          }\n\n          if (leafComparator == null) {\n            leafComparator = comparator.getLeafComparator(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          leafComparator.setScorer(new FakeScorer(doc, score));\n          leafComparator.copy(0, doc);\n          Object val = comparator.value(0);\n          if (null != ft) val = ft.marshalSortValue(val);\n          vals[position] = val;\n        }\n\n        sortVals.add(sortField.getField(), vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3584d3db8b472772e3329d9d95d584b68ae997e","date":1551710517,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#doFieldSortValues(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    //\n    // TODO: See SOLR-5595\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      try {\n      NamedList<Object[]> sortVals = new NamedList<>(); // order is important for the sort fields\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<LeafReaderContext> leaves = topReaderContext.leaves();\n      LeafReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      final DocList docs = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docs.size();\n      final long[] sortedIds = new long[nDocs];\n      final float[] scores = new float[nDocs]; // doc scores, parallel to sortedIds\n      DocIterator it = docs.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n        scores[i] = docs.hasScores() ? it.score() : Float.NaN;\n      }\n\n      // sort ids and scores together\n      new InPlaceMergeSorter() {\n        @Override\n        protected void swap(int i, int j) {\n          long tmpId = sortedIds[i];\n          float tmpScore = scores[i];\n          sortedIds[i] = sortedIds[j];\n          scores[i] = scores[j];\n          sortedIds[j] = tmpId;\n          scores[j] = tmpScore;\n        }\n\n        @Override\n        protected int compare(int i, int j) {\n          return Long.compare(sortedIds[i], sortedIds[j]);\n        }\n      }.sort(0, sortedIds.length);\n\n      SortSpec sortSpec = rb.getSortSpec();\n      Sort sort = searcher.weightSort(sortSpec.getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n      for (int fld = 0; fld < schemaFields.size(); fld++) {\n        SchemaField schemaField = schemaFields.get(fld);\n        FieldType ft = null == schemaField? null : schemaField.getType();\n        SortField sortField = sortFields[fld];\n\n        SortField.Type type = sortField.getType();\n        // :TODO: would be simpler to always serialize every position of SortField[]\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator<?> comparator = sortField.getComparator(1,0);\n        LeafFieldComparator leafComparator = null;\n        Object[] vals = new Object[nDocs];\n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (int i = 0; i < sortedIds.length; ++i) {\n          long idAndPos = sortedIds[i];\n          float score = scores[i];\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate leafComparator.\n              lastIdx = idx;\n              leafComparator = null;\n            }\n          }\n\n          if (leafComparator == null) {\n            leafComparator = comparator.getLeafComparator(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          leafComparator.setScorer(new ScoreAndDoc(doc, score));\n          leafComparator.copy(0, doc);\n          Object val = comparator.value(0);\n          if (null != ft) val = ft.marshalSortValue(val);\n          vals[position] = val;\n        }\n\n        sortVals.add(sortField.getField(), vals);\n      }\n      rsp.add(\"sort_values\", sortVals);\n    }catch(ExitableDirectoryReader.ExitingReaderException x) {\n      // it's hard to understand where we stopped, so yield nothing\n      // search handler will flag partial results\n      rsp.add(\"sort_values\",new NamedList<>() );\n      throw x;\n    }\n    }\n  }\n\n","sourceOld":"  protected void doFieldSortValues(ResponseBuilder rb, SolrIndexSearcher searcher) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    //\n    // TODO: See SOLR-5595\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      NamedList<Object[]> sortVals = new NamedList<>(); // order is important for the sort fields\n      IndexReaderContext topReaderContext = searcher.getTopReaderContext();\n      List<LeafReaderContext> leaves = topReaderContext.leaves();\n      LeafReaderContext currentLeaf = null;\n      if (leaves.size()==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        currentLeaf = leaves.get(0);\n        leaves=null;\n      }\n\n      DocList docList = rb.getResults().docList;\n\n      // sort ids from lowest to highest so we can access them in order\n      int nDocs = docList.size();\n      final long[] sortedIds = new long[nDocs];\n      final float[] scores = new float[nDocs]; // doc scores, parallel to sortedIds\n      DocList docs = rb.getResults().docList;\n      DocIterator it = docs.iterator();\n      for (int i=0; i<nDocs; i++) {\n        sortedIds[i] = (((long)it.nextDoc()) << 32) | i;\n        scores[i] = docs.hasScores() ? it.score() : Float.NaN;\n      }\n\n      // sort ids and scores together\n      new InPlaceMergeSorter() {\n        @Override\n        protected void swap(int i, int j) {\n          long tmpId = sortedIds[i];\n          float tmpScore = scores[i];\n          sortedIds[i] = sortedIds[j];\n          scores[i] = scores[j];\n          sortedIds[j] = tmpId;\n          scores[j] = tmpScore;\n        }\n\n        @Override\n        protected int compare(int i, int j) {\n          return Long.compare(sortedIds[i], sortedIds[j]);\n        }\n      }.sort(0, sortedIds.length);\n\n      SortSpec sortSpec = rb.getSortSpec();\n      Sort sort = searcher.weightSort(sortSpec.getSort());\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      List<SchemaField> schemaFields = sortSpec.getSchemaFields();\n\n      for (int fld = 0; fld < schemaFields.size(); fld++) {\n        SchemaField schemaField = schemaFields.get(fld);\n        FieldType ft = null == schemaField? null : schemaField.getType();\n        SortField sortField = sortFields[fld];\n\n        SortField.Type type = sortField.getType();\n        // :TODO: would be simpler to always serialize every position of SortField[]\n        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;\n\n        FieldComparator<?> comparator = sortField.getComparator(1,0);\n        LeafFieldComparator leafComparator = null;\n        Object[] vals = new Object[nDocs];\n\n        int lastIdx = -1;\n        int idx = 0;\n\n        for (int i = 0; i < sortedIds.length; ++i) {\n          long idAndPos = sortedIds[i];\n          float score = scores[i];\n          int doc = (int)(idAndPos >>> 32);\n          int position = (int)idAndPos;\n\n          if (leaves != null) {\n            idx = ReaderUtil.subIndex(doc, leaves);\n            currentLeaf = leaves.get(idx);\n            if (idx != lastIdx) {\n              // we switched segments.  invalidate leafComparator.\n              lastIdx = idx;\n              leafComparator = null;\n            }\n          }\n\n          if (leafComparator == null) {\n            leafComparator = comparator.getLeafComparator(currentLeaf);\n          }\n\n          doc -= currentLeaf.docBase;  // adjust for what segment this is in\n          leafComparator.setScorer(new ScoreAndDoc(doc, score));\n          leafComparator.copy(0, doc);\n          Object val = comparator.value(0);\n          if (null != ft) val = ft.marshalSortValue(val);\n          vals[position] = val;\n        }\n\n        sortVals.add(sortField.getField(), vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n  }\n\n","bugFix":["a311f7ac72ff006bb02172c40f62062b35cb6a2a","9b240c33c89713e9821af46e867f4710eb811864","65e2bf06d895fdda62d42fc57fbfc20de7156a0e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"da6c07e76d701edbcc45c3e83ad8464a5e44a4c0":["ccc08aa684aee4964baee0644a6ba047bfd70829"],"96ea64d994d340044e0d57aeb6a5871539d10ca5":["d5bc8e25f59990525f5beb14afe9c96240dcf4a2","65e2bf06d895fdda62d42fc57fbfc20de7156a0e"],"ccc08aa684aee4964baee0644a6ba047bfd70829":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"d5bc8e25f59990525f5beb14afe9c96240dcf4a2":["02453e8d9fe1bde22dc7676145ad809cb1dbfcad"],"6dbd758f2776b0129f6b3641b6490ddc68d7b0f3":["0a18eb901f731cd8fa21582194fb07b0754fe389"],"0a18eb901f731cd8fa21582194fb07b0754fe389":["901e951cec2e6af4e503209a6721c8834db23279"],"a3584d3db8b472772e3329d9d95d584b68ae997e":["6dbd758f2776b0129f6b3641b6490ddc68d7b0f3"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["5ba39ba201a572fd944ed71d888de0cd4f2957af"],"08970e5b8411182a29412c177eff67ec1110095b":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"a78a90fc9701e511308346ea29f4f5e548bb39fe":["0d4602ca2700dfd2f6159ad1499e5b6d1f3b92a8"],"02453e8d9fe1bde22dc7676145ad809cb1dbfcad":["faff74992839549208db29d95b9ad4a1d3846c79"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["c26f00b574427b55127e869b935845554afde1fa"],"65e2bf06d895fdda62d42fc57fbfc20de7156a0e":["d5bc8e25f59990525f5beb14afe9c96240dcf4a2"],"8493985e6883b3fa8231d172694d2aa3a85cb182":["da6c07e76d701edbcc45c3e83ad8464a5e44a4c0"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["65e2bf06d895fdda62d42fc57fbfc20de7156a0e"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"0d4602ca2700dfd2f6159ad1499e5b6d1f3b92a8":["a311f7ac72ff006bb02172c40f62062b35cb6a2a"],"901e951cec2e6af4e503209a6721c8834db23279":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"faff74992839549208db29d95b9ad4a1d3846c79":["08970e5b8411182a29412c177eff67ec1110095b"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["da6c07e76d701edbcc45c3e83ad8464a5e44a4c0","8493985e6883b3fa8231d172694d2aa3a85cb182"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["08970e5b8411182a29412c177eff67ec1110095b","02453e8d9fe1bde22dc7676145ad809cb1dbfcad"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2e859e664a65796dadf8aaf65db6f66f3a885368":["901e951cec2e6af4e503209a6721c8834db23279","0a18eb901f731cd8fa21582194fb07b0754fe389"],"5ba39ba201a572fd944ed71d888de0cd4f2957af":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a311f7ac72ff006bb02172c40f62062b35cb6a2a":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a3584d3db8b472772e3329d9d95d584b68ae997e"]},"commit2Childs":{"da6c07e76d701edbcc45c3e83ad8464a5e44a4c0":["8493985e6883b3fa8231d172694d2aa3a85cb182","5cab9a86bd67202d20b6adc463008c8e982b070a"],"96ea64d994d340044e0d57aeb6a5871539d10ca5":[],"ccc08aa684aee4964baee0644a6ba047bfd70829":["da6c07e76d701edbcc45c3e83ad8464a5e44a4c0"],"c26f00b574427b55127e869b935845554afde1fa":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"d5bc8e25f59990525f5beb14afe9c96240dcf4a2":["96ea64d994d340044e0d57aeb6a5871539d10ca5","65e2bf06d895fdda62d42fc57fbfc20de7156a0e"],"6dbd758f2776b0129f6b3641b6490ddc68d7b0f3":["a3584d3db8b472772e3329d9d95d584b68ae997e"],"0a18eb901f731cd8fa21582194fb07b0754fe389":["6dbd758f2776b0129f6b3641b6490ddc68d7b0f3","2e859e664a65796dadf8aaf65db6f66f3a885368"],"a3584d3db8b472772e3329d9d95d584b68ae997e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["901e951cec2e6af4e503209a6721c8834db23279"],"08970e5b8411182a29412c177eff67ec1110095b":["faff74992839549208db29d95b9ad4a1d3846c79","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"a78a90fc9701e511308346ea29f4f5e548bb39fe":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"02453e8d9fe1bde22dc7676145ad809cb1dbfcad":["d5bc8e25f59990525f5beb14afe9c96240dcf4a2","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["ccc08aa684aee4964baee0644a6ba047bfd70829"],"65e2bf06d895fdda62d42fc57fbfc20de7156a0e":["96ea64d994d340044e0d57aeb6a5871539d10ca5","634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"8493985e6883b3fa8231d172694d2aa3a85cb182":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["5ba39ba201a572fd944ed71d888de0cd4f2957af"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["08970e5b8411182a29412c177eff67ec1110095b"],"0d4602ca2700dfd2f6159ad1499e5b6d1f3b92a8":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"901e951cec2e6af4e503209a6721c8834db23279":["0a18eb901f731cd8fa21582194fb07b0754fe389","2e859e664a65796dadf8aaf65db6f66f3a885368"],"faff74992839549208db29d95b9ad4a1d3846c79":["02453e8d9fe1bde22dc7676145ad809cb1dbfcad"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["a311f7ac72ff006bb02172c40f62062b35cb6a2a"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"2e859e664a65796dadf8aaf65db6f66f3a885368":[],"5ba39ba201a572fd944ed71d888de0cd4f2957af":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"a311f7ac72ff006bb02172c40f62062b35cb6a2a":["0d4602ca2700dfd2f6159ad1499e5b6d1f3b92a8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["96ea64d994d340044e0d57aeb6a5871539d10ca5","74f45af4339b0daf7a95c820ab88c1aea74fbce0","a258fbb26824fd104ed795e5d9033d2d040049ee","2e859e664a65796dadf8aaf65db6f66f3a885368","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}