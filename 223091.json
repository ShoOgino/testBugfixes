{"path":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","commits":[{"id":"9d153abcf92dc5329d98571a8c3035df9bd80648","date":1337702630,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfo,SegmentReader,NumberFormat).mjava","sourceNew":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.docCount; ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, null, false);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, null, false);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n                \n                final boolean hasPositions;\n                final boolean hasOffsets;\n                final boolean hasFreqs;\n\n                // TODO: really we need a reflection/query\n                // API so we can just ask what was indexed\n                // instead of \"probing\"...\n\n                // Try offsets:\n                postings = termsEnum.docsAndPositions(null, postings, true);\n                if (postings == null) {\n                  hasOffsets = false;\n                  // Try only positions:\n                  postings = termsEnum.docsAndPositions(null, postings, false);\n                  if (postings == null) {\n                    hasPositions = false;\n                    // Try docIDs & freqs:\n                    docs = termsEnum.docs(null, docs, true);\n                    if (docs == null) {\n                      // OK, only docIDs:\n                      hasFreqs = false;\n                      docs = termsEnum.docs(null, docs, false);\n                    } else {\n                      hasFreqs = true;\n                    }\n                  } else {\n                    hasPositions = true;\n                    hasFreqs = true;\n                  }\n                } else {\n                  hasOffsets = true;\n                  // NOTE: may be a lie... but we accept -1\n                  hasPositions = true;\n                  hasFreqs = true;\n                }\n\n                final DocsEnum docs2;\n                if (hasPositions || hasOffsets) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                final boolean postingsHasFreq;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, true);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ offsets but postings were not\n                  postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, false);\n                  if (postingsPostings == null) {\n                    postingsDocs = postingsTermsEnum.docs(null, postingsDocs, true);\n                    if (postingsDocs == null) {\n                      postingsHasFreq = false;\n                      postingsDocs = postingsTermsEnum.docs(null, postingsDocs, false);\n                      if (postingsDocs == null) {\n                        throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                      }\n                    } else {\n                      postingsHasFreq = true;\n                    }\n                  } else {\n                    postingsHasFreq = true;\n                  }\n                } else {\n                  postingsHasFreq = true;\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (hasFreqs) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasPositions || hasOffsets) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (pos != -1 && postingsPos != -1 && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      if (hasOffsets) {\n                        // Call the methods to at least make\n                        // sure they don't throw exc:\n                        final int startOffset = postings.startOffset();\n                        final int endOffset = postings.endOffset();\n                        // TODO: these are too anal...?\n                        /*\n                          if (endOffset < startOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                          }\n                          if (startOffset < lastStartOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                          }\n                          lastStartOffset = startOffset;\n                        */\n\n                        if (postingsPostings != null) {\n                          final int postingsStartOffset = postingsPostings.startOffset();\n\n                          final int postingsEndOffset = postingsPostings.endOffset();\n                          if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                          }\n                          if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format((((float) status.totVectors) / status.docCount)) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfo info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.docCount; ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, null, false);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, null, false);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n                \n                final boolean hasPositions;\n                final boolean hasOffsets;\n                final boolean hasFreqs;\n\n                // TODO: really we need a reflection/query\n                // API so we can just ask what was indexed\n                // instead of \"probing\"...\n\n                // Try offsets:\n                postings = termsEnum.docsAndPositions(null, postings, true);\n                if (postings == null) {\n                  hasOffsets = false;\n                  // Try only positions:\n                  postings = termsEnum.docsAndPositions(null, postings, false);\n                  if (postings == null) {\n                    hasPositions = false;\n                    // Try docIDs & freqs:\n                    docs = termsEnum.docs(null, docs, true);\n                    if (docs == null) {\n                      // OK, only docIDs:\n                      hasFreqs = false;\n                      docs = termsEnum.docs(null, docs, false);\n                    } else {\n                      hasFreqs = true;\n                    }\n                  } else {\n                    hasPositions = true;\n                    hasFreqs = true;\n                  }\n                } else {\n                  hasOffsets = true;\n                  // NOTE: may be a lie... but we accept -1\n                  hasPositions = true;\n                  hasFreqs = true;\n                }\n\n                final DocsEnum docs2;\n                if (hasPositions || hasOffsets) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                final boolean postingsHasFreq;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, true);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ offsets but postings were not\n                  postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, false);\n                  if (postingsPostings == null) {\n                    postingsDocs = postingsTermsEnum.docs(null, postingsDocs, true);\n                    if (postingsDocs == null) {\n                      postingsHasFreq = false;\n                      postingsDocs = postingsTermsEnum.docs(null, postingsDocs, false);\n                      if (postingsDocs == null) {\n                        throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                      }\n                    } else {\n                      postingsHasFreq = true;\n                    }\n                  } else {\n                    postingsHasFreq = true;\n                  }\n                } else {\n                  postingsHasFreq = true;\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (hasFreqs) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasPositions || hasOffsets) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (pos != -1 && postingsPos != -1 && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      if (hasOffsets) {\n                        // Call the methods to at least make\n                        // sure they don't throw exc:\n                        final int startOffset = postings.startOffset();\n                        final int endOffset = postings.endOffset();\n                        // TODO: these are too anal...?\n                        /*\n                          if (endOffset < startOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                          }\n                          if (startOffset < lastStartOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                          }\n                          lastStartOffset = startOffset;\n                        */\n\n                        if (postingsPostings != null) {\n                          final int postingsStartOffset = postingsPostings.startOffset();\n\n                          final int postingsEndOffset = postingsPostings.endOffset();\n                          if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                          }\n                          if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format((((float) status.totVectors) / status.docCount)) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"203d7d3cb7712e10ef33009a63247ae40c302d7a","date":1337798111,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","sourceNew":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, null, false);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, null, false);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n                \n                final boolean hasPositions;\n                final boolean hasOffsets;\n                final boolean hasFreqs;\n\n                // TODO: really we need a reflection/query\n                // API so we can just ask what was indexed\n                // instead of \"probing\"...\n\n                // Try offsets:\n                postings = termsEnum.docsAndPositions(null, postings, true);\n                if (postings == null) {\n                  hasOffsets = false;\n                  // Try only positions:\n                  postings = termsEnum.docsAndPositions(null, postings, false);\n                  if (postings == null) {\n                    hasPositions = false;\n                    // Try docIDs & freqs:\n                    docs = termsEnum.docs(null, docs, true);\n                    if (docs == null) {\n                      // OK, only docIDs:\n                      hasFreqs = false;\n                      docs = termsEnum.docs(null, docs, false);\n                    } else {\n                      hasFreqs = true;\n                    }\n                  } else {\n                    hasPositions = true;\n                    hasFreqs = true;\n                  }\n                } else {\n                  hasOffsets = true;\n                  // NOTE: may be a lie... but we accept -1\n                  hasPositions = true;\n                  hasFreqs = true;\n                }\n\n                final DocsEnum docs2;\n                if (hasPositions || hasOffsets) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                final boolean postingsHasFreq;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, true);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ offsets but postings were not\n                  postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, false);\n                  if (postingsPostings == null) {\n                    postingsDocs = postingsTermsEnum.docs(null, postingsDocs, true);\n                    if (postingsDocs == null) {\n                      postingsHasFreq = false;\n                      postingsDocs = postingsTermsEnum.docs(null, postingsDocs, false);\n                      if (postingsDocs == null) {\n                        throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                      }\n                    } else {\n                      postingsHasFreq = true;\n                    }\n                  } else {\n                    postingsHasFreq = true;\n                  }\n                } else {\n                  postingsHasFreq = true;\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (hasFreqs) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasPositions || hasOffsets) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (pos != -1 && postingsPos != -1 && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      if (hasOffsets) {\n                        // Call the methods to at least make\n                        // sure they don't throw exc:\n                        final int startOffset = postings.startOffset();\n                        final int endOffset = postings.endOffset();\n                        // TODO: these are too anal...?\n                        /*\n                          if (endOffset < startOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                          }\n                          if (startOffset < lastStartOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                          }\n                          lastStartOffset = startOffset;\n                        */\n\n                        if (postingsPostings != null) {\n                          final int postingsStartOffset = postingsPostings.startOffset();\n\n                          final int postingsEndOffset = postingsPostings.endOffset();\n                          if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                          }\n                          if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format((((float) status.totVectors) / status.docCount)) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.docCount; ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, null, false);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, null, false);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n                \n                final boolean hasPositions;\n                final boolean hasOffsets;\n                final boolean hasFreqs;\n\n                // TODO: really we need a reflection/query\n                // API so we can just ask what was indexed\n                // instead of \"probing\"...\n\n                // Try offsets:\n                postings = termsEnum.docsAndPositions(null, postings, true);\n                if (postings == null) {\n                  hasOffsets = false;\n                  // Try only positions:\n                  postings = termsEnum.docsAndPositions(null, postings, false);\n                  if (postings == null) {\n                    hasPositions = false;\n                    // Try docIDs & freqs:\n                    docs = termsEnum.docs(null, docs, true);\n                    if (docs == null) {\n                      // OK, only docIDs:\n                      hasFreqs = false;\n                      docs = termsEnum.docs(null, docs, false);\n                    } else {\n                      hasFreqs = true;\n                    }\n                  } else {\n                    hasPositions = true;\n                    hasFreqs = true;\n                  }\n                } else {\n                  hasOffsets = true;\n                  // NOTE: may be a lie... but we accept -1\n                  hasPositions = true;\n                  hasFreqs = true;\n                }\n\n                final DocsEnum docs2;\n                if (hasPositions || hasOffsets) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                final boolean postingsHasFreq;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, true);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ offsets but postings were not\n                  postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, false);\n                  if (postingsPostings == null) {\n                    postingsDocs = postingsTermsEnum.docs(null, postingsDocs, true);\n                    if (postingsDocs == null) {\n                      postingsHasFreq = false;\n                      postingsDocs = postingsTermsEnum.docs(null, postingsDocs, false);\n                      if (postingsDocs == null) {\n                        throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                      }\n                    } else {\n                      postingsHasFreq = true;\n                    }\n                  } else {\n                    postingsHasFreq = true;\n                  }\n                } else {\n                  postingsHasFreq = true;\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (hasFreqs) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasPositions || hasOffsets) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (pos != -1 && postingsPos != -1 && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      if (hasOffsets) {\n                        // Call the methods to at least make\n                        // sure they don't throw exc:\n                        final int startOffset = postings.startOffset();\n                        final int endOffset = postings.endOffset();\n                        // TODO: these are too anal...?\n                        /*\n                          if (endOffset < startOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                          }\n                          if (startOffset < lastStartOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                          }\n                          lastStartOffset = startOffset;\n                        */\n\n                        if (postingsPostings != null) {\n                          final int postingsStartOffset = postingsPostings.startOffset();\n\n                          final int postingsEndOffset = postingsPostings.endOffset();\n                          if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                          }\n                          if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format((((float) status.totVectors) / status.docCount)) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfo,SegmentReader,NumberFormat).mjava","sourceNew":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, null, false);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, null, false);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n                \n                final boolean hasPositions;\n                final boolean hasOffsets;\n                final boolean hasFreqs;\n\n                // TODO: really we need a reflection/query\n                // API so we can just ask what was indexed\n                // instead of \"probing\"...\n\n                // Try offsets:\n                postings = termsEnum.docsAndPositions(null, postings, true);\n                if (postings == null) {\n                  hasOffsets = false;\n                  // Try only positions:\n                  postings = termsEnum.docsAndPositions(null, postings, false);\n                  if (postings == null) {\n                    hasPositions = false;\n                    // Try docIDs & freqs:\n                    docs = termsEnum.docs(null, docs, true);\n                    if (docs == null) {\n                      // OK, only docIDs:\n                      hasFreqs = false;\n                      docs = termsEnum.docs(null, docs, false);\n                    } else {\n                      hasFreqs = true;\n                    }\n                  } else {\n                    hasPositions = true;\n                    hasFreqs = true;\n                  }\n                } else {\n                  hasOffsets = true;\n                  // NOTE: may be a lie... but we accept -1\n                  hasPositions = true;\n                  hasFreqs = true;\n                }\n\n                final DocsEnum docs2;\n                if (hasPositions || hasOffsets) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                final boolean postingsHasFreq;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, true);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ offsets but postings were not\n                  postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, false);\n                  if (postingsPostings == null) {\n                    postingsDocs = postingsTermsEnum.docs(null, postingsDocs, true);\n                    if (postingsDocs == null) {\n                      postingsHasFreq = false;\n                      postingsDocs = postingsTermsEnum.docs(null, postingsDocs, false);\n                      if (postingsDocs == null) {\n                        throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                      }\n                    } else {\n                      postingsHasFreq = true;\n                    }\n                  } else {\n                    postingsHasFreq = true;\n                  }\n                } else {\n                  postingsHasFreq = true;\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (hasFreqs) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasPositions || hasOffsets) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (pos != -1 && postingsPos != -1 && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      if (hasOffsets) {\n                        // Call the methods to at least make\n                        // sure they don't throw exc:\n                        final int startOffset = postings.startOffset();\n                        final int endOffset = postings.endOffset();\n                        // TODO: these are too anal...?\n                        /*\n                          if (endOffset < startOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                          }\n                          if (startOffset < lastStartOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                          }\n                          lastStartOffset = startOffset;\n                        */\n\n                        if (postingsPostings != null) {\n                          final int postingsStartOffset = postingsPostings.startOffset();\n\n                          final int postingsEndOffset = postingsPostings.endOffset();\n                          if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                          }\n                          if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format((((float) status.totVectors) / status.docCount)) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfo info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.docCount; ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, null);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, null);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.storeTermVector) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n                \n                final boolean hasPositions;\n                final boolean hasOffsets;\n                final boolean hasFreqs;\n\n                // TODO: really we need a reflection/query\n                // API so we can just ask what was indexed\n                // instead of \"probing\"...\n\n                // Try offsets:\n                postings = termsEnum.docsAndPositions(null, postings, true);\n                if (postings == null) {\n                  hasOffsets = false;\n                  // Try only positions:\n                  postings = termsEnum.docsAndPositions(null, postings, false);\n                  if (postings == null) {\n                    hasPositions = false;\n                    // Try docIDs & freqs:\n                    docs = termsEnum.docs(null, docs, true);\n                    if (docs == null) {\n                      // OK, only docIDs:\n                      hasFreqs = false;\n                      docs = termsEnum.docs(null, docs, false);\n                    } else {\n                      hasFreqs = true;\n                    }\n                  } else {\n                    hasPositions = true;\n                    hasFreqs = true;\n                  }\n                } else {\n                  hasOffsets = true;\n                  // NOTE: may be a lie... but we accept -1\n                  hasPositions = true;\n                  hasFreqs = true;\n                }\n\n                final DocsEnum docs2;\n                if (hasPositions || hasOffsets) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                final boolean postingsHasFreq;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, true);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ offsets but postings were not\n                  postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, false);\n                  if (postingsPostings == null) {\n                    postingsDocs = postingsTermsEnum.docs(null, postingsDocs, true);\n                    if (postingsDocs == null) {\n                      postingsHasFreq = false;\n                      postingsDocs = postingsTermsEnum.docs(null, postingsDocs, false);\n                      if (postingsDocs == null) {\n                        throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                      }\n                    } else {\n                      postingsHasFreq = true;\n                    }\n                  } else {\n                    postingsHasFreq = true;\n                  }\n                } else {\n                  postingsHasFreq = true;\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (hasFreqs) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasPositions || hasOffsets) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (pos != -1 && postingsPos != -1 && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      if (hasOffsets) {\n                        // Call the methods to at least make\n                        // sure they don't throw exc:\n                        final int startOffset = postings.startOffset();\n                        final int endOffset = postings.endOffset();\n                        // TODO: these are too anal...?\n                        /*\n                          if (endOffset < startOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                          }\n                          if (startOffset < lastStartOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                          }\n                          lastStartOffset = startOffset;\n                        */\n\n                        if (postingsPostings != null) {\n                          final int postingsStartOffset = postingsPostings.startOffset();\n\n                          final int postingsEndOffset = postingsPostings.endOffset();\n                          if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                          }\n                          if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format((((float) status.totVectors) / status.docCount)) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f0b2a0f7efff91a413da6cc75c82ef07af7baba4","date":1338485531,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","sourceNew":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n                \n                final boolean hasPositions;\n                final boolean hasOffsets;\n                final boolean hasFreqs;\n\n                // TODO: really we need a reflection/query\n                // API so we can just ask what was indexed\n                // instead of \"probing\"...\n\n                // Try offsets:\n                postings = termsEnum.docsAndPositions(null, postings, true);\n                if (postings == null) {\n                  hasOffsets = false;\n                  // Try only positions:\n                  postings = termsEnum.docsAndPositions(null, postings, false);\n                  if (postings == null) {\n                    hasPositions = false;\n                    // Try docIDs & freqs:\n                    docs = termsEnum.docs(null, docs, true);\n                    if (docs == null) {\n                      // OK, only docIDs:\n                      hasFreqs = false;\n                      docs = termsEnum.docs(null, docs, false);\n                    } else {\n                      hasFreqs = true;\n                    }\n                  } else {\n                    hasPositions = true;\n                    hasFreqs = true;\n                  }\n                } else {\n                  hasOffsets = true;\n                  // NOTE: may be a lie... but we accept -1\n                  hasPositions = true;\n                  hasFreqs = true;\n                }\n\n                final DocsEnum docs2;\n                if (hasPositions || hasOffsets) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                final boolean postingsHasFreq;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, true);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ offsets but postings were not\n                  postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, false);\n                  if (postingsPostings == null) {\n                    postingsDocs = postingsTermsEnum.docs(null, postingsDocs, true);\n                    if (postingsDocs == null) {\n                      postingsHasFreq = false;\n                      postingsDocs = postingsTermsEnum.docs(null, postingsDocs, false);\n                      if (postingsDocs == null) {\n                        throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                      }\n                    } else {\n                      postingsHasFreq = true;\n                    }\n                  } else {\n                    postingsHasFreq = true;\n                  }\n                } else {\n                  postingsHasFreq = true;\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (hasFreqs) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasPositions || hasOffsets) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (pos != -1 && postingsPos != -1 && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      if (hasOffsets) {\n                        // Call the methods to at least make\n                        // sure they don't throw exc:\n                        final int startOffset = postings.startOffset();\n                        final int endOffset = postings.endOffset();\n                        // TODO: these are too anal...?\n                        /*\n                          if (endOffset < startOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                          }\n                          if (startOffset < lastStartOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                          }\n                          lastStartOffset = startOffset;\n                        */\n\n                        if (postingsPostings != null) {\n                          final int postingsStartOffset = postingsPostings.startOffset();\n\n                          final int postingsEndOffset = postingsPostings.endOffset();\n                          if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                          }\n                          if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format((((float) status.totVectors) / status.docCount)) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, null, false);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, null, false);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n                \n                final boolean hasPositions;\n                final boolean hasOffsets;\n                final boolean hasFreqs;\n\n                // TODO: really we need a reflection/query\n                // API so we can just ask what was indexed\n                // instead of \"probing\"...\n\n                // Try offsets:\n                postings = termsEnum.docsAndPositions(null, postings, true);\n                if (postings == null) {\n                  hasOffsets = false;\n                  // Try only positions:\n                  postings = termsEnum.docsAndPositions(null, postings, false);\n                  if (postings == null) {\n                    hasPositions = false;\n                    // Try docIDs & freqs:\n                    docs = termsEnum.docs(null, docs, true);\n                    if (docs == null) {\n                      // OK, only docIDs:\n                      hasFreqs = false;\n                      docs = termsEnum.docs(null, docs, false);\n                    } else {\n                      hasFreqs = true;\n                    }\n                  } else {\n                    hasPositions = true;\n                    hasFreqs = true;\n                  }\n                } else {\n                  hasOffsets = true;\n                  // NOTE: may be a lie... but we accept -1\n                  hasPositions = true;\n                  hasFreqs = true;\n                }\n\n                final DocsEnum docs2;\n                if (hasPositions || hasOffsets) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                final boolean postingsHasFreq;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, true);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ offsets but postings were not\n                  postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, false);\n                  if (postingsPostings == null) {\n                    postingsDocs = postingsTermsEnum.docs(null, postingsDocs, true);\n                    if (postingsDocs == null) {\n                      postingsHasFreq = false;\n                      postingsDocs = postingsTermsEnum.docs(null, postingsDocs, false);\n                      if (postingsDocs == null) {\n                        throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                      }\n                    } else {\n                      postingsHasFreq = true;\n                    }\n                  } else {\n                    postingsHasFreq = true;\n                  }\n                } else {\n                  postingsHasFreq = true;\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (hasFreqs) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasPositions || hasOffsets) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (pos != -1 && postingsPos != -1 && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      if (hasOffsets) {\n                        // Call the methods to at least make\n                        // sure they don't throw exc:\n                        final int startOffset = postings.startOffset();\n                        final int endOffset = postings.endOffset();\n                        // TODO: these are too anal...?\n                        /*\n                          if (endOffset < startOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                          }\n                          if (startOffset < lastStartOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                          }\n                          lastStartOffset = startOffset;\n                        */\n\n                        if (postingsPostings != null) {\n                          final int postingsStartOffset = postingsPostings.startOffset();\n\n                          final int postingsEndOffset = postingsPostings.endOffset();\n                          if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                          }\n                          if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format((((float) status.totVectors) / status.docCount)) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","bugFix":null,"bugIntro":["138923418367b4cadabaadb48c45f03a96cfde8b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"138923418367b4cadabaadb48c45f03a96cfde8b","date":1342359927,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","sourceNew":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false, true);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, true);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n                \n                final boolean hasPositions;\n                final boolean hasOffsets;\n                final boolean hasFreqs;\n\n                // TODO: really we need a reflection/query\n                // API so we can just ask what was indexed\n                // instead of \"probing\"...\n\n                // Try offsets:\n                postings = termsEnum.docsAndPositions(null, postings, true);\n                if (postings == null) {\n                  hasOffsets = false;\n                  // Try only positions:\n                  postings = termsEnum.docsAndPositions(null, postings, false);\n                  if (postings == null) {\n                    hasPositions = false;\n                    // Try docIDs & freqs:\n                    docs = termsEnum.docs(null, docs, true);\n                    if (docs == null) {\n                      // OK, only docIDs:\n                      hasFreqs = false;\n                      docs = termsEnum.docs(null, docs, false);\n                    } else {\n                      hasFreqs = true;\n                    }\n                  } else {\n                    hasPositions = true;\n                    hasFreqs = true;\n                  }\n                } else {\n                  hasOffsets = true;\n                  // NOTE: may be a lie... but we accept -1\n                  hasPositions = true;\n                  hasFreqs = true;\n                }\n\n                final DocsEnum docs2;\n                if (hasPositions || hasOffsets) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                final boolean postingsHasFreq;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, true);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ offsets but postings were not\n                  postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, false);\n                  if (postingsPostings == null) {\n                    postingsDocs = postingsTermsEnum.docs(null, postingsDocs, true);\n                    if (postingsDocs == null) {\n                      postingsHasFreq = false;\n                      postingsDocs = postingsTermsEnum.docs(null, postingsDocs, false);\n                      if (postingsDocs == null) {\n                        throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                      }\n                    } else {\n                      postingsHasFreq = true;\n                    }\n                  } else {\n                    postingsHasFreq = true;\n                  }\n                } else {\n                  postingsHasFreq = true;\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (hasFreqs) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasPositions || hasOffsets) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (pos != -1 && postingsPos != -1 && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      if (hasOffsets) {\n                        // Call the methods to at least make\n                        // sure they don't throw exc:\n                        final int startOffset = postings.startOffset();\n                        final int endOffset = postings.endOffset();\n                        // TODO: these are too anal...?\n                        /*\n                          if (endOffset < startOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                          }\n                          if (startOffset < lastStartOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                          }\n                          lastStartOffset = startOffset;\n                        */\n\n                        if (postingsPostings != null) {\n                          final int postingsStartOffset = postingsPostings.startOffset();\n\n                          final int postingsEndOffset = postingsPostings.endOffset();\n                          if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                          }\n                          if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format((((float) status.totVectors) / status.docCount)) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n                \n                final boolean hasPositions;\n                final boolean hasOffsets;\n                final boolean hasFreqs;\n\n                // TODO: really we need a reflection/query\n                // API so we can just ask what was indexed\n                // instead of \"probing\"...\n\n                // Try offsets:\n                postings = termsEnum.docsAndPositions(null, postings, true);\n                if (postings == null) {\n                  hasOffsets = false;\n                  // Try only positions:\n                  postings = termsEnum.docsAndPositions(null, postings, false);\n                  if (postings == null) {\n                    hasPositions = false;\n                    // Try docIDs & freqs:\n                    docs = termsEnum.docs(null, docs, true);\n                    if (docs == null) {\n                      // OK, only docIDs:\n                      hasFreqs = false;\n                      docs = termsEnum.docs(null, docs, false);\n                    } else {\n                      hasFreqs = true;\n                    }\n                  } else {\n                    hasPositions = true;\n                    hasFreqs = true;\n                  }\n                } else {\n                  hasOffsets = true;\n                  // NOTE: may be a lie... but we accept -1\n                  hasPositions = true;\n                  hasFreqs = true;\n                }\n\n                final DocsEnum docs2;\n                if (hasPositions || hasOffsets) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                final boolean postingsHasFreq;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, true);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ offsets but postings were not\n                  postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, false);\n                  if (postingsPostings == null) {\n                    postingsDocs = postingsTermsEnum.docs(null, postingsDocs, true);\n                    if (postingsDocs == null) {\n                      postingsHasFreq = false;\n                      postingsDocs = postingsTermsEnum.docs(null, postingsDocs, false);\n                      if (postingsDocs == null) {\n                        throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                      }\n                    } else {\n                      postingsHasFreq = true;\n                    }\n                  } else {\n                    postingsHasFreq = true;\n                  }\n                } else {\n                  postingsHasFreq = true;\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (hasFreqs) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasPositions || hasOffsets) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (pos != -1 && postingsPos != -1 && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      if (hasOffsets) {\n                        // Call the methods to at least make\n                        // sure they don't throw exc:\n                        final int startOffset = postings.startOffset();\n                        final int endOffset = postings.endOffset();\n                        // TODO: these are too anal...?\n                        /*\n                          if (endOffset < startOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                          }\n                          if (startOffset < lastStartOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                          }\n                          lastStartOffset = startOffset;\n                        */\n\n                        if (postingsPostings != null) {\n                          final int postingsStartOffset = postingsPostings.startOffset();\n\n                          final int postingsEndOffset = postingsPostings.endOffset();\n                          if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                          }\n                          if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format((((float) status.totVectors) / status.docCount)) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","bugFix":["f0b2a0f7efff91a413da6cc75c82ef07af7baba4"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c638f0552fb6cb9ef3566f1eb38953ce86ee2fa3","date":1342711272,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","sourceNew":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false, true);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, true);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n                \n                final boolean hasPositions;\n                final boolean hasOffsets;\n                final boolean hasFreqs;\n\n                // TODO: really we need a reflection/query\n                // API so we can just ask what was indexed\n                // instead of \"probing\"...\n\n                // Try offsets:\n                postings = termsEnum.docsAndPositions(null, postings, true);\n                if (postings == null) {\n                  hasOffsets = false;\n                  // Try only positions:\n                  postings = termsEnum.docsAndPositions(null, postings, false);\n                  if (postings == null) {\n                    hasPositions = false;\n                    // Try docIDs & freqs:\n                    docs = termsEnum.docs(null, docs, true);\n                    if (docs == null) {\n                      // OK, only docIDs:\n                      hasFreqs = false;\n                      docs = termsEnum.docs(null, docs, false);\n                    } else {\n                      hasFreqs = true;\n                    }\n                  } else {\n                    hasPositions = true;\n                    hasFreqs = true;\n                  }\n                } else {\n                  hasOffsets = true;\n                  // NOTE: may be a lie... but we accept -1\n                  hasPositions = true;\n                  hasFreqs = true;\n                }\n\n                final DocsEnum docs2;\n                if (hasPositions || hasOffsets) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                final boolean postingsHasFreq;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, true);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ offsets but postings were not\n                  postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, false);\n                  if (postingsPostings == null) {\n                    postingsDocs = postingsTermsEnum.docs(null, postingsDocs, true);\n                    if (postingsDocs == null) {\n                      postingsHasFreq = false;\n                      postingsDocs = postingsTermsEnum.docs(null, postingsDocs, false);\n                      if (postingsDocs == null) {\n                        throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                      }\n                    } else {\n                      postingsHasFreq = true;\n                    }\n                  } else {\n                    postingsHasFreq = true;\n                  }\n                } else {\n                  postingsHasFreq = true;\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (hasFreqs) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasPositions || hasOffsets) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (pos != -1 && postingsPos != -1 && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      if (hasOffsets) {\n                        // Call the methods to at least make\n                        // sure they don't throw exc:\n                        final int startOffset = postings.startOffset();\n                        final int endOffset = postings.endOffset();\n                        // TODO: these are too anal...?\n                        /*\n                          if (endOffset < startOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                          }\n                          if (startOffset < lastStartOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                          }\n                          lastStartOffset = startOffset;\n                        */\n\n                        if (postingsPostings != null) {\n                          final int postingsStartOffset = postingsPostings.startOffset();\n\n                          final int postingsEndOffset = postingsPostings.endOffset();\n                          if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                          }\n                          if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      float vectorAvg = status.docCount == 0 ? 0 : status.totVectors / (float)status.docCount;\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format(vectorAvg) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false, true);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, true);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n                \n                final boolean hasPositions;\n                final boolean hasOffsets;\n                final boolean hasFreqs;\n\n                // TODO: really we need a reflection/query\n                // API so we can just ask what was indexed\n                // instead of \"probing\"...\n\n                // Try offsets:\n                postings = termsEnum.docsAndPositions(null, postings, true);\n                if (postings == null) {\n                  hasOffsets = false;\n                  // Try only positions:\n                  postings = termsEnum.docsAndPositions(null, postings, false);\n                  if (postings == null) {\n                    hasPositions = false;\n                    // Try docIDs & freqs:\n                    docs = termsEnum.docs(null, docs, true);\n                    if (docs == null) {\n                      // OK, only docIDs:\n                      hasFreqs = false;\n                      docs = termsEnum.docs(null, docs, false);\n                    } else {\n                      hasFreqs = true;\n                    }\n                  } else {\n                    hasPositions = true;\n                    hasFreqs = true;\n                  }\n                } else {\n                  hasOffsets = true;\n                  // NOTE: may be a lie... but we accept -1\n                  hasPositions = true;\n                  hasFreqs = true;\n                }\n\n                final DocsEnum docs2;\n                if (hasPositions || hasOffsets) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                final boolean postingsHasFreq;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, true);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ offsets but postings were not\n                  postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, false);\n                  if (postingsPostings == null) {\n                    postingsDocs = postingsTermsEnum.docs(null, postingsDocs, true);\n                    if (postingsDocs == null) {\n                      postingsHasFreq = false;\n                      postingsDocs = postingsTermsEnum.docs(null, postingsDocs, false);\n                      if (postingsDocs == null) {\n                        throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                      }\n                    } else {\n                      postingsHasFreq = true;\n                    }\n                  } else {\n                    postingsHasFreq = true;\n                  }\n                } else {\n                  postingsHasFreq = true;\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (hasFreqs) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasPositions || hasOffsets) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (pos != -1 && postingsPos != -1 && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      if (hasOffsets) {\n                        // Call the methods to at least make\n                        // sure they don't throw exc:\n                        final int startOffset = postings.startOffset();\n                        final int endOffset = postings.endOffset();\n                        // TODO: these are too anal...?\n                        /*\n                          if (endOffset < startOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                          }\n                          if (startOffset < lastStartOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                          }\n                          lastStartOffset = startOffset;\n                        */\n\n                        if (postingsPostings != null) {\n                          final int postingsStartOffset = postingsPostings.startOffset();\n\n                          final int postingsEndOffset = postingsPostings.endOffset();\n                          if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                          }\n                          if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format((((float) status.totVectors) / status.docCount)) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","sourceNew":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false, true);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, true);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n                \n                final boolean hasPositions;\n                final boolean hasOffsets;\n                final boolean hasFreqs;\n\n                // TODO: really we need a reflection/query\n                // API so we can just ask what was indexed\n                // instead of \"probing\"...\n\n                // Try offsets:\n                postings = termsEnum.docsAndPositions(null, postings, true);\n                if (postings == null) {\n                  hasOffsets = false;\n                  // Try only positions:\n                  postings = termsEnum.docsAndPositions(null, postings, false);\n                  if (postings == null) {\n                    hasPositions = false;\n                    // Try docIDs & freqs:\n                    docs = termsEnum.docs(null, docs, true);\n                    if (docs == null) {\n                      // OK, only docIDs:\n                      hasFreqs = false;\n                      docs = termsEnum.docs(null, docs, false);\n                    } else {\n                      hasFreqs = true;\n                    }\n                  } else {\n                    hasPositions = true;\n                    hasFreqs = true;\n                  }\n                } else {\n                  hasOffsets = true;\n                  // NOTE: may be a lie... but we accept -1\n                  hasPositions = true;\n                  hasFreqs = true;\n                }\n\n                final DocsEnum docs2;\n                if (hasPositions || hasOffsets) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                final boolean postingsHasFreq;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, true);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ offsets but postings were not\n                  postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, false);\n                  if (postingsPostings == null) {\n                    postingsDocs = postingsTermsEnum.docs(null, postingsDocs, true);\n                    if (postingsDocs == null) {\n                      postingsHasFreq = false;\n                      postingsDocs = postingsTermsEnum.docs(null, postingsDocs, false);\n                      if (postingsDocs == null) {\n                        throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                      }\n                    } else {\n                      postingsHasFreq = true;\n                    }\n                  } else {\n                    postingsHasFreq = true;\n                  }\n                } else {\n                  postingsHasFreq = true;\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (hasFreqs) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasPositions || hasOffsets) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (pos != -1 && postingsPos != -1 && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      if (hasOffsets) {\n                        // Call the methods to at least make\n                        // sure they don't throw exc:\n                        final int startOffset = postings.startOffset();\n                        final int endOffset = postings.endOffset();\n                        // TODO: these are too anal...?\n                        /*\n                          if (endOffset < startOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                          }\n                          if (startOffset < lastStartOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                          }\n                          lastStartOffset = startOffset;\n                        */\n\n                        if (postingsPostings != null) {\n                          final int postingsStartOffset = postingsPostings.startOffset();\n\n                          final int postingsEndOffset = postingsPostings.endOffset();\n                          if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                          }\n                          if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format((((float) status.totVectors) / status.docCount)) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n                \n                final boolean hasPositions;\n                final boolean hasOffsets;\n                final boolean hasFreqs;\n\n                // TODO: really we need a reflection/query\n                // API so we can just ask what was indexed\n                // instead of \"probing\"...\n\n                // Try offsets:\n                postings = termsEnum.docsAndPositions(null, postings, true);\n                if (postings == null) {\n                  hasOffsets = false;\n                  // Try only positions:\n                  postings = termsEnum.docsAndPositions(null, postings, false);\n                  if (postings == null) {\n                    hasPositions = false;\n                    // Try docIDs & freqs:\n                    docs = termsEnum.docs(null, docs, true);\n                    if (docs == null) {\n                      // OK, only docIDs:\n                      hasFreqs = false;\n                      docs = termsEnum.docs(null, docs, false);\n                    } else {\n                      hasFreqs = true;\n                    }\n                  } else {\n                    hasPositions = true;\n                    hasFreqs = true;\n                  }\n                } else {\n                  hasOffsets = true;\n                  // NOTE: may be a lie... but we accept -1\n                  hasPositions = true;\n                  hasFreqs = true;\n                }\n\n                final DocsEnum docs2;\n                if (hasPositions || hasOffsets) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                final boolean postingsHasFreq;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, true);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ offsets but postings were not\n                  postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, false);\n                  if (postingsPostings == null) {\n                    postingsDocs = postingsTermsEnum.docs(null, postingsDocs, true);\n                    if (postingsDocs == null) {\n                      postingsHasFreq = false;\n                      postingsDocs = postingsTermsEnum.docs(null, postingsDocs, false);\n                      if (postingsDocs == null) {\n                        throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                      }\n                    } else {\n                      postingsHasFreq = true;\n                    }\n                  } else {\n                    postingsHasFreq = true;\n                  }\n                } else {\n                  postingsHasFreq = true;\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (hasFreqs) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasPositions || hasOffsets) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (pos != -1 && postingsPos != -1 && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      if (hasOffsets) {\n                        // Call the methods to at least make\n                        // sure they don't throw exc:\n                        final int startOffset = postings.startOffset();\n                        final int endOffset = postings.endOffset();\n                        // TODO: these are too anal...?\n                        /*\n                          if (endOffset < startOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                          }\n                          if (startOffset < lastStartOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                          }\n                          lastStartOffset = startOffset;\n                        */\n\n                        if (postingsPostings != null) {\n                          final int postingsStartOffset = postingsPostings.startOffset();\n\n                          final int postingsEndOffset = postingsPostings.endOffset();\n                          if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                          }\n                          if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format((((float) status.totVectors) / status.docCount)) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","date":1343059585,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","sourceNew":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false, true);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, true);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n                \n                final boolean hasPositions;\n                final boolean hasOffsets;\n                final boolean hasFreqs;\n\n                // TODO: really we need a reflection/query\n                // API so we can just ask what was indexed\n                // instead of \"probing\"...\n\n                // Try offsets:\n                postings = termsEnum.docsAndPositions(null, postings, true);\n                if (postings == null) {\n                  hasOffsets = false;\n                  // Try only positions:\n                  postings = termsEnum.docsAndPositions(null, postings, false);\n                  if (postings == null) {\n                    hasPositions = false;\n                    // Try docIDs & freqs:\n                    docs = termsEnum.docs(null, docs, true);\n                    if (docs == null) {\n                      // OK, only docIDs:\n                      hasFreqs = false;\n                      docs = termsEnum.docs(null, docs, false);\n                    } else {\n                      hasFreqs = true;\n                    }\n                  } else {\n                    hasPositions = true;\n                    hasFreqs = true;\n                  }\n                } else {\n                  hasOffsets = true;\n                  // NOTE: may be a lie... but we accept -1\n                  hasPositions = true;\n                  hasFreqs = true;\n                }\n\n                final DocsEnum docs2;\n                if (hasPositions || hasOffsets) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                final boolean postingsHasFreq;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, true);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ offsets but postings were not\n                  postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, false);\n                  if (postingsPostings == null) {\n                    postingsDocs = postingsTermsEnum.docs(null, postingsDocs, true);\n                    if (postingsDocs == null) {\n                      postingsHasFreq = false;\n                      postingsDocs = postingsTermsEnum.docs(null, postingsDocs, false);\n                      if (postingsDocs == null) {\n                        throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                      }\n                    } else {\n                      postingsHasFreq = true;\n                    }\n                  } else {\n                    postingsHasFreq = true;\n                  }\n                } else {\n                  postingsHasFreq = true;\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (hasFreqs) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasPositions || hasOffsets) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (pos != -1 && postingsPos != -1 && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      if (hasOffsets) {\n                        // Call the methods to at least make\n                        // sure they don't throw exc:\n                        final int startOffset = postings.startOffset();\n                        final int endOffset = postings.endOffset();\n                        // TODO: these are too anal...?\n                        /*\n                          if (endOffset < startOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                          }\n                          if (startOffset < lastStartOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                          }\n                          lastStartOffset = startOffset;\n                        */\n\n                        if (postingsPostings != null) {\n                          final int postingsStartOffset = postingsPostings.startOffset();\n\n                          final int postingsEndOffset = postingsPostings.endOffset();\n                          if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                          }\n                          if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      float vectorAvg = status.docCount == 0 ? 0 : status.totVectors / (float)status.docCount;\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format(vectorAvg) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false, true);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, true);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n                \n                final boolean hasPositions;\n                final boolean hasOffsets;\n                final boolean hasFreqs;\n\n                // TODO: really we need a reflection/query\n                // API so we can just ask what was indexed\n                // instead of \"probing\"...\n\n                // Try offsets:\n                postings = termsEnum.docsAndPositions(null, postings, true);\n                if (postings == null) {\n                  hasOffsets = false;\n                  // Try only positions:\n                  postings = termsEnum.docsAndPositions(null, postings, false);\n                  if (postings == null) {\n                    hasPositions = false;\n                    // Try docIDs & freqs:\n                    docs = termsEnum.docs(null, docs, true);\n                    if (docs == null) {\n                      // OK, only docIDs:\n                      hasFreqs = false;\n                      docs = termsEnum.docs(null, docs, false);\n                    } else {\n                      hasFreqs = true;\n                    }\n                  } else {\n                    hasPositions = true;\n                    hasFreqs = true;\n                  }\n                } else {\n                  hasOffsets = true;\n                  // NOTE: may be a lie... but we accept -1\n                  hasPositions = true;\n                  hasFreqs = true;\n                }\n\n                final DocsEnum docs2;\n                if (hasPositions || hasOffsets) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                final boolean postingsHasFreq;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, true);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ offsets but postings were not\n                  postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, false);\n                  if (postingsPostings == null) {\n                    postingsDocs = postingsTermsEnum.docs(null, postingsDocs, true);\n                    if (postingsDocs == null) {\n                      postingsHasFreq = false;\n                      postingsDocs = postingsTermsEnum.docs(null, postingsDocs, false);\n                      if (postingsDocs == null) {\n                        throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                      }\n                    } else {\n                      postingsHasFreq = true;\n                    }\n                  } else {\n                    postingsHasFreq = true;\n                  }\n                } else {\n                  postingsHasFreq = true;\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (hasFreqs) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasPositions || hasOffsets) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (pos != -1 && postingsPos != -1 && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      if (hasOffsets) {\n                        // Call the methods to at least make\n                        // sure they don't throw exc:\n                        final int startOffset = postings.startOffset();\n                        final int endOffset = postings.endOffset();\n                        // TODO: these are too anal...?\n                        /*\n                          if (endOffset < startOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                          }\n                          if (startOffset < lastStartOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                          }\n                          lastStartOffset = startOffset;\n                        */\n\n                        if (postingsPostings != null) {\n                          final int postingsStartOffset = postingsPostings.startOffset();\n\n                          final int postingsEndOffset = postingsPostings.endOffset();\n                          if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                          }\n                          if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format((((float) status.totVectors) / status.docCount)) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","sourceNew":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false, true);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, true);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n                \n                final boolean hasPositions;\n                final boolean hasOffsets;\n                final boolean hasFreqs;\n\n                // TODO: really we need a reflection/query\n                // API so we can just ask what was indexed\n                // instead of \"probing\"...\n\n                // Try offsets:\n                postings = termsEnum.docsAndPositions(null, postings, true);\n                if (postings == null) {\n                  hasOffsets = false;\n                  // Try only positions:\n                  postings = termsEnum.docsAndPositions(null, postings, false);\n                  if (postings == null) {\n                    hasPositions = false;\n                    // Try docIDs & freqs:\n                    docs = termsEnum.docs(null, docs, true);\n                    if (docs == null) {\n                      // OK, only docIDs:\n                      hasFreqs = false;\n                      docs = termsEnum.docs(null, docs, false);\n                    } else {\n                      hasFreqs = true;\n                    }\n                  } else {\n                    hasPositions = true;\n                    hasFreqs = true;\n                  }\n                } else {\n                  hasOffsets = true;\n                  // NOTE: may be a lie... but we accept -1\n                  hasPositions = true;\n                  hasFreqs = true;\n                }\n\n                final DocsEnum docs2;\n                if (hasPositions || hasOffsets) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                final boolean postingsHasFreq;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, true);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ offsets but postings were not\n                  postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, false);\n                  if (postingsPostings == null) {\n                    postingsDocs = postingsTermsEnum.docs(null, postingsDocs, true);\n                    if (postingsDocs == null) {\n                      postingsHasFreq = false;\n                      postingsDocs = postingsTermsEnum.docs(null, postingsDocs, false);\n                      if (postingsDocs == null) {\n                        throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                      }\n                    } else {\n                      postingsHasFreq = true;\n                    }\n                  } else {\n                    postingsHasFreq = true;\n                  }\n                } else {\n                  postingsHasFreq = true;\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (hasFreqs) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasPositions || hasOffsets) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (pos != -1 && postingsPos != -1 && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      if (hasOffsets) {\n                        // Call the methods to at least make\n                        // sure they don't throw exc:\n                        final int startOffset = postings.startOffset();\n                        final int endOffset = postings.endOffset();\n                        // TODO: these are too anal...?\n                        /*\n                          if (endOffset < startOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                          }\n                          if (startOffset < lastStartOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                          }\n                          lastStartOffset = startOffset;\n                        */\n\n                        if (postingsPostings != null) {\n                          final int postingsStartOffset = postingsPostings.startOffset();\n\n                          final int postingsEndOffset = postingsPostings.endOffset();\n                          if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                          }\n                          if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      float vectorAvg = status.docCount == 0 ? 0 : status.totVectors / (float)status.docCount;\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format(vectorAvg) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n                \n                final boolean hasPositions;\n                final boolean hasOffsets;\n                final boolean hasFreqs;\n\n                // TODO: really we need a reflection/query\n                // API so we can just ask what was indexed\n                // instead of \"probing\"...\n\n                // Try offsets:\n                postings = termsEnum.docsAndPositions(null, postings, true);\n                if (postings == null) {\n                  hasOffsets = false;\n                  // Try only positions:\n                  postings = termsEnum.docsAndPositions(null, postings, false);\n                  if (postings == null) {\n                    hasPositions = false;\n                    // Try docIDs & freqs:\n                    docs = termsEnum.docs(null, docs, true);\n                    if (docs == null) {\n                      // OK, only docIDs:\n                      hasFreqs = false;\n                      docs = termsEnum.docs(null, docs, false);\n                    } else {\n                      hasFreqs = true;\n                    }\n                  } else {\n                    hasPositions = true;\n                    hasFreqs = true;\n                  }\n                } else {\n                  hasOffsets = true;\n                  // NOTE: may be a lie... but we accept -1\n                  hasPositions = true;\n                  hasFreqs = true;\n                }\n\n                final DocsEnum docs2;\n                if (hasPositions || hasOffsets) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                final boolean postingsHasFreq;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, true);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ offsets but postings were not\n                  postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, false);\n                  if (postingsPostings == null) {\n                    postingsDocs = postingsTermsEnum.docs(null, postingsDocs, true);\n                    if (postingsDocs == null) {\n                      postingsHasFreq = false;\n                      postingsDocs = postingsTermsEnum.docs(null, postingsDocs, false);\n                      if (postingsDocs == null) {\n                        throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                      }\n                    } else {\n                      postingsHasFreq = true;\n                    }\n                  } else {\n                    postingsHasFreq = true;\n                  }\n                } else {\n                  postingsHasFreq = true;\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (hasFreqs) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasPositions || hasOffsets) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (pos != -1 && postingsPos != -1 && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      if (hasOffsets) {\n                        // Call the methods to at least make\n                        // sure they don't throw exc:\n                        final int startOffset = postings.startOffset();\n                        final int endOffset = postings.endOffset();\n                        // TODO: these are too anal...?\n                        /*\n                          if (endOffset < startOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                          }\n                          if (startOffset < lastStartOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                          }\n                          lastStartOffset = startOffset;\n                        */\n\n                        if (postingsPostings != null) {\n                          final int postingsStartOffset = postingsPostings.startOffset();\n\n                          final int postingsEndOffset = postingsPostings.endOffset();\n                          if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                          }\n                          if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format((((float) status.totVectors) / status.docCount)) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"322360ac5185a8446d3e0b530b2068bef67cd3d5","date":1343669494,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","sourceNew":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false, true);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, true);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n                \n                final boolean hasProx;\n                final boolean hasFreqs;\n\n                // TODO: really we need a reflection/query\n                // API so we can just ask what was indexed\n                // instead of \"probing\"...\n\n                // TODO: cleanup:\n\n                // Try offsets:\n                postings = termsEnum.docsAndPositions(null, postings);\n                if (postings == null) {\n                  hasProx = false;\n                  // Try docIDs & freqs:\n                  docs = termsEnum.docs(null, docs, true);\n                  if (docs == null) {\n                    // OK, only docIDs:\n                    hasFreqs = false;\n                    docs = termsEnum.docs(null, docs, false);\n                  } else {\n                      hasFreqs = true;\n                  }\n                } else {\n                  hasProx = true;\n                  hasFreqs = true;\n                }\n\n                final DocsEnum docs2;\n                if (hasProx) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                final boolean postingsHasFreq;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ pos but postings were not\n                  postingsDocs = postingsTermsEnum.docs(null, postingsDocs, true);\n                  if (postingsDocs == null) {\n                    postingsHasFreq = false;\n                    postingsDocs = postingsTermsEnum.docs(null, postingsDocs, false);\n                    if (postingsDocs == null) {\n                      throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                    }\n                  } else {\n                      postingsHasFreq = true;\n                  }\n                } else {\n                  postingsHasFreq = true;\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (hasFreqs) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasProx) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (pos != -1 && postingsPos != -1 && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      // Call the methods to at least make\n                      // sure they don't throw exc:\n                      final int startOffset = postings.startOffset();\n                      final int endOffset = postings.endOffset();\n                      // TODO: these are too anal...?\n                      /*\n                        if (endOffset < startOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                        }\n                        if (startOffset < lastStartOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                        }\n                        lastStartOffset = startOffset;\n                      */\n\n                      if (postingsPostings != null) {\n                        final int postingsStartOffset = postingsPostings.startOffset();\n\n                        final int postingsEndOffset = postingsPostings.endOffset();\n                        if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                        }\n                        if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      float vectorAvg = status.docCount == 0 ? 0 : status.totVectors / (float)status.docCount;\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format(vectorAvg) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false, true);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, true);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n                \n                final boolean hasPositions;\n                final boolean hasOffsets;\n                final boolean hasFreqs;\n\n                // TODO: really we need a reflection/query\n                // API so we can just ask what was indexed\n                // instead of \"probing\"...\n\n                // Try offsets:\n                postings = termsEnum.docsAndPositions(null, postings, true);\n                if (postings == null) {\n                  hasOffsets = false;\n                  // Try only positions:\n                  postings = termsEnum.docsAndPositions(null, postings, false);\n                  if (postings == null) {\n                    hasPositions = false;\n                    // Try docIDs & freqs:\n                    docs = termsEnum.docs(null, docs, true);\n                    if (docs == null) {\n                      // OK, only docIDs:\n                      hasFreqs = false;\n                      docs = termsEnum.docs(null, docs, false);\n                    } else {\n                      hasFreqs = true;\n                    }\n                  } else {\n                    hasPositions = true;\n                    hasFreqs = true;\n                  }\n                } else {\n                  hasOffsets = true;\n                  // NOTE: may be a lie... but we accept -1\n                  hasPositions = true;\n                  hasFreqs = true;\n                }\n\n                final DocsEnum docs2;\n                if (hasPositions || hasOffsets) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                final boolean postingsHasFreq;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, true);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ offsets but postings were not\n                  postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, false);\n                  if (postingsPostings == null) {\n                    postingsDocs = postingsTermsEnum.docs(null, postingsDocs, true);\n                    if (postingsDocs == null) {\n                      postingsHasFreq = false;\n                      postingsDocs = postingsTermsEnum.docs(null, postingsDocs, false);\n                      if (postingsDocs == null) {\n                        throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                      }\n                    } else {\n                      postingsHasFreq = true;\n                    }\n                  } else {\n                    postingsHasFreq = true;\n                  }\n                } else {\n                  postingsHasFreq = true;\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (hasFreqs) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasPositions || hasOffsets) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (pos != -1 && postingsPos != -1 && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      if (hasOffsets) {\n                        // Call the methods to at least make\n                        // sure they don't throw exc:\n                        final int startOffset = postings.startOffset();\n                        final int endOffset = postings.endOffset();\n                        // TODO: these are too anal...?\n                        /*\n                          if (endOffset < startOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                          }\n                          if (startOffset < lastStartOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                          }\n                          lastStartOffset = startOffset;\n                        */\n\n                        if (postingsPostings != null) {\n                          final int postingsStartOffset = postingsPostings.startOffset();\n\n                          final int postingsEndOffset = postingsPostings.endOffset();\n                          if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                          }\n                          if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      float vectorAvg = status.docCount == 0 ? 0 : status.totVectors / (float)status.docCount;\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format(vectorAvg) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","bugFix":null,"bugIntro":["5699a2da08aaf5a165f2ceefe7cf8f5c70a12efc","02331260bb246364779cb6f04919ca47900d01bb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"02331260bb246364779cb6f04919ca47900d01bb","date":1343749884,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","sourceNew":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false, true);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, true);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n              final boolean postingsHasFreq = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n                \n                final boolean hasProx;\n\n                // Try positions:\n                postings = termsEnum.docsAndPositions(null, postings);\n                if (postings == null) {\n                  hasProx = false;\n                  // Try docIDs & freqs:\n                  docs = termsEnum.docs(null, docs);\n                } else {\n                  hasProx = true;\n                }\n\n                final DocsEnum docs2;\n                if (hasProx) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ pos but postings were not\n                  postingsDocs = postingsTermsEnum.docs(null, postingsDocs);\n                  if (postingsDocs == null) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                  }\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (postingsHasFreq) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasProx) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (pos != -1 && postingsPos != -1 && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      // Call the methods to at least make\n                      // sure they don't throw exc:\n                      final int startOffset = postings.startOffset();\n                      final int endOffset = postings.endOffset();\n                      // TODO: these are too anal...?\n                      /*\n                        if (endOffset < startOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                        }\n                        if (startOffset < lastStartOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                        }\n                        lastStartOffset = startOffset;\n                      */\n\n                      if (postingsPostings != null) {\n                        final int postingsStartOffset = postingsPostings.startOffset();\n\n                        final int postingsEndOffset = postingsPostings.endOffset();\n                        if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                        }\n                        if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      float vectorAvg = status.docCount == 0 ? 0 : status.totVectors / (float)status.docCount;\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format(vectorAvg) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false, true);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, true);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n                \n                final boolean hasProx;\n                final boolean hasFreqs;\n\n                // TODO: really we need a reflection/query\n                // API so we can just ask what was indexed\n                // instead of \"probing\"...\n\n                // TODO: cleanup:\n\n                // Try offsets:\n                postings = termsEnum.docsAndPositions(null, postings);\n                if (postings == null) {\n                  hasProx = false;\n                  // Try docIDs & freqs:\n                  docs = termsEnum.docs(null, docs, true);\n                  if (docs == null) {\n                    // OK, only docIDs:\n                    hasFreqs = false;\n                    docs = termsEnum.docs(null, docs, false);\n                  } else {\n                      hasFreqs = true;\n                  }\n                } else {\n                  hasProx = true;\n                  hasFreqs = true;\n                }\n\n                final DocsEnum docs2;\n                if (hasProx) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                final boolean postingsHasFreq;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ pos but postings were not\n                  postingsDocs = postingsTermsEnum.docs(null, postingsDocs, true);\n                  if (postingsDocs == null) {\n                    postingsHasFreq = false;\n                    postingsDocs = postingsTermsEnum.docs(null, postingsDocs, false);\n                    if (postingsDocs == null) {\n                      throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                    }\n                  } else {\n                      postingsHasFreq = true;\n                  }\n                } else {\n                  postingsHasFreq = true;\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (hasFreqs) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasProx) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (pos != -1 && postingsPos != -1 && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      // Call the methods to at least make\n                      // sure they don't throw exc:\n                      final int startOffset = postings.startOffset();\n                      final int endOffset = postings.endOffset();\n                      // TODO: these are too anal...?\n                      /*\n                        if (endOffset < startOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                        }\n                        if (startOffset < lastStartOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                        }\n                        lastStartOffset = startOffset;\n                      */\n\n                      if (postingsPostings != null) {\n                        final int postingsStartOffset = postingsPostings.startOffset();\n\n                        final int postingsEndOffset = postingsPostings.endOffset();\n                        if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                        }\n                        if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      float vectorAvg = status.docCount == 0 ? 0 : status.totVectors / (float)status.docCount;\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format(vectorAvg) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","bugFix":["322360ac5185a8446d3e0b530b2068bef67cd3d5","814339e4b1ce2063ccbc6cacc6443a6446c7718b"],"bugIntro":["5699a2da08aaf5a165f2ceefe7cf8f5c70a12efc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","sourceNew":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false, true);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, true);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n              final boolean postingsHasFreq = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n                \n                final boolean hasProx;\n\n                // Try positions:\n                postings = termsEnum.docsAndPositions(null, postings);\n                if (postings == null) {\n                  hasProx = false;\n                  // Try docIDs & freqs:\n                  docs = termsEnum.docs(null, docs);\n                } else {\n                  hasProx = true;\n                }\n\n                final DocsEnum docs2;\n                if (hasProx) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ pos but postings were not\n                  postingsDocs = postingsTermsEnum.docs(null, postingsDocs);\n                  if (postingsDocs == null) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                  }\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (postingsHasFreq) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasProx) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (pos != -1 && postingsPos != -1 && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      // Call the methods to at least make\n                      // sure they don't throw exc:\n                      final int startOffset = postings.startOffset();\n                      final int endOffset = postings.endOffset();\n                      // TODO: these are too anal...?\n                      /*\n                        if (endOffset < startOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                        }\n                        if (startOffset < lastStartOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                        }\n                        lastStartOffset = startOffset;\n                      */\n\n                      if (postingsPostings != null) {\n                        final int postingsStartOffset = postingsPostings.startOffset();\n\n                        final int postingsEndOffset = postingsPostings.endOffset();\n                        if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                        }\n                        if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      float vectorAvg = status.docCount == 0 ? 0 : status.totVectors / (float)status.docCount;\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format(vectorAvg) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false, true);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, true);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n                \n                final boolean hasPositions;\n                final boolean hasOffsets;\n                final boolean hasFreqs;\n\n                // TODO: really we need a reflection/query\n                // API so we can just ask what was indexed\n                // instead of \"probing\"...\n\n                // Try offsets:\n                postings = termsEnum.docsAndPositions(null, postings, true);\n                if (postings == null) {\n                  hasOffsets = false;\n                  // Try only positions:\n                  postings = termsEnum.docsAndPositions(null, postings, false);\n                  if (postings == null) {\n                    hasPositions = false;\n                    // Try docIDs & freqs:\n                    docs = termsEnum.docs(null, docs, true);\n                    if (docs == null) {\n                      // OK, only docIDs:\n                      hasFreqs = false;\n                      docs = termsEnum.docs(null, docs, false);\n                    } else {\n                      hasFreqs = true;\n                    }\n                  } else {\n                    hasPositions = true;\n                    hasFreqs = true;\n                  }\n                } else {\n                  hasOffsets = true;\n                  // NOTE: may be a lie... but we accept -1\n                  hasPositions = true;\n                  hasFreqs = true;\n                }\n\n                final DocsEnum docs2;\n                if (hasPositions || hasOffsets) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                final boolean postingsHasFreq;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, true);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ offsets but postings were not\n                  postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, false);\n                  if (postingsPostings == null) {\n                    postingsDocs = postingsTermsEnum.docs(null, postingsDocs, true);\n                    if (postingsDocs == null) {\n                      postingsHasFreq = false;\n                      postingsDocs = postingsTermsEnum.docs(null, postingsDocs, false);\n                      if (postingsDocs == null) {\n                        throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                      }\n                    } else {\n                      postingsHasFreq = true;\n                    }\n                  } else {\n                    postingsHasFreq = true;\n                  }\n                } else {\n                  postingsHasFreq = true;\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (hasFreqs) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasPositions || hasOffsets) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (pos != -1 && postingsPos != -1 && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      if (hasOffsets) {\n                        // Call the methods to at least make\n                        // sure they don't throw exc:\n                        final int startOffset = postings.startOffset();\n                        final int endOffset = postings.endOffset();\n                        // TODO: these are too anal...?\n                        /*\n                          if (endOffset < startOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                          }\n                          if (startOffset < lastStartOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                          }\n                          lastStartOffset = startOffset;\n                        */\n\n                        if (postingsPostings != null) {\n                          final int postingsStartOffset = postingsPostings.startOffset();\n\n                          final int postingsEndOffset = postingsPostings.endOffset();\n                          if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                          }\n                          if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      float vectorAvg = status.docCount == 0 ? 0 : status.totVectors / (float)status.docCount;\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format(vectorAvg) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","sourceNew":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false, true);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, true);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n              final boolean postingsHasFreq = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n                \n                final boolean hasProx;\n\n                // Try positions:\n                postings = termsEnum.docsAndPositions(null, postings);\n                if (postings == null) {\n                  hasProx = false;\n                  // Try docIDs & freqs:\n                  docs = termsEnum.docs(null, docs);\n                } else {\n                  hasProx = true;\n                }\n\n                final DocsEnum docs2;\n                if (hasProx) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ pos but postings were not\n                  postingsDocs = postingsTermsEnum.docs(null, postingsDocs);\n                  if (postingsDocs == null) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                  }\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (postingsHasFreq) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasProx) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (pos != -1 && postingsPos != -1 && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      // Call the methods to at least make\n                      // sure they don't throw exc:\n                      final int startOffset = postings.startOffset();\n                      final int endOffset = postings.endOffset();\n                      // TODO: these are too anal...?\n                      /*\n                        if (endOffset < startOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                        }\n                        if (startOffset < lastStartOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                        }\n                        lastStartOffset = startOffset;\n                      */\n\n                      if (postingsPostings != null) {\n                        final int postingsStartOffset = postingsPostings.startOffset();\n\n                        final int postingsEndOffset = postingsPostings.endOffset();\n                        if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                        }\n                        if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      float vectorAvg = status.docCount == 0 ? 0 : status.totVectors / (float)status.docCount;\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format(vectorAvg) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false, true);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, true);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n                \n                final boolean hasPositions;\n                final boolean hasOffsets;\n                final boolean hasFreqs;\n\n                // TODO: really we need a reflection/query\n                // API so we can just ask what was indexed\n                // instead of \"probing\"...\n\n                // Try offsets:\n                postings = termsEnum.docsAndPositions(null, postings, true);\n                if (postings == null) {\n                  hasOffsets = false;\n                  // Try only positions:\n                  postings = termsEnum.docsAndPositions(null, postings, false);\n                  if (postings == null) {\n                    hasPositions = false;\n                    // Try docIDs & freqs:\n                    docs = termsEnum.docs(null, docs, true);\n                    if (docs == null) {\n                      // OK, only docIDs:\n                      hasFreqs = false;\n                      docs = termsEnum.docs(null, docs, false);\n                    } else {\n                      hasFreqs = true;\n                    }\n                  } else {\n                    hasPositions = true;\n                    hasFreqs = true;\n                  }\n                } else {\n                  hasOffsets = true;\n                  // NOTE: may be a lie... but we accept -1\n                  hasPositions = true;\n                  hasFreqs = true;\n                }\n\n                final DocsEnum docs2;\n                if (hasPositions || hasOffsets) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                final boolean postingsHasFreq;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, true);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ offsets but postings were not\n                  postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings, false);\n                  if (postingsPostings == null) {\n                    postingsDocs = postingsTermsEnum.docs(null, postingsDocs, true);\n                    if (postingsDocs == null) {\n                      postingsHasFreq = false;\n                      postingsDocs = postingsTermsEnum.docs(null, postingsDocs, false);\n                      if (postingsDocs == null) {\n                        throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                      }\n                    } else {\n                      postingsHasFreq = true;\n                    }\n                  } else {\n                    postingsHasFreq = true;\n                  }\n                } else {\n                  postingsHasFreq = true;\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (hasFreqs) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasPositions || hasOffsets) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (pos != -1 && postingsPos != -1 && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      if (hasOffsets) {\n                        // Call the methods to at least make\n                        // sure they don't throw exc:\n                        final int startOffset = postings.startOffset();\n                        final int endOffset = postings.endOffset();\n                        // TODO: these are too anal...?\n                        /*\n                          if (endOffset < startOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                          }\n                          if (startOffset < lastStartOffset) {\n                          throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                          }\n                          lastStartOffset = startOffset;\n                        */\n\n                        if (postingsPostings != null) {\n                          final int postingsStartOffset = postingsPostings.startOffset();\n\n                          final int postingsEndOffset = postingsPostings.endOffset();\n                          if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                          }\n                          if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      float vectorAvg = status.docCount == 0 ? 0 : status.totVectors / (float)status.docCount;\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format(vectorAvg) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5699a2da08aaf5a165f2ceefe7cf8f5c70a12efc","date":1344608180,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","sourceNew":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false, true);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, true);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n              final boolean postingsHasFreq = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              final boolean hasProx = terms.hasOffsets() || terms.hasPositions();\n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n\n                if (hasProx) {\n                  postings = termsEnum.docsAndPositions(null, postings);\n                  assert postings != null;\n                  docs = null;\n                } else {\n                  docs = termsEnum.docs(null, docs);\n                  assert docs != null;\n                  postings = null;\n                }\n\n                final DocsEnum docs2;\n                if (hasProx) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ pos but postings were not\n                  postingsDocs = postingsTermsEnum.docs(null, postingsDocs);\n                  if (postingsDocs == null) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                  }\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (postingsHasFreq) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasProx) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (pos != -1 && postingsPos != -1 && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      // Call the methods to at least make\n                      // sure they don't throw exc:\n                      final int startOffset = postings.startOffset();\n                      final int endOffset = postings.endOffset();\n                      // TODO: these are too anal...?\n                      /*\n                        if (endOffset < startOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                        }\n                        if (startOffset < lastStartOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                        }\n                        lastStartOffset = startOffset;\n                      */\n\n                      if (postingsPostings != null) {\n                        final int postingsStartOffset = postingsPostings.startOffset();\n\n                        final int postingsEndOffset = postingsPostings.endOffset();\n                        if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                        }\n                        if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      float vectorAvg = status.docCount == 0 ? 0 : status.totVectors / (float)status.docCount;\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format(vectorAvg) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false, true);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, true);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n              final boolean postingsHasFreq = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n                \n                final boolean hasProx;\n\n                // Try positions:\n                postings = termsEnum.docsAndPositions(null, postings);\n                if (postings == null) {\n                  hasProx = false;\n                  // Try docIDs & freqs:\n                  docs = termsEnum.docs(null, docs);\n                } else {\n                  hasProx = true;\n                }\n\n                final DocsEnum docs2;\n                if (hasProx) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ pos but postings were not\n                  postingsDocs = postingsTermsEnum.docs(null, postingsDocs);\n                  if (postingsDocs == null) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                  }\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (postingsHasFreq) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasProx) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (pos != -1 && postingsPos != -1 && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      // Call the methods to at least make\n                      // sure they don't throw exc:\n                      final int startOffset = postings.startOffset();\n                      final int endOffset = postings.endOffset();\n                      // TODO: these are too anal...?\n                      /*\n                        if (endOffset < startOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                        }\n                        if (startOffset < lastStartOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                        }\n                        lastStartOffset = startOffset;\n                      */\n\n                      if (postingsPostings != null) {\n                        final int postingsStartOffset = postingsPostings.startOffset();\n\n                        final int postingsEndOffset = postingsPostings.endOffset();\n                        if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                        }\n                        if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      float vectorAvg = status.docCount == 0 ? 0 : status.totVectors / (float)status.docCount;\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format(vectorAvg) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","bugFix":["02331260bb246364779cb6f04919ca47900d01bb","322360ac5185a8446d3e0b530b2068bef67cd3d5","814339e4b1ce2063ccbc6cacc6443a6446c7718b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86b9dbd07cb2512df60935f96f02fd20a04927dd","date":1344695516,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","sourceNew":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false, true);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, true);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n              final boolean postingsHasFreq = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              final boolean hasProx = terms.hasOffsets() || terms.hasPositions();\n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n\n                if (hasProx) {\n                  postings = termsEnum.docsAndPositions(null, postings);\n                  assert postings != null;\n                  docs = null;\n                } else {\n                  docs = termsEnum.docs(null, docs);\n                  assert docs != null;\n                  postings = null;\n                }\n\n                final DocsEnum docs2;\n                if (hasProx) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ pos but postings were not\n                  postingsDocs = postingsTermsEnum.docs(null, postingsDocs);\n                  if (postingsDocs == null) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                  }\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (postingsHasFreq) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasProx) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (terms.hasPositions() && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      // Call the methods to at least make\n                      // sure they don't throw exc:\n                      final int startOffset = postings.startOffset();\n                      final int endOffset = postings.endOffset();\n                      // TODO: these are too anal...?\n                      /*\n                        if (endOffset < startOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                        }\n                        if (startOffset < lastStartOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                        }\n                        lastStartOffset = startOffset;\n                      */\n\n                      if (postingsPostings != null) {\n                        final int postingsStartOffset = postingsPostings.startOffset();\n\n                        final int postingsEndOffset = postingsPostings.endOffset();\n                        if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                        }\n                        if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      float vectorAvg = status.docCount == 0 ? 0 : status.totVectors / (float)status.docCount;\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format(vectorAvg) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false, true);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, true);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n              final boolean postingsHasFreq = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              final boolean hasProx = terms.hasOffsets() || terms.hasPositions();\n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n\n                if (hasProx) {\n                  postings = termsEnum.docsAndPositions(null, postings);\n                  assert postings != null;\n                  docs = null;\n                } else {\n                  docs = termsEnum.docs(null, docs);\n                  assert docs != null;\n                  postings = null;\n                }\n\n                final DocsEnum docs2;\n                if (hasProx) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ pos but postings were not\n                  postingsDocs = postingsTermsEnum.docs(null, postingsDocs);\n                  if (postingsDocs == null) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                  }\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (postingsHasFreq) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasProx) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (pos != -1 && postingsPos != -1 && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      // Call the methods to at least make\n                      // sure they don't throw exc:\n                      final int startOffset = postings.startOffset();\n                      final int endOffset = postings.endOffset();\n                      // TODO: these are too anal...?\n                      /*\n                        if (endOffset < startOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                        }\n                        if (startOffset < lastStartOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                        }\n                        lastStartOffset = startOffset;\n                      */\n\n                      if (postingsPostings != null) {\n                        final int postingsStartOffset = postingsPostings.startOffset();\n\n                        final int postingsEndOffset = postingsPostings.endOffset();\n                        if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                        }\n                        if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      float vectorAvg = status.docCount == 0 ? 0 : status.totVectors / (float)status.docCount;\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format(vectorAvg) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0935c850ea562932997b72c69d93e345f21d7f45","date":1344711506,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","sourceNew":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false, true);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, true);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n              final boolean postingsHasFreq = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n              final boolean postingsHasPayload = fieldInfo.hasPayloads();\n              final boolean vectorsHasPayload = terms.hasPayloads();\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              final boolean hasProx = terms.hasOffsets() || terms.hasPositions();\n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n\n                if (hasProx) {\n                  postings = termsEnum.docsAndPositions(null, postings);\n                  assert postings != null;\n                  docs = null;\n                } else {\n                  docs = termsEnum.docs(null, docs);\n                  assert docs != null;\n                  postings = null;\n                }\n\n                final DocsEnum docs2;\n                if (hasProx) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ pos but postings were not\n                  postingsDocs = postingsTermsEnum.docs(null, postingsDocs);\n                  if (postingsDocs == null) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                  }\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (postingsHasFreq) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasProx) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (terms.hasPositions() && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      // Call the methods to at least make\n                      // sure they don't throw exc:\n                      final int startOffset = postings.startOffset();\n                      final int endOffset = postings.endOffset();\n                      // TODO: these are too anal...?\n                      /*\n                        if (endOffset < startOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                        }\n                        if (startOffset < lastStartOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                        }\n                        lastStartOffset = startOffset;\n                      */\n\n                      if (postingsPostings != null) {\n                        final int postingsStartOffset = postingsPostings.startOffset();\n\n                        final int postingsEndOffset = postingsPostings.endOffset();\n                        if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                        }\n                        if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                        }\n                      }\n                      \n                      BytesRef payload = null;\n                      if (postings.hasPayload()) {\n                        assert vectorsHasPayload;\n                        payload = postings.getPayload();\n                      }\n                      \n                      if (postingsHasPayload && vectorsHasPayload) {\n                        assert postingsPostings != null;\n                        \n                        if (payload == null) {\n                          // we have payloads, but not at this position. \n                          // postings has payloads too, it should not have one at this position\n                          if (postingsPostings.hasPayload()) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \" has no payload but postings does: \" + postingsPostings.getPayload());\n                          }\n                        } else {\n                          // we have payloads, and one at this position\n                          // postings should also have one at this position, with the same bytes.\n                          if (!postingsPostings.hasPayload()) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \" has payload=\" + payload + \" but postings does not.\");\n                          }\n                          BytesRef postingsPayload = postingsPostings.getPayload();\n                          if (!payload.equals(postingsPayload)) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \" has payload=\" + payload + \" but differs from postings payload=\" + postingsPayload);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      float vectorAvg = status.docCount == 0 ? 0 : status.totVectors / (float)status.docCount;\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format(vectorAvg) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false, true);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, true);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n              final boolean postingsHasFreq = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              final boolean hasProx = terms.hasOffsets() || terms.hasPositions();\n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n\n                if (hasProx) {\n                  postings = termsEnum.docsAndPositions(null, postings);\n                  assert postings != null;\n                  docs = null;\n                } else {\n                  docs = termsEnum.docs(null, docs);\n                  assert docs != null;\n                  postings = null;\n                }\n\n                final DocsEnum docs2;\n                if (hasProx) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ pos but postings were not\n                  postingsDocs = postingsTermsEnum.docs(null, postingsDocs);\n                  if (postingsDocs == null) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                  }\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (postingsHasFreq) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasProx) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (terms.hasPositions() && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      // Call the methods to at least make\n                      // sure they don't throw exc:\n                      final int startOffset = postings.startOffset();\n                      final int endOffset = postings.endOffset();\n                      // TODO: these are too anal...?\n                      /*\n                        if (endOffset < startOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                        }\n                        if (startOffset < lastStartOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                        }\n                        lastStartOffset = startOffset;\n                      */\n\n                      if (postingsPostings != null) {\n                        final int postingsStartOffset = postingsPostings.startOffset();\n\n                        final int postingsEndOffset = postingsPostings.endOffset();\n                        if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                        }\n                        if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      float vectorAvg = status.docCount == 0 ? 0 : status.totVectors / (float)status.docCount;\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format(vectorAvg) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2b4c7e630332c5e9e7d7a70f4ace4b3ffd3fc552","date":1344797146,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","sourceNew":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false, true);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, true);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n              final boolean postingsHasFreq = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n              final boolean postingsHasPayload = fieldInfo.hasPayloads();\n              final boolean vectorsHasPayload = terms.hasPayloads();\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              final boolean hasProx = terms.hasOffsets() || terms.hasPositions();\n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n\n                if (hasProx) {\n                  postings = termsEnum.docsAndPositions(null, postings);\n                  assert postings != null;\n                  docs = null;\n                } else {\n                  docs = termsEnum.docs(null, docs);\n                  assert docs != null;\n                  postings = null;\n                }\n\n                final DocsEnum docs2;\n                if (hasProx) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ pos but postings were not\n                  postingsDocs = postingsTermsEnum.docs(null, postingsDocs);\n                  if (postingsDocs == null) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                  }\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (postingsHasFreq) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasProx) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (terms.hasPositions() && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      // Call the methods to at least make\n                      // sure they don't throw exc:\n                      final int startOffset = postings.startOffset();\n                      final int endOffset = postings.endOffset();\n                      // TODO: these are too anal...?\n                      /*\n                        if (endOffset < startOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                        }\n                        if (startOffset < lastStartOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                        }\n                        lastStartOffset = startOffset;\n                      */\n\n                      if (postingsPostings != null) {\n                        final int postingsStartOffset = postingsPostings.startOffset();\n\n                        final int postingsEndOffset = postingsPostings.endOffset();\n                        if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                        }\n                        if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                        }\n                      }\n                      \n                      BytesRef payload = postings.getPayload();\n           \n                      if (payload != null) {\n                        assert vectorsHasPayload;\n                      }\n                      \n                      if (postingsHasPayload && vectorsHasPayload) {\n                        assert postingsPostings != null;\n                        \n                        if (payload == null) {\n                          // we have payloads, but not at this position. \n                          // postings has payloads too, it should not have one at this position\n                          if (postingsPostings.getPayload() != null) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \" has no payload but postings does: \" + postingsPostings.getPayload());\n                          }\n                        } else {\n                          // we have payloads, and one at this position\n                          // postings should also have one at this position, with the same bytes.\n                          if (postingsPostings.getPayload() == null) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \" has payload=\" + payload + \" but postings does not.\");\n                          }\n                          BytesRef postingsPayload = postingsPostings.getPayload();\n                          if (!payload.equals(postingsPayload)) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \" has payload=\" + payload + \" but differs from postings payload=\" + postingsPayload);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      float vectorAvg = status.docCount == 0 ? 0 : status.totVectors / (float)status.docCount;\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format(vectorAvg) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false, true);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, true);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n              final boolean postingsHasFreq = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n              final boolean postingsHasPayload = fieldInfo.hasPayloads();\n              final boolean vectorsHasPayload = terms.hasPayloads();\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              final boolean hasProx = terms.hasOffsets() || terms.hasPositions();\n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n\n                if (hasProx) {\n                  postings = termsEnum.docsAndPositions(null, postings);\n                  assert postings != null;\n                  docs = null;\n                } else {\n                  docs = termsEnum.docs(null, docs);\n                  assert docs != null;\n                  postings = null;\n                }\n\n                final DocsEnum docs2;\n                if (hasProx) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ pos but postings were not\n                  postingsDocs = postingsTermsEnum.docs(null, postingsDocs);\n                  if (postingsDocs == null) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                  }\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (postingsHasFreq) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasProx) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (terms.hasPositions() && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      // Call the methods to at least make\n                      // sure they don't throw exc:\n                      final int startOffset = postings.startOffset();\n                      final int endOffset = postings.endOffset();\n                      // TODO: these are too anal...?\n                      /*\n                        if (endOffset < startOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                        }\n                        if (startOffset < lastStartOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                        }\n                        lastStartOffset = startOffset;\n                      */\n\n                      if (postingsPostings != null) {\n                        final int postingsStartOffset = postingsPostings.startOffset();\n\n                        final int postingsEndOffset = postingsPostings.endOffset();\n                        if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                        }\n                        if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                        }\n                      }\n                      \n                      BytesRef payload = null;\n                      if (postings.hasPayload()) {\n                        assert vectorsHasPayload;\n                        payload = postings.getPayload();\n                      }\n                      \n                      if (postingsHasPayload && vectorsHasPayload) {\n                        assert postingsPostings != null;\n                        \n                        if (payload == null) {\n                          // we have payloads, but not at this position. \n                          // postings has payloads too, it should not have one at this position\n                          if (postingsPostings.hasPayload()) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \" has no payload but postings does: \" + postingsPostings.getPayload());\n                          }\n                        } else {\n                          // we have payloads, and one at this position\n                          // postings should also have one at this position, with the same bytes.\n                          if (!postingsPostings.hasPayload()) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \" has payload=\" + payload + \" but postings does not.\");\n                          }\n                          BytesRef postingsPayload = postingsPostings.getPayload();\n                          if (!payload.equals(postingsPayload)) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \" has payload=\" + payload + \" but differs from postings payload=\" + postingsPayload);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      float vectorAvg = status.docCount == 0 ? 0 : status.totVectors / (float)status.docCount;\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format(vectorAvg) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb07ab105350b80ed9d63ca64b117084ed7391bc","date":1344824719,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","sourceNew":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false, true);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, true);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          for(String field : tfv) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n              final boolean postingsHasFreq = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n              final boolean postingsHasPayload = fieldInfo.hasPayloads();\n              final boolean vectorsHasPayload = terms.hasPayloads();\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              final boolean hasProx = terms.hasOffsets() || terms.hasPositions();\n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n\n                if (hasProx) {\n                  postings = termsEnum.docsAndPositions(null, postings);\n                  assert postings != null;\n                  docs = null;\n                } else {\n                  docs = termsEnum.docs(null, docs);\n                  assert docs != null;\n                  postings = null;\n                }\n\n                final DocsEnum docs2;\n                if (hasProx) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ pos but postings were not\n                  postingsDocs = postingsTermsEnum.docs(null, postingsDocs);\n                  if (postingsDocs == null) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                  }\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (postingsHasFreq) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasProx) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (terms.hasPositions() && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      // Call the methods to at least make\n                      // sure they don't throw exc:\n                      final int startOffset = postings.startOffset();\n                      final int endOffset = postings.endOffset();\n                      // TODO: these are too anal...?\n                      /*\n                        if (endOffset < startOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                        }\n                        if (startOffset < lastStartOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                        }\n                        lastStartOffset = startOffset;\n                      */\n\n                      if (postingsPostings != null) {\n                        final int postingsStartOffset = postingsPostings.startOffset();\n\n                        final int postingsEndOffset = postingsPostings.endOffset();\n                        if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                        }\n                        if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                        }\n                      }\n                      \n                      BytesRef payload = postings.getPayload();\n           \n                      if (payload != null) {\n                        assert vectorsHasPayload;\n                      }\n                      \n                      if (postingsHasPayload && vectorsHasPayload) {\n                        assert postingsPostings != null;\n                        \n                        if (payload == null) {\n                          // we have payloads, but not at this position. \n                          // postings has payloads too, it should not have one at this position\n                          if (postingsPostings.getPayload() != null) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \" has no payload but postings does: \" + postingsPostings.getPayload());\n                          }\n                        } else {\n                          // we have payloads, and one at this position\n                          // postings should also have one at this position, with the same bytes.\n                          if (postingsPostings.getPayload() == null) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \" has payload=\" + payload + \" but postings does not.\");\n                          }\n                          BytesRef postingsPayload = postingsPostings.getPayload();\n                          if (!payload.equals(postingsPayload)) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \" has payload=\" + payload + \" but differs from postings payload=\" + postingsPayload);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      float vectorAvg = status.docCount == 0 ? 0 : status.totVectors / (float)status.docCount;\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format(vectorAvg) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false, true);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, true);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n              final boolean postingsHasFreq = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n              final boolean postingsHasPayload = fieldInfo.hasPayloads();\n              final boolean vectorsHasPayload = terms.hasPayloads();\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              final boolean hasProx = terms.hasOffsets() || terms.hasPositions();\n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n\n                if (hasProx) {\n                  postings = termsEnum.docsAndPositions(null, postings);\n                  assert postings != null;\n                  docs = null;\n                } else {\n                  docs = termsEnum.docs(null, docs);\n                  assert docs != null;\n                  postings = null;\n                }\n\n                final DocsEnum docs2;\n                if (hasProx) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ pos but postings were not\n                  postingsDocs = postingsTermsEnum.docs(null, postingsDocs);\n                  if (postingsDocs == null) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                  }\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (postingsHasFreq) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasProx) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (terms.hasPositions() && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      // Call the methods to at least make\n                      // sure they don't throw exc:\n                      final int startOffset = postings.startOffset();\n                      final int endOffset = postings.endOffset();\n                      // TODO: these are too anal...?\n                      /*\n                        if (endOffset < startOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                        }\n                        if (startOffset < lastStartOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                        }\n                        lastStartOffset = startOffset;\n                      */\n\n                      if (postingsPostings != null) {\n                        final int postingsStartOffset = postingsPostings.startOffset();\n\n                        final int postingsEndOffset = postingsPostings.endOffset();\n                        if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                        }\n                        if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                        }\n                      }\n                      \n                      BytesRef payload = postings.getPayload();\n           \n                      if (payload != null) {\n                        assert vectorsHasPayload;\n                      }\n                      \n                      if (postingsHasPayload && vectorsHasPayload) {\n                        assert postingsPostings != null;\n                        \n                        if (payload == null) {\n                          // we have payloads, but not at this position. \n                          // postings has payloads too, it should not have one at this position\n                          if (postingsPostings.getPayload() != null) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \" has no payload but postings does: \" + postingsPostings.getPayload());\n                          }\n                        } else {\n                          // we have payloads, and one at this position\n                          // postings should also have one at this position, with the same bytes.\n                          if (postingsPostings.getPayload() == null) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \" has payload=\" + payload + \" but postings does not.\");\n                          }\n                          BytesRef postingsPayload = postingsPostings.getPayload();\n                          if (!payload.equals(postingsPayload)) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \" has payload=\" + payload + \" but differs from postings payload=\" + postingsPayload);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      float vectorAvg = status.docCount == 0 ? 0 : status.totVectors / (float)status.docCount;\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format(vectorAvg) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","sourceNew":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false, true);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, true);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          for(String field : tfv) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n              final boolean postingsHasFreq = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n              final boolean postingsHasPayload = fieldInfo.hasPayloads();\n              final boolean vectorsHasPayload = terms.hasPayloads();\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              final boolean hasProx = terms.hasOffsets() || terms.hasPositions();\n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n\n                if (hasProx) {\n                  postings = termsEnum.docsAndPositions(null, postings);\n                  assert postings != null;\n                  docs = null;\n                } else {\n                  docs = termsEnum.docs(null, docs);\n                  assert docs != null;\n                  postings = null;\n                }\n\n                final DocsEnum docs2;\n                if (hasProx) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ pos but postings were not\n                  postingsDocs = postingsTermsEnum.docs(null, postingsDocs);\n                  if (postingsDocs == null) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                  }\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (postingsHasFreq) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasProx) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (terms.hasPositions() && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      // Call the methods to at least make\n                      // sure they don't throw exc:\n                      final int startOffset = postings.startOffset();\n                      final int endOffset = postings.endOffset();\n                      // TODO: these are too anal...?\n                      /*\n                        if (endOffset < startOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                        }\n                        if (startOffset < lastStartOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                        }\n                        lastStartOffset = startOffset;\n                      */\n\n                      if (postingsPostings != null) {\n                        final int postingsStartOffset = postingsPostings.startOffset();\n\n                        final int postingsEndOffset = postingsPostings.endOffset();\n                        if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                        }\n                        if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                        }\n                      }\n                      \n                      BytesRef payload = postings.getPayload();\n           \n                      if (payload != null) {\n                        assert vectorsHasPayload;\n                      }\n                      \n                      if (postingsHasPayload && vectorsHasPayload) {\n                        assert postingsPostings != null;\n                        \n                        if (payload == null) {\n                          // we have payloads, but not at this position. \n                          // postings has payloads too, it should not have one at this position\n                          if (postingsPostings.getPayload() != null) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \" has no payload but postings does: \" + postingsPostings.getPayload());\n                          }\n                        } else {\n                          // we have payloads, and one at this position\n                          // postings should also have one at this position, with the same bytes.\n                          if (postingsPostings.getPayload() == null) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \" has payload=\" + payload + \" but postings does not.\");\n                          }\n                          BytesRef postingsPayload = postingsPostings.getPayload();\n                          if (!payload.equals(postingsPayload)) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \" has payload=\" + payload + \" but differs from postings payload=\" + postingsPayload);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      float vectorAvg = status.docCount == 0 ? 0 : status.totVectors / (float)status.docCount;\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format(vectorAvg) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false, true);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, true);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n              final boolean postingsHasFreq = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n                \n                final boolean hasProx;\n\n                // Try positions:\n                postings = termsEnum.docsAndPositions(null, postings);\n                if (postings == null) {\n                  hasProx = false;\n                  // Try docIDs & freqs:\n                  docs = termsEnum.docs(null, docs);\n                } else {\n                  hasProx = true;\n                }\n\n                final DocsEnum docs2;\n                if (hasProx) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ pos but postings were not\n                  postingsDocs = postingsTermsEnum.docs(null, postingsDocs);\n                  if (postingsDocs == null) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                  }\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (postingsHasFreq) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasProx) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (pos != -1 && postingsPos != -1 && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      // Call the methods to at least make\n                      // sure they don't throw exc:\n                      final int startOffset = postings.startOffset();\n                      final int endOffset = postings.endOffset();\n                      // TODO: these are too anal...?\n                      /*\n                        if (endOffset < startOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                        }\n                        if (startOffset < lastStartOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                        }\n                        lastStartOffset = startOffset;\n                      */\n\n                      if (postingsPostings != null) {\n                        final int postingsStartOffset = postingsPostings.startOffset();\n\n                        final int postingsEndOffset = postingsPostings.endOffset();\n                        if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                        }\n                        if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      float vectorAvg = status.docCount == 0 ? 0 : status.totVectors / (float)status.docCount;\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format(vectorAvg) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","date":1344867506,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","sourceNew":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false, true);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, true);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          for(String field : tfv) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n              final boolean postingsHasFreq = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n              final boolean postingsHasPayload = fieldInfo.hasPayloads();\n              final boolean vectorsHasPayload = terms.hasPayloads();\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              final boolean hasProx = terms.hasOffsets() || terms.hasPositions();\n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n\n                if (hasProx) {\n                  postings = termsEnum.docsAndPositions(null, postings);\n                  assert postings != null;\n                  docs = null;\n                } else {\n                  docs = termsEnum.docs(null, docs);\n                  assert docs != null;\n                  postings = null;\n                }\n\n                final DocsEnum docs2;\n                if (hasProx) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ pos but postings were not\n                  postingsDocs = postingsTermsEnum.docs(null, postingsDocs);\n                  if (postingsDocs == null) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                  }\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (postingsHasFreq) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasProx) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (terms.hasPositions() && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      // Call the methods to at least make\n                      // sure they don't throw exc:\n                      final int startOffset = postings.startOffset();\n                      final int endOffset = postings.endOffset();\n                      // TODO: these are too anal...?\n                      /*\n                        if (endOffset < startOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                        }\n                        if (startOffset < lastStartOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                        }\n                        lastStartOffset = startOffset;\n                      */\n\n                      if (postingsPostings != null) {\n                        final int postingsStartOffset = postingsPostings.startOffset();\n\n                        final int postingsEndOffset = postingsPostings.endOffset();\n                        if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                        }\n                        if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                        }\n                      }\n                      \n                      BytesRef payload = postings.getPayload();\n           \n                      if (payload != null) {\n                        assert vectorsHasPayload;\n                      }\n                      \n                      if (postingsHasPayload && vectorsHasPayload) {\n                        assert postingsPostings != null;\n                        \n                        if (payload == null) {\n                          // we have payloads, but not at this position. \n                          // postings has payloads too, it should not have one at this position\n                          if (postingsPostings.getPayload() != null) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \" has no payload but postings does: \" + postingsPostings.getPayload());\n                          }\n                        } else {\n                          // we have payloads, and one at this position\n                          // postings should also have one at this position, with the same bytes.\n                          if (postingsPostings.getPayload() == null) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \" has payload=\" + payload + \" but postings does not.\");\n                          }\n                          BytesRef postingsPayload = postingsPostings.getPayload();\n                          if (!payload.equals(postingsPayload)) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \" has payload=\" + payload + \" but differs from postings payload=\" + postingsPayload);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      float vectorAvg = status.docCount == 0 ? 0 : status.totVectors / (float)status.docCount;\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format(vectorAvg) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false, true);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, true);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          FieldsEnum fieldsEnum = tfv.iterator();\n          String field = null;\n          while((field = fieldsEnum.next()) != null) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n              final boolean postingsHasFreq = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n                \n                final boolean hasProx;\n\n                // Try positions:\n                postings = termsEnum.docsAndPositions(null, postings);\n                if (postings == null) {\n                  hasProx = false;\n                  // Try docIDs & freqs:\n                  docs = termsEnum.docs(null, docs);\n                } else {\n                  hasProx = true;\n                }\n\n                final DocsEnum docs2;\n                if (hasProx) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ pos but postings were not\n                  postingsDocs = postingsTermsEnum.docs(null, postingsDocs);\n                  if (postingsDocs == null) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                  }\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (postingsHasFreq) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasProx) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (pos != -1 && postingsPos != -1 && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      // Call the methods to at least make\n                      // sure they don't throw exc:\n                      final int startOffset = postings.startOffset();\n                      final int endOffset = postings.endOffset();\n                      // TODO: these are too anal...?\n                      /*\n                        if (endOffset < startOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                        }\n                        if (startOffset < lastStartOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                        }\n                        lastStartOffset = startOffset;\n                      */\n\n                      if (postingsPostings != null) {\n                        final int postingsStartOffset = postingsPostings.startOffset();\n\n                        final int postingsEndOffset = postingsPostings.endOffset();\n                        if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                        }\n                        if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      float vectorAvg = status.docCount == 0 ? 0 : status.totVectors / (float)status.docCount;\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format(vectorAvg) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e99275efa2c9c9ae3bdba986218af82f2bf3dc30","date":1354658499,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(AtomicReader,PrintStream,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","sourceNew":"  /**\n   * Test term vectors.\n   * @lucene.experimental\n   */\n  public static Status.TermVectorStatus testTermVectors(AtomicReader reader, PrintStream infoStream, boolean verbose, boolean crossCheckTermVectors) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n    final FieldInfos fieldInfos = reader.getFieldInfos();\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < reader.maxDoc(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false, true, infoStream, verbose);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, true, infoStream, verbose);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          for(String field : tfv) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n              final boolean postingsHasFreq = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n              final boolean postingsHasPayload = fieldInfo.hasPayloads();\n              final boolean vectorsHasPayload = terms.hasPayloads();\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              final boolean hasProx = terms.hasOffsets() || terms.hasPositions();\n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n\n                if (hasProx) {\n                  postings = termsEnum.docsAndPositions(null, postings);\n                  assert postings != null;\n                  docs = null;\n                } else {\n                  docs = termsEnum.docs(null, docs);\n                  assert docs != null;\n                  postings = null;\n                }\n\n                final DocsEnum docs2;\n                if (hasProx) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ pos but postings were not\n                  postingsDocs = postingsTermsEnum.docs(null, postingsDocs);\n                  if (postingsDocs == null) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                  }\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (postingsHasFreq) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasProx) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (terms.hasPositions() && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      // Call the methods to at least make\n                      // sure they don't throw exc:\n                      final int startOffset = postings.startOffset();\n                      final int endOffset = postings.endOffset();\n                      // TODO: these are too anal...?\n                      /*\n                        if (endOffset < startOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                        }\n                        if (startOffset < lastStartOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                        }\n                        lastStartOffset = startOffset;\n                      */\n\n                      if (postingsPostings != null) {\n                        final int postingsStartOffset = postingsPostings.startOffset();\n\n                        final int postingsEndOffset = postingsPostings.endOffset();\n                        if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                        }\n                        if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                        }\n                      }\n                      \n                      BytesRef payload = postings.getPayload();\n           \n                      if (payload != null) {\n                        assert vectorsHasPayload;\n                      }\n                      \n                      if (postingsHasPayload && vectorsHasPayload) {\n                        assert postingsPostings != null;\n                        \n                        if (payload == null) {\n                          // we have payloads, but not at this position. \n                          // postings has payloads too, it should not have one at this position\n                          if (postingsPostings.getPayload() != null) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \" has no payload but postings does: \" + postingsPostings.getPayload());\n                          }\n                        } else {\n                          // we have payloads, and one at this position\n                          // postings should also have one at this position, with the same bytes.\n                          if (postingsPostings.getPayload() == null) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \" has payload=\" + payload + \" but postings does not.\");\n                          }\n                          BytesRef postingsPayload = postingsPostings.getPayload();\n                          if (!payload.equals(postingsPayload)) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \" has payload=\" + payload + \" but differs from postings payload=\" + postingsPayload);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      float vectorAvg = status.docCount == 0 ? 0 : status.totVectors / (float)status.docCount;\n      msg(infoStream, \"OK [\" + status.totVectors + \" total vector count; avg \" + \n          NumberFormat.getInstance(Locale.ROOT).format(vectorAvg) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(infoStream, \"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","sourceOld":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false, true);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, true);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          for(String field : tfv) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n              final boolean postingsHasFreq = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n              final boolean postingsHasPayload = fieldInfo.hasPayloads();\n              final boolean vectorsHasPayload = terms.hasPayloads();\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              final boolean hasProx = terms.hasOffsets() || terms.hasPositions();\n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n\n                if (hasProx) {\n                  postings = termsEnum.docsAndPositions(null, postings);\n                  assert postings != null;\n                  docs = null;\n                } else {\n                  docs = termsEnum.docs(null, docs);\n                  assert docs != null;\n                  postings = null;\n                }\n\n                final DocsEnum docs2;\n                if (hasProx) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ pos but postings were not\n                  postingsDocs = postingsTermsEnum.docs(null, postingsDocs);\n                  if (postingsDocs == null) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                  }\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (postingsHasFreq) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasProx) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (terms.hasPositions() && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      // Call the methods to at least make\n                      // sure they don't throw exc:\n                      final int startOffset = postings.startOffset();\n                      final int endOffset = postings.endOffset();\n                      // TODO: these are too anal...?\n                      /*\n                        if (endOffset < startOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                        }\n                        if (startOffset < lastStartOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                        }\n                        lastStartOffset = startOffset;\n                      */\n\n                      if (postingsPostings != null) {\n                        final int postingsStartOffset = postingsPostings.startOffset();\n\n                        final int postingsEndOffset = postingsPostings.endOffset();\n                        if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                        }\n                        if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                        }\n                      }\n                      \n                      BytesRef payload = postings.getPayload();\n           \n                      if (payload != null) {\n                        assert vectorsHasPayload;\n                      }\n                      \n                      if (postingsHasPayload && vectorsHasPayload) {\n                        assert postingsPostings != null;\n                        \n                        if (payload == null) {\n                          // we have payloads, but not at this position. \n                          // postings has payloads too, it should not have one at this position\n                          if (postingsPostings.getPayload() != null) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \" has no payload but postings does: \" + postingsPostings.getPayload());\n                          }\n                        } else {\n                          // we have payloads, and one at this position\n                          // postings should also have one at this position, with the same bytes.\n                          if (postingsPostings.getPayload() == null) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \" has payload=\" + payload + \" but postings does not.\");\n                          }\n                          BytesRef postingsPayload = postingsPostings.getPayload();\n                          if (!payload.equals(postingsPayload)) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \" has payload=\" + payload + \" but differs from postings payload=\" + postingsPayload);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      float vectorAvg = status.docCount == 0 ? 0 : status.totVectors / (float)status.docCount;\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format(vectorAvg) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testTermVectors(FieldInfos,SegmentInfoPerCommit,SegmentReader,NumberFormat).mjava","sourceNew":null,"sourceOld":"  /**\n   * Test term vectors for a segment.\n   */\n  private Status.TermVectorStatus testTermVectors(FieldInfos fieldInfos, SegmentInfoPerCommit info, SegmentReader reader, NumberFormat format) {\n    final Status.TermVectorStatus status = new Status.TermVectorStatus();\n\n    final Bits onlyDocIsDeleted = new FixedBitSet(1);\n    \n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: term vectors........\");\n      }\n\n      DocsEnum docs = null;\n      DocsAndPositionsEnum postings = null;\n\n      // Only used if crossCheckTermVectors is true:\n      DocsEnum postingsDocs = null;\n      DocsAndPositionsEnum postingsPostings = null;\n\n      final Bits liveDocs = reader.getLiveDocs();\n\n      final Fields postingsFields;\n      // TODO: testTermsIndex\n      if (crossCheckTermVectors) {\n        postingsFields = reader.fields();\n      } else {\n        postingsFields = null;\n      }\n\n      TermsEnum termsEnum = null;\n      TermsEnum postingsTermsEnum = null;\n\n      for (int j = 0; j < info.info.getDocCount(); ++j) {\n        // Intentionally pull/visit (but don't count in\n        // stats) deleted documents to make sure they too\n        // are not corrupt:\n        Fields tfv = reader.getTermVectors(j);\n\n        // TODO: can we make a IS(FIR) that searches just\n        // this term vector... to pass for searcher?\n\n        if (tfv != null) {\n          // First run with no deletions:\n          checkFields(tfv, null, 1, fieldInfos, false, true);\n\n          // Again, with the one doc deleted:\n          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, true);\n\n          // Only agg stats if the doc is live:\n          final boolean doStats = liveDocs == null || liveDocs.get(j);\n          if (doStats) {\n            status.docCount++;\n          }\n\n          for(String field : tfv) {\n            if (doStats) {\n              status.totVectors++;\n            }\n\n            // Make sure FieldInfo thinks this field is vector'd:\n            final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);\n            if (!fieldInfo.hasVectors()) {\n              throw new RuntimeException(\"docID=\" + j + \" has term vectors for field=\" + field + \" but FieldInfo has storeTermVector=false\");\n            }\n\n            if (crossCheckTermVectors) {\n              Terms terms = tfv.terms(field);\n              termsEnum = terms.iterator(termsEnum);\n              final boolean postingsHasFreq = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n              final boolean postingsHasPayload = fieldInfo.hasPayloads();\n              final boolean vectorsHasPayload = terms.hasPayloads();\n\n              Terms postingsTerms = postingsFields.terms(field);\n              if (postingsTerms == null) {\n                throw new RuntimeException(\"vector field=\" + field + \" does not exist in postings; doc=\" + j);\n              }\n              postingsTermsEnum = postingsTerms.iterator(postingsTermsEnum);\n              \n              final boolean hasProx = terms.hasOffsets() || terms.hasPositions();\n              BytesRef term = null;\n              while ((term = termsEnum.next()) != null) {\n\n                if (hasProx) {\n                  postings = termsEnum.docsAndPositions(null, postings);\n                  assert postings != null;\n                  docs = null;\n                } else {\n                  docs = termsEnum.docs(null, docs);\n                  assert docs != null;\n                  postings = null;\n                }\n\n                final DocsEnum docs2;\n                if (hasProx) {\n                  assert postings != null;\n                  docs2 = postings;\n                } else {\n                  assert docs != null;\n                  docs2 = docs;\n                }\n\n                final DocsEnum postingsDocs2;\n                if (!postingsTermsEnum.seekExact(term, true)) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                }\n                postingsPostings = postingsTermsEnum.docsAndPositions(null, postingsPostings);\n                if (postingsPostings == null) {\n                  // Term vectors were indexed w/ pos but postings were not\n                  postingsDocs = postingsTermsEnum.docs(null, postingsDocs);\n                  if (postingsDocs == null) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" does not exist in postings; doc=\" + j);\n                  }\n                }\n\n                if (postingsPostings != null) {\n                  postingsDocs2 = postingsPostings;\n                } else {\n                  postingsDocs2 = postingsDocs;\n                }\n                  \n                final int advanceDoc = postingsDocs2.advance(j);\n                if (advanceDoc != j) {\n                  throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \": doc=\" + j + \" was not found in postings (got: \" + advanceDoc + \")\");\n                }\n\n                final int doc = docs2.nextDoc();\n                  \n                if (doc != 0) {\n                  throw new RuntimeException(\"vector for doc \" + j + \" didn't return docID=0: got docID=\" + doc);\n                }\n\n                if (postingsHasFreq) {\n                  final int tf = docs2.freq();\n                  if (postingsHasFreq && postingsDocs2.freq() != tf) {\n                    throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": freq=\" + tf + \" differs from postings freq=\" + postingsDocs2.freq());\n                  }\n                \n                  if (hasProx) {\n                    for (int i = 0; i < tf; i++) {\n                      int pos = postings.nextPosition();\n                      if (postingsPostings != null) {\n                        int postingsPos = postingsPostings.nextPosition();\n                        if (terms.hasPositions() && pos != postingsPos) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": pos=\" + pos + \" differs from postings pos=\" + postingsPos);\n                        }\n                      }\n\n                      // Call the methods to at least make\n                      // sure they don't throw exc:\n                      final int startOffset = postings.startOffset();\n                      final int endOffset = postings.endOffset();\n                      // TODO: these are too anal...?\n                      /*\n                        if (endOffset < startOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is > endOffset=\" + endOffset);\n                        }\n                        if (startOffset < lastStartOffset) {\n                        throw new RuntimeException(\"vector startOffset=\" + startOffset + \" is < prior startOffset=\" + lastStartOffset);\n                        }\n                        lastStartOffset = startOffset;\n                      */\n\n                      if (postingsPostings != null) {\n                        final int postingsStartOffset = postingsPostings.startOffset();\n\n                        final int postingsEndOffset = postingsPostings.endOffset();\n                        if (startOffset != -1 && postingsStartOffset != -1 && startOffset != postingsStartOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": startOffset=\" + startOffset + \" differs from postings startOffset=\" + postingsStartOffset);\n                        }\n                        if (endOffset != -1 && postingsEndOffset != -1 && endOffset != postingsEndOffset) {\n                          throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \": endOffset=\" + endOffset + \" differs from postings endOffset=\" + postingsEndOffset);\n                        }\n                      }\n                      \n                      BytesRef payload = postings.getPayload();\n           \n                      if (payload != null) {\n                        assert vectorsHasPayload;\n                      }\n                      \n                      if (postingsHasPayload && vectorsHasPayload) {\n                        assert postingsPostings != null;\n                        \n                        if (payload == null) {\n                          // we have payloads, but not at this position. \n                          // postings has payloads too, it should not have one at this position\n                          if (postingsPostings.getPayload() != null) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \" has no payload but postings does: \" + postingsPostings.getPayload());\n                          }\n                        } else {\n                          // we have payloads, and one at this position\n                          // postings should also have one at this position, with the same bytes.\n                          if (postingsPostings.getPayload() == null) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \" has payload=\" + payload + \" but postings does not.\");\n                          }\n                          BytesRef postingsPayload = postingsPostings.getPayload();\n                          if (!payload.equals(postingsPayload)) {\n                            throw new RuntimeException(\"vector term=\" + term + \" field=\" + field + \" doc=\" + j + \" has payload=\" + payload + \" but differs from postings payload=\" + postingsPayload);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      float vectorAvg = status.docCount == 0 ? 0 : status.totVectors / (float)status.docCount;\n      msg(\"OK [\" + status.totVectors + \" total vector count; avg \" + \n          format.format(vectorAvg) + \" term/freq vector fields per doc]\");\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    \n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fb07ab105350b80ed9d63ca64b117084ed7391bc":["2b4c7e630332c5e9e7d7a70f4ace4b3ffd3fc552"],"9d153abcf92dc5329d98571a8c3035df9bd80648":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e99275efa2c9c9ae3bdba986218af82f2bf3dc30":["fb07ab105350b80ed9d63ca64b117084ed7391bc"],"5699a2da08aaf5a165f2ceefe7cf8f5c70a12efc":["02331260bb246364779cb6f04919ca47900d01bb"],"c638f0552fb6cb9ef3566f1eb38953ce86ee2fa3":["138923418367b4cadabaadb48c45f03a96cfde8b"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","203d7d3cb7712e10ef33009a63247ae40c302d7a"],"aba371508186796cc6151d8223a5b4e16d02e26e":["f0b2a0f7efff91a413da6cc75c82ef07af7baba4","c638f0552fb6cb9ef3566f1eb38953ce86ee2fa3"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","fb07ab105350b80ed9d63ca64b117084ed7391bc"],"2b4c7e630332c5e9e7d7a70f4ace4b3ffd3fc552":["0935c850ea562932997b72c69d93e345f21d7f45"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["fb07ab105350b80ed9d63ca64b117084ed7391bc","e99275efa2c9c9ae3bdba986218af82f2bf3dc30"],"138923418367b4cadabaadb48c45f03a96cfde8b":["f0b2a0f7efff91a413da6cc75c82ef07af7baba4"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["f0b2a0f7efff91a413da6cc75c82ef07af7baba4","138923418367b4cadabaadb48c45f03a96cfde8b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","02331260bb246364779cb6f04919ca47900d01bb"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["aba371508186796cc6151d8223a5b4e16d02e26e","02331260bb246364779cb6f04919ca47900d01bb"],"f0b2a0f7efff91a413da6cc75c82ef07af7baba4":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["fe33227f6805edab2036cbb80645cc4e2d1fa424","c638f0552fb6cb9ef3566f1eb38953ce86ee2fa3"],"0935c850ea562932997b72c69d93e345f21d7f45":["86b9dbd07cb2512df60935f96f02fd20a04927dd"],"86b9dbd07cb2512df60935f96f02fd20a04927dd":["5699a2da08aaf5a165f2ceefe7cf8f5c70a12efc"],"322360ac5185a8446d3e0b530b2068bef67cd3d5":["c638f0552fb6cb9ef3566f1eb38953ce86ee2fa3"],"203d7d3cb7712e10ef33009a63247ae40c302d7a":["9d153abcf92dc5329d98571a8c3035df9bd80648"],"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9":["d6f074e73200c07d54f242d3880a8da5a35ff97b","fb07ab105350b80ed9d63ca64b117084ed7391bc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"02331260bb246364779cb6f04919ca47900d01bb":["322360ac5185a8446d3e0b530b2068bef67cd3d5"]},"commit2Childs":{"fb07ab105350b80ed9d63ca64b117084ed7391bc":["e99275efa2c9c9ae3bdba986218af82f2bf3dc30","c7869f64c874ebf7f317d22c00baf2b6857797a6","d4d69c535930b5cce125cff868d40f6373dc27d4","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9"],"9d153abcf92dc5329d98571a8c3035df9bd80648":["203d7d3cb7712e10ef33009a63247ae40c302d7a"],"e99275efa2c9c9ae3bdba986218af82f2bf3dc30":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"5699a2da08aaf5a165f2ceefe7cf8f5c70a12efc":["86b9dbd07cb2512df60935f96f02fd20a04927dd"],"c638f0552fb6cb9ef3566f1eb38953ce86ee2fa3":["aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","322360ac5185a8446d3e0b530b2068bef67cd3d5"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["f0b2a0f7efff91a413da6cc75c82ef07af7baba4"],"aba371508186796cc6151d8223a5b4e16d02e26e":["d6f074e73200c07d54f242d3880a8da5a35ff97b"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":[],"2b4c7e630332c5e9e7d7a70f4ace4b3ffd3fc552":["fb07ab105350b80ed9d63ca64b117084ed7391bc"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"138923418367b4cadabaadb48c45f03a96cfde8b":["c638f0552fb6cb9ef3566f1eb38953ce86ee2fa3","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9d153abcf92dc5329d98571a8c3035df9bd80648","615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["c7869f64c874ebf7f317d22c00baf2b6857797a6"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9"],"f0b2a0f7efff91a413da6cc75c82ef07af7baba4":["aba371508186796cc6151d8223a5b4e16d02e26e","138923418367b4cadabaadb48c45f03a96cfde8b","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"0935c850ea562932997b72c69d93e345f21d7f45":["2b4c7e630332c5e9e7d7a70f4ace4b3ffd3fc552"],"86b9dbd07cb2512df60935f96f02fd20a04927dd":["0935c850ea562932997b72c69d93e345f21d7f45"],"203d7d3cb7712e10ef33009a63247ae40c302d7a":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"322360ac5185a8446d3e0b530b2068bef67cd3d5":["02331260bb246364779cb6f04919ca47900d01bb"],"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9":[],"02331260bb246364779cb6f04919ca47900d01bb":["5699a2da08aaf5a165f2ceefe7cf8f5c70a12efc","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c7869f64c874ebf7f317d22c00baf2b6857797a6","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}