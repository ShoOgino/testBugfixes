{"path":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#setLinear(int).mjava","commits":[{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#setLinear(int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Sets the enum to operate in linear fashion, as we have found\n   * a looping transition at position\n   */\n  private void setLinear(int position) {\n    int state = runAutomaton.getInitialState();\n    char maxInterval = 0xffff;\n    for (int i = 0; i < position; i++)\n      state = runAutomaton.step(state, utf16.result[i]);\n    for (int i = 0; i < allTransitions[state].length; i++) {\n      Transition t = allTransitions[state][i];\n      if (t.getMin() <= utf16.result[position] && utf16.result[position] <= t.getMax()) {\n        maxInterval = t.getMax();\n        break;\n      }\n    }\n    // 0xffff terms don't get the optimization... not worth the trouble.\n    if (maxInterval < 0xffff)\n      maxInterval++;\n    int length = position + 1; /* position + maxTransition */\n    if (linearUpperBoundUTF16.result.length < length)\n      linearUpperBoundUTF16.result = new char[length];\n    System.arraycopy(utf16.result, 0, linearUpperBoundUTF16.result, 0, position);\n    linearUpperBoundUTF16.result[position] = maxInterval;\n    linearUpperBoundUTF16.setLength(length);\n    UnicodeUtil.nextValidUTF16String(linearUpperBoundUTF16);\n    UnicodeUtil.UTF16toUTF8(linearUpperBoundUTF16.result, 0, length, linearUpperBound);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5acb0ee59cc50caf85402e92d148fdb2af61bc19","date":1272929037,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#setLinear(int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#setLinear(int).mjava","sourceNew":"  /**\n   * Sets the enum to operate in linear fashion, as we have found\n   * a looping transition at position\n   */\n  private void setLinear(int position) {\n    int state = runAutomaton.getInitialState();\n    int maxInterval = 0xef;\n    for (int i = 0; i < position; i++) {\n      state = runAutomaton.step(state, seekBytesRef.bytes[i] & 0xff);\n      assert state >= 0: \"state=\" + state;\n    }\n    for (int i = 0; i < allTransitions[state].length; i++) {\n      Transition t = allTransitions[state][i];\n      if (compareToUTF16(t.getMin(), (seekBytesRef.bytes[position] & 0xff)) <= 0 && \n          compareToUTF16((seekBytesRef.bytes[position] & 0xff), t.getMax()) <= 0) {\n        maxInterval = t.getMax();\n        break;\n      }\n    }\n    // 0xef terms don't get the optimization... not worth the trouble.\n    if (maxInterval != 0xef)\n      maxInterval = incrementUTF16(maxInterval);\n    int length = position + 1; /* position + maxTransition */\n    if (linearUpperBound.bytes.length < length)\n      linearUpperBound.bytes = new byte[length];\n    System.arraycopy(seekBytesRef.bytes, 0, linearUpperBound.bytes, 0, position);\n    linearUpperBound.bytes[position] = (byte) maxInterval;\n    linearUpperBound.length = length;\n  }\n\n","sourceOld":"  /**\n   * Sets the enum to operate in linear fashion, as we have found\n   * a looping transition at position\n   */\n  private void setLinear(int position) {\n    int state = runAutomaton.getInitialState();\n    char maxInterval = 0xffff;\n    for (int i = 0; i < position; i++)\n      state = runAutomaton.step(state, utf16.result[i]);\n    for (int i = 0; i < allTransitions[state].length; i++) {\n      Transition t = allTransitions[state][i];\n      if (t.getMin() <= utf16.result[position] && utf16.result[position] <= t.getMax()) {\n        maxInterval = t.getMax();\n        break;\n      }\n    }\n    // 0xffff terms don't get the optimization... not worth the trouble.\n    if (maxInterval < 0xffff)\n      maxInterval++;\n    int length = position + 1; /* position + maxTransition */\n    if (linearUpperBoundUTF16.result.length < length)\n      linearUpperBoundUTF16.result = new char[length];\n    System.arraycopy(utf16.result, 0, linearUpperBoundUTF16.result, 0, position);\n    linearUpperBoundUTF16.result[position] = maxInterval;\n    linearUpperBoundUTF16.setLength(length);\n    UnicodeUtil.nextValidUTF16String(linearUpperBoundUTF16);\n    UnicodeUtil.UTF16toUTF8(linearUpperBoundUTF16.result, 0, length, linearUpperBound);\n  }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"08932c793647a36953d1816b1060121f48820d3f","date":1277386540,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#setLinear(int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#setLinear(int).mjava","sourceNew":"  /**\n   * Sets the enum to operate in linear fashion, as we have found\n   * a looping transition at position\n   */\n  private void setLinear(int position) {\n    int state = runAutomaton.getInitialState();\n    int maxInterval = 0xef;\n    for (int i = 0; i < position; i++) {\n      state = runAutomaton.step(state, seekBytesRef.bytes[i] & 0xff);\n      assert state >= 0: \"state=\" + state;\n    }\n    for (int i = 0; i < allTransitions[state].length; i++) {\n      Transition t = allTransitions[state][i];\n      if (t.getMin() <= (seekBytesRef.bytes[position] & 0xff) && \n          (seekBytesRef.bytes[position] & 0xff) <= t.getMax()) {\n        maxInterval = t.getMax();\n        break;\n      }\n    }\n    // 0xff terms don't get the optimization... not worth the trouble.\n    if (maxInterval != 0xff)\n      maxInterval = incrementUTF8(maxInterval);\n    int length = position + 1; /* position + maxTransition */\n    if (linearUpperBound.bytes.length < length)\n      linearUpperBound.bytes = new byte[length];\n    System.arraycopy(seekBytesRef.bytes, 0, linearUpperBound.bytes, 0, position);\n    linearUpperBound.bytes[position] = (byte) maxInterval;\n    linearUpperBound.length = length;\n  }\n\n","sourceOld":"  /**\n   * Sets the enum to operate in linear fashion, as we have found\n   * a looping transition at position\n   */\n  private void setLinear(int position) {\n    int state = runAutomaton.getInitialState();\n    int maxInterval = 0xef;\n    for (int i = 0; i < position; i++) {\n      state = runAutomaton.step(state, seekBytesRef.bytes[i] & 0xff);\n      assert state >= 0: \"state=\" + state;\n    }\n    for (int i = 0; i < allTransitions[state].length; i++) {\n      Transition t = allTransitions[state][i];\n      if (compareToUTF16(t.getMin(), (seekBytesRef.bytes[position] & 0xff)) <= 0 && \n          compareToUTF16((seekBytesRef.bytes[position] & 0xff), t.getMax()) <= 0) {\n        maxInterval = t.getMax();\n        break;\n      }\n    }\n    // 0xef terms don't get the optimization... not worth the trouble.\n    if (maxInterval != 0xef)\n      maxInterval = incrementUTF16(maxInterval);\n    int length = position + 1; /* position + maxTransition */\n    if (linearUpperBound.bytes.length < length)\n      linearUpperBound.bytes = new byte[length];\n    System.arraycopy(seekBytesRef.bytes, 0, linearUpperBound.bytes, 0, position);\n    linearUpperBound.bytes[position] = (byte) maxInterval;\n    linearUpperBound.length = length;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#setLinear(int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#setLinear(int).mjava","sourceNew":"  /**\n   * Sets the enum to operate in linear fashion, as we have found\n   * a looping transition at position\n   */\n  private void setLinear(int position) {\n    int state = runAutomaton.getInitialState();\n    int maxInterval = 0xef;\n    for (int i = 0; i < position; i++) {\n      state = runAutomaton.step(state, seekBytesRef.bytes[i] & 0xff);\n      assert state >= 0: \"state=\" + state;\n    }\n    for (int i = 0; i < allTransitions[state].length; i++) {\n      Transition t = allTransitions[state][i];\n      if (t.getMin() <= (seekBytesRef.bytes[position] & 0xff) && \n          (seekBytesRef.bytes[position] & 0xff) <= t.getMax()) {\n        maxInterval = t.getMax();\n        break;\n      }\n    }\n    // 0xff terms don't get the optimization... not worth the trouble.\n    if (maxInterval != 0xff)\n      maxInterval = incrementUTF8(maxInterval);\n    int length = position + 1; /* position + maxTransition */\n    if (linearUpperBound.bytes.length < length)\n      linearUpperBound.bytes = new byte[length];\n    System.arraycopy(seekBytesRef.bytes, 0, linearUpperBound.bytes, 0, position);\n    linearUpperBound.bytes[position] = (byte) maxInterval;\n    linearUpperBound.length = length;\n  }\n\n","sourceOld":"  /**\n   * Sets the enum to operate in linear fashion, as we have found\n   * a looping transition at position\n   */\n  private void setLinear(int position) {\n    int state = runAutomaton.getInitialState();\n    int maxInterval = 0xef;\n    for (int i = 0; i < position; i++) {\n      state = runAutomaton.step(state, seekBytesRef.bytes[i] & 0xff);\n      assert state >= 0: \"state=\" + state;\n    }\n    for (int i = 0; i < allTransitions[state].length; i++) {\n      Transition t = allTransitions[state][i];\n      if (compareToUTF16(t.getMin(), (seekBytesRef.bytes[position] & 0xff)) <= 0 && \n          compareToUTF16((seekBytesRef.bytes[position] & 0xff), t.getMax()) <= 0) {\n        maxInterval = t.getMax();\n        break;\n      }\n    }\n    // 0xef terms don't get the optimization... not worth the trouble.\n    if (maxInterval != 0xef)\n      maxInterval = incrementUTF16(maxInterval);\n    int length = position + 1; /* position + maxTransition */\n    if (linearUpperBound.bytes.length < length)\n      linearUpperBound.bytes = new byte[length];\n    System.arraycopy(seekBytesRef.bytes, 0, linearUpperBound.bytes, 0, position);\n    linearUpperBound.bytes[position] = (byte) maxInterval;\n    linearUpperBound.length = length;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"780a676adba1080a3bb08ca427a08ff996227ecd","date":1285561731,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#setLinear(int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#setLinear(int).mjava","sourceNew":"  /**\n   * Sets the enum to operate in linear fashion, as we have found\n   * a looping transition at position\n   */\n  private void setLinear(int position) {\n    int state = runAutomaton.getInitialState();\n    int maxInterval = 0xff;\n    for (int i = 0; i < position; i++) {\n      state = runAutomaton.step(state, seekBytesRef.bytes[i] & 0xff);\n      assert state >= 0: \"state=\" + state;\n    }\n    for (int i = 0; i < allTransitions[state].length; i++) {\n      Transition t = allTransitions[state][i];\n      if (t.getMin() <= (seekBytesRef.bytes[position] & 0xff) && \n          (seekBytesRef.bytes[position] & 0xff) <= t.getMax()) {\n        maxInterval = t.getMax();\n        break;\n      }\n    }\n    // 0xff terms don't get the optimization... not worth the trouble.\n    if (maxInterval != 0xff)\n      maxInterval++;\n    int length = position + 1; /* position + maxTransition */\n    if (linearUpperBound.bytes.length < length)\n      linearUpperBound.bytes = new byte[length];\n    System.arraycopy(seekBytesRef.bytes, 0, linearUpperBound.bytes, 0, position);\n    linearUpperBound.bytes[position] = (byte) maxInterval;\n    linearUpperBound.length = length;\n  }\n\n","sourceOld":"  /**\n   * Sets the enum to operate in linear fashion, as we have found\n   * a looping transition at position\n   */\n  private void setLinear(int position) {\n    int state = runAutomaton.getInitialState();\n    int maxInterval = 0xef;\n    for (int i = 0; i < position; i++) {\n      state = runAutomaton.step(state, seekBytesRef.bytes[i] & 0xff);\n      assert state >= 0: \"state=\" + state;\n    }\n    for (int i = 0; i < allTransitions[state].length; i++) {\n      Transition t = allTransitions[state][i];\n      if (t.getMin() <= (seekBytesRef.bytes[position] & 0xff) && \n          (seekBytesRef.bytes[position] & 0xff) <= t.getMax()) {\n        maxInterval = t.getMax();\n        break;\n      }\n    }\n    // 0xff terms don't get the optimization... not worth the trouble.\n    if (maxInterval != 0xff)\n      maxInterval = incrementUTF8(maxInterval);\n    int length = position + 1; /* position + maxTransition */\n    if (linearUpperBound.bytes.length < length)\n      linearUpperBound.bytes = new byte[length];\n    System.arraycopy(seekBytesRef.bytes, 0, linearUpperBound.bytes, 0, position);\n    linearUpperBound.bytes[position] = (byte) maxInterval;\n    linearUpperBound.length = length;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#setLinear(int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#setLinear(int).mjava","sourceNew":"  /**\n   * Sets the enum to operate in linear fashion, as we have found\n   * a looping transition at position\n   */\n  private void setLinear(int position) {\n    int state = runAutomaton.getInitialState();\n    int maxInterval = 0xff;\n    for (int i = 0; i < position; i++) {\n      state = runAutomaton.step(state, seekBytesRef.bytes[i] & 0xff);\n      assert state >= 0: \"state=\" + state;\n    }\n    for (int i = 0; i < allTransitions[state].length; i++) {\n      Transition t = allTransitions[state][i];\n      if (t.getMin() <= (seekBytesRef.bytes[position] & 0xff) && \n          (seekBytesRef.bytes[position] & 0xff) <= t.getMax()) {\n        maxInterval = t.getMax();\n        break;\n      }\n    }\n    // 0xff terms don't get the optimization... not worth the trouble.\n    if (maxInterval != 0xff)\n      maxInterval++;\n    int length = position + 1; /* position + maxTransition */\n    if (linearUpperBound.bytes.length < length)\n      linearUpperBound.bytes = new byte[length];\n    System.arraycopy(seekBytesRef.bytes, 0, linearUpperBound.bytes, 0, position);\n    linearUpperBound.bytes[position] = (byte) maxInterval;\n    linearUpperBound.length = length;\n  }\n\n","sourceOld":"  /**\n   * Sets the enum to operate in linear fashion, as we have found\n   * a looping transition at position\n   */\n  private void setLinear(int position) {\n    int state = runAutomaton.getInitialState();\n    int maxInterval = 0xef;\n    for (int i = 0; i < position; i++) {\n      state = runAutomaton.step(state, seekBytesRef.bytes[i] & 0xff);\n      assert state >= 0: \"state=\" + state;\n    }\n    for (int i = 0; i < allTransitions[state].length; i++) {\n      Transition t = allTransitions[state][i];\n      if (t.getMin() <= (seekBytesRef.bytes[position] & 0xff) && \n          (seekBytesRef.bytes[position] & 0xff) <= t.getMax()) {\n        maxInterval = t.getMax();\n        break;\n      }\n    }\n    // 0xff terms don't get the optimization... not worth the trouble.\n    if (maxInterval != 0xff)\n      maxInterval = incrementUTF8(maxInterval);\n    int length = position + 1; /* position + maxTransition */\n    if (linearUpperBound.bytes.length < length)\n      linearUpperBound.bytes = new byte[length];\n    System.arraycopy(seekBytesRef.bytes, 0, linearUpperBound.bytes, 0, position);\n    linearUpperBound.bytes[position] = (byte) maxInterval;\n    linearUpperBound.length = length;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd75dcd3293ef3dfcd82f2259df2405d5dfe4fc7","date":1297092846,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#setLinear(int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#setLinear(int).mjava","sourceNew":"  /**\n   * Sets the enum to operate in linear fashion, as we have found\n   * a looping transition at position: we set an upper bound and \n   * act like a TermRangeQuery for this portion of the term space.\n   */\n  private void setLinear(int position) {\n    assert linear == false;\n    \n    int state = runAutomaton.getInitialState();\n    int maxInterval = 0xff;\n    for (int i = 0; i < position; i++) {\n      state = runAutomaton.step(state, seekBytesRef.bytes[i] & 0xff);\n      assert state >= 0: \"state=\" + state;\n    }\n    for (int i = 0; i < allTransitions[state].length; i++) {\n      Transition t = allTransitions[state][i];\n      if (t.getMin() <= (seekBytesRef.bytes[position] & 0xff) && \n          (seekBytesRef.bytes[position] & 0xff) <= t.getMax()) {\n        maxInterval = t.getMax();\n        break;\n      }\n    }\n    // 0xff terms don't get the optimization... not worth the trouble.\n    if (maxInterval != 0xff)\n      maxInterval++;\n    int length = position + 1; /* position + maxTransition */\n    if (linearUpperBound.bytes.length < length)\n      linearUpperBound.bytes = new byte[length];\n    System.arraycopy(seekBytesRef.bytes, 0, linearUpperBound.bytes, 0, position);\n    linearUpperBound.bytes[position] = (byte) maxInterval;\n    linearUpperBound.length = length;\n    \n    linear = true;\n  }\n\n","sourceOld":"  /**\n   * Sets the enum to operate in linear fashion, as we have found\n   * a looping transition at position\n   */\n  private void setLinear(int position) {\n    int state = runAutomaton.getInitialState();\n    int maxInterval = 0xff;\n    for (int i = 0; i < position; i++) {\n      state = runAutomaton.step(state, seekBytesRef.bytes[i] & 0xff);\n      assert state >= 0: \"state=\" + state;\n    }\n    for (int i = 0; i < allTransitions[state].length; i++) {\n      Transition t = allTransitions[state][i];\n      if (t.getMin() <= (seekBytesRef.bytes[position] & 0xff) && \n          (seekBytesRef.bytes[position] & 0xff) <= t.getMax()) {\n        maxInterval = t.getMax();\n        break;\n      }\n    }\n    // 0xff terms don't get the optimization... not worth the trouble.\n    if (maxInterval != 0xff)\n      maxInterval++;\n    int length = position + 1; /* position + maxTransition */\n    if (linearUpperBound.bytes.length < length)\n      linearUpperBound.bytes = new byte[length];\n    System.arraycopy(seekBytesRef.bytes, 0, linearUpperBound.bytes, 0, position);\n    linearUpperBound.bytes[position] = (byte) maxInterval;\n    linearUpperBound.length = length;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#setLinear(int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#setLinear(int).mjava","sourceNew":"  /**\n   * Sets the enum to operate in linear fashion, as we have found\n   * a looping transition at position: we set an upper bound and \n   * act like a TermRangeQuery for this portion of the term space.\n   */\n  private void setLinear(int position) {\n    assert linear == false;\n    \n    int state = runAutomaton.getInitialState();\n    int maxInterval = 0xff;\n    for (int i = 0; i < position; i++) {\n      state = runAutomaton.step(state, seekBytesRef.bytes[i] & 0xff);\n      assert state >= 0: \"state=\" + state;\n    }\n    for (int i = 0; i < allTransitions[state].length; i++) {\n      Transition t = allTransitions[state][i];\n      if (t.getMin() <= (seekBytesRef.bytes[position] & 0xff) && \n          (seekBytesRef.bytes[position] & 0xff) <= t.getMax()) {\n        maxInterval = t.getMax();\n        break;\n      }\n    }\n    // 0xff terms don't get the optimization... not worth the trouble.\n    if (maxInterval != 0xff)\n      maxInterval++;\n    int length = position + 1; /* position + maxTransition */\n    if (linearUpperBound.bytes.length < length)\n      linearUpperBound.bytes = new byte[length];\n    System.arraycopy(seekBytesRef.bytes, 0, linearUpperBound.bytes, 0, position);\n    linearUpperBound.bytes[position] = (byte) maxInterval;\n    linearUpperBound.length = length;\n    \n    linear = true;\n  }\n\n","sourceOld":"  /**\n   * Sets the enum to operate in linear fashion, as we have found\n   * a looping transition at position\n   */\n  private void setLinear(int position) {\n    int state = runAutomaton.getInitialState();\n    int maxInterval = 0xff;\n    for (int i = 0; i < position; i++) {\n      state = runAutomaton.step(state, seekBytesRef.bytes[i] & 0xff);\n      assert state >= 0: \"state=\" + state;\n    }\n    for (int i = 0; i < allTransitions[state].length; i++) {\n      Transition t = allTransitions[state][i];\n      if (t.getMin() <= (seekBytesRef.bytes[position] & 0xff) && \n          (seekBytesRef.bytes[position] & 0xff) <= t.getMax()) {\n        maxInterval = t.getMax();\n        break;\n      }\n    }\n    // 0xff terms don't get the optimization... not worth the trouble.\n    if (maxInterval != 0xff)\n      maxInterval++;\n    int length = position + 1; /* position + maxTransition */\n    if (linearUpperBound.bytes.length < length)\n      linearUpperBound.bytes = new byte[length];\n    System.arraycopy(seekBytesRef.bytes, 0, linearUpperBound.bytes, 0, position);\n    linearUpperBound.bytes[position] = (byte) maxInterval;\n    linearUpperBound.length = length;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#setLinear(int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#setLinear(int).mjava","sourceNew":"  /**\n   * Sets the enum to operate in linear fashion, as we have found\n   * a looping transition at position: we set an upper bound and \n   * act like a TermRangeQuery for this portion of the term space.\n   */\n  private void setLinear(int position) {\n    assert linear == false;\n    \n    int state = runAutomaton.getInitialState();\n    int maxInterval = 0xff;\n    for (int i = 0; i < position; i++) {\n      state = runAutomaton.step(state, seekBytesRef.bytes[i] & 0xff);\n      assert state >= 0: \"state=\" + state;\n    }\n    for (int i = 0; i < allTransitions[state].length; i++) {\n      Transition t = allTransitions[state][i];\n      if (t.getMin() <= (seekBytesRef.bytes[position] & 0xff) && \n          (seekBytesRef.bytes[position] & 0xff) <= t.getMax()) {\n        maxInterval = t.getMax();\n        break;\n      }\n    }\n    // 0xff terms don't get the optimization... not worth the trouble.\n    if (maxInterval != 0xff)\n      maxInterval++;\n    int length = position + 1; /* position + maxTransition */\n    if (linearUpperBound.bytes.length < length)\n      linearUpperBound.bytes = new byte[length];\n    System.arraycopy(seekBytesRef.bytes, 0, linearUpperBound.bytes, 0, position);\n    linearUpperBound.bytes[position] = (byte) maxInterval;\n    linearUpperBound.length = length;\n    \n    linear = true;\n  }\n\n","sourceOld":"  /**\n   * Sets the enum to operate in linear fashion, as we have found\n   * a looping transition at position\n   */\n  private void setLinear(int position) {\n    int state = runAutomaton.getInitialState();\n    int maxInterval = 0xff;\n    for (int i = 0; i < position; i++) {\n      state = runAutomaton.step(state, seekBytesRef.bytes[i] & 0xff);\n      assert state >= 0: \"state=\" + state;\n    }\n    for (int i = 0; i < allTransitions[state].length; i++) {\n      Transition t = allTransitions[state][i];\n      if (t.getMin() <= (seekBytesRef.bytes[position] & 0xff) && \n          (seekBytesRef.bytes[position] & 0xff) <= t.getMax()) {\n        maxInterval = t.getMax();\n        break;\n      }\n    }\n    // 0xff terms don't get the optimization... not worth the trouble.\n    if (maxInterval != 0xff)\n      maxInterval++;\n    int length = position + 1; /* position + maxTransition */\n    if (linearUpperBound.bytes.length < length)\n      linearUpperBound.bytes = new byte[length];\n    System.arraycopy(seekBytesRef.bytes, 0, linearUpperBound.bytes, 0, position);\n    linearUpperBound.bytes[position] = (byte) maxInterval;\n    linearUpperBound.length = length;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60ba444201d2570214b6fcf1d15600dc1a01f548","date":1313868045,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/AutomatonTermsEnum#setLinear(int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#setLinear(int).mjava","sourceNew":"  /**\n   * Sets the enum to operate in linear fashion, as we have found\n   * a looping transition at position: we set an upper bound and \n   * act like a TermRangeQuery for this portion of the term space.\n   */\n  private void setLinear(int position) {\n    assert linear == false;\n    \n    int state = runAutomaton.getInitialState();\n    int maxInterval = 0xff;\n    for (int i = 0; i < position; i++) {\n      state = runAutomaton.step(state, seekBytesRef.bytes[i] & 0xff);\n      assert state >= 0: \"state=\" + state;\n    }\n    for (int i = 0; i < allTransitions[state].length; i++) {\n      Transition t = allTransitions[state][i];\n      if (t.getMin() <= (seekBytesRef.bytes[position] & 0xff) && \n          (seekBytesRef.bytes[position] & 0xff) <= t.getMax()) {\n        maxInterval = t.getMax();\n        break;\n      }\n    }\n    // 0xff terms don't get the optimization... not worth the trouble.\n    if (maxInterval != 0xff)\n      maxInterval++;\n    int length = position + 1; /* position + maxTransition */\n    if (linearUpperBound.bytes.length < length)\n      linearUpperBound.bytes = new byte[length];\n    System.arraycopy(seekBytesRef.bytes, 0, linearUpperBound.bytes, 0, position);\n    linearUpperBound.bytes[position] = (byte) maxInterval;\n    linearUpperBound.length = length;\n    \n    linear = true;\n  }\n\n","sourceOld":"  /**\n   * Sets the enum to operate in linear fashion, as we have found\n   * a looping transition at position: we set an upper bound and \n   * act like a TermRangeQuery for this portion of the term space.\n   */\n  private void setLinear(int position) {\n    assert linear == false;\n    \n    int state = runAutomaton.getInitialState();\n    int maxInterval = 0xff;\n    for (int i = 0; i < position; i++) {\n      state = runAutomaton.step(state, seekBytesRef.bytes[i] & 0xff);\n      assert state >= 0: \"state=\" + state;\n    }\n    for (int i = 0; i < allTransitions[state].length; i++) {\n      Transition t = allTransitions[state][i];\n      if (t.getMin() <= (seekBytesRef.bytes[position] & 0xff) && \n          (seekBytesRef.bytes[position] & 0xff) <= t.getMax()) {\n        maxInterval = t.getMax();\n        break;\n      }\n    }\n    // 0xff terms don't get the optimization... not worth the trouble.\n    if (maxInterval != 0xff)\n      maxInterval++;\n    int length = position + 1; /* position + maxTransition */\n    if (linearUpperBound.bytes.length < length)\n      linearUpperBound.bytes = new byte[length];\n    System.arraycopy(seekBytesRef.bytes, 0, linearUpperBound.bytes, 0, position);\n    linearUpperBound.bytes[position] = (byte) maxInterval;\n    linearUpperBound.length = length;\n    \n    linear = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"60ba444201d2570214b6fcf1d15600dc1a01f548":["bd75dcd3293ef3dfcd82f2259df2405d5dfe4fc7"],"08932c793647a36953d1816b1060121f48820d3f":["5acb0ee59cc50caf85402e92d148fdb2af61bc19"],"bd75dcd3293ef3dfcd82f2259df2405d5dfe4fc7":["780a676adba1080a3bb08ca427a08ff996227ecd"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["780a676adba1080a3bb08ca427a08ff996227ecd","bd75dcd3293ef3dfcd82f2259df2405d5dfe4fc7"],"5acb0ee59cc50caf85402e92d148fdb2af61bc19":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5f4e87790277826a2aea119328600dfb07761f32":["5acb0ee59cc50caf85402e92d148fdb2af61bc19","08932c793647a36953d1816b1060121f48820d3f"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["5f4e87790277826a2aea119328600dfb07761f32","780a676adba1080a3bb08ca427a08ff996227ecd"],"780a676adba1080a3bb08ca427a08ff996227ecd":["08932c793647a36953d1816b1060121f48820d3f"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","bd75dcd3293ef3dfcd82f2259df2405d5dfe4fc7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["60ba444201d2570214b6fcf1d15600dc1a01f548"]},"commit2Childs":{"60ba444201d2570214b6fcf1d15600dc1a01f548":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"08932c793647a36953d1816b1060121f48820d3f":["5f4e87790277826a2aea119328600dfb07761f32","780a676adba1080a3bb08ca427a08ff996227ecd"],"bd75dcd3293ef3dfcd82f2259df2405d5dfe4fc7":["60ba444201d2570214b6fcf1d15600dc1a01f548","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"5acb0ee59cc50caf85402e92d148fdb2af61bc19":["08932c793647a36953d1816b1060121f48820d3f","5f4e87790277826a2aea119328600dfb07761f32"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["5acb0ee59cc50caf85402e92d148fdb2af61bc19"],"5f4e87790277826a2aea119328600dfb07761f32":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"780a676adba1080a3bb08ca427a08ff996227ecd":["bd75dcd3293ef3dfcd82f2259df2405d5dfe4fc7","29ef99d61cda9641b6250bf9567329a6e65f901d","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}