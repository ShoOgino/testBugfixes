{"path":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testIds().mjava","commits":[{"id":"e3cc329405ce41b8ef462b4cd30611eca1567620","date":1408661910,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testIds().mjava","pathOld":"/dev/null","sourceNew":"  /** Make sure we see ids per segment and per commit. */\n  public void testIds() throws Exception {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, newIndexWriterConfig(new MockAnalyzer(random())));\n    w.addDocument(new Document());\n    w.close();\n    \n    SegmentInfos sis = new SegmentInfos();\n    sis.read(d);\n    String id1 = sis.getId();\n    assertNotNull(id1);\n    \n    String id2 = sis.info(0).info.getId();\n    if (defaultCodecSupportsSegmentIds()) {\n      assertNotNull(id2);\n    } else {\n      assertNull(id2);\n    }\n\n    // Make sure CheckIndex includes id output:\n    ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n    CheckIndex checker = new CheckIndex(d);\n    checker.setCrossCheckTermVectors(false);\n    checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n    CheckIndex.Status indexStatus = checker.checkIndex(null);\n    String s = bos.toString(IOUtils.UTF_8);\n    // Make sure CheckIndex didn't fail\n    assertTrue(s, indexStatus != null && indexStatus.clean);\n\n    // Commit id is always stored:\n    assertTrue(\"missing id=\" + id1 + \" in:\\n\" + s, s.contains(\"id=\" + id1));\n\n    // Per-segment id may or may not be stored depending on the codec:\n    if (defaultCodecSupportsSegmentIds()) {\n      assertTrue(\"missing id=\" + id2 + \" in:\\n\" + s, s.contains(\"id=\" + id2));\n    } else {\n      assertTrue(\"missing id=null in:\\n\" + s, s.contains(\"id=null\"));\n    }\n    d.close();\n\n    Set<String> ids = new HashSet<>();\n    for(int i=0;i<100000;i++) {\n      String id = StringHelper.randomId();\n      assertFalse(\"id=\" + id + \" i=\" + i, ids.contains(id));\n      ids.add(id);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["5f6bd27530a2846413fe2d00030493c0e2d3a072","402ad3ddc9da7b70da1b167667a60ece6a1381fb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad2a673349939e48652bf304cccf673c3412198f","date":1409585169,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testIds().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testIds().mjava","sourceNew":"  /** Make sure we see ids per segment and per commit. */\n  public void testIds() throws Exception {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, newIndexWriterConfig(new MockAnalyzer(random())));\n    w.addDocument(new Document());\n    w.close();\n    \n    SegmentInfos sis = new SegmentInfos();\n    sis.read(d);\n    String id1 = sis.getId();\n    assertNotNull(id1);\n    \n    String id2 = sis.info(0).info.getId();\n    assertNotNull(id2);\n\n    // Make sure CheckIndex includes id output:\n    ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n    CheckIndex checker = new CheckIndex(d);\n    checker.setCrossCheckTermVectors(false);\n    checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n    CheckIndex.Status indexStatus = checker.checkIndex(null);\n    String s = bos.toString(IOUtils.UTF_8);\n    // Make sure CheckIndex didn't fail\n    assertTrue(s, indexStatus != null && indexStatus.clean);\n\n    // Commit id is always stored:\n    assertTrue(\"missing id=\" + id1 + \" in:\\n\" + s, s.contains(\"id=\" + id1));\n\n    assertTrue(\"missing id=\" + id2 + \" in:\\n\" + s, s.contains(\"id=\" + id2));\n    d.close();\n\n    Set<String> ids = new HashSet<>();\n    for(int i=0;i<100000;i++) {\n      String id = StringHelper.randomId();\n      assertFalse(\"id=\" + id + \" i=\" + i, ids.contains(id));\n      ids.add(id);\n    }\n  }\n\n","sourceOld":"  /** Make sure we see ids per segment and per commit. */\n  public void testIds() throws Exception {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, newIndexWriterConfig(new MockAnalyzer(random())));\n    w.addDocument(new Document());\n    w.close();\n    \n    SegmentInfos sis = new SegmentInfos();\n    sis.read(d);\n    String id1 = sis.getId();\n    assertNotNull(id1);\n    \n    String id2 = sis.info(0).info.getId();\n    if (defaultCodecSupportsSegmentIds()) {\n      assertNotNull(id2);\n    } else {\n      assertNull(id2);\n    }\n\n    // Make sure CheckIndex includes id output:\n    ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n    CheckIndex checker = new CheckIndex(d);\n    checker.setCrossCheckTermVectors(false);\n    checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n    CheckIndex.Status indexStatus = checker.checkIndex(null);\n    String s = bos.toString(IOUtils.UTF_8);\n    // Make sure CheckIndex didn't fail\n    assertTrue(s, indexStatus != null && indexStatus.clean);\n\n    // Commit id is always stored:\n    assertTrue(\"missing id=\" + id1 + \" in:\\n\" + s, s.contains(\"id=\" + id1));\n\n    // Per-segment id may or may not be stored depending on the codec:\n    if (defaultCodecSupportsSegmentIds()) {\n      assertTrue(\"missing id=\" + id2 + \" in:\\n\" + s, s.contains(\"id=\" + id2));\n    } else {\n      assertTrue(\"missing id=null in:\\n\" + s, s.contains(\"id=null\"));\n    }\n    d.close();\n\n    Set<String> ids = new HashSet<>();\n    for(int i=0;i<100000;i++) {\n      String id = StringHelper.randomId();\n      assertFalse(\"id=\" + id + \" i=\" + i, ids.contains(id));\n      ids.add(id);\n    }\n  }\n\n","bugFix":null,"bugIntro":["5f6bd27530a2846413fe2d00030493c0e2d3a072"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"402ad3ddc9da7b70da1b167667a60ece6a1381fb","date":1409656478,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testIds().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testIds().mjava","sourceNew":"  /** Make sure we see ids per segment and per commit. */\n  public void testIds() throws Exception {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, newIndexWriterConfig(new MockAnalyzer(random())));\n    w.addDocument(new Document());\n    w.close();\n    \n    SegmentInfos sis = new SegmentInfos();\n    sis.read(d);\n    String id1 = sis.getId();\n    assertNotNull(id1);\n    \n    String id2 = sis.info(0).info.getId();\n    assertNotNull(id2);\n\n    // Make sure CheckIndex includes id output:\n    ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n    CheckIndex checker = new CheckIndex(d);\n    checker.setCrossCheckTermVectors(false);\n    checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n    CheckIndex.Status indexStatus = checker.checkIndex(null);\n    String s = bos.toString(IOUtils.UTF_8);\n    // Make sure CheckIndex didn't fail\n    assertTrue(s, indexStatus != null && indexStatus.clean);\n\n    // Commit id is always stored:\n    assertTrue(\"missing id=\" + id1 + \" in:\\n\" + s, s.contains(\"id=\" + id1));\n\n    assertTrue(\"missing id=\" + id2 + \" in:\\n\" + s, s.contains(\"id=\" + id2));\n    d.close();\n\n    Set<String> ids = new HashSet<>();\n    for(int i=0;i<100000;i++) {\n      String id = StringHelper.randomId();\n      assertFalse(\"id=\" + id + \" i=\" + i, ids.contains(id));\n      ids.add(id);\n    }\n  }\n\n","sourceOld":"  /** Make sure we see ids per segment and per commit. */\n  public void testIds() throws Exception {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, newIndexWriterConfig(new MockAnalyzer(random())));\n    w.addDocument(new Document());\n    w.close();\n    \n    SegmentInfos sis = new SegmentInfos();\n    sis.read(d);\n    String id1 = sis.getId();\n    assertNotNull(id1);\n    \n    String id2 = sis.info(0).info.getId();\n    if (defaultCodecSupportsSegmentIds()) {\n      assertNotNull(id2);\n    } else {\n      assertNull(id2);\n    }\n\n    // Make sure CheckIndex includes id output:\n    ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n    CheckIndex checker = new CheckIndex(d);\n    checker.setCrossCheckTermVectors(false);\n    checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n    CheckIndex.Status indexStatus = checker.checkIndex(null);\n    String s = bos.toString(IOUtils.UTF_8);\n    // Make sure CheckIndex didn't fail\n    assertTrue(s, indexStatus != null && indexStatus.clean);\n\n    // Commit id is always stored:\n    assertTrue(\"missing id=\" + id1 + \" in:\\n\" + s, s.contains(\"id=\" + id1));\n\n    // Per-segment id may or may not be stored depending on the codec:\n    if (defaultCodecSupportsSegmentIds()) {\n      assertTrue(\"missing id=\" + id2 + \" in:\\n\" + s, s.contains(\"id=\" + id2));\n    } else {\n      assertTrue(\"missing id=null in:\\n\" + s, s.contains(\"id=null\"));\n    }\n    d.close();\n\n    Set<String> ids = new HashSet<>();\n    for(int i=0;i<100000;i++) {\n      String id = StringHelper.randomId();\n      assertFalse(\"id=\" + id + \" i=\" + i, ids.contains(id));\n      ids.add(id);\n    }\n  }\n\n","bugFix":["e3cc329405ce41b8ef462b4cd30611eca1567620"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a5d957b3a23cce91c77a2c9971ecf0c9f99dd503","date":1411708843,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testIds().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testIds().mjava","sourceNew":"  /** Make sure we see ids per segment and per commit. */\n  public void testIds() throws Exception {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, newIndexWriterConfig(new MockAnalyzer(random())));\n    w.addDocument(new Document());\n    w.close();\n    \n    SegmentInfos sis = new SegmentInfos();\n    sis.read(d);\n    byte[] id1 = sis.getId();\n    assertNotNull(id1);\n    assertEquals(StringHelper.ID_LENGTH, id1.length);\n    \n    byte[] id2 = sis.info(0).info.getId();\n    assertNotNull(id2);\n    assertEquals(StringHelper.ID_LENGTH, id2.length);\n\n    // Make sure CheckIndex includes id output:\n    ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n    CheckIndex checker = new CheckIndex(d);\n    checker.setCrossCheckTermVectors(false);\n    checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n    CheckIndex.Status indexStatus = checker.checkIndex(null);\n    String s = bos.toString(IOUtils.UTF_8);\n    // Make sure CheckIndex didn't fail\n    assertTrue(s, indexStatus != null && indexStatus.clean);\n\n    // Commit id is always stored:\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n    d.close();\n\n    Set<String> ids = new HashSet<>();\n    for(int i=0;i<100000;i++) {\n      String id = StringHelper.idToString(StringHelper.randomId());\n      assertFalse(\"id=\" + id + \" i=\" + i, ids.contains(id));\n      ids.add(id);\n    }\n  }\n\n","sourceOld":"  /** Make sure we see ids per segment and per commit. */\n  public void testIds() throws Exception {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, newIndexWriterConfig(new MockAnalyzer(random())));\n    w.addDocument(new Document());\n    w.close();\n    \n    SegmentInfos sis = new SegmentInfos();\n    sis.read(d);\n    String id1 = sis.getId();\n    assertNotNull(id1);\n    \n    String id2 = sis.info(0).info.getId();\n    assertNotNull(id2);\n\n    // Make sure CheckIndex includes id output:\n    ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n    CheckIndex checker = new CheckIndex(d);\n    checker.setCrossCheckTermVectors(false);\n    checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n    CheckIndex.Status indexStatus = checker.checkIndex(null);\n    String s = bos.toString(IOUtils.UTF_8);\n    // Make sure CheckIndex didn't fail\n    assertTrue(s, indexStatus != null && indexStatus.clean);\n\n    // Commit id is always stored:\n    assertTrue(\"missing id=\" + id1 + \" in:\\n\" + s, s.contains(\"id=\" + id1));\n\n    assertTrue(\"missing id=\" + id2 + \" in:\\n\" + s, s.contains(\"id=\" + id2));\n    d.close();\n\n    Set<String> ids = new HashSet<>();\n    for(int i=0;i<100000;i++) {\n      String id = StringHelper.randomId();\n      assertFalse(\"id=\" + id + \" i=\" + i, ids.contains(id));\n      ids.add(id);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5f6bd27530a2846413fe2d00030493c0e2d3a072","date":1411811855,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testIds().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testIds().mjava","sourceNew":"  /** Make sure we see ids per segment and per commit. */\n  public void testIds() throws Exception {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, newIndexWriterConfig(new MockAnalyzer(random())));\n    w.addDocument(new Document());\n    w.close();\n    \n    SegmentInfos sis = new SegmentInfos();\n    sis.read(d);\n    byte[] id1 = sis.getId();\n    assertNotNull(id1);\n    assertEquals(StringHelper.ID_LENGTH, id1.length);\n    \n    byte[] id2 = sis.info(0).info.getId();\n    assertNotNull(id2);\n    assertEquals(StringHelper.ID_LENGTH, id2.length);\n\n    // Make sure CheckIndex includes id output:\n    ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n    CheckIndex checker = new CheckIndex(d);\n    checker.setCrossCheckTermVectors(false);\n    checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n    CheckIndex.Status indexStatus = checker.checkIndex(null);\n    String s = bos.toString(IOUtils.UTF_8);\n    // Make sure CheckIndex didn't fail\n    assertTrue(s, indexStatus != null && indexStatus.clean);\n\n    // Commit id is always stored:\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n    d.close();\n\n    Set<String> ids = new HashSet<>();\n    for(int i=0;i<100000;i++) {\n      String id = StringHelper.idToString(StringHelper.randomId());\n      assertFalse(\"id=\" + id + \" i=\" + i, ids.contains(id));\n      ids.add(id);\n    }\n  }\n\n","sourceOld":"  /** Make sure we see ids per segment and per commit. */\n  public void testIds() throws Exception {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, newIndexWriterConfig(new MockAnalyzer(random())));\n    w.addDocument(new Document());\n    w.close();\n    \n    SegmentInfos sis = new SegmentInfos();\n    sis.read(d);\n    String id1 = sis.getId();\n    assertNotNull(id1);\n    \n    String id2 = sis.info(0).info.getId();\n    assertNotNull(id2);\n\n    // Make sure CheckIndex includes id output:\n    ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n    CheckIndex checker = new CheckIndex(d);\n    checker.setCrossCheckTermVectors(false);\n    checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n    CheckIndex.Status indexStatus = checker.checkIndex(null);\n    String s = bos.toString(IOUtils.UTF_8);\n    // Make sure CheckIndex didn't fail\n    assertTrue(s, indexStatus != null && indexStatus.clean);\n\n    // Commit id is always stored:\n    assertTrue(\"missing id=\" + id1 + \" in:\\n\" + s, s.contains(\"id=\" + id1));\n\n    assertTrue(\"missing id=\" + id2 + \" in:\\n\" + s, s.contains(\"id=\" + id2));\n    d.close();\n\n    Set<String> ids = new HashSet<>();\n    for(int i=0;i<100000;i++) {\n      String id = StringHelper.randomId();\n      assertFalse(\"id=\" + id + \" i=\" + i, ids.contains(id));\n      ids.add(id);\n    }\n  }\n\n","bugFix":["e3cc329405ce41b8ef462b4cd30611eca1567620","ad2a673349939e48652bf304cccf673c3412198f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7523916a1350712e1ae710affd4e88ccd7c431d","date":1412161942,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testIds().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testIds().mjava","sourceNew":"  /** Make sure we see ids per segment and per commit. */\n  public void testIds() throws Exception {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, newIndexWriterConfig(new MockAnalyzer(random())));\n    w.addDocument(new Document());\n    w.close();\n    \n    SegmentInfos sis = new SegmentInfos();\n    sis.read(d);\n    byte[] id1 = sis.getId();\n    assertNotNull(id1);\n    assertEquals(StringHelper.ID_LENGTH, id1.length);\n    \n    byte[] id2 = sis.info(0).info.getId();\n    assertNotNull(id2);\n    assertEquals(StringHelper.ID_LENGTH, id2.length);\n\n    // Make sure CheckIndex includes id output:\n    ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n    CheckIndex checker = new CheckIndex(d);\n    checker.setCrossCheckTermVectors(false);\n    checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n    CheckIndex.Status indexStatus = checker.checkIndex(null);\n    String s = bos.toString(IOUtils.UTF_8);\n    checker.close();\n    // Make sure CheckIndex didn't fail\n    assertTrue(s, indexStatus != null && indexStatus.clean);\n\n    // Commit id is always stored:\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n    d.close();\n\n    Set<String> ids = new HashSet<>();\n    for(int i=0;i<100000;i++) {\n      String id = StringHelper.idToString(StringHelper.randomId());\n      assertFalse(\"id=\" + id + \" i=\" + i, ids.contains(id));\n      ids.add(id);\n    }\n  }\n\n","sourceOld":"  /** Make sure we see ids per segment and per commit. */\n  public void testIds() throws Exception {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, newIndexWriterConfig(new MockAnalyzer(random())));\n    w.addDocument(new Document());\n    w.close();\n    \n    SegmentInfos sis = new SegmentInfos();\n    sis.read(d);\n    byte[] id1 = sis.getId();\n    assertNotNull(id1);\n    assertEquals(StringHelper.ID_LENGTH, id1.length);\n    \n    byte[] id2 = sis.info(0).info.getId();\n    assertNotNull(id2);\n    assertEquals(StringHelper.ID_LENGTH, id2.length);\n\n    // Make sure CheckIndex includes id output:\n    ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n    CheckIndex checker = new CheckIndex(d);\n    checker.setCrossCheckTermVectors(false);\n    checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n    CheckIndex.Status indexStatus = checker.checkIndex(null);\n    String s = bos.toString(IOUtils.UTF_8);\n    // Make sure CheckIndex didn't fail\n    assertTrue(s, indexStatus != null && indexStatus.clean);\n\n    // Commit id is always stored:\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n    d.close();\n\n    Set<String> ids = new HashSet<>();\n    for(int i=0;i<100000;i++) {\n      String id = StringHelper.idToString(StringHelper.randomId());\n      assertFalse(\"id=\" + id + \" i=\" + i, ids.contains(id));\n      ids.add(id);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9a47902d6207303f5ed3e7aaca62ca33433af66","date":1412435312,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testIds().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testIds().mjava","sourceNew":"  /** Make sure we see ids per segment and per commit. */\n  public void testIds() throws Exception {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, newIndexWriterConfig(new MockAnalyzer(random())));\n    w.addDocument(new Document());\n    w.close();\n    \n    SegmentInfos sis = new SegmentInfos();\n    sis.read(d);\n    byte[] id1 = sis.getId();\n    assertNotNull(id1);\n    assertEquals(StringHelper.ID_LENGTH, id1.length);\n    \n    byte[] id2 = sis.info(0).info.getId();\n    assertNotNull(id2);\n    assertEquals(StringHelper.ID_LENGTH, id2.length);\n\n    // Make sure CheckIndex includes id output:\n    ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n    CheckIndex checker = new CheckIndex(d);\n    checker.setCrossCheckTermVectors(false);\n    checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n    CheckIndex.Status indexStatus = checker.checkIndex(null);\n    String s = bos.toString(IOUtils.UTF_8);\n    checker.close();\n    // Make sure CheckIndex didn't fail\n    assertTrue(s, indexStatus != null && indexStatus.clean);\n\n    // Commit id is always stored:\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n    d.close();\n\n    Set<String> ids = new HashSet<>();\n    for(int i=0;i<100000;i++) {\n      String id = StringHelper.idToString(StringHelper.randomId());\n      assertFalse(\"id=\" + id + \" i=\" + i, ids.contains(id));\n      ids.add(id);\n    }\n  }\n\n","sourceOld":"  /** Make sure we see ids per segment and per commit. */\n  public void testIds() throws Exception {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, newIndexWriterConfig(new MockAnalyzer(random())));\n    w.addDocument(new Document());\n    w.close();\n    \n    SegmentInfos sis = new SegmentInfos();\n    sis.read(d);\n    byte[] id1 = sis.getId();\n    assertNotNull(id1);\n    assertEquals(StringHelper.ID_LENGTH, id1.length);\n    \n    byte[] id2 = sis.info(0).info.getId();\n    assertNotNull(id2);\n    assertEquals(StringHelper.ID_LENGTH, id2.length);\n\n    // Make sure CheckIndex includes id output:\n    ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n    CheckIndex checker = new CheckIndex(d);\n    checker.setCrossCheckTermVectors(false);\n    checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n    CheckIndex.Status indexStatus = checker.checkIndex(null);\n    String s = bos.toString(IOUtils.UTF_8);\n    // Make sure CheckIndex didn't fail\n    assertTrue(s, indexStatus != null && indexStatus.clean);\n\n    // Commit id is always stored:\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n    d.close();\n\n    Set<String> ids = new HashSet<>();\n    for(int i=0;i<100000;i++) {\n      String id = StringHelper.idToString(StringHelper.randomId());\n      assertFalse(\"id=\" + id + \" i=\" + i, ids.contains(id));\n      ids.add(id);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3384e6013a93e4d11b7d75388693f8d0388602bf","date":1413951663,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testIds().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testIds().mjava","sourceNew":"  /** Make sure we see ids per segment and per commit. */\n  public void testIds() throws Exception {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, newIndexWriterConfig(new MockAnalyzer(random())));\n    w.addDocument(new Document());\n    w.close();\n    \n    SegmentInfos sis = SegmentInfos.readLatestCommit(d);\n    byte[] id1 = sis.getId();\n    assertNotNull(id1);\n    assertEquals(StringHelper.ID_LENGTH, id1.length);\n    \n    byte[] id2 = sis.info(0).info.getId();\n    assertNotNull(id2);\n    assertEquals(StringHelper.ID_LENGTH, id2.length);\n\n    // Make sure CheckIndex includes id output:\n    ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n    CheckIndex checker = new CheckIndex(d);\n    checker.setCrossCheckTermVectors(false);\n    checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n    CheckIndex.Status indexStatus = checker.checkIndex(null);\n    String s = bos.toString(IOUtils.UTF_8);\n    checker.close();\n    // Make sure CheckIndex didn't fail\n    assertTrue(s, indexStatus != null && indexStatus.clean);\n\n    // Commit id is always stored:\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n    d.close();\n\n    Set<String> ids = new HashSet<>();\n    for(int i=0;i<100000;i++) {\n      String id = StringHelper.idToString(StringHelper.randomId());\n      assertFalse(\"id=\" + id + \" i=\" + i, ids.contains(id));\n      ids.add(id);\n    }\n  }\n\n","sourceOld":"  /** Make sure we see ids per segment and per commit. */\n  public void testIds() throws Exception {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, newIndexWriterConfig(new MockAnalyzer(random())));\n    w.addDocument(new Document());\n    w.close();\n    \n    SegmentInfos sis = new SegmentInfos();\n    sis.read(d);\n    byte[] id1 = sis.getId();\n    assertNotNull(id1);\n    assertEquals(StringHelper.ID_LENGTH, id1.length);\n    \n    byte[] id2 = sis.info(0).info.getId();\n    assertNotNull(id2);\n    assertEquals(StringHelper.ID_LENGTH, id2.length);\n\n    // Make sure CheckIndex includes id output:\n    ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n    CheckIndex checker = new CheckIndex(d);\n    checker.setCrossCheckTermVectors(false);\n    checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n    CheckIndex.Status indexStatus = checker.checkIndex(null);\n    String s = bos.toString(IOUtils.UTF_8);\n    checker.close();\n    // Make sure CheckIndex didn't fail\n    assertTrue(s, indexStatus != null && indexStatus.clean);\n\n    // Commit id is always stored:\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n    d.close();\n\n    Set<String> ids = new HashSet<>();\n    for(int i=0;i<100000;i++) {\n      String id = StringHelper.idToString(StringHelper.randomId());\n      assertFalse(\"id=\" + id + \" i=\" + i, ids.contains(id));\n      ids.add(id);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db68c63cbfaa8698b9c4475f75ed2b9c9696d238","date":1414118621,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testIds().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testIds().mjava","sourceNew":"  /** Make sure we see ids per segment and per commit. */\n  public void testIds() throws Exception {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, newIndexWriterConfig(new MockAnalyzer(random())));\n    w.addDocument(new Document());\n    w.close();\n    \n    SegmentInfos sis = SegmentInfos.readLatestCommit(d);\n    byte[] id1 = sis.getId();\n    assertNotNull(id1);\n    assertEquals(StringHelper.ID_LENGTH, id1.length);\n    \n    byte[] id2 = sis.info(0).info.getId();\n    assertNotNull(id2);\n    assertEquals(StringHelper.ID_LENGTH, id2.length);\n\n    // Make sure CheckIndex includes id output:\n    ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n    CheckIndex checker = new CheckIndex(d);\n    checker.setCrossCheckTermVectors(false);\n    checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n    CheckIndex.Status indexStatus = checker.checkIndex(null);\n    String s = bos.toString(IOUtils.UTF_8);\n    checker.close();\n    // Make sure CheckIndex didn't fail\n    assertTrue(s, indexStatus != null && indexStatus.clean);\n\n    // Commit id is always stored:\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n    d.close();\n\n    Set<String> ids = new HashSet<>();\n    for(int i=0;i<100000;i++) {\n      String id = StringHelper.idToString(StringHelper.randomId());\n      assertFalse(\"id=\" + id + \" i=\" + i, ids.contains(id));\n      ids.add(id);\n    }\n  }\n\n","sourceOld":"  /** Make sure we see ids per segment and per commit. */\n  public void testIds() throws Exception {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, newIndexWriterConfig(new MockAnalyzer(random())));\n    w.addDocument(new Document());\n    w.close();\n    \n    SegmentInfos sis = new SegmentInfos();\n    sis.read(d);\n    byte[] id1 = sis.getId();\n    assertNotNull(id1);\n    assertEquals(StringHelper.ID_LENGTH, id1.length);\n    \n    byte[] id2 = sis.info(0).info.getId();\n    assertNotNull(id2);\n    assertEquals(StringHelper.ID_LENGTH, id2.length);\n\n    // Make sure CheckIndex includes id output:\n    ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n    CheckIndex checker = new CheckIndex(d);\n    checker.setCrossCheckTermVectors(false);\n    checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n    CheckIndex.Status indexStatus = checker.checkIndex(null);\n    String s = bos.toString(IOUtils.UTF_8);\n    checker.close();\n    // Make sure CheckIndex didn't fail\n    assertTrue(s, indexStatus != null && indexStatus.clean);\n\n    // Commit id is always stored:\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n    d.close();\n\n    Set<String> ids = new HashSet<>();\n    for(int i=0;i<100000;i++) {\n      String id = StringHelper.idToString(StringHelper.randomId());\n      assertFalse(\"id=\" + id + \" i=\" + i, ids.contains(id));\n      ids.add(id);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9a0e5953a07337cd41bcde610503024c07073b26","date":1519143251,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testIds().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testIds().mjava","sourceNew":"  /** Make sure we see ids per segment and per commit. */\n  public void testIds() throws Exception {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, newIndexWriterConfig(new MockAnalyzer(random())));\n    w.addDocument(new Document());\n    w.close();\n    \n    SegmentInfos sis = SegmentInfos.readLatestCommit(d);\n    byte[] id1 = sis.getId();\n    assertNotNull(id1);\n    assertEquals(StringHelper.ID_LENGTH, id1.length);\n    \n    byte[] id2 = sis.info(0).info.getId();\n    assertNotNull(id2);\n    assertEquals(StringHelper.ID_LENGTH, id2.length);\n\n    // Make sure CheckIndex includes id output:\n    ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n    CheckIndex checker = new CheckIndex(d);\n    checker.setDoSlowChecks(false);\n    checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n    CheckIndex.Status indexStatus = checker.checkIndex(null);\n    String s = bos.toString(IOUtils.UTF_8);\n    checker.close();\n    // Make sure CheckIndex didn't fail\n    assertTrue(s, indexStatus != null && indexStatus.clean);\n\n    // Commit id is always stored:\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n    d.close();\n\n    Set<String> ids = new HashSet<>();\n    for(int i=0;i<100000;i++) {\n      String id = StringHelper.idToString(StringHelper.randomId());\n      assertFalse(\"id=\" + id + \" i=\" + i, ids.contains(id));\n      ids.add(id);\n    }\n  }\n\n","sourceOld":"  /** Make sure we see ids per segment and per commit. */\n  public void testIds() throws Exception {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, newIndexWriterConfig(new MockAnalyzer(random())));\n    w.addDocument(new Document());\n    w.close();\n    \n    SegmentInfos sis = SegmentInfos.readLatestCommit(d);\n    byte[] id1 = sis.getId();\n    assertNotNull(id1);\n    assertEquals(StringHelper.ID_LENGTH, id1.length);\n    \n    byte[] id2 = sis.info(0).info.getId();\n    assertNotNull(id2);\n    assertEquals(StringHelper.ID_LENGTH, id2.length);\n\n    // Make sure CheckIndex includes id output:\n    ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n    CheckIndex checker = new CheckIndex(d);\n    checker.setCrossCheckTermVectors(false);\n    checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n    CheckIndex.Status indexStatus = checker.checkIndex(null);\n    String s = bos.toString(IOUtils.UTF_8);\n    checker.close();\n    // Make sure CheckIndex didn't fail\n    assertTrue(s, indexStatus != null && indexStatus.clean);\n\n    // Commit id is always stored:\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n    d.close();\n\n    Set<String> ids = new HashSet<>();\n    for(int i=0;i<100000;i++) {\n      String id = StringHelper.idToString(StringHelper.randomId());\n      assertFalse(\"id=\" + id + \" i=\" + i, ids.contains(id));\n      ids.add(id);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14654be3f7a82c9a3c52169e365baa55bfe64f66","date":1587212697,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testIds().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testIds().mjava","sourceNew":"  /** Make sure we see ids per segment and per commit. */\n  public void testIds() throws Exception {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, newIndexWriterConfig(new MockAnalyzer(random())));\n    w.addDocument(new Document());\n    w.close();\n    \n    SegmentInfos sis = SegmentInfos.readLatestCommit(d);\n    byte[] id1 = sis.getId();\n    assertNotNull(id1);\n    assertEquals(StringHelper.ID_LENGTH, id1.length);\n    \n    byte[] id2 = sis.info(0).info.getId();\n    byte[] sciId2 = sis.info(0).getId();\n    assertNotNull(id2);\n    assertNotNull(sciId2);\n    assertEquals(StringHelper.ID_LENGTH, id2.length);\n    assertEquals(StringHelper.ID_LENGTH, sciId2.length);\n\n    // Make sure CheckIndex includes id output:\n    ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n    CheckIndex checker = new CheckIndex(d);\n    checker.setDoSlowChecks(false);\n    checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n    CheckIndex.Status indexStatus = checker.checkIndex(null);\n    String s = bos.toString(IOUtils.UTF_8);\n    checker.close();\n    // Make sure CheckIndex didn't fail\n    assertTrue(s, indexStatus != null && indexStatus.clean);\n\n    // Commit id is always stored:\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n    d.close();\n\n    Set<String> ids = new HashSet<>();\n    for(int i=0;i<100000;i++) {\n      String id = StringHelper.idToString(StringHelper.randomId());\n      assertFalse(\"id=\" + id + \" i=\" + i, ids.contains(id));\n      ids.add(id);\n    }\n  }\n\n","sourceOld":"  /** Make sure we see ids per segment and per commit. */\n  public void testIds() throws Exception {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, newIndexWriterConfig(new MockAnalyzer(random())));\n    w.addDocument(new Document());\n    w.close();\n    \n    SegmentInfos sis = SegmentInfos.readLatestCommit(d);\n    byte[] id1 = sis.getId();\n    assertNotNull(id1);\n    assertEquals(StringHelper.ID_LENGTH, id1.length);\n    \n    byte[] id2 = sis.info(0).info.getId();\n    assertNotNull(id2);\n    assertEquals(StringHelper.ID_LENGTH, id2.length);\n\n    // Make sure CheckIndex includes id output:\n    ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n    CheckIndex checker = new CheckIndex(d);\n    checker.setDoSlowChecks(false);\n    checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n    CheckIndex.Status indexStatus = checker.checkIndex(null);\n    String s = bos.toString(IOUtils.UTF_8);\n    checker.close();\n    // Make sure CheckIndex didn't fail\n    assertTrue(s, indexStatus != null && indexStatus.clean);\n\n    // Commit id is always stored:\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n    d.close();\n\n    Set<String> ids = new HashSet<>();\n    for(int i=0;i<100000;i++) {\n      String id = StringHelper.idToString(StringHelper.randomId());\n      assertFalse(\"id=\" + id + \" i=\" + i, ids.contains(id));\n      ids.add(id);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe39f1a106531207c028defebbc9eb5bb489ac50","date":1592513789,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testIds().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testIds().mjava","sourceNew":"  /** Make sure we see ids per segment and per commit. */\n  public void testIds() throws Exception {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, newIndexWriterConfig(new MockAnalyzer(random())));\n    w.addDocument(new Document());\n    w.close();\n\n    SegmentInfos sis = SegmentInfos.readLatestCommit(d);\n    byte[] id1 = sis.getId();\n    assertNotNull(id1);\n    assertEquals(StringHelper.ID_LENGTH, id1.length);\n\n    byte[] id2 = sis.info(0).info.getId();\n    byte[] sciId2 = sis.info(0).getId();\n    assertNotNull(id2);\n    assertNotNull(sciId2);\n    assertEquals(StringHelper.ID_LENGTH, id2.length);\n    assertEquals(StringHelper.ID_LENGTH, sciId2.length);\n\n    // Make sure CheckIndex includes id output:\n    ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n    CheckIndex checker = new CheckIndex(d);\n    checker.setDoSlowChecks(false);\n    checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n    CheckIndex.Status indexStatus = checker.checkIndex(null);\n    String s = bos.toString(IOUtils.UTF_8);\n    checker.close();\n    // Make sure CheckIndex didn't fail\n    assertTrue(s, indexStatus != null && indexStatus.clean);\n\n    // Commit id is always stored:\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n    d.close();\n\n    Set<String> ids = new HashSet<>();\n    for(int i=0;i<100000;i++) {\n      String id = StringHelper.idToString(StringHelper.randomId());\n      assertFalse(\"id=\" + id + \" i=\" + i, ids.contains(id));\n      ids.add(id);\n    }\n  }\n\n","sourceOld":"  /** Make sure we see ids per segment and per commit. */\n  public void testIds() throws Exception {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, newIndexWriterConfig(new MockAnalyzer(random())));\n    w.addDocument(new Document());\n    w.close();\n    \n    SegmentInfos sis = SegmentInfos.readLatestCommit(d);\n    byte[] id1 = sis.getId();\n    assertNotNull(id1);\n    assertEquals(StringHelper.ID_LENGTH, id1.length);\n    \n    byte[] id2 = sis.info(0).info.getId();\n    byte[] sciId2 = sis.info(0).getId();\n    assertNotNull(id2);\n    assertNotNull(sciId2);\n    assertEquals(StringHelper.ID_LENGTH, id2.length);\n    assertEquals(StringHelper.ID_LENGTH, sciId2.length);\n\n    // Make sure CheckIndex includes id output:\n    ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n    CheckIndex checker = new CheckIndex(d);\n    checker.setDoSlowChecks(false);\n    checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n    CheckIndex.Status indexStatus = checker.checkIndex(null);\n    String s = bos.toString(IOUtils.UTF_8);\n    checker.close();\n    // Make sure CheckIndex didn't fail\n    assertTrue(s, indexStatus != null && indexStatus.clean);\n\n    // Commit id is always stored:\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n    d.close();\n\n    Set<String> ids = new HashSet<>();\n    for(int i=0;i<100000;i++) {\n      String id = StringHelper.idToString(StringHelper.randomId());\n      assertFalse(\"id=\" + id + \" i=\" + i, ids.contains(id));\n      ids.add(id);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1182fe36fb5df768dc2da53f6d5338cbc07268ae","date":1592861749,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testIds().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testIds().mjava","sourceNew":"  /** Make sure we see ids per segment and per commit. */\n  public void testIds() throws Exception {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, newIndexWriterConfig(new MockAnalyzer(random())));\n    w.addDocument(new Document());\n    w.close();\n    \n    SegmentInfos sis = SegmentInfos.readLatestCommit(d);\n    byte[] id1 = sis.getId();\n    assertNotNull(id1);\n    assertEquals(StringHelper.ID_LENGTH, id1.length);\n    \n    byte[] id2 = sis.info(0).info.getId();\n    byte[] sciId2 = sis.info(0).getId();\n    assertNotNull(id2);\n    assertNotNull(sciId2);\n    assertEquals(StringHelper.ID_LENGTH, id2.length);\n    assertEquals(StringHelper.ID_LENGTH, sciId2.length);\n\n    // Make sure CheckIndex includes id output:\n    ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n    CheckIndex checker = new CheckIndex(d);\n    checker.setDoSlowChecks(false);\n    checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n    CheckIndex.Status indexStatus = checker.checkIndex(null);\n    String s = bos.toString(IOUtils.UTF_8);\n    checker.close();\n    // Make sure CheckIndex didn't fail\n    assertTrue(s, indexStatus != null && indexStatus.clean);\n\n    // Commit id is always stored:\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n    d.close();\n\n    Set<String> ids = new HashSet<>();\n    for(int i=0;i<100000;i++) {\n      String id = StringHelper.idToString(StringHelper.randomId());\n      assertFalse(\"id=\" + id + \" i=\" + i, ids.contains(id));\n      ids.add(id);\n    }\n  }\n\n","sourceOld":"  /** Make sure we see ids per segment and per commit. */\n  public void testIds() throws Exception {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, newIndexWriterConfig(new MockAnalyzer(random())));\n    w.addDocument(new Document());\n    w.close();\n\n    SegmentInfos sis = SegmentInfos.readLatestCommit(d);\n    byte[] id1 = sis.getId();\n    assertNotNull(id1);\n    assertEquals(StringHelper.ID_LENGTH, id1.length);\n\n    byte[] id2 = sis.info(0).info.getId();\n    byte[] sciId2 = sis.info(0).getId();\n    assertNotNull(id2);\n    assertNotNull(sciId2);\n    assertEquals(StringHelper.ID_LENGTH, id2.length);\n    assertEquals(StringHelper.ID_LENGTH, sciId2.length);\n\n    // Make sure CheckIndex includes id output:\n    ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n    CheckIndex checker = new CheckIndex(d);\n    checker.setDoSlowChecks(false);\n    checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n    CheckIndex.Status indexStatus = checker.checkIndex(null);\n    String s = bos.toString(IOUtils.UTF_8);\n    checker.close();\n    // Make sure CheckIndex didn't fail\n    assertTrue(s, indexStatus != null && indexStatus.clean);\n\n    // Commit id is always stored:\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n    d.close();\n\n    Set<String> ids = new HashSet<>();\n    for(int i=0;i<100000;i++) {\n      String id = StringHelper.idToString(StringHelper.randomId());\n      assertFalse(\"id=\" + id + \" i=\" + i, ids.contains(id));\n      ids.add(id);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c2a23476693f2bd9a4b44cc3187c429a2e21dac2","date":1593289545,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testIds().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testIds().mjava","sourceNew":"  /** Make sure we see ids per segment and per commit. */\n  public void testIds() throws Exception {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, newIndexWriterConfig(new MockAnalyzer(random())));\n    w.addDocument(new Document());\n    w.close();\n\n    SegmentInfos sis = SegmentInfos.readLatestCommit(d);\n    byte[] id1 = sis.getId();\n    assertNotNull(id1);\n    assertEquals(StringHelper.ID_LENGTH, id1.length);\n\n    byte[] id2 = sis.info(0).info.getId();\n    byte[] sciId2 = sis.info(0).getId();\n    assertNotNull(id2);\n    assertNotNull(sciId2);\n    assertEquals(StringHelper.ID_LENGTH, id2.length);\n    assertEquals(StringHelper.ID_LENGTH, sciId2.length);\n\n    // Make sure CheckIndex includes id output:\n    ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n    CheckIndex checker = new CheckIndex(d);\n    checker.setDoSlowChecks(false);\n    checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n    CheckIndex.Status indexStatus = checker.checkIndex(null);\n    String s = bos.toString(IOUtils.UTF_8);\n    checker.close();\n    // Make sure CheckIndex didn't fail\n    assertTrue(s, indexStatus != null && indexStatus.clean);\n\n    // Commit id is always stored:\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n    d.close();\n\n    Set<String> ids = new HashSet<>();\n    for(int i=0;i<100000;i++) {\n      String id = StringHelper.idToString(StringHelper.randomId());\n      assertFalse(\"id=\" + id + \" i=\" + i, ids.contains(id));\n      ids.add(id);\n    }\n  }\n\n","sourceOld":"  /** Make sure we see ids per segment and per commit. */\n  public void testIds() throws Exception {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, newIndexWriterConfig(new MockAnalyzer(random())));\n    w.addDocument(new Document());\n    w.close();\n    \n    SegmentInfos sis = SegmentInfos.readLatestCommit(d);\n    byte[] id1 = sis.getId();\n    assertNotNull(id1);\n    assertEquals(StringHelper.ID_LENGTH, id1.length);\n    \n    byte[] id2 = sis.info(0).info.getId();\n    byte[] sciId2 = sis.info(0).getId();\n    assertNotNull(id2);\n    assertNotNull(sciId2);\n    assertEquals(StringHelper.ID_LENGTH, id2.length);\n    assertEquals(StringHelper.ID_LENGTH, sciId2.length);\n\n    // Make sure CheckIndex includes id output:\n    ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n    CheckIndex checker = new CheckIndex(d);\n    checker.setDoSlowChecks(false);\n    checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n    CheckIndex.Status indexStatus = checker.checkIndex(null);\n    String s = bos.toString(IOUtils.UTF_8);\n    checker.close();\n    // Make sure CheckIndex didn't fail\n    assertTrue(s, indexStatus != null && indexStatus.clean);\n\n    // Commit id is always stored:\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n\n    assertTrue(\"missing id=\" + StringHelper.idToString(id1) + \" in:\\n\" + s, s.contains(\"id=\" + StringHelper.idToString(id1)));\n    d.close();\n\n    Set<String> ids = new HashSet<>();\n    for(int i=0;i<100000;i++) {\n      String id = StringHelper.idToString(StringHelper.randomId());\n      assertFalse(\"id=\" + id + \" i=\" + i, ids.contains(id));\n      ids.add(id);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a5d957b3a23cce91c77a2c9971ecf0c9f99dd503":["402ad3ddc9da7b70da1b167667a60ece6a1381fb"],"5f6bd27530a2846413fe2d00030493c0e2d3a072":["402ad3ddc9da7b70da1b167667a60ece6a1381fb","a5d957b3a23cce91c77a2c9971ecf0c9f99dd503"],"f7523916a1350712e1ae710affd4e88ccd7c431d":["5f6bd27530a2846413fe2d00030493c0e2d3a072"],"3384e6013a93e4d11b7d75388693f8d0388602bf":["d9a47902d6207303f5ed3e7aaca62ca33433af66"],"d9a47902d6207303f5ed3e7aaca62ca33433af66":["a5d957b3a23cce91c77a2c9971ecf0c9f99dd503","f7523916a1350712e1ae710affd4e88ccd7c431d"],"fe39f1a106531207c028defebbc9eb5bb489ac50":["14654be3f7a82c9a3c52169e365baa55bfe64f66"],"402ad3ddc9da7b70da1b167667a60ece6a1381fb":["e3cc329405ce41b8ef462b4cd30611eca1567620","ad2a673349939e48652bf304cccf673c3412198f"],"c2a23476693f2bd9a4b44cc3187c429a2e21dac2":["1182fe36fb5df768dc2da53f6d5338cbc07268ae"],"e3cc329405ce41b8ef462b4cd30611eca1567620":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"14654be3f7a82c9a3c52169e365baa55bfe64f66":["9a0e5953a07337cd41bcde610503024c07073b26"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["f7523916a1350712e1ae710affd4e88ccd7c431d","3384e6013a93e4d11b7d75388693f8d0388602bf"],"1182fe36fb5df768dc2da53f6d5338cbc07268ae":["fe39f1a106531207c028defebbc9eb5bb489ac50"],"9a0e5953a07337cd41bcde610503024c07073b26":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"ad2a673349939e48652bf304cccf673c3412198f":["e3cc329405ce41b8ef462b4cd30611eca1567620"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c2a23476693f2bd9a4b44cc3187c429a2e21dac2"]},"commit2Childs":{"a5d957b3a23cce91c77a2c9971ecf0c9f99dd503":["5f6bd27530a2846413fe2d00030493c0e2d3a072","d9a47902d6207303f5ed3e7aaca62ca33433af66"],"5f6bd27530a2846413fe2d00030493c0e2d3a072":["f7523916a1350712e1ae710affd4e88ccd7c431d"],"f7523916a1350712e1ae710affd4e88ccd7c431d":["d9a47902d6207303f5ed3e7aaca62ca33433af66","db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"3384e6013a93e4d11b7d75388693f8d0388602bf":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"d9a47902d6207303f5ed3e7aaca62ca33433af66":["3384e6013a93e4d11b7d75388693f8d0388602bf"],"fe39f1a106531207c028defebbc9eb5bb489ac50":["1182fe36fb5df768dc2da53f6d5338cbc07268ae"],"402ad3ddc9da7b70da1b167667a60ece6a1381fb":["a5d957b3a23cce91c77a2c9971ecf0c9f99dd503","5f6bd27530a2846413fe2d00030493c0e2d3a072"],"c2a23476693f2bd9a4b44cc3187c429a2e21dac2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e3cc329405ce41b8ef462b4cd30611eca1567620":["402ad3ddc9da7b70da1b167667a60ece6a1381fb","ad2a673349939e48652bf304cccf673c3412198f"],"14654be3f7a82c9a3c52169e365baa55bfe64f66":["fe39f1a106531207c028defebbc9eb5bb489ac50"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e3cc329405ce41b8ef462b4cd30611eca1567620"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["9a0e5953a07337cd41bcde610503024c07073b26"],"ad2a673349939e48652bf304cccf673c3412198f":["402ad3ddc9da7b70da1b167667a60ece6a1381fb"],"1182fe36fb5df768dc2da53f6d5338cbc07268ae":["c2a23476693f2bd9a4b44cc3187c429a2e21dac2"],"9a0e5953a07337cd41bcde610503024c07073b26":["14654be3f7a82c9a3c52169e365baa55bfe64f66"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}