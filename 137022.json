{"path":"solr/core/src/java/org/apache/solr/handler/component/SpatialHeatmapFacets#getHeatmapForField(String,String,ResponseBuilder,SolrParams,DocSet).mjava","commits":[{"id":"59d82b0be40ecfcc2c94c776b324e0903a62b844","date":1423535462,"type":0,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpatialHeatmapFacets#getHeatmapForField(String,String,ResponseBuilder,SolrParams,DocSet).mjava","pathOld":"/dev/null","sourceNew":"  /** Called by {@link org.apache.solr.request.SimpleFacets} to compute heatmap facets. */\n  public static NamedList<Object> getHeatmapForField(String fieldKey, String fieldName, ResponseBuilder rb, SolrParams params, DocSet docSet) throws IOException {\n    //get the strategy from the field type\n    final SchemaField schemaField = rb.req.getSchema().getField(fieldName);\n    final FieldType type = schemaField.getType();\n    if (!(type instanceof AbstractSpatialPrefixTreeFieldType)) {\n      //FYI we support the term query one too but few people use that one\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"heatmap field needs to be of type \"\n          + SpatialRecursivePrefixTreeFieldType.class);\n    }\n    AbstractSpatialPrefixTreeFieldType rptType = (AbstractSpatialPrefixTreeFieldType) type;\n    final PrefixTreeStrategy strategy = (PrefixTreeStrategy) rptType.getStrategy(fieldName);\n    final SpatialContext ctx = strategy.getSpatialContext();\n\n    //get the bbox (query Rectangle)\n    String geomStr = params.getFieldParam(fieldKey, FacetParams.FACET_HEATMAP_GEOM);\n    final Shape boundsShape = geomStr == null ? ctx.getWorldBounds() : SpatialUtils.parseGeomSolrException(geomStr, ctx);\n\n    //get the grid level (possibly indirectly via distErr or distErrPct)\n    final int gridLevel;\n    Integer gridLevelObj = params.getFieldInt(fieldKey, FacetParams.FACET_HEATMAP_LEVEL);\n    final int maxGridLevel = strategy.getGrid().getMaxLevels();\n    if (gridLevelObj != null) {\n      gridLevel = gridLevelObj;\n      if (gridLevel <= 0 || gridLevel > maxGridLevel) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            FacetParams.FACET_HEATMAP_LEVEL +\" should be > 0 and <= \" + maxGridLevel);\n      }\n    } else {\n      //SpatialArgs has utility methods to resolve a 'distErr' from optionally set distErr & distErrPct. Arguably that\n      // should be refactored to feel less weird than using it like this.\n      SpatialArgs spatialArgs = new SpatialArgs(SpatialOperation.Intersects/*ignored*/,\n          boundsShape == null ? ctx.getWorldBounds() : boundsShape);\n      final Double distErrObj = params.getFieldDouble(fieldKey, FacetParams.FACET_HEATMAP_DIST_ERR);\n      if (distErrObj != null) {\n        // convert distErr units based on configured units\n        spatialArgs.setDistErr(distErrObj * rptType.getDistanceUnits().multiplierFromThisUnitToDegrees());\n      }\n      spatialArgs.setDistErrPct(params.getFieldDouble(fieldKey, FacetParams.FACET_HEATMAP_DIST_ERR_PCT));\n      double distErr = spatialArgs.resolveDistErr(ctx, DEFAULT_DIST_ERR_PCT);\n      if (distErr <= 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            FacetParams.FACET_HEATMAP_DIST_ERR_PCT + \" or \" + FacetParams.FACET_HEATMAP_DIST_ERR\n                + \" should be > 0 or instead provide \" + FacetParams.FACET_HEATMAP_LEVEL + \"=\" + maxGridLevel\n                + \" if you insist on maximum detail\");\n      }\n      //The SPT (grid) can lookup a grid level satisfying an error distance constraint\n      gridLevel = strategy.getGrid().getLevelForDistance(distErr);\n    }\n\n    //Compute!\n    final HeatmapFacetCounter.Heatmap heatmap;\n    try {\n      heatmap = HeatmapFacetCounter.calcFacets(\n          strategy,\n          rb.req.getSearcher().getTopReaderContext(),\n          docSet.getTopFilter(),\n          boundsShape,\n          gridLevel,\n          params.getFieldInt(fieldKey, FacetParams.FACET_HEATMAP_MAX_CELLS, 100_000) // will throw if exceeded\n      );\n    } catch (IllegalArgumentException e) {//e.g. too many cells\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.toString(), e);\n    }\n\n    //Populate response\n    NamedList<Object> result = new NamedList<>();\n    result.add(\"gridLevel\", gridLevel);\n    result.add(\"columns\", heatmap.columns);\n    result.add(\"rows\", heatmap.rows);\n    result.add(\"minX\", heatmap.region.getMinX());\n    result.add(\"maxX\", heatmap.region.getMaxX());\n    result.add(\"minY\", heatmap.region.getMinY());\n    result.add(\"maxY\", heatmap.region.getMaxY());\n\n    boolean hasNonZero = false;\n    for (int count : heatmap.counts) {\n      if (count > 0) {\n        hasNonZero = true;\n        break;\n      }\n    }\n    formatCountsAndAddToNL(fieldKey, rb, params, heatmap.columns, heatmap.rows, hasNonZero ? heatmap.counts : null, result);\n\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0caf86b778fe22b63626ba65f24f7b69c5c5b384","date":1432213473,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpatialHeatmapFacets#getHeatmapForField(String,String,ResponseBuilder,SolrParams,DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpatialHeatmapFacets#getHeatmapForField(String,String,ResponseBuilder,SolrParams,DocSet).mjava","sourceNew":"  /** Called by {@link org.apache.solr.request.SimpleFacets} to compute heatmap facets. */\n  public static NamedList<Object> getHeatmapForField(String fieldKey, String fieldName, ResponseBuilder rb, SolrParams params, DocSet docSet) throws IOException {\n    //get the strategy from the field type\n    final SchemaField schemaField = rb.req.getSchema().getField(fieldName);\n    final FieldType type = schemaField.getType();\n\n    final PrefixTreeStrategy strategy;\n    final DistanceUnits distanceUnits;\n    // note: the two instanceof conditions is not ideal, versus one. If we start needing to add more then refactor.\n    if ((type instanceof AbstractSpatialPrefixTreeFieldType)) {\n      AbstractSpatialPrefixTreeFieldType rptType = (AbstractSpatialPrefixTreeFieldType) type;\n      strategy = (PrefixTreeStrategy) rptType.getStrategy(fieldName);\n      distanceUnits = rptType.getDistanceUnits();\n    } else if (type instanceof RptWithGeometrySpatialField) {\n      RptWithGeometrySpatialField rptSdvType  = (RptWithGeometrySpatialField) type;\n      strategy = rptSdvType.getStrategy(fieldName).getIndexStrategy();\n      distanceUnits = rptSdvType.getDistanceUnits();\n    } else {\n      //FYI we support the term query one too but few people use that one\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"heatmap field needs to be of type \"\n          + SpatialRecursivePrefixTreeFieldType.class + \" or \" + RptWithGeometrySpatialField.class);\n    }\n\n    final SpatialContext ctx = strategy.getSpatialContext();\n\n    //get the bbox (query Rectangle)\n    String geomStr = params.getFieldParam(fieldKey, FacetParams.FACET_HEATMAP_GEOM);\n    final Shape boundsShape = geomStr == null ? ctx.getWorldBounds() : SpatialUtils.parseGeomSolrException(geomStr, ctx);\n\n    //get the grid level (possibly indirectly via distErr or distErrPct)\n    final int gridLevel;\n    Integer gridLevelObj = params.getFieldInt(fieldKey, FacetParams.FACET_HEATMAP_LEVEL);\n    final int maxGridLevel = strategy.getGrid().getMaxLevels();\n    if (gridLevelObj != null) {\n      gridLevel = gridLevelObj;\n      if (gridLevel <= 0 || gridLevel > maxGridLevel) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            FacetParams.FACET_HEATMAP_LEVEL +\" should be > 0 and <= \" + maxGridLevel);\n      }\n    } else {\n      //SpatialArgs has utility methods to resolve a 'distErr' from optionally set distErr & distErrPct. Arguably that\n      // should be refactored to feel less weird than using it like this.\n      SpatialArgs spatialArgs = new SpatialArgs(SpatialOperation.Intersects/*ignored*/,\n          boundsShape == null ? ctx.getWorldBounds() : boundsShape);\n      final Double distErrObj = params.getFieldDouble(fieldKey, FacetParams.FACET_HEATMAP_DIST_ERR);\n      if (distErrObj != null) {\n        // convert distErr units based on configured units\n        spatialArgs.setDistErr(distErrObj * distanceUnits.multiplierFromThisUnitToDegrees());\n      }\n      spatialArgs.setDistErrPct(params.getFieldDouble(fieldKey, FacetParams.FACET_HEATMAP_DIST_ERR_PCT));\n      double distErr = spatialArgs.resolveDistErr(ctx, DEFAULT_DIST_ERR_PCT);\n      if (distErr <= 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            FacetParams.FACET_HEATMAP_DIST_ERR_PCT + \" or \" + FacetParams.FACET_HEATMAP_DIST_ERR\n                + \" should be > 0 or instead provide \" + FacetParams.FACET_HEATMAP_LEVEL + \"=\" + maxGridLevel\n                + \" if you insist on maximum detail\");\n      }\n      //The SPT (grid) can lookup a grid level satisfying an error distance constraint\n      gridLevel = strategy.getGrid().getLevelForDistance(distErr);\n    }\n\n    //Compute!\n    final HeatmapFacetCounter.Heatmap heatmap;\n    try {\n      heatmap = HeatmapFacetCounter.calcFacets(\n          strategy,\n          rb.req.getSearcher().getTopReaderContext(),\n          docSet.getTopFilter(),\n          boundsShape,\n          gridLevel,\n          params.getFieldInt(fieldKey, FacetParams.FACET_HEATMAP_MAX_CELLS, 100_000) // will throw if exceeded\n      );\n    } catch (IllegalArgumentException e) {//e.g. too many cells\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.toString(), e);\n    }\n\n    //Populate response\n    NamedList<Object> result = new NamedList<>();\n    result.add(\"gridLevel\", gridLevel);\n    result.add(\"columns\", heatmap.columns);\n    result.add(\"rows\", heatmap.rows);\n    result.add(\"minX\", heatmap.region.getMinX());\n    result.add(\"maxX\", heatmap.region.getMaxX());\n    result.add(\"minY\", heatmap.region.getMinY());\n    result.add(\"maxY\", heatmap.region.getMaxY());\n\n    boolean hasNonZero = false;\n    for (int count : heatmap.counts) {\n      if (count > 0) {\n        hasNonZero = true;\n        break;\n      }\n    }\n    formatCountsAndAddToNL(fieldKey, rb, params, heatmap.columns, heatmap.rows, hasNonZero ? heatmap.counts : null, result);\n\n    return result;\n  }\n\n","sourceOld":"  /** Called by {@link org.apache.solr.request.SimpleFacets} to compute heatmap facets. */\n  public static NamedList<Object> getHeatmapForField(String fieldKey, String fieldName, ResponseBuilder rb, SolrParams params, DocSet docSet) throws IOException {\n    //get the strategy from the field type\n    final SchemaField schemaField = rb.req.getSchema().getField(fieldName);\n    final FieldType type = schemaField.getType();\n    if (!(type instanceof AbstractSpatialPrefixTreeFieldType)) {\n      //FYI we support the term query one too but few people use that one\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"heatmap field needs to be of type \"\n          + SpatialRecursivePrefixTreeFieldType.class);\n    }\n    AbstractSpatialPrefixTreeFieldType rptType = (AbstractSpatialPrefixTreeFieldType) type;\n    final PrefixTreeStrategy strategy = (PrefixTreeStrategy) rptType.getStrategy(fieldName);\n    final SpatialContext ctx = strategy.getSpatialContext();\n\n    //get the bbox (query Rectangle)\n    String geomStr = params.getFieldParam(fieldKey, FacetParams.FACET_HEATMAP_GEOM);\n    final Shape boundsShape = geomStr == null ? ctx.getWorldBounds() : SpatialUtils.parseGeomSolrException(geomStr, ctx);\n\n    //get the grid level (possibly indirectly via distErr or distErrPct)\n    final int gridLevel;\n    Integer gridLevelObj = params.getFieldInt(fieldKey, FacetParams.FACET_HEATMAP_LEVEL);\n    final int maxGridLevel = strategy.getGrid().getMaxLevels();\n    if (gridLevelObj != null) {\n      gridLevel = gridLevelObj;\n      if (gridLevel <= 0 || gridLevel > maxGridLevel) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            FacetParams.FACET_HEATMAP_LEVEL +\" should be > 0 and <= \" + maxGridLevel);\n      }\n    } else {\n      //SpatialArgs has utility methods to resolve a 'distErr' from optionally set distErr & distErrPct. Arguably that\n      // should be refactored to feel less weird than using it like this.\n      SpatialArgs spatialArgs = new SpatialArgs(SpatialOperation.Intersects/*ignored*/,\n          boundsShape == null ? ctx.getWorldBounds() : boundsShape);\n      final Double distErrObj = params.getFieldDouble(fieldKey, FacetParams.FACET_HEATMAP_DIST_ERR);\n      if (distErrObj != null) {\n        // convert distErr units based on configured units\n        spatialArgs.setDistErr(distErrObj * rptType.getDistanceUnits().multiplierFromThisUnitToDegrees());\n      }\n      spatialArgs.setDistErrPct(params.getFieldDouble(fieldKey, FacetParams.FACET_HEATMAP_DIST_ERR_PCT));\n      double distErr = spatialArgs.resolveDistErr(ctx, DEFAULT_DIST_ERR_PCT);\n      if (distErr <= 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            FacetParams.FACET_HEATMAP_DIST_ERR_PCT + \" or \" + FacetParams.FACET_HEATMAP_DIST_ERR\n                + \" should be > 0 or instead provide \" + FacetParams.FACET_HEATMAP_LEVEL + \"=\" + maxGridLevel\n                + \" if you insist on maximum detail\");\n      }\n      //The SPT (grid) can lookup a grid level satisfying an error distance constraint\n      gridLevel = strategy.getGrid().getLevelForDistance(distErr);\n    }\n\n    //Compute!\n    final HeatmapFacetCounter.Heatmap heatmap;\n    try {\n      heatmap = HeatmapFacetCounter.calcFacets(\n          strategy,\n          rb.req.getSearcher().getTopReaderContext(),\n          docSet.getTopFilter(),\n          boundsShape,\n          gridLevel,\n          params.getFieldInt(fieldKey, FacetParams.FACET_HEATMAP_MAX_CELLS, 100_000) // will throw if exceeded\n      );\n    } catch (IllegalArgumentException e) {//e.g. too many cells\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.toString(), e);\n    }\n\n    //Populate response\n    NamedList<Object> result = new NamedList<>();\n    result.add(\"gridLevel\", gridLevel);\n    result.add(\"columns\", heatmap.columns);\n    result.add(\"rows\", heatmap.rows);\n    result.add(\"minX\", heatmap.region.getMinX());\n    result.add(\"maxX\", heatmap.region.getMaxX());\n    result.add(\"minY\", heatmap.region.getMinY());\n    result.add(\"maxY\", heatmap.region.getMaxY());\n\n    boolean hasNonZero = false;\n    for (int count : heatmap.counts) {\n      if (count > 0) {\n        hasNonZero = true;\n        break;\n      }\n    }\n    formatCountsAndAddToNL(fieldKey, rb, params, heatmap.columns, heatmap.rows, hasNonZero ? heatmap.counts : null, result);\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"672b198fc3dce868916c727917cae58c2906763d","date":1443669960,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpatialHeatmapFacets#getHeatmapForField(String,String,ResponseBuilder,SolrParams,DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpatialHeatmapFacets#getHeatmapForField(String,String,ResponseBuilder,SolrParams,DocSet).mjava","sourceNew":"  /** Called by {@link org.apache.solr.request.SimpleFacets} to compute heatmap facets. */\n  public static NamedList<Object> getHeatmapForField(String fieldKey, String fieldName, ResponseBuilder rb, SolrParams params, DocSet docSet) throws IOException {\n    //get the strategy from the field type\n    final SchemaField schemaField = rb.req.getSchema().getField(fieldName);\n    final FieldType type = schemaField.getType();\n\n    final PrefixTreeStrategy strategy;\n    final DistanceUnits distanceUnits;\n    // note: the two instanceof conditions is not ideal, versus one. If we start needing to add more then refactor.\n    if ((type instanceof AbstractSpatialPrefixTreeFieldType)) {\n      AbstractSpatialPrefixTreeFieldType rptType = (AbstractSpatialPrefixTreeFieldType) type;\n      strategy = (PrefixTreeStrategy) rptType.getStrategy(fieldName);\n      distanceUnits = rptType.getDistanceUnits();\n    } else if (type instanceof RptWithGeometrySpatialField) {\n      RptWithGeometrySpatialField rptSdvType  = (RptWithGeometrySpatialField) type;\n      strategy = rptSdvType.getStrategy(fieldName).getIndexStrategy();\n      distanceUnits = rptSdvType.getDistanceUnits();\n    } else {\n      //FYI we support the term query one too but few people use that one\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"heatmap field needs to be of type \"\n          + SpatialRecursivePrefixTreeFieldType.class + \" or \" + RptWithGeometrySpatialField.class);\n    }\n\n    final SpatialContext ctx = strategy.getSpatialContext();\n\n    //get the bbox (query Rectangle)\n    String geomStr = params.getFieldParam(fieldKey, FacetParams.FACET_HEATMAP_GEOM);\n    final Shape boundsShape = geomStr == null ? ctx.getWorldBounds() : SpatialUtils.parseGeomSolrException(geomStr, ctx);\n\n    //get the grid level (possibly indirectly via distErr or distErrPct)\n    final int gridLevel;\n    Integer gridLevelObj = params.getFieldInt(fieldKey, FacetParams.FACET_HEATMAP_LEVEL);\n    final int maxGridLevel = strategy.getGrid().getMaxLevels();\n    if (gridLevelObj != null) {\n      gridLevel = gridLevelObj;\n      if (gridLevel <= 0 || gridLevel > maxGridLevel) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            FacetParams.FACET_HEATMAP_LEVEL +\" should be > 0 and <= \" + maxGridLevel);\n      }\n    } else {\n      //SpatialArgs has utility methods to resolve a 'distErr' from optionally set distErr & distErrPct. Arguably that\n      // should be refactored to feel less weird than using it like this.\n      SpatialArgs spatialArgs = new SpatialArgs(SpatialOperation.Intersects/*ignored*/,\n          boundsShape == null ? ctx.getWorldBounds() : boundsShape);\n      final Double distErrObj = params.getFieldDouble(fieldKey, FacetParams.FACET_HEATMAP_DIST_ERR);\n      if (distErrObj != null) {\n        // convert distErr units based on configured units\n        spatialArgs.setDistErr(distErrObj * distanceUnits.multiplierFromThisUnitToDegrees());\n      }\n      spatialArgs.setDistErrPct(params.getFieldDouble(fieldKey, FacetParams.FACET_HEATMAP_DIST_ERR_PCT));\n      double distErr = spatialArgs.resolveDistErr(ctx, DEFAULT_DIST_ERR_PCT);\n      if (distErr <= 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            FacetParams.FACET_HEATMAP_DIST_ERR_PCT + \" or \" + FacetParams.FACET_HEATMAP_DIST_ERR\n                + \" should be > 0 or instead provide \" + FacetParams.FACET_HEATMAP_LEVEL + \"=\" + maxGridLevel\n                + \" if you insist on maximum detail\");\n      }\n      //The SPT (grid) can lookup a grid level satisfying an error distance constraint\n      gridLevel = strategy.getGrid().getLevelForDistance(distErr);\n    }\n\n    // Turn docSet into Bits\n    Bits topAcceptDocs;\n    if (docSet instanceof BitDocSet) {\n      BitDocSet set = (BitDocSet) docSet;\n      topAcceptDocs = set.getBits();\n    } else {\n      topAcceptDocs = new Bits() {\n        @Override\n        public boolean get(int index) {\n          return docSet.exists(index);\n        }\n\n        @Override\n        public int length() {\n          return rb.req.getSearcher().maxDoc();\n        }\n      };\n    }\n\n    //Compute!\n    final HeatmapFacetCounter.Heatmap heatmap;\n    try {\n      heatmap = HeatmapFacetCounter.calcFacets(\n          strategy,\n          rb.req.getSearcher().getTopReaderContext(),\n          topAcceptDocs,\n          boundsShape,\n          gridLevel,\n          params.getFieldInt(fieldKey, FacetParams.FACET_HEATMAP_MAX_CELLS, 100_000) // will throw if exceeded\n      );\n    } catch (IllegalArgumentException e) {//e.g. too many cells\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.toString(), e);\n    }\n\n    //Populate response\n    NamedList<Object> result = new NamedList<>();\n    result.add(\"gridLevel\", gridLevel);\n    result.add(\"columns\", heatmap.columns);\n    result.add(\"rows\", heatmap.rows);\n    result.add(\"minX\", heatmap.region.getMinX());\n    result.add(\"maxX\", heatmap.region.getMaxX());\n    result.add(\"minY\", heatmap.region.getMinY());\n    result.add(\"maxY\", heatmap.region.getMaxY());\n\n    boolean hasNonZero = false;\n    for (int count : heatmap.counts) {\n      if (count > 0) {\n        hasNonZero = true;\n        break;\n      }\n    }\n    formatCountsAndAddToNL(fieldKey, rb, params, heatmap.columns, heatmap.rows, hasNonZero ? heatmap.counts : null, result);\n\n    return result;\n  }\n\n","sourceOld":"  /** Called by {@link org.apache.solr.request.SimpleFacets} to compute heatmap facets. */\n  public static NamedList<Object> getHeatmapForField(String fieldKey, String fieldName, ResponseBuilder rb, SolrParams params, DocSet docSet) throws IOException {\n    //get the strategy from the field type\n    final SchemaField schemaField = rb.req.getSchema().getField(fieldName);\n    final FieldType type = schemaField.getType();\n\n    final PrefixTreeStrategy strategy;\n    final DistanceUnits distanceUnits;\n    // note: the two instanceof conditions is not ideal, versus one. If we start needing to add more then refactor.\n    if ((type instanceof AbstractSpatialPrefixTreeFieldType)) {\n      AbstractSpatialPrefixTreeFieldType rptType = (AbstractSpatialPrefixTreeFieldType) type;\n      strategy = (PrefixTreeStrategy) rptType.getStrategy(fieldName);\n      distanceUnits = rptType.getDistanceUnits();\n    } else if (type instanceof RptWithGeometrySpatialField) {\n      RptWithGeometrySpatialField rptSdvType  = (RptWithGeometrySpatialField) type;\n      strategy = rptSdvType.getStrategy(fieldName).getIndexStrategy();\n      distanceUnits = rptSdvType.getDistanceUnits();\n    } else {\n      //FYI we support the term query one too but few people use that one\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"heatmap field needs to be of type \"\n          + SpatialRecursivePrefixTreeFieldType.class + \" or \" + RptWithGeometrySpatialField.class);\n    }\n\n    final SpatialContext ctx = strategy.getSpatialContext();\n\n    //get the bbox (query Rectangle)\n    String geomStr = params.getFieldParam(fieldKey, FacetParams.FACET_HEATMAP_GEOM);\n    final Shape boundsShape = geomStr == null ? ctx.getWorldBounds() : SpatialUtils.parseGeomSolrException(geomStr, ctx);\n\n    //get the grid level (possibly indirectly via distErr or distErrPct)\n    final int gridLevel;\n    Integer gridLevelObj = params.getFieldInt(fieldKey, FacetParams.FACET_HEATMAP_LEVEL);\n    final int maxGridLevel = strategy.getGrid().getMaxLevels();\n    if (gridLevelObj != null) {\n      gridLevel = gridLevelObj;\n      if (gridLevel <= 0 || gridLevel > maxGridLevel) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            FacetParams.FACET_HEATMAP_LEVEL +\" should be > 0 and <= \" + maxGridLevel);\n      }\n    } else {\n      //SpatialArgs has utility methods to resolve a 'distErr' from optionally set distErr & distErrPct. Arguably that\n      // should be refactored to feel less weird than using it like this.\n      SpatialArgs spatialArgs = new SpatialArgs(SpatialOperation.Intersects/*ignored*/,\n          boundsShape == null ? ctx.getWorldBounds() : boundsShape);\n      final Double distErrObj = params.getFieldDouble(fieldKey, FacetParams.FACET_HEATMAP_DIST_ERR);\n      if (distErrObj != null) {\n        // convert distErr units based on configured units\n        spatialArgs.setDistErr(distErrObj * distanceUnits.multiplierFromThisUnitToDegrees());\n      }\n      spatialArgs.setDistErrPct(params.getFieldDouble(fieldKey, FacetParams.FACET_HEATMAP_DIST_ERR_PCT));\n      double distErr = spatialArgs.resolveDistErr(ctx, DEFAULT_DIST_ERR_PCT);\n      if (distErr <= 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            FacetParams.FACET_HEATMAP_DIST_ERR_PCT + \" or \" + FacetParams.FACET_HEATMAP_DIST_ERR\n                + \" should be > 0 or instead provide \" + FacetParams.FACET_HEATMAP_LEVEL + \"=\" + maxGridLevel\n                + \" if you insist on maximum detail\");\n      }\n      //The SPT (grid) can lookup a grid level satisfying an error distance constraint\n      gridLevel = strategy.getGrid().getLevelForDistance(distErr);\n    }\n\n    //Compute!\n    final HeatmapFacetCounter.Heatmap heatmap;\n    try {\n      heatmap = HeatmapFacetCounter.calcFacets(\n          strategy,\n          rb.req.getSearcher().getTopReaderContext(),\n          docSet.getTopFilter(),\n          boundsShape,\n          gridLevel,\n          params.getFieldInt(fieldKey, FacetParams.FACET_HEATMAP_MAX_CELLS, 100_000) // will throw if exceeded\n      );\n    } catch (IllegalArgumentException e) {//e.g. too many cells\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.toString(), e);\n    }\n\n    //Populate response\n    NamedList<Object> result = new NamedList<>();\n    result.add(\"gridLevel\", gridLevel);\n    result.add(\"columns\", heatmap.columns);\n    result.add(\"rows\", heatmap.rows);\n    result.add(\"minX\", heatmap.region.getMinX());\n    result.add(\"maxX\", heatmap.region.getMaxX());\n    result.add(\"minY\", heatmap.region.getMinY());\n    result.add(\"maxY\", heatmap.region.getMaxY());\n\n    boolean hasNonZero = false;\n    for (int count : heatmap.counts) {\n      if (count > 0) {\n        hasNonZero = true;\n        break;\n      }\n    }\n    formatCountsAndAddToNL(fieldKey, rb, params, heatmap.columns, heatmap.rows, hasNonZero ? heatmap.counts : null, result);\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"80eab62695350cc8593def10dd537faebd86a8e3","date":1492724788,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpatialHeatmapFacets#getHeatmapForField(String,String,ResponseBuilder,SolrParams,DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpatialHeatmapFacets#getHeatmapForField(String,String,ResponseBuilder,SolrParams,DocSet).mjava","sourceNew":"  /** Called by {@link org.apache.solr.request.SimpleFacets} to compute heatmap facets. */\n  public static NamedList<Object> getHeatmapForField(String fieldKey, String fieldName, ResponseBuilder rb, SolrParams params, DocSet docSet) throws IOException {\n    //get the strategy from the field type\n    final SchemaField schemaField = rb.req.getSchema().getField(fieldName);\n    final FieldType type = schemaField.getType();\n\n    final PrefixTreeStrategy strategy;\n    final DistanceUnits distanceUnits;\n    // note: the two instanceof conditions is not ideal, versus one. If we start needing to add more then refactor.\n    if ((type instanceof AbstractSpatialPrefixTreeFieldType)) {\n      AbstractSpatialPrefixTreeFieldType rptType = (AbstractSpatialPrefixTreeFieldType) type;\n      strategy = (PrefixTreeStrategy) rptType.getStrategy(fieldName);\n      distanceUnits = rptType.getDistanceUnits();\n    } else if (type instanceof RptWithGeometrySpatialField) {\n      RptWithGeometrySpatialField rptSdvType  = (RptWithGeometrySpatialField) type;\n      strategy = rptSdvType.getStrategy(fieldName).getIndexStrategy();\n      distanceUnits = rptSdvType.getDistanceUnits();\n    } else {\n      //FYI we support the term query one too but few people use that one\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"heatmap field needs to be of type \"\n          + SpatialRecursivePrefixTreeFieldType.class + \" or \" + RptWithGeometrySpatialField.class);\n    }\n\n    final SpatialContext ctx = strategy.getSpatialContext();\n\n    //get the bbox (query Rectangle)\n    String geomStr = params.getFieldParam(fieldKey, FacetParams.FACET_HEATMAP_GEOM);\n    final Shape boundsShape = geomStr == null ? ctx.getWorldBounds() : SpatialUtils.parseGeomSolrException(geomStr, ctx);\n\n    //get the grid level (possibly indirectly via distErr or distErrPct)\n    final int gridLevel;\n    Integer gridLevelObj = params.getFieldInt(fieldKey, FacetParams.FACET_HEATMAP_LEVEL);\n    final int maxGridLevel = strategy.getGrid().getMaxLevels();\n    if (gridLevelObj != null) {\n      gridLevel = gridLevelObj;\n      if (gridLevel <= 0 || gridLevel > maxGridLevel) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            FacetParams.FACET_HEATMAP_LEVEL +\" should be > 0 and <= \" + maxGridLevel);\n      }\n    } else {\n      //SpatialArgs has utility methods to resolve a 'distErr' from optionally set distErr & distErrPct. Arguably that\n      // should be refactored to feel less weird than using it like this.\n      SpatialArgs spatialArgs = new SpatialArgs(SpatialOperation.Intersects/*ignored*/,\n          boundsShape == null ? ctx.getWorldBounds() : boundsShape);\n      final Double distErrObj = params.getFieldDouble(fieldKey, FacetParams.FACET_HEATMAP_DIST_ERR);\n      if (distErrObj != null) {\n        // convert distErr units based on configured units\n        spatialArgs.setDistErr(distErrObj * distanceUnits.multiplierFromThisUnitToDegrees());\n      }\n      spatialArgs.setDistErrPct(params.getFieldDouble(fieldKey, FacetParams.FACET_HEATMAP_DIST_ERR_PCT));\n      double distErr = spatialArgs.resolveDistErr(ctx, DEFAULT_DIST_ERR_PCT);\n      if (distErr <= 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            FacetParams.FACET_HEATMAP_DIST_ERR_PCT + \" or \" + FacetParams.FACET_HEATMAP_DIST_ERR\n                + \" should be > 0 or instead provide \" + FacetParams.FACET_HEATMAP_LEVEL + \"=\" + maxGridLevel\n                + \" if you insist on maximum detail\");\n      }\n      //The SPT (grid) can lookup a grid level satisfying an error distance constraint\n      gridLevel = strategy.getGrid().getLevelForDistance(distErr);\n    }\n\n    //Compute!\n    final HeatmapFacetCounter.Heatmap heatmap;\n    try {\n      heatmap = HeatmapFacetCounter.calcFacets(\n          strategy,\n          rb.req.getSearcher().getTopReaderContext(),\n          getTopAcceptDocs(docSet, rb.req.getSearcher()), // turn DocSet into Bits\n          boundsShape,\n          gridLevel,\n          params.getFieldInt(fieldKey, FacetParams.FACET_HEATMAP_MAX_CELLS, 100_000) // will throw if exceeded\n      );\n    } catch (IllegalArgumentException e) {//e.g. too many cells\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.toString(), e);\n    }\n\n    //Populate response\n    NamedList<Object> result = new NamedList<>();\n    result.add(\"gridLevel\", gridLevel);\n    result.add(\"columns\", heatmap.columns);\n    result.add(\"rows\", heatmap.rows);\n    result.add(\"minX\", heatmap.region.getMinX());\n    result.add(\"maxX\", heatmap.region.getMaxX());\n    result.add(\"minY\", heatmap.region.getMinY());\n    result.add(\"maxY\", heatmap.region.getMaxY());\n\n    boolean hasNonZero = false;\n    for (int count : heatmap.counts) {\n      if (count > 0) {\n        hasNonZero = true;\n        break;\n      }\n    }\n    formatCountsAndAddToNL(fieldKey, rb, params, heatmap.columns, heatmap.rows, hasNonZero ? heatmap.counts : null, result);\n\n    return result;\n  }\n\n","sourceOld":"  /** Called by {@link org.apache.solr.request.SimpleFacets} to compute heatmap facets. */\n  public static NamedList<Object> getHeatmapForField(String fieldKey, String fieldName, ResponseBuilder rb, SolrParams params, DocSet docSet) throws IOException {\n    //get the strategy from the field type\n    final SchemaField schemaField = rb.req.getSchema().getField(fieldName);\n    final FieldType type = schemaField.getType();\n\n    final PrefixTreeStrategy strategy;\n    final DistanceUnits distanceUnits;\n    // note: the two instanceof conditions is not ideal, versus one. If we start needing to add more then refactor.\n    if ((type instanceof AbstractSpatialPrefixTreeFieldType)) {\n      AbstractSpatialPrefixTreeFieldType rptType = (AbstractSpatialPrefixTreeFieldType) type;\n      strategy = (PrefixTreeStrategy) rptType.getStrategy(fieldName);\n      distanceUnits = rptType.getDistanceUnits();\n    } else if (type instanceof RptWithGeometrySpatialField) {\n      RptWithGeometrySpatialField rptSdvType  = (RptWithGeometrySpatialField) type;\n      strategy = rptSdvType.getStrategy(fieldName).getIndexStrategy();\n      distanceUnits = rptSdvType.getDistanceUnits();\n    } else {\n      //FYI we support the term query one too but few people use that one\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"heatmap field needs to be of type \"\n          + SpatialRecursivePrefixTreeFieldType.class + \" or \" + RptWithGeometrySpatialField.class);\n    }\n\n    final SpatialContext ctx = strategy.getSpatialContext();\n\n    //get the bbox (query Rectangle)\n    String geomStr = params.getFieldParam(fieldKey, FacetParams.FACET_HEATMAP_GEOM);\n    final Shape boundsShape = geomStr == null ? ctx.getWorldBounds() : SpatialUtils.parseGeomSolrException(geomStr, ctx);\n\n    //get the grid level (possibly indirectly via distErr or distErrPct)\n    final int gridLevel;\n    Integer gridLevelObj = params.getFieldInt(fieldKey, FacetParams.FACET_HEATMAP_LEVEL);\n    final int maxGridLevel = strategy.getGrid().getMaxLevels();\n    if (gridLevelObj != null) {\n      gridLevel = gridLevelObj;\n      if (gridLevel <= 0 || gridLevel > maxGridLevel) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            FacetParams.FACET_HEATMAP_LEVEL +\" should be > 0 and <= \" + maxGridLevel);\n      }\n    } else {\n      //SpatialArgs has utility methods to resolve a 'distErr' from optionally set distErr & distErrPct. Arguably that\n      // should be refactored to feel less weird than using it like this.\n      SpatialArgs spatialArgs = new SpatialArgs(SpatialOperation.Intersects/*ignored*/,\n          boundsShape == null ? ctx.getWorldBounds() : boundsShape);\n      final Double distErrObj = params.getFieldDouble(fieldKey, FacetParams.FACET_HEATMAP_DIST_ERR);\n      if (distErrObj != null) {\n        // convert distErr units based on configured units\n        spatialArgs.setDistErr(distErrObj * distanceUnits.multiplierFromThisUnitToDegrees());\n      }\n      spatialArgs.setDistErrPct(params.getFieldDouble(fieldKey, FacetParams.FACET_HEATMAP_DIST_ERR_PCT));\n      double distErr = spatialArgs.resolveDistErr(ctx, DEFAULT_DIST_ERR_PCT);\n      if (distErr <= 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            FacetParams.FACET_HEATMAP_DIST_ERR_PCT + \" or \" + FacetParams.FACET_HEATMAP_DIST_ERR\n                + \" should be > 0 or instead provide \" + FacetParams.FACET_HEATMAP_LEVEL + \"=\" + maxGridLevel\n                + \" if you insist on maximum detail\");\n      }\n      //The SPT (grid) can lookup a grid level satisfying an error distance constraint\n      gridLevel = strategy.getGrid().getLevelForDistance(distErr);\n    }\n\n    // Turn docSet into Bits\n    Bits topAcceptDocs;\n    if (docSet instanceof BitDocSet) {\n      BitDocSet set = (BitDocSet) docSet;\n      topAcceptDocs = set.getBits();\n    } else {\n      topAcceptDocs = new Bits() {\n        @Override\n        public boolean get(int index) {\n          return docSet.exists(index);\n        }\n\n        @Override\n        public int length() {\n          return rb.req.getSearcher().maxDoc();\n        }\n      };\n    }\n\n    //Compute!\n    final HeatmapFacetCounter.Heatmap heatmap;\n    try {\n      heatmap = HeatmapFacetCounter.calcFacets(\n          strategy,\n          rb.req.getSearcher().getTopReaderContext(),\n          topAcceptDocs,\n          boundsShape,\n          gridLevel,\n          params.getFieldInt(fieldKey, FacetParams.FACET_HEATMAP_MAX_CELLS, 100_000) // will throw if exceeded\n      );\n    } catch (IllegalArgumentException e) {//e.g. too many cells\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.toString(), e);\n    }\n\n    //Populate response\n    NamedList<Object> result = new NamedList<>();\n    result.add(\"gridLevel\", gridLevel);\n    result.add(\"columns\", heatmap.columns);\n    result.add(\"rows\", heatmap.rows);\n    result.add(\"minX\", heatmap.region.getMinX());\n    result.add(\"maxX\", heatmap.region.getMaxX());\n    result.add(\"minY\", heatmap.region.getMinY());\n    result.add(\"maxY\", heatmap.region.getMaxY());\n\n    boolean hasNonZero = false;\n    for (int count : heatmap.counts) {\n      if (count > 0) {\n        hasNonZero = true;\n        break;\n      }\n    }\n    formatCountsAndAddToNL(fieldKey, rb, params, heatmap.columns, heatmap.rows, hasNonZero ? heatmap.counts : null, result);\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpatialHeatmapFacets#getHeatmapForField(String,String,ResponseBuilder,SolrParams,DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpatialHeatmapFacets#getHeatmapForField(String,String,ResponseBuilder,SolrParams,DocSet).mjava","sourceNew":"  /** Called by {@link org.apache.solr.request.SimpleFacets} to compute heatmap facets. */\n  public static NamedList<Object> getHeatmapForField(String fieldKey, String fieldName, ResponseBuilder rb, SolrParams params, DocSet docSet) throws IOException {\n    //get the strategy from the field type\n    final SchemaField schemaField = rb.req.getSchema().getField(fieldName);\n    final FieldType type = schemaField.getType();\n\n    final PrefixTreeStrategy strategy;\n    final DistanceUnits distanceUnits;\n    // note: the two instanceof conditions is not ideal, versus one. If we start needing to add more then refactor.\n    if ((type instanceof AbstractSpatialPrefixTreeFieldType)) {\n      AbstractSpatialPrefixTreeFieldType rptType = (AbstractSpatialPrefixTreeFieldType) type;\n      strategy = (PrefixTreeStrategy) rptType.getStrategy(fieldName);\n      distanceUnits = rptType.getDistanceUnits();\n    } else if (type instanceof RptWithGeometrySpatialField) {\n      RptWithGeometrySpatialField rptSdvType  = (RptWithGeometrySpatialField) type;\n      strategy = rptSdvType.getStrategy(fieldName).getIndexStrategy();\n      distanceUnits = rptSdvType.getDistanceUnits();\n    } else {\n      //FYI we support the term query one too but few people use that one\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"heatmap field needs to be of type \"\n          + SpatialRecursivePrefixTreeFieldType.class + \" or \" + RptWithGeometrySpatialField.class);\n    }\n\n    final SpatialContext ctx = strategy.getSpatialContext();\n\n    //get the bbox (query Rectangle)\n    String geomStr = params.getFieldParam(fieldKey, FacetParams.FACET_HEATMAP_GEOM);\n    final Shape boundsShape = geomStr == null ? ctx.getWorldBounds() : SpatialUtils.parseGeomSolrException(geomStr, ctx);\n\n    //get the grid level (possibly indirectly via distErr or distErrPct)\n    final int gridLevel;\n    Integer gridLevelObj = params.getFieldInt(fieldKey, FacetParams.FACET_HEATMAP_LEVEL);\n    final int maxGridLevel = strategy.getGrid().getMaxLevels();\n    if (gridLevelObj != null) {\n      gridLevel = gridLevelObj;\n      if (gridLevel <= 0 || gridLevel > maxGridLevel) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            FacetParams.FACET_HEATMAP_LEVEL +\" should be > 0 and <= \" + maxGridLevel);\n      }\n    } else {\n      //SpatialArgs has utility methods to resolve a 'distErr' from optionally set distErr & distErrPct. Arguably that\n      // should be refactored to feel less weird than using it like this.\n      SpatialArgs spatialArgs = new SpatialArgs(SpatialOperation.Intersects/*ignored*/,\n          boundsShape == null ? ctx.getWorldBounds() : boundsShape);\n      final Double distErrObj = params.getFieldDouble(fieldKey, FacetParams.FACET_HEATMAP_DIST_ERR);\n      if (distErrObj != null) {\n        // convert distErr units based on configured units\n        spatialArgs.setDistErr(distErrObj * distanceUnits.multiplierFromThisUnitToDegrees());\n      }\n      spatialArgs.setDistErrPct(params.getFieldDouble(fieldKey, FacetParams.FACET_HEATMAP_DIST_ERR_PCT));\n      double distErr = spatialArgs.resolveDistErr(ctx, DEFAULT_DIST_ERR_PCT);\n      if (distErr <= 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            FacetParams.FACET_HEATMAP_DIST_ERR_PCT + \" or \" + FacetParams.FACET_HEATMAP_DIST_ERR\n                + \" should be > 0 or instead provide \" + FacetParams.FACET_HEATMAP_LEVEL + \"=\" + maxGridLevel\n                + \" if you insist on maximum detail\");\n      }\n      //The SPT (grid) can lookup a grid level satisfying an error distance constraint\n      gridLevel = strategy.getGrid().getLevelForDistance(distErr);\n    }\n\n    //Compute!\n    final HeatmapFacetCounter.Heatmap heatmap;\n    try {\n      heatmap = HeatmapFacetCounter.calcFacets(\n          strategy,\n          rb.req.getSearcher().getTopReaderContext(),\n          getTopAcceptDocs(docSet, rb.req.getSearcher()), // turn DocSet into Bits\n          boundsShape,\n          gridLevel,\n          params.getFieldInt(fieldKey, FacetParams.FACET_HEATMAP_MAX_CELLS, 100_000) // will throw if exceeded\n      );\n    } catch (IllegalArgumentException e) {//e.g. too many cells\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.toString(), e);\n    }\n\n    //Populate response\n    NamedList<Object> result = new NamedList<>();\n    result.add(\"gridLevel\", gridLevel);\n    result.add(\"columns\", heatmap.columns);\n    result.add(\"rows\", heatmap.rows);\n    result.add(\"minX\", heatmap.region.getMinX());\n    result.add(\"maxX\", heatmap.region.getMaxX());\n    result.add(\"minY\", heatmap.region.getMinY());\n    result.add(\"maxY\", heatmap.region.getMaxY());\n\n    boolean hasNonZero = false;\n    for (int count : heatmap.counts) {\n      if (count > 0) {\n        hasNonZero = true;\n        break;\n      }\n    }\n    formatCountsAndAddToNL(fieldKey, rb, params, heatmap.columns, heatmap.rows, hasNonZero ? heatmap.counts : null, result);\n\n    return result;\n  }\n\n","sourceOld":"  /** Called by {@link org.apache.solr.request.SimpleFacets} to compute heatmap facets. */\n  public static NamedList<Object> getHeatmapForField(String fieldKey, String fieldName, ResponseBuilder rb, SolrParams params, DocSet docSet) throws IOException {\n    //get the strategy from the field type\n    final SchemaField schemaField = rb.req.getSchema().getField(fieldName);\n    final FieldType type = schemaField.getType();\n\n    final PrefixTreeStrategy strategy;\n    final DistanceUnits distanceUnits;\n    // note: the two instanceof conditions is not ideal, versus one. If we start needing to add more then refactor.\n    if ((type instanceof AbstractSpatialPrefixTreeFieldType)) {\n      AbstractSpatialPrefixTreeFieldType rptType = (AbstractSpatialPrefixTreeFieldType) type;\n      strategy = (PrefixTreeStrategy) rptType.getStrategy(fieldName);\n      distanceUnits = rptType.getDistanceUnits();\n    } else if (type instanceof RptWithGeometrySpatialField) {\n      RptWithGeometrySpatialField rptSdvType  = (RptWithGeometrySpatialField) type;\n      strategy = rptSdvType.getStrategy(fieldName).getIndexStrategy();\n      distanceUnits = rptSdvType.getDistanceUnits();\n    } else {\n      //FYI we support the term query one too but few people use that one\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"heatmap field needs to be of type \"\n          + SpatialRecursivePrefixTreeFieldType.class + \" or \" + RptWithGeometrySpatialField.class);\n    }\n\n    final SpatialContext ctx = strategy.getSpatialContext();\n\n    //get the bbox (query Rectangle)\n    String geomStr = params.getFieldParam(fieldKey, FacetParams.FACET_HEATMAP_GEOM);\n    final Shape boundsShape = geomStr == null ? ctx.getWorldBounds() : SpatialUtils.parseGeomSolrException(geomStr, ctx);\n\n    //get the grid level (possibly indirectly via distErr or distErrPct)\n    final int gridLevel;\n    Integer gridLevelObj = params.getFieldInt(fieldKey, FacetParams.FACET_HEATMAP_LEVEL);\n    final int maxGridLevel = strategy.getGrid().getMaxLevels();\n    if (gridLevelObj != null) {\n      gridLevel = gridLevelObj;\n      if (gridLevel <= 0 || gridLevel > maxGridLevel) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            FacetParams.FACET_HEATMAP_LEVEL +\" should be > 0 and <= \" + maxGridLevel);\n      }\n    } else {\n      //SpatialArgs has utility methods to resolve a 'distErr' from optionally set distErr & distErrPct. Arguably that\n      // should be refactored to feel less weird than using it like this.\n      SpatialArgs spatialArgs = new SpatialArgs(SpatialOperation.Intersects/*ignored*/,\n          boundsShape == null ? ctx.getWorldBounds() : boundsShape);\n      final Double distErrObj = params.getFieldDouble(fieldKey, FacetParams.FACET_HEATMAP_DIST_ERR);\n      if (distErrObj != null) {\n        // convert distErr units based on configured units\n        spatialArgs.setDistErr(distErrObj * distanceUnits.multiplierFromThisUnitToDegrees());\n      }\n      spatialArgs.setDistErrPct(params.getFieldDouble(fieldKey, FacetParams.FACET_HEATMAP_DIST_ERR_PCT));\n      double distErr = spatialArgs.resolveDistErr(ctx, DEFAULT_DIST_ERR_PCT);\n      if (distErr <= 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            FacetParams.FACET_HEATMAP_DIST_ERR_PCT + \" or \" + FacetParams.FACET_HEATMAP_DIST_ERR\n                + \" should be > 0 or instead provide \" + FacetParams.FACET_HEATMAP_LEVEL + \"=\" + maxGridLevel\n                + \" if you insist on maximum detail\");\n      }\n      //The SPT (grid) can lookup a grid level satisfying an error distance constraint\n      gridLevel = strategy.getGrid().getLevelForDistance(distErr);\n    }\n\n    // Turn docSet into Bits\n    Bits topAcceptDocs;\n    if (docSet instanceof BitDocSet) {\n      BitDocSet set = (BitDocSet) docSet;\n      topAcceptDocs = set.getBits();\n    } else {\n      topAcceptDocs = new Bits() {\n        @Override\n        public boolean get(int index) {\n          return docSet.exists(index);\n        }\n\n        @Override\n        public int length() {\n          return rb.req.getSearcher().maxDoc();\n        }\n      };\n    }\n\n    //Compute!\n    final HeatmapFacetCounter.Heatmap heatmap;\n    try {\n      heatmap = HeatmapFacetCounter.calcFacets(\n          strategy,\n          rb.req.getSearcher().getTopReaderContext(),\n          topAcceptDocs,\n          boundsShape,\n          gridLevel,\n          params.getFieldInt(fieldKey, FacetParams.FACET_HEATMAP_MAX_CELLS, 100_000) // will throw if exceeded\n      );\n    } catch (IllegalArgumentException e) {//e.g. too many cells\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.toString(), e);\n    }\n\n    //Populate response\n    NamedList<Object> result = new NamedList<>();\n    result.add(\"gridLevel\", gridLevel);\n    result.add(\"columns\", heatmap.columns);\n    result.add(\"rows\", heatmap.rows);\n    result.add(\"minX\", heatmap.region.getMinX());\n    result.add(\"maxX\", heatmap.region.getMaxX());\n    result.add(\"minY\", heatmap.region.getMinY());\n    result.add(\"maxY\", heatmap.region.getMaxY());\n\n    boolean hasNonZero = false;\n    for (int count : heatmap.counts) {\n      if (count > 0) {\n        hasNonZero = true;\n        break;\n      }\n    }\n    formatCountsAndAddToNL(fieldKey, rb, params, heatmap.columns, heatmap.rows, hasNonZero ? heatmap.counts : null, result);\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2ab027bdfe663227636ccbeda13ae82add302939","date":1529980633,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpatialHeatmapFacets#getHeatmapForField(String,String,ResponseBuilder,SolrParams,DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpatialHeatmapFacets#getHeatmapForField(String,String,ResponseBuilder,SolrParams,DocSet).mjava","sourceNew":"  /** Called by {@link org.apache.solr.request.SimpleFacets} to compute heatmap facets. */\n  public static NamedList<Object> getHeatmapForField(String fieldKey, String fieldName, ResponseBuilder rb, SolrParams params, DocSet docSet) throws IOException {\n    final FacetRequest facetRequest = createHeatmapRequest(fieldKey, fieldName, rb, params);\n    return (NamedList) facetRequest.process(rb.req, docSet);\n  }\n\n","sourceOld":"  /** Called by {@link org.apache.solr.request.SimpleFacets} to compute heatmap facets. */\n  public static NamedList<Object> getHeatmapForField(String fieldKey, String fieldName, ResponseBuilder rb, SolrParams params, DocSet docSet) throws IOException {\n    //get the strategy from the field type\n    final SchemaField schemaField = rb.req.getSchema().getField(fieldName);\n    final FieldType type = schemaField.getType();\n\n    final PrefixTreeStrategy strategy;\n    final DistanceUnits distanceUnits;\n    // note: the two instanceof conditions is not ideal, versus one. If we start needing to add more then refactor.\n    if ((type instanceof AbstractSpatialPrefixTreeFieldType)) {\n      AbstractSpatialPrefixTreeFieldType rptType = (AbstractSpatialPrefixTreeFieldType) type;\n      strategy = (PrefixTreeStrategy) rptType.getStrategy(fieldName);\n      distanceUnits = rptType.getDistanceUnits();\n    } else if (type instanceof RptWithGeometrySpatialField) {\n      RptWithGeometrySpatialField rptSdvType  = (RptWithGeometrySpatialField) type;\n      strategy = rptSdvType.getStrategy(fieldName).getIndexStrategy();\n      distanceUnits = rptSdvType.getDistanceUnits();\n    } else {\n      //FYI we support the term query one too but few people use that one\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"heatmap field needs to be of type \"\n          + SpatialRecursivePrefixTreeFieldType.class + \" or \" + RptWithGeometrySpatialField.class);\n    }\n\n    final SpatialContext ctx = strategy.getSpatialContext();\n\n    //get the bbox (query Rectangle)\n    String geomStr = params.getFieldParam(fieldKey, FacetParams.FACET_HEATMAP_GEOM);\n    final Shape boundsShape = geomStr == null ? ctx.getWorldBounds() : SpatialUtils.parseGeomSolrException(geomStr, ctx);\n\n    //get the grid level (possibly indirectly via distErr or distErrPct)\n    final int gridLevel;\n    Integer gridLevelObj = params.getFieldInt(fieldKey, FacetParams.FACET_HEATMAP_LEVEL);\n    final int maxGridLevel = strategy.getGrid().getMaxLevels();\n    if (gridLevelObj != null) {\n      gridLevel = gridLevelObj;\n      if (gridLevel <= 0 || gridLevel > maxGridLevel) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            FacetParams.FACET_HEATMAP_LEVEL +\" should be > 0 and <= \" + maxGridLevel);\n      }\n    } else {\n      //SpatialArgs has utility methods to resolve a 'distErr' from optionally set distErr & distErrPct. Arguably that\n      // should be refactored to feel less weird than using it like this.\n      SpatialArgs spatialArgs = new SpatialArgs(SpatialOperation.Intersects/*ignored*/,\n          boundsShape == null ? ctx.getWorldBounds() : boundsShape);\n      final Double distErrObj = params.getFieldDouble(fieldKey, FacetParams.FACET_HEATMAP_DIST_ERR);\n      if (distErrObj != null) {\n        // convert distErr units based on configured units\n        spatialArgs.setDistErr(distErrObj * distanceUnits.multiplierFromThisUnitToDegrees());\n      }\n      spatialArgs.setDistErrPct(params.getFieldDouble(fieldKey, FacetParams.FACET_HEATMAP_DIST_ERR_PCT));\n      double distErr = spatialArgs.resolveDistErr(ctx, DEFAULT_DIST_ERR_PCT);\n      if (distErr <= 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            FacetParams.FACET_HEATMAP_DIST_ERR_PCT + \" or \" + FacetParams.FACET_HEATMAP_DIST_ERR\n                + \" should be > 0 or instead provide \" + FacetParams.FACET_HEATMAP_LEVEL + \"=\" + maxGridLevel\n                + \" if you insist on maximum detail\");\n      }\n      //The SPT (grid) can lookup a grid level satisfying an error distance constraint\n      gridLevel = strategy.getGrid().getLevelForDistance(distErr);\n    }\n\n    //Compute!\n    final HeatmapFacetCounter.Heatmap heatmap;\n    try {\n      heatmap = HeatmapFacetCounter.calcFacets(\n          strategy,\n          rb.req.getSearcher().getTopReaderContext(),\n          getTopAcceptDocs(docSet, rb.req.getSearcher()), // turn DocSet into Bits\n          boundsShape,\n          gridLevel,\n          params.getFieldInt(fieldKey, FacetParams.FACET_HEATMAP_MAX_CELLS, 100_000) // will throw if exceeded\n      );\n    } catch (IllegalArgumentException e) {//e.g. too many cells\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.toString(), e);\n    }\n\n    //Populate response\n    NamedList<Object> result = new NamedList<>();\n    result.add(\"gridLevel\", gridLevel);\n    result.add(\"columns\", heatmap.columns);\n    result.add(\"rows\", heatmap.rows);\n    result.add(\"minX\", heatmap.region.getMinX());\n    result.add(\"maxX\", heatmap.region.getMaxX());\n    result.add(\"minY\", heatmap.region.getMinY());\n    result.add(\"maxY\", heatmap.region.getMaxY());\n\n    boolean hasNonZero = false;\n    for (int count : heatmap.counts) {\n      if (count > 0) {\n        hasNonZero = true;\n        break;\n      }\n    }\n    formatCountsAndAddToNL(fieldKey, rb, params, heatmap.columns, heatmap.rows, hasNonZero ? heatmap.counts : null, result);\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpatialHeatmapFacets#getHeatmapForField(String,String,ResponseBuilder,SolrParams,DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpatialHeatmapFacets#getHeatmapForField(String,String,ResponseBuilder,SolrParams,DocSet).mjava","sourceNew":"  /** Called by {@link org.apache.solr.request.SimpleFacets} to compute heatmap facets. */\n  public static NamedList<Object> getHeatmapForField(String fieldKey, String fieldName, ResponseBuilder rb, SolrParams params, DocSet docSet) throws IOException {\n    final FacetRequest facetRequest = createHeatmapRequest(fieldKey, fieldName, rb, params);\n    return (NamedList) facetRequest.process(rb.req, docSet);\n  }\n\n","sourceOld":"  /** Called by {@link org.apache.solr.request.SimpleFacets} to compute heatmap facets. */\n  public static NamedList<Object> getHeatmapForField(String fieldKey, String fieldName, ResponseBuilder rb, SolrParams params, DocSet docSet) throws IOException {\n    //get the strategy from the field type\n    final SchemaField schemaField = rb.req.getSchema().getField(fieldName);\n    final FieldType type = schemaField.getType();\n\n    final PrefixTreeStrategy strategy;\n    final DistanceUnits distanceUnits;\n    // note: the two instanceof conditions is not ideal, versus one. If we start needing to add more then refactor.\n    if ((type instanceof AbstractSpatialPrefixTreeFieldType)) {\n      AbstractSpatialPrefixTreeFieldType rptType = (AbstractSpatialPrefixTreeFieldType) type;\n      strategy = (PrefixTreeStrategy) rptType.getStrategy(fieldName);\n      distanceUnits = rptType.getDistanceUnits();\n    } else if (type instanceof RptWithGeometrySpatialField) {\n      RptWithGeometrySpatialField rptSdvType  = (RptWithGeometrySpatialField) type;\n      strategy = rptSdvType.getStrategy(fieldName).getIndexStrategy();\n      distanceUnits = rptSdvType.getDistanceUnits();\n    } else {\n      //FYI we support the term query one too but few people use that one\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"heatmap field needs to be of type \"\n          + SpatialRecursivePrefixTreeFieldType.class + \" or \" + RptWithGeometrySpatialField.class);\n    }\n\n    final SpatialContext ctx = strategy.getSpatialContext();\n\n    //get the bbox (query Rectangle)\n    String geomStr = params.getFieldParam(fieldKey, FacetParams.FACET_HEATMAP_GEOM);\n    final Shape boundsShape = geomStr == null ? ctx.getWorldBounds() : SpatialUtils.parseGeomSolrException(geomStr, ctx);\n\n    //get the grid level (possibly indirectly via distErr or distErrPct)\n    final int gridLevel;\n    Integer gridLevelObj = params.getFieldInt(fieldKey, FacetParams.FACET_HEATMAP_LEVEL);\n    final int maxGridLevel = strategy.getGrid().getMaxLevels();\n    if (gridLevelObj != null) {\n      gridLevel = gridLevelObj;\n      if (gridLevel <= 0 || gridLevel > maxGridLevel) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            FacetParams.FACET_HEATMAP_LEVEL +\" should be > 0 and <= \" + maxGridLevel);\n      }\n    } else {\n      //SpatialArgs has utility methods to resolve a 'distErr' from optionally set distErr & distErrPct. Arguably that\n      // should be refactored to feel less weird than using it like this.\n      SpatialArgs spatialArgs = new SpatialArgs(SpatialOperation.Intersects/*ignored*/,\n          boundsShape == null ? ctx.getWorldBounds() : boundsShape);\n      final Double distErrObj = params.getFieldDouble(fieldKey, FacetParams.FACET_HEATMAP_DIST_ERR);\n      if (distErrObj != null) {\n        // convert distErr units based on configured units\n        spatialArgs.setDistErr(distErrObj * distanceUnits.multiplierFromThisUnitToDegrees());\n      }\n      spatialArgs.setDistErrPct(params.getFieldDouble(fieldKey, FacetParams.FACET_HEATMAP_DIST_ERR_PCT));\n      double distErr = spatialArgs.resolveDistErr(ctx, DEFAULT_DIST_ERR_PCT);\n      if (distErr <= 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            FacetParams.FACET_HEATMAP_DIST_ERR_PCT + \" or \" + FacetParams.FACET_HEATMAP_DIST_ERR\n                + \" should be > 0 or instead provide \" + FacetParams.FACET_HEATMAP_LEVEL + \"=\" + maxGridLevel\n                + \" if you insist on maximum detail\");\n      }\n      //The SPT (grid) can lookup a grid level satisfying an error distance constraint\n      gridLevel = strategy.getGrid().getLevelForDistance(distErr);\n    }\n\n    //Compute!\n    final HeatmapFacetCounter.Heatmap heatmap;\n    try {\n      heatmap = HeatmapFacetCounter.calcFacets(\n          strategy,\n          rb.req.getSearcher().getTopReaderContext(),\n          getTopAcceptDocs(docSet, rb.req.getSearcher()), // turn DocSet into Bits\n          boundsShape,\n          gridLevel,\n          params.getFieldInt(fieldKey, FacetParams.FACET_HEATMAP_MAX_CELLS, 100_000) // will throw if exceeded\n      );\n    } catch (IllegalArgumentException e) {//e.g. too many cells\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.toString(), e);\n    }\n\n    //Populate response\n    NamedList<Object> result = new NamedList<>();\n    result.add(\"gridLevel\", gridLevel);\n    result.add(\"columns\", heatmap.columns);\n    result.add(\"rows\", heatmap.rows);\n    result.add(\"minX\", heatmap.region.getMinX());\n    result.add(\"maxX\", heatmap.region.getMaxX());\n    result.add(\"minY\", heatmap.region.getMinY());\n    result.add(\"maxY\", heatmap.region.getMaxY());\n\n    boolean hasNonZero = false;\n    for (int count : heatmap.counts) {\n      if (count > 0) {\n        hasNonZero = true;\n        break;\n      }\n    }\n    formatCountsAndAddToNL(fieldKey, rb, params, heatmap.columns, heatmap.rows, hasNonZero ? heatmap.counts : null, result);\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpatialHeatmapFacets#getHeatmapForField(String,String,ResponseBuilder,SolrParams,DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpatialHeatmapFacets#getHeatmapForField(String,String,ResponseBuilder,SolrParams,DocSet).mjava","sourceNew":"  /** Called by {@link org.apache.solr.request.SimpleFacets} to compute heatmap facets. */\n  public static NamedList<Object> getHeatmapForField(String fieldKey, String fieldName, ResponseBuilder rb, SolrParams params, DocSet docSet) throws IOException {\n    final FacetRequest facetRequest = createHeatmapRequest(fieldKey, fieldName, rb, params);\n    return (NamedList) facetRequest.process(rb.req, docSet);\n  }\n\n","sourceOld":"  /** Called by {@link org.apache.solr.request.SimpleFacets} to compute heatmap facets. */\n  public static NamedList<Object> getHeatmapForField(String fieldKey, String fieldName, ResponseBuilder rb, SolrParams params, DocSet docSet) throws IOException {\n    //get the strategy from the field type\n    final SchemaField schemaField = rb.req.getSchema().getField(fieldName);\n    final FieldType type = schemaField.getType();\n\n    final PrefixTreeStrategy strategy;\n    final DistanceUnits distanceUnits;\n    // note: the two instanceof conditions is not ideal, versus one. If we start needing to add more then refactor.\n    if ((type instanceof AbstractSpatialPrefixTreeFieldType)) {\n      AbstractSpatialPrefixTreeFieldType rptType = (AbstractSpatialPrefixTreeFieldType) type;\n      strategy = (PrefixTreeStrategy) rptType.getStrategy(fieldName);\n      distanceUnits = rptType.getDistanceUnits();\n    } else if (type instanceof RptWithGeometrySpatialField) {\n      RptWithGeometrySpatialField rptSdvType  = (RptWithGeometrySpatialField) type;\n      strategy = rptSdvType.getStrategy(fieldName).getIndexStrategy();\n      distanceUnits = rptSdvType.getDistanceUnits();\n    } else {\n      //FYI we support the term query one too but few people use that one\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"heatmap field needs to be of type \"\n          + SpatialRecursivePrefixTreeFieldType.class + \" or \" + RptWithGeometrySpatialField.class);\n    }\n\n    final SpatialContext ctx = strategy.getSpatialContext();\n\n    //get the bbox (query Rectangle)\n    String geomStr = params.getFieldParam(fieldKey, FacetParams.FACET_HEATMAP_GEOM);\n    final Shape boundsShape = geomStr == null ? ctx.getWorldBounds() : SpatialUtils.parseGeomSolrException(geomStr, ctx);\n\n    //get the grid level (possibly indirectly via distErr or distErrPct)\n    final int gridLevel;\n    Integer gridLevelObj = params.getFieldInt(fieldKey, FacetParams.FACET_HEATMAP_LEVEL);\n    final int maxGridLevel = strategy.getGrid().getMaxLevels();\n    if (gridLevelObj != null) {\n      gridLevel = gridLevelObj;\n      if (gridLevel <= 0 || gridLevel > maxGridLevel) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            FacetParams.FACET_HEATMAP_LEVEL +\" should be > 0 and <= \" + maxGridLevel);\n      }\n    } else {\n      //SpatialArgs has utility methods to resolve a 'distErr' from optionally set distErr & distErrPct. Arguably that\n      // should be refactored to feel less weird than using it like this.\n      SpatialArgs spatialArgs = new SpatialArgs(SpatialOperation.Intersects/*ignored*/,\n          boundsShape == null ? ctx.getWorldBounds() : boundsShape);\n      final Double distErrObj = params.getFieldDouble(fieldKey, FacetParams.FACET_HEATMAP_DIST_ERR);\n      if (distErrObj != null) {\n        // convert distErr units based on configured units\n        spatialArgs.setDistErr(distErrObj * distanceUnits.multiplierFromThisUnitToDegrees());\n      }\n      spatialArgs.setDistErrPct(params.getFieldDouble(fieldKey, FacetParams.FACET_HEATMAP_DIST_ERR_PCT));\n      double distErr = spatialArgs.resolveDistErr(ctx, DEFAULT_DIST_ERR_PCT);\n      if (distErr <= 0) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            FacetParams.FACET_HEATMAP_DIST_ERR_PCT + \" or \" + FacetParams.FACET_HEATMAP_DIST_ERR\n                + \" should be > 0 or instead provide \" + FacetParams.FACET_HEATMAP_LEVEL + \"=\" + maxGridLevel\n                + \" if you insist on maximum detail\");\n      }\n      //The SPT (grid) can lookup a grid level satisfying an error distance constraint\n      gridLevel = strategy.getGrid().getLevelForDistance(distErr);\n    }\n\n    //Compute!\n    final HeatmapFacetCounter.Heatmap heatmap;\n    try {\n      heatmap = HeatmapFacetCounter.calcFacets(\n          strategy,\n          rb.req.getSearcher().getTopReaderContext(),\n          getTopAcceptDocs(docSet, rb.req.getSearcher()), // turn DocSet into Bits\n          boundsShape,\n          gridLevel,\n          params.getFieldInt(fieldKey, FacetParams.FACET_HEATMAP_MAX_CELLS, 100_000) // will throw if exceeded\n      );\n    } catch (IllegalArgumentException e) {//e.g. too many cells\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e.toString(), e);\n    }\n\n    //Populate response\n    NamedList<Object> result = new NamedList<>();\n    result.add(\"gridLevel\", gridLevel);\n    result.add(\"columns\", heatmap.columns);\n    result.add(\"rows\", heatmap.rows);\n    result.add(\"minX\", heatmap.region.getMinX());\n    result.add(\"maxX\", heatmap.region.getMaxX());\n    result.add(\"minY\", heatmap.region.getMinY());\n    result.add(\"maxY\", heatmap.region.getMaxY());\n\n    boolean hasNonZero = false;\n    for (int count : heatmap.counts) {\n      if (count > 0) {\n        hasNonZero = true;\n        break;\n      }\n    }\n    formatCountsAndAddToNL(fieldKey, rb, params, heatmap.columns, heatmap.rows, hasNonZero ? heatmap.counts : null, result);\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8582f07e9350eaeb33bf6c4617b8c9895d99c839","date":1591307386,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpatialHeatmapFacets#getHeatmapForField(String,String,ResponseBuilder,SolrParams,DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpatialHeatmapFacets#getHeatmapForField(String,String,ResponseBuilder,SolrParams,DocSet).mjava","sourceNew":"  /** Called by {@link org.apache.solr.request.SimpleFacets} to compute heatmap facets. */\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public static NamedList<Object> getHeatmapForField(String fieldKey, String fieldName, ResponseBuilder rb, SolrParams params, DocSet docSet) throws IOException {\n    final FacetRequest facetRequest = createHeatmapRequest(fieldKey, fieldName, rb, params);\n    return (NamedList) facetRequest.process(rb.req, docSet);\n  }\n\n","sourceOld":"  /** Called by {@link org.apache.solr.request.SimpleFacets} to compute heatmap facets. */\n  public static NamedList<Object> getHeatmapForField(String fieldKey, String fieldName, ResponseBuilder rb, SolrParams params, DocSet docSet) throws IOException {\n    final FacetRequest facetRequest = createHeatmapRequest(fieldKey, fieldName, rb, params);\n    return (NamedList) facetRequest.process(rb.req, docSet);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2ab027bdfe663227636ccbeda13ae82add302939":["80eab62695350cc8593def10dd537faebd86a8e3"],"59d82b0be40ecfcc2c94c776b324e0903a62b844":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["672b198fc3dce868916c727917cae58c2906763d","80eab62695350cc8593def10dd537faebd86a8e3"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["80eab62695350cc8593def10dd537faebd86a8e3","2ab027bdfe663227636ccbeda13ae82add302939"],"672b198fc3dce868916c727917cae58c2906763d":["0caf86b778fe22b63626ba65f24f7b69c5c5b384"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"80eab62695350cc8593def10dd537faebd86a8e3":["672b198fc3dce868916c727917cae58c2906763d"],"0caf86b778fe22b63626ba65f24f7b69c5c5b384":["59d82b0be40ecfcc2c94c776b324e0903a62b844"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8582f07e9350eaeb33bf6c4617b8c9895d99c839"],"8582f07e9350eaeb33bf6c4617b8c9895d99c839":["2ab027bdfe663227636ccbeda13ae82add302939"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["80eab62695350cc8593def10dd537faebd86a8e3","2ab027bdfe663227636ccbeda13ae82add302939"]},"commit2Childs":{"2ab027bdfe663227636ccbeda13ae82add302939":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","8582f07e9350eaeb33bf6c4617b8c9895d99c839","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"59d82b0be40ecfcc2c94c776b324e0903a62b844":["0caf86b778fe22b63626ba65f24f7b69c5c5b384"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"672b198fc3dce868916c727917cae58c2906763d":["e9017cf144952056066919f1ebc7897ff9bd71b1","80eab62695350cc8593def10dd537faebd86a8e3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["59d82b0be40ecfcc2c94c776b324e0903a62b844"],"80eab62695350cc8593def10dd537faebd86a8e3":["2ab027bdfe663227636ccbeda13ae82add302939","e9017cf144952056066919f1ebc7897ff9bd71b1","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"0caf86b778fe22b63626ba65f24f7b69c5c5b384":["672b198fc3dce868916c727917cae58c2906763d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"8582f07e9350eaeb33bf6c4617b8c9895d99c839":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}