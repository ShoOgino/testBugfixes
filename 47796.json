{"path":"src/java/org/apache/lucene/search/MultiSearcherThread[ParallelMultiSearcher]#run().mjava","commits":[{"id":"82dc8f80042322d1c443b6c70bdec5249eb745c2","date":1074623829,"type":0,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/MultiSearcherThread[ParallelMultiSearcher]#run().mjava","pathOld":"/dev/null","sourceNew":"\tpublic void run() {\n\t\ttry {\n\t\t\tdocs = searchable.search(query, filter, nDocs);\n\t\t}\n\t\t// Store the IOException for later use by the caller of this thread\n\t\tcatch (IOException ioe) {\n\t\t\tthis.ioe = ioe;\n\t\t}\n\t\tif (ioe == null) {\n\t\t\tScoreDoc[] scoreDocs = docs.scoreDocs;\n\t\t\tfor (int j = 0;\n\t\t\t\tj < scoreDocs.length;\n\t\t\t\tj++) { // merge scoreDocs into hq\n\t\t\t\tScoreDoc scoreDoc = scoreDocs[j];\n\t\t\t\tscoreDoc.doc += starts[i]; // convert doc \n\t\t\t\t//it would be so nice if we had a thread-safe insert \n\t\t\t\tsynchronized (hq) {\n\t\t\t\t\tif (!hq.insert(scoreDoc))\n\t\t\t\t\t\tbreak;\n\t\t\t\t} // no more scores > minScore\n\t\t\t}\n\t\t}\n\t}\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c6691cb6747f9e850337c706c06b92e9ddf816e1","date":1077044431,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/MultiSearcherThread[ParallelMultiSearcher]#run().mjava","pathOld":"src/java/org/apache/lucene/search/MultiSearcherThread[ParallelMultiSearcher]#run().mjava","sourceNew":"  public void run() {\n    try {\n      docs = (sort == null) ? searchable.search (query, filter, nDocs)\n        : searchable.search (query, filter, nDocs, sort);\n    }\n    // Store the IOException for later use by the caller of this thread\n    catch (IOException ioe) {\n      this.ioe = ioe;\n    }\n    if (ioe == null) {\n      // if we are sorting by fields, we need to tell the field sorted hit queue\n      // the actual type of fields, in case the original list contained AUTO.\n      // if the searchable returns null for fields, we'll have problems.\n      if (sort != null) {\n        ((FieldDocSortedHitQueue)hq).setFields (((TopFieldDocs)docs).fields);\n      }\n      ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0;\n           j < scoreDocs.length;\n           j++) { // merge scoreDocs into hq\n        ScoreDoc scoreDoc = scoreDocs[j];\n        scoreDoc.doc += starts[i]; // convert doc \n        //it would be so nice if we had a thread-safe insert \n        synchronized (hq) {\n          if (!hq.insert(scoreDoc))\n            break;\n        } // no more scores > minScore\n      }\n    }\n  }\n\n","sourceOld":"\tpublic void run() {\n\t\ttry {\n\t\t\tdocs = searchable.search(query, filter, nDocs);\n\t\t}\n\t\t// Store the IOException for later use by the caller of this thread\n\t\tcatch (IOException ioe) {\n\t\t\tthis.ioe = ioe;\n\t\t}\n\t\tif (ioe == null) {\n\t\t\tScoreDoc[] scoreDocs = docs.scoreDocs;\n\t\t\tfor (int j = 0;\n\t\t\t\tj < scoreDocs.length;\n\t\t\t\tj++) { // merge scoreDocs into hq\n\t\t\t\tScoreDoc scoreDoc = scoreDocs[j];\n\t\t\t\tscoreDoc.doc += starts[i]; // convert doc \n\t\t\t\t//it would be so nice if we had a thread-safe insert \n\t\t\t\tsynchronized (hq) {\n\t\t\t\t\tif (!hq.insert(scoreDoc))\n\t\t\t\t\t\tbreak;\n\t\t\t\t} // no more scores > minScore\n\t\t\t}\n\t\t}\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"402061809f3a4629ea0c449e33e9f94a9772f3c3","date":1113967712,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/MultiSearcherThread[ParallelMultiSearcher]#run().mjava","pathOld":"src/java/org/apache/lucene/search/MultiSearcherThread[ParallelMultiSearcher]#run().mjava","sourceNew":"  public void run() {\n    try {\n      docs = (sort == null) ? searchable.search (weight, filter, nDocs)\n        : searchable.search (weight, filter, nDocs, sort);\n    }\n    // Store the IOException for later use by the caller of this thread\n    catch (IOException ioe) {\n      this.ioe = ioe;\n    }\n    if (ioe == null) {\n      // if we are sorting by fields, we need to tell the field sorted hit queue\n      // the actual type of fields, in case the original list contained AUTO.\n      // if the searchable returns null for fields, we'll have problems.\n      if (sort != null) {\n        ((FieldDocSortedHitQueue)hq).setFields (((TopFieldDocs)docs).fields);\n      }\n      ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0;\n           j < scoreDocs.length;\n           j++) { // merge scoreDocs into hq\n        ScoreDoc scoreDoc = scoreDocs[j];\n        scoreDoc.doc += starts[i]; // convert doc \n        //it would be so nice if we had a thread-safe insert \n        synchronized (hq) {\n          if (!hq.insert(scoreDoc))\n            break;\n        } // no more scores > minScore\n      }\n    }\n  }\n\n","sourceOld":"  public void run() {\n    try {\n      docs = (sort == null) ? searchable.search (query, filter, nDocs)\n        : searchable.search (query, filter, nDocs, sort);\n    }\n    // Store the IOException for later use by the caller of this thread\n    catch (IOException ioe) {\n      this.ioe = ioe;\n    }\n    if (ioe == null) {\n      // if we are sorting by fields, we need to tell the field sorted hit queue\n      // the actual type of fields, in case the original list contained AUTO.\n      // if the searchable returns null for fields, we'll have problems.\n      if (sort != null) {\n        ((FieldDocSortedHitQueue)hq).setFields (((TopFieldDocs)docs).fields);\n      }\n      ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0;\n           j < scoreDocs.length;\n           j++) { // merge scoreDocs into hq\n        ScoreDoc scoreDoc = scoreDocs[j];\n        scoreDoc.doc += starts[i]; // convert doc \n        //it would be so nice if we had a thread-safe insert \n        synchronized (hq) {\n          if (!hq.insert(scoreDoc))\n            break;\n        } // no more scores > minScore\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17563f8c3ca7e14d56ce4dcbb3fe9b042ba613cc","date":1241865401,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/MultiSearcherThread[ParallelMultiSearcher]#run().mjava","pathOld":"src/java/org/apache/lucene/search/MultiSearcherThread[ParallelMultiSearcher]#run().mjava","sourceNew":"  public void run() {\n    try {\n      docs = (sort == null) ? searchable.search (weight, filter, nDocs)\n        : searchable.search (weight, filter, nDocs, sort);\n    }\n    // Store the IOException for later use by the caller of this thread\n    catch (IOException ioe) {\n      this.ioe = ioe;\n    }\n    if (ioe == null) {\n      // if we are sorting by fields, we need to tell the field sorted hit queue\n      // the actual type of fields, in case the original list contained AUTO.\n      // if the searchable returns null for fields, we'll have problems.\n      if (sort != null) {\n        TopFieldDocs docsFields = (TopFieldDocs) docs;\n        // If one of the Sort fields is FIELD_DOC, need to fix its values, so that\n        // it will break ties by doc Id properly. Otherwise, it will compare to\n        // 'relative' doc Ids, that belong to two different searchers.\n        for (int j = 0; j < docsFields.fields.length; j++) {\n          if (docsFields.fields[j].getType() == SortField.DOC) {\n            // iterate over the score docs and change their fields value\n            for (int j2 = 0; j2 < docs.scoreDocs.length; j2++) {\n              FieldDoc fd = (FieldDoc) docs.scoreDocs[j2];\n              fd.fields[j] = new Integer(((Integer) fd.fields[j]).intValue() + starts[i]);\n            }\n            break;\n          }\n        }\n\n        ((FieldDocSortedHitQueue) hq).setFields(docsFields.fields);\n      }\n      ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0;\n           j < scoreDocs.length;\n           j++) { // merge scoreDocs into hq\n        ScoreDoc scoreDoc = scoreDocs[j];\n        scoreDoc.doc += starts[i]; // convert doc \n        //it would be so nice if we had a thread-safe insert \n        synchronized (hq) {\n          if (!hq.insert(scoreDoc))\n            break;\n        } // no more scores > minScore\n      }\n    }\n  }\n\n","sourceOld":"  public void run() {\n    try {\n      docs = (sort == null) ? searchable.search (weight, filter, nDocs)\n        : searchable.search (weight, filter, nDocs, sort);\n    }\n    // Store the IOException for later use by the caller of this thread\n    catch (IOException ioe) {\n      this.ioe = ioe;\n    }\n    if (ioe == null) {\n      // if we are sorting by fields, we need to tell the field sorted hit queue\n      // the actual type of fields, in case the original list contained AUTO.\n      // if the searchable returns null for fields, we'll have problems.\n      if (sort != null) {\n        ((FieldDocSortedHitQueue)hq).setFields (((TopFieldDocs)docs).fields);\n      }\n      ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0;\n           j < scoreDocs.length;\n           j++) { // merge scoreDocs into hq\n        ScoreDoc scoreDoc = scoreDocs[j];\n        scoreDoc.doc += starts[i]; // convert doc \n        //it would be so nice if we had a thread-safe insert \n        synchronized (hq) {\n          if (!hq.insert(scoreDoc))\n            break;\n        } // no more scores > minScore\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"052fac7830290bd38a04cddee1a121ee07656b56","date":1245780702,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/MultiSearcherThread[ParallelMultiSearcher]#run().mjava","pathOld":"src/java/org/apache/lucene/search/MultiSearcherThread[ParallelMultiSearcher]#run().mjava","sourceNew":"  public void run() {\n    try {\n      docs = (sort == null) ? searchable.search (weight, filter, nDocs)\n        : searchable.search (weight, filter, nDocs, sort);\n    }\n    // Store the IOException for later use by the caller of this thread\n    catch (IOException ioe) {\n      this.ioe = ioe;\n    }\n    if (ioe == null) {\n      // if we are sorting by fields, we need to tell the field sorted hit queue\n      // the actual type of fields, in case the original list contained AUTO.\n      // if the searchable returns null for fields, we'll have problems.\n      if (sort != null) {\n        TopFieldDocs docsFields = (TopFieldDocs) docs;\n        // If one of the Sort fields is FIELD_DOC, need to fix its values, so that\n        // it will break ties by doc Id properly. Otherwise, it will compare to\n        // 'relative' doc Ids, that belong to two different searchables.\n        for (int j = 0; j < docsFields.fields.length; j++) {\n          if (docsFields.fields[j].getType() == SortField.DOC) {\n            // iterate over the score docs and change their fields value\n            for (int j2 = 0; j2 < docs.scoreDocs.length; j2++) {\n              FieldDoc fd = (FieldDoc) docs.scoreDocs[j2];\n              fd.fields[j] = new Integer(((Integer) fd.fields[j]).intValue() + starts[i]);\n            }\n            break;\n          }\n        }\n\n        ((FieldDocSortedHitQueue) hq).setFields(docsFields.fields);\n      }\n      ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0;\n           j < scoreDocs.length;\n           j++) { // merge scoreDocs into hq\n        ScoreDoc scoreDoc = scoreDocs[j];\n        scoreDoc.doc += starts[i]; // convert doc \n        //it would be so nice if we had a thread-safe insert \n        synchronized (hq) {\n          if (!hq.insert(scoreDoc))\n            break;\n        } // no more scores > minScore\n      }\n    }\n  }\n\n","sourceOld":"  public void run() {\n    try {\n      docs = (sort == null) ? searchable.search (weight, filter, nDocs)\n        : searchable.search (weight, filter, nDocs, sort);\n    }\n    // Store the IOException for later use by the caller of this thread\n    catch (IOException ioe) {\n      this.ioe = ioe;\n    }\n    if (ioe == null) {\n      // if we are sorting by fields, we need to tell the field sorted hit queue\n      // the actual type of fields, in case the original list contained AUTO.\n      // if the searchable returns null for fields, we'll have problems.\n      if (sort != null) {\n        TopFieldDocs docsFields = (TopFieldDocs) docs;\n        // If one of the Sort fields is FIELD_DOC, need to fix its values, so that\n        // it will break ties by doc Id properly. Otherwise, it will compare to\n        // 'relative' doc Ids, that belong to two different searchers.\n        for (int j = 0; j < docsFields.fields.length; j++) {\n          if (docsFields.fields[j].getType() == SortField.DOC) {\n            // iterate over the score docs and change their fields value\n            for (int j2 = 0; j2 < docs.scoreDocs.length; j2++) {\n              FieldDoc fd = (FieldDoc) docs.scoreDocs[j2];\n              fd.fields[j] = new Integer(((Integer) fd.fields[j]).intValue() + starts[i]);\n            }\n            break;\n          }\n        }\n\n        ((FieldDocSortedHitQueue) hq).setFields(docsFields.fields);\n      }\n      ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0;\n           j < scoreDocs.length;\n           j++) { // merge scoreDocs into hq\n        ScoreDoc scoreDoc = scoreDocs[j];\n        scoreDoc.doc += starts[i]; // convert doc \n        //it would be so nice if we had a thread-safe insert \n        synchronized (hq) {\n          if (!hq.insert(scoreDoc))\n            break;\n        } // no more scores > minScore\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bcde5e3f23911110baa101ed062b544162825b5","date":1254521804,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/MultiSearcherThread[ParallelMultiSearcher]#run().mjava","pathOld":"src/java/org/apache/lucene/search/MultiSearcherThread[ParallelMultiSearcher]#run().mjava","sourceNew":"  public void run() {\n    try {\n      docs = (sort == null) ? searchable.search (weight, filter, nDocs)\n        : searchable.search (weight, filter, nDocs, sort);\n    }\n    // Store the IOException for later use by the caller of this thread\n    catch (IOException ioe) {\n      this.ioe = ioe;\n    }\n    if (ioe == null) {\n      // if we are sorting by fields, we need to tell the field sorted hit queue\n      // the actual type of fields, in case the original list contained AUTO.\n      // if the searchable returns null for fields, we'll have problems.\n      if (sort != null) {\n        TopFieldDocs docsFields = (TopFieldDocs) docs;\n        // If one of the Sort fields is FIELD_DOC, need to fix its values, so that\n        // it will break ties by doc Id properly. Otherwise, it will compare to\n        // 'relative' doc Ids, that belong to two different searchables.\n        for (int j = 0; j < docsFields.fields.length; j++) {\n          if (docsFields.fields[j].getType() == SortField.DOC) {\n            // iterate over the score docs and change their fields value\n            for (int j2 = 0; j2 < docs.scoreDocs.length; j2++) {\n              FieldDoc fd = (FieldDoc) docs.scoreDocs[j2];\n              fd.fields[j] = Integer.valueOf(((Integer) fd.fields[j]).intValue() + starts[i]);\n            }\n            break;\n          }\n        }\n\n        ((FieldDocSortedHitQueue) hq).setFields(docsFields.fields);\n      }\n      ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0;\n           j < scoreDocs.length;\n           j++) { // merge scoreDocs into hq\n        ScoreDoc scoreDoc = scoreDocs[j];\n        scoreDoc.doc += starts[i]; // convert doc \n        //it would be so nice if we had a thread-safe insert \n        synchronized (hq) {\n          if (!hq.insert(scoreDoc))\n            break;\n        } // no more scores > minScore\n      }\n    }\n  }\n\n","sourceOld":"  public void run() {\n    try {\n      docs = (sort == null) ? searchable.search (weight, filter, nDocs)\n        : searchable.search (weight, filter, nDocs, sort);\n    }\n    // Store the IOException for later use by the caller of this thread\n    catch (IOException ioe) {\n      this.ioe = ioe;\n    }\n    if (ioe == null) {\n      // if we are sorting by fields, we need to tell the field sorted hit queue\n      // the actual type of fields, in case the original list contained AUTO.\n      // if the searchable returns null for fields, we'll have problems.\n      if (sort != null) {\n        TopFieldDocs docsFields = (TopFieldDocs) docs;\n        // If one of the Sort fields is FIELD_DOC, need to fix its values, so that\n        // it will break ties by doc Id properly. Otherwise, it will compare to\n        // 'relative' doc Ids, that belong to two different searchables.\n        for (int j = 0; j < docsFields.fields.length; j++) {\n          if (docsFields.fields[j].getType() == SortField.DOC) {\n            // iterate over the score docs and change their fields value\n            for (int j2 = 0; j2 < docs.scoreDocs.length; j2++) {\n              FieldDoc fd = (FieldDoc) docs.scoreDocs[j2];\n              fd.fields[j] = new Integer(((Integer) fd.fields[j]).intValue() + starts[i]);\n            }\n            break;\n          }\n        }\n\n        ((FieldDocSortedHitQueue) hq).setFields(docsFields.fields);\n      }\n      ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0;\n           j < scoreDocs.length;\n           j++) { // merge scoreDocs into hq\n        ScoreDoc scoreDoc = scoreDocs[j];\n        scoreDoc.doc += starts[i]; // convert doc \n        //it would be so nice if we had a thread-safe insert \n        synchronized (hq) {\n          if (!hq.insert(scoreDoc))\n            break;\n        } // no more scores > minScore\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0731e137bcbb58121034de6ddaa67332fbe6e5d1","date":1255233265,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/MultiSearcherThread[ParallelMultiSearcher]#run().mjava","pathOld":"src/java/org/apache/lucene/search/MultiSearcherThread[ParallelMultiSearcher]#run().mjava","sourceNew":"  public void run() {\n    try {\n      docs = (sort == null) ? searchable.search (weight, filter, nDocs)\n        : searchable.search (weight, filter, nDocs, sort);\n    }\n    // Store the IOException for later use by the caller of this thread\n    catch (IOException ioe) {\n      this.ioe = ioe;\n    }\n    if (ioe == null) {\n      // if we are sorting by fields, we need to tell the field sorted hit queue\n      // the actual type of fields, in case the original list contained AUTO.\n      // if the searchable returns null for fields, we'll have problems.\n      if (sort != null) {\n        TopFieldDocs docsFields = (TopFieldDocs) docs;\n        // If one of the Sort fields is FIELD_DOC, need to fix its values, so that\n        // it will break ties by doc Id properly. Otherwise, it will compare to\n        // 'relative' doc Ids, that belong to two different searchables.\n        for (int j = 0; j < docsFields.fields.length; j++) {\n          if (docsFields.fields[j].getType() == SortField.DOC) {\n            // iterate over the score docs and change their fields value\n            for (int j2 = 0; j2 < docs.scoreDocs.length; j2++) {\n              FieldDoc fd = (FieldDoc) docs.scoreDocs[j2];\n              fd.fields[j] = Integer.valueOf(((Integer) fd.fields[j]).intValue() + starts[i]);\n            }\n            break;\n          }\n        }\n\n        ((FieldDocSortedHitQueue) hq).setFields(docsFields.fields);\n      }\n      ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0;\n           j < scoreDocs.length;\n           j++) { // merge scoreDocs into hq\n        ScoreDoc scoreDoc = scoreDocs[j];\n        scoreDoc.doc += starts[i]; // convert doc \n        //it would be so nice if we had a thread-safe insert \n        synchronized (hq) {\n          if (scoreDoc == hq.insertWithOverflow(scoreDoc))\n            break;\n        } // no more scores > minScore\n      }\n    }\n  }\n\n","sourceOld":"  public void run() {\n    try {\n      docs = (sort == null) ? searchable.search (weight, filter, nDocs)\n        : searchable.search (weight, filter, nDocs, sort);\n    }\n    // Store the IOException for later use by the caller of this thread\n    catch (IOException ioe) {\n      this.ioe = ioe;\n    }\n    if (ioe == null) {\n      // if we are sorting by fields, we need to tell the field sorted hit queue\n      // the actual type of fields, in case the original list contained AUTO.\n      // if the searchable returns null for fields, we'll have problems.\n      if (sort != null) {\n        TopFieldDocs docsFields = (TopFieldDocs) docs;\n        // If one of the Sort fields is FIELD_DOC, need to fix its values, so that\n        // it will break ties by doc Id properly. Otherwise, it will compare to\n        // 'relative' doc Ids, that belong to two different searchables.\n        for (int j = 0; j < docsFields.fields.length; j++) {\n          if (docsFields.fields[j].getType() == SortField.DOC) {\n            // iterate over the score docs and change their fields value\n            for (int j2 = 0; j2 < docs.scoreDocs.length; j2++) {\n              FieldDoc fd = (FieldDoc) docs.scoreDocs[j2];\n              fd.fields[j] = Integer.valueOf(((Integer) fd.fields[j]).intValue() + starts[i]);\n            }\n            break;\n          }\n        }\n\n        ((FieldDocSortedHitQueue) hq).setFields(docsFields.fields);\n      }\n      ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0;\n           j < scoreDocs.length;\n           j++) { // merge scoreDocs into hq\n        ScoreDoc scoreDoc = scoreDocs[j];\n        scoreDoc.doc += starts[i]; // convert doc \n        //it would be so nice if we had a thread-safe insert \n        synchronized (hq) {\n          if (!hq.insert(scoreDoc))\n            break;\n        } // no more scores > minScore\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ded38b25fe842ef1efc6715745bb8d8ed8e2fc99","date":1255432705,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/MultiSearcherThread[ParallelMultiSearcher]#run().mjava","pathOld":"src/java/org/apache/lucene/search/MultiSearcherThread[ParallelMultiSearcher]#run().mjava","sourceNew":"  public void run() {\n    try {\n      docs = (sort == null) ? searchable.search (weight, filter, nDocs)\n        : searchable.search (weight, filter, nDocs, sort);\n    }\n    // Store the IOException for later use by the caller of this thread\n    catch (IOException ioe) {\n      this.ioe = ioe;\n    }\n    if (ioe == null) {\n      if (sort != null) {\n        TopFieldDocs docsFields = (TopFieldDocs) docs;\n        // If one of the Sort fields is FIELD_DOC, need to fix its values, so that\n        // it will break ties by doc Id properly. Otherwise, it will compare to\n        // 'relative' doc Ids, that belong to two different searchables.\n        for (int j = 0; j < docsFields.fields.length; j++) {\n          if (docsFields.fields[j].getType() == SortField.DOC) {\n            // iterate over the score docs and change their fields value\n            for (int j2 = 0; j2 < docs.scoreDocs.length; j2++) {\n              FieldDoc fd = (FieldDoc) docs.scoreDocs[j2];\n              fd.fields[j] = Integer.valueOf(((Integer) fd.fields[j]).intValue() + starts[i]);\n            }\n            break;\n          }\n        }\n\n        ((FieldDocSortedHitQueue) hq).setFields(docsFields.fields);\n      }\n      ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0;\n           j < scoreDocs.length;\n           j++) { // merge scoreDocs into hq\n        ScoreDoc scoreDoc = scoreDocs[j];\n        scoreDoc.doc += starts[i]; // convert doc \n        //it would be so nice if we had a thread-safe insert \n        synchronized (hq) {\n          if (scoreDoc == hq.insertWithOverflow(scoreDoc))\n            break;\n        } // no more scores > minScore\n      }\n    }\n  }\n\n","sourceOld":"  public void run() {\n    try {\n      docs = (sort == null) ? searchable.search (weight, filter, nDocs)\n        : searchable.search (weight, filter, nDocs, sort);\n    }\n    // Store the IOException for later use by the caller of this thread\n    catch (IOException ioe) {\n      this.ioe = ioe;\n    }\n    if (ioe == null) {\n      // if we are sorting by fields, we need to tell the field sorted hit queue\n      // the actual type of fields, in case the original list contained AUTO.\n      // if the searchable returns null for fields, we'll have problems.\n      if (sort != null) {\n        TopFieldDocs docsFields = (TopFieldDocs) docs;\n        // If one of the Sort fields is FIELD_DOC, need to fix its values, so that\n        // it will break ties by doc Id properly. Otherwise, it will compare to\n        // 'relative' doc Ids, that belong to two different searchables.\n        for (int j = 0; j < docsFields.fields.length; j++) {\n          if (docsFields.fields[j].getType() == SortField.DOC) {\n            // iterate over the score docs and change their fields value\n            for (int j2 = 0; j2 < docs.scoreDocs.length; j2++) {\n              FieldDoc fd = (FieldDoc) docs.scoreDocs[j2];\n              fd.fields[j] = Integer.valueOf(((Integer) fd.fields[j]).intValue() + starts[i]);\n            }\n            break;\n          }\n        }\n\n        ((FieldDocSortedHitQueue) hq).setFields(docsFields.fields);\n      }\n      ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0;\n           j < scoreDocs.length;\n           j++) { // merge scoreDocs into hq\n        ScoreDoc scoreDoc = scoreDocs[j];\n        scoreDoc.doc += starts[i]; // convert doc \n        //it would be so nice if we had a thread-safe insert \n        synchronized (hq) {\n          if (scoreDoc == hq.insertWithOverflow(scoreDoc))\n            break;\n        } // no more scores > minScore\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f63c5771d883c45d43e7d5ac11344582906f7d17","date":1256132259,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/MultiSearcherThread[ParallelMultiSearcher]#run().mjava","pathOld":"src/java/org/apache/lucene/search/MultiSearcherThread[ParallelMultiSearcher]#run().mjava","sourceNew":"  public void run() {\n    try {\n      docs = (sort == null) ? searchable.search (weight, filter, nDocs)\n        : searchable.search (weight, filter, nDocs, sort);\n    }\n    // Store the IOException for later use by the caller of this thread\n    catch (IOException ioe) {\n      this.ioe = ioe;\n    }\n    if (ioe == null) {\n      if (sort != null) {\n        TopFieldDocs docsFields = (TopFieldDocs) docs;\n        // If one of the Sort fields is FIELD_DOC, need to fix its values, so that\n        // it will break ties by doc Id properly. Otherwise, it will compare to\n        // 'relative' doc Ids, that belong to two different searchables.\n        for (int j = 0; j < docsFields.fields.length; j++) {\n          if (docsFields.fields[j].getType() == SortField.DOC) {\n            // iterate over the score docs and change their fields value\n            for (int j2 = 0; j2 < docs.scoreDocs.length; j2++) {\n              FieldDoc fd = (FieldDoc) docs.scoreDocs[j2];\n              fd.fields[j] = Integer.valueOf(((Integer) fd.fields[j]).intValue() + starts[i]);\n            }\n            break;\n          }\n        }\n\n        ((FieldDocSortedHitQueue) hq).setFields(docsFields.fields);\n      }\n      ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0;\n           j < scoreDocs.length;\n           j++) { // merge scoreDocs into hq\n        ScoreDoc scoreDoc = scoreDocs[j];\n        scoreDoc.doc += starts[i]; // convert doc \n        //it would be so nice if we had a thread-safe insert \n        synchronized (hq) {\n          if (scoreDoc == ((HitQueue) hq).insertWithOverflow(scoreDoc))\n            break;\n        } // no more scores > minScore\n      }\n    }\n  }\n\n","sourceOld":"  public void run() {\n    try {\n      docs = (sort == null) ? searchable.search (weight, filter, nDocs)\n        : searchable.search (weight, filter, nDocs, sort);\n    }\n    // Store the IOException for later use by the caller of this thread\n    catch (IOException ioe) {\n      this.ioe = ioe;\n    }\n    if (ioe == null) {\n      if (sort != null) {\n        TopFieldDocs docsFields = (TopFieldDocs) docs;\n        // If one of the Sort fields is FIELD_DOC, need to fix its values, so that\n        // it will break ties by doc Id properly. Otherwise, it will compare to\n        // 'relative' doc Ids, that belong to two different searchables.\n        for (int j = 0; j < docsFields.fields.length; j++) {\n          if (docsFields.fields[j].getType() == SortField.DOC) {\n            // iterate over the score docs and change their fields value\n            for (int j2 = 0; j2 < docs.scoreDocs.length; j2++) {\n              FieldDoc fd = (FieldDoc) docs.scoreDocs[j2];\n              fd.fields[j] = Integer.valueOf(((Integer) fd.fields[j]).intValue() + starts[i]);\n            }\n            break;\n          }\n        }\n\n        ((FieldDocSortedHitQueue) hq).setFields(docsFields.fields);\n      }\n      ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0;\n           j < scoreDocs.length;\n           j++) { // merge scoreDocs into hq\n        ScoreDoc scoreDoc = scoreDocs[j];\n        scoreDoc.doc += starts[i]; // convert doc \n        //it would be so nice if we had a thread-safe insert \n        synchronized (hq) {\n          if (scoreDoc == hq.insertWithOverflow(scoreDoc))\n            break;\n        } // no more scores > minScore\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c96d8c09d99e64ce03476bf4348a0ef052df4c4","date":1256134511,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/MultiSearcherThread[ParallelMultiSearcher]#run().mjava","pathOld":"src/java/org/apache/lucene/search/MultiSearcherThread[ParallelMultiSearcher]#run().mjava","sourceNew":"  @SuppressWarnings (\"unchecked\")\n  public void run() {\n    try {\n      docs = (sort == null) ? searchable.search (weight, filter, nDocs)\n        : searchable.search (weight, filter, nDocs, sort);\n    }\n    // Store the IOException for later use by the caller of this thread\n    catch (IOException ioe) {\n      this.ioe = ioe;\n    }\n    if (ioe == null) {\n      if (sort != null) {\n        TopFieldDocs docsFields = (TopFieldDocs) docs;\n        // If one of the Sort fields is FIELD_DOC, need to fix its values, so that\n        // it will break ties by doc Id properly. Otherwise, it will compare to\n        // 'relative' doc Ids, that belong to two different searchables.\n        for (int j = 0; j < docsFields.fields.length; j++) {\n          if (docsFields.fields[j].getType() == SortField.DOC) {\n            // iterate over the score docs and change their fields value\n            for (int j2 = 0; j2 < docs.scoreDocs.length; j2++) {\n              FieldDoc fd = (FieldDoc) docs.scoreDocs[j2];\n              fd.fields[j] = Integer.valueOf(((Integer) fd.fields[j]).intValue() + starts[i]);\n            }\n            break;\n          }\n        }\n\n        ((FieldDocSortedHitQueue) hq).setFields(docsFields.fields);\n      }\n      ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0;\n           j < scoreDocs.length;\n           j++) { // merge scoreDocs into hq\n        ScoreDoc scoreDoc = scoreDocs[j];\n        scoreDoc.doc += starts[i]; // convert doc \n        //it would be so nice if we had a thread-safe insert \n        synchronized (hq) {\n          if (scoreDoc == ((PriorityQueue<ScoreDoc>) hq).insertWithOverflow(scoreDoc))\n            break;\n        } // no more scores > minScore\n      }\n    }\n  }\n\n","sourceOld":"  public void run() {\n    try {\n      docs = (sort == null) ? searchable.search (weight, filter, nDocs)\n        : searchable.search (weight, filter, nDocs, sort);\n    }\n    // Store the IOException for later use by the caller of this thread\n    catch (IOException ioe) {\n      this.ioe = ioe;\n    }\n    if (ioe == null) {\n      if (sort != null) {\n        TopFieldDocs docsFields = (TopFieldDocs) docs;\n        // If one of the Sort fields is FIELD_DOC, need to fix its values, so that\n        // it will break ties by doc Id properly. Otherwise, it will compare to\n        // 'relative' doc Ids, that belong to two different searchables.\n        for (int j = 0; j < docsFields.fields.length; j++) {\n          if (docsFields.fields[j].getType() == SortField.DOC) {\n            // iterate over the score docs and change their fields value\n            for (int j2 = 0; j2 < docs.scoreDocs.length; j2++) {\n              FieldDoc fd = (FieldDoc) docs.scoreDocs[j2];\n              fd.fields[j] = Integer.valueOf(((Integer) fd.fields[j]).intValue() + starts[i]);\n            }\n            break;\n          }\n        }\n\n        ((FieldDocSortedHitQueue) hq).setFields(docsFields.fields);\n      }\n      ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0;\n           j < scoreDocs.length;\n           j++) { // merge scoreDocs into hq\n        ScoreDoc scoreDoc = scoreDocs[j];\n        scoreDoc.doc += starts[i]; // convert doc \n        //it would be so nice if we had a thread-safe insert \n        synchronized (hq) {\n          if (scoreDoc == ((HitQueue) hq).insertWithOverflow(scoreDoc))\n            break;\n        } // no more scores > minScore\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f0303db6d494aaa871941deaa60b1253cc287cba","date":1256138186,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/MultiSearcherThread[ParallelMultiSearcher]#run().mjava","pathOld":"src/java/org/apache/lucene/search/MultiSearcherThread[ParallelMultiSearcher]#run().mjava","sourceNew":"  @SuppressWarnings (\"unchecked\")\n  public void run() {\n    try {\n      docs = (sort == null) ? searchable.search (weight, filter, nDocs)\n        : searchable.search (weight, filter, nDocs, sort);\n    }\n    // Store the IOException for later use by the caller of this thread\n    catch (IOException ioe) {\n      this.ioe = ioe;\n    }\n    if (ioe == null) {\n      if (sort != null) {\n        TopFieldDocs docsFields = (TopFieldDocs) docs;\n        // If one of the Sort fields is FIELD_DOC, need to fix its values, so that\n        // it will break ties by doc Id properly. Otherwise, it will compare to\n        // 'relative' doc Ids, that belong to two different searchables.\n        for (int j = 0; j < docsFields.fields.length; j++) {\n          if (docsFields.fields[j].getType() == SortField.DOC) {\n            // iterate over the score docs and change their fields value\n            for (int j2 = 0; j2 < docs.scoreDocs.length; j2++) {\n              FieldDoc fd = (FieldDoc) docs.scoreDocs[j2];\n              fd.fields[j] = Integer.valueOf(((Integer) fd.fields[j]).intValue() + starts[i]);\n            }\n            break;\n          }\n        }\n\n        ((FieldDocSortedHitQueue) hq).setFields(docsFields.fields);\n      }\n      ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0;\n           j < scoreDocs.length;\n           j++) { // merge scoreDocs into hq\n        ScoreDoc scoreDoc = scoreDocs[j];\n        scoreDoc.doc += starts[i]; // convert doc \n        //it would be so nice if we had a thread-safe insert \n        synchronized (hq) {\n          // this cast is bad, because we assume that the list has correct type.\n          // Because of that we have the @SuppressWarnings :-(\n          if (scoreDoc == ((PriorityQueue<ScoreDoc>) hq).insertWithOverflow(scoreDoc))\n            break;\n        } // no more scores > minScore\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings (\"unchecked\")\n  public void run() {\n    try {\n      docs = (sort == null) ? searchable.search (weight, filter, nDocs)\n        : searchable.search (weight, filter, nDocs, sort);\n    }\n    // Store the IOException for later use by the caller of this thread\n    catch (IOException ioe) {\n      this.ioe = ioe;\n    }\n    if (ioe == null) {\n      if (sort != null) {\n        TopFieldDocs docsFields = (TopFieldDocs) docs;\n        // If one of the Sort fields is FIELD_DOC, need to fix its values, so that\n        // it will break ties by doc Id properly. Otherwise, it will compare to\n        // 'relative' doc Ids, that belong to two different searchables.\n        for (int j = 0; j < docsFields.fields.length; j++) {\n          if (docsFields.fields[j].getType() == SortField.DOC) {\n            // iterate over the score docs and change their fields value\n            for (int j2 = 0; j2 < docs.scoreDocs.length; j2++) {\n              FieldDoc fd = (FieldDoc) docs.scoreDocs[j2];\n              fd.fields[j] = Integer.valueOf(((Integer) fd.fields[j]).intValue() + starts[i]);\n            }\n            break;\n          }\n        }\n\n        ((FieldDocSortedHitQueue) hq).setFields(docsFields.fields);\n      }\n      ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0;\n           j < scoreDocs.length;\n           j++) { // merge scoreDocs into hq\n        ScoreDoc scoreDoc = scoreDocs[j];\n        scoreDoc.doc += starts[i]; // convert doc \n        //it would be so nice if we had a thread-safe insert \n        synchronized (hq) {\n          if (scoreDoc == ((PriorityQueue<ScoreDoc>) hq).insertWithOverflow(scoreDoc))\n            break;\n        } // no more scores > minScore\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8a9e385641d717e641408d8fbbc62be8fc766357","date":1256746606,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/MultiSearcherThread[ParallelMultiSearcher]#run().mjava","pathOld":"src/java/org/apache/lucene/search/MultiSearcherThread[ParallelMultiSearcher]#run().mjava","sourceNew":"  @Override\n  @SuppressWarnings (\"unchecked\")\n  public void run() {\n    try {\n      docs = (sort == null) ? searchable.search (weight, filter, nDocs)\n        : searchable.search (weight, filter, nDocs, sort);\n    }\n    // Store the IOException for later use by the caller of this thread\n    catch (IOException ioe) {\n      this.ioe = ioe;\n    }\n    if (ioe == null) {\n      if (sort != null) {\n        TopFieldDocs docsFields = (TopFieldDocs) docs;\n        // If one of the Sort fields is FIELD_DOC, need to fix its values, so that\n        // it will break ties by doc Id properly. Otherwise, it will compare to\n        // 'relative' doc Ids, that belong to two different searchables.\n        for (int j = 0; j < docsFields.fields.length; j++) {\n          if (docsFields.fields[j].getType() == SortField.DOC) {\n            // iterate over the score docs and change their fields value\n            for (int j2 = 0; j2 < docs.scoreDocs.length; j2++) {\n              FieldDoc fd = (FieldDoc) docs.scoreDocs[j2];\n              fd.fields[j] = Integer.valueOf(((Integer) fd.fields[j]).intValue() + starts[i]);\n            }\n            break;\n          }\n        }\n\n        ((FieldDocSortedHitQueue) hq).setFields(docsFields.fields);\n      }\n      ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0;\n           j < scoreDocs.length;\n           j++) { // merge scoreDocs into hq\n        ScoreDoc scoreDoc = scoreDocs[j];\n        scoreDoc.doc += starts[i]; // convert doc \n        //it would be so nice if we had a thread-safe insert \n        synchronized (hq) {\n          // this cast is bad, because we assume that the list has correct type.\n          // Because of that we have the @SuppressWarnings :-(\n          if (scoreDoc == ((PriorityQueue<ScoreDoc>) hq).insertWithOverflow(scoreDoc))\n            break;\n        } // no more scores > minScore\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings (\"unchecked\")\n  public void run() {\n    try {\n      docs = (sort == null) ? searchable.search (weight, filter, nDocs)\n        : searchable.search (weight, filter, nDocs, sort);\n    }\n    // Store the IOException for later use by the caller of this thread\n    catch (IOException ioe) {\n      this.ioe = ioe;\n    }\n    if (ioe == null) {\n      if (sort != null) {\n        TopFieldDocs docsFields = (TopFieldDocs) docs;\n        // If one of the Sort fields is FIELD_DOC, need to fix its values, so that\n        // it will break ties by doc Id properly. Otherwise, it will compare to\n        // 'relative' doc Ids, that belong to two different searchables.\n        for (int j = 0; j < docsFields.fields.length; j++) {\n          if (docsFields.fields[j].getType() == SortField.DOC) {\n            // iterate over the score docs and change their fields value\n            for (int j2 = 0; j2 < docs.scoreDocs.length; j2++) {\n              FieldDoc fd = (FieldDoc) docs.scoreDocs[j2];\n              fd.fields[j] = Integer.valueOf(((Integer) fd.fields[j]).intValue() + starts[i]);\n            }\n            break;\n          }\n        }\n\n        ((FieldDocSortedHitQueue) hq).setFields(docsFields.fields);\n      }\n      ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0;\n           j < scoreDocs.length;\n           j++) { // merge scoreDocs into hq\n        ScoreDoc scoreDoc = scoreDocs[j];\n        scoreDoc.doc += starts[i]; // convert doc \n        //it would be so nice if we had a thread-safe insert \n        synchronized (hq) {\n          // this cast is bad, because we assume that the list has correct type.\n          // Because of that we have the @SuppressWarnings :-(\n          if (scoreDoc == ((PriorityQueue<ScoreDoc>) hq).insertWithOverflow(scoreDoc))\n            break;\n        } // no more scores > minScore\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7325af1b9f607a9e8e30785e8de8ffd1d4c08ddf","date":1257873376,"type":4,"author":"Uwe Schindler","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/search/MultiSearcherThread[ParallelMultiSearcher]#run().mjava","sourceNew":null,"sourceOld":"  @Override\n  @SuppressWarnings (\"unchecked\")\n  public void run() {\n    try {\n      docs = (sort == null) ? searchable.search (weight, filter, nDocs)\n        : searchable.search (weight, filter, nDocs, sort);\n    }\n    // Store the IOException for later use by the caller of this thread\n    catch (IOException ioe) {\n      this.ioe = ioe;\n    }\n    if (ioe == null) {\n      if (sort != null) {\n        TopFieldDocs docsFields = (TopFieldDocs) docs;\n        // If one of the Sort fields is FIELD_DOC, need to fix its values, so that\n        // it will break ties by doc Id properly. Otherwise, it will compare to\n        // 'relative' doc Ids, that belong to two different searchables.\n        for (int j = 0; j < docsFields.fields.length; j++) {\n          if (docsFields.fields[j].getType() == SortField.DOC) {\n            // iterate over the score docs and change their fields value\n            for (int j2 = 0; j2 < docs.scoreDocs.length; j2++) {\n              FieldDoc fd = (FieldDoc) docs.scoreDocs[j2];\n              fd.fields[j] = Integer.valueOf(((Integer) fd.fields[j]).intValue() + starts[i]);\n            }\n            break;\n          }\n        }\n\n        ((FieldDocSortedHitQueue) hq).setFields(docsFields.fields);\n      }\n      ScoreDoc[] scoreDocs = docs.scoreDocs;\n      for (int j = 0;\n           j < scoreDocs.length;\n           j++) { // merge scoreDocs into hq\n        ScoreDoc scoreDoc = scoreDocs[j];\n        scoreDoc.doc += starts[i]; // convert doc \n        //it would be so nice if we had a thread-safe insert \n        synchronized (hq) {\n          // this cast is bad, because we assume that the list has correct type.\n          // Because of that we have the @SuppressWarnings :-(\n          if (scoreDoc == ((PriorityQueue<ScoreDoc>) hq).insertWithOverflow(scoreDoc))\n            break;\n        } // no more scores > minScore\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6bcde5e3f23911110baa101ed062b544162825b5":["052fac7830290bd38a04cddee1a121ee07656b56"],"8a9e385641d717e641408d8fbbc62be8fc766357":["f0303db6d494aaa871941deaa60b1253cc287cba"],"ded38b25fe842ef1efc6715745bb8d8ed8e2fc99":["0731e137bcbb58121034de6ddaa67332fbe6e5d1"],"f63c5771d883c45d43e7d5ac11344582906f7d17":["ded38b25fe842ef1efc6715745bb8d8ed8e2fc99"],"82dc8f80042322d1c443b6c70bdec5249eb745c2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f0303db6d494aaa871941deaa60b1253cc287cba":["4c96d8c09d99e64ce03476bf4348a0ef052df4c4"],"17563f8c3ca7e14d56ce4dcbb3fe9b042ba613cc":["402061809f3a4629ea0c449e33e9f94a9772f3c3"],"4c96d8c09d99e64ce03476bf4348a0ef052df4c4":["f63c5771d883c45d43e7d5ac11344582906f7d17"],"c6691cb6747f9e850337c706c06b92e9ddf816e1":["82dc8f80042322d1c443b6c70bdec5249eb745c2"],"402061809f3a4629ea0c449e33e9f94a9772f3c3":["c6691cb6747f9e850337c706c06b92e9ddf816e1"],"7325af1b9f607a9e8e30785e8de8ffd1d4c08ddf":["8a9e385641d717e641408d8fbbc62be8fc766357"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0731e137bcbb58121034de6ddaa67332fbe6e5d1":["6bcde5e3f23911110baa101ed062b544162825b5"],"052fac7830290bd38a04cddee1a121ee07656b56":["17563f8c3ca7e14d56ce4dcbb3fe9b042ba613cc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7325af1b9f607a9e8e30785e8de8ffd1d4c08ddf"]},"commit2Childs":{"6bcde5e3f23911110baa101ed062b544162825b5":["0731e137bcbb58121034de6ddaa67332fbe6e5d1"],"8a9e385641d717e641408d8fbbc62be8fc766357":["7325af1b9f607a9e8e30785e8de8ffd1d4c08ddf"],"ded38b25fe842ef1efc6715745bb8d8ed8e2fc99":["f63c5771d883c45d43e7d5ac11344582906f7d17"],"f63c5771d883c45d43e7d5ac11344582906f7d17":["4c96d8c09d99e64ce03476bf4348a0ef052df4c4"],"82dc8f80042322d1c443b6c70bdec5249eb745c2":["c6691cb6747f9e850337c706c06b92e9ddf816e1"],"f0303db6d494aaa871941deaa60b1253cc287cba":["8a9e385641d717e641408d8fbbc62be8fc766357"],"17563f8c3ca7e14d56ce4dcbb3fe9b042ba613cc":["052fac7830290bd38a04cddee1a121ee07656b56"],"4c96d8c09d99e64ce03476bf4348a0ef052df4c4":["f0303db6d494aaa871941deaa60b1253cc287cba"],"c6691cb6747f9e850337c706c06b92e9ddf816e1":["402061809f3a4629ea0c449e33e9f94a9772f3c3"],"402061809f3a4629ea0c449e33e9f94a9772f3c3":["17563f8c3ca7e14d56ce4dcbb3fe9b042ba613cc"],"7325af1b9f607a9e8e30785e8de8ffd1d4c08ddf":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["82dc8f80042322d1c443b6c70bdec5249eb745c2"],"0731e137bcbb58121034de6ddaa67332fbe6e5d1":["ded38b25fe842ef1efc6715745bb8d8ed8e2fc99"],"052fac7830290bd38a04cddee1a121ee07656b56":["6bcde5e3f23911110baa101ed062b544162825b5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}