{"path":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#process(SolrInputDocument).mjava","commits":[{"id":"0f45f65b8ca4312a6880cc80396c35205dc21543","date":1317846119,"type":0,"author":"Jan HÃ¸ydahl","isMerge":false,"pathNew":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#process(SolrInputDocument).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * This is the main, testable process method called from processAdd()\n   * @param doc the SolrInputDocument to work on\n   * @return the modified SolrInputDocument\n   */\n  protected SolrInputDocument process(SolrInputDocument doc) {\n    String docLang = null;\n    HashSet<String> docLangs = new HashSet<String>();\n    String fallbackLang = getFallbackLang(doc, fallbackFields, fallbackValue);\n      \n    if(langField == null || !doc.containsKey(langField) || (doc.containsKey(langField) && overwrite)) {\n      String allText = concatFields(doc, inputFields);\n      List<DetectedLanguage> languagelist = detectLanguage(allText);\n      docLang = resolveLanguage(languagelist, fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Detected main document language from fields \"+inputFields+\": \"+docLang);\n\n      if(doc.containsKey(langField) && overwrite) {\n        log.debug(\"Overwritten old value \"+doc.getFieldValue(langField));\n      }\n      if(langField != null && langField.length() != 0) {\n        doc.setField(langField, docLang);\n      }\n    } else {\n      // langField is set, we sanity check it against whitelist and fallback\n      docLang = resolveLanguage((String) doc.getFieldValue(langField), fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Field \"+langField+\" already contained value \"+docLang+\", not overwriting.\");\n    }\n\n    if(enableMapping) {\n      for (String fieldName : allMapFieldsSet) {\n        if(doc.containsKey(fieldName)) {        \n          String fieldLang;\n          if(mapIndividual && mapIndividualFieldsSet.contains(fieldName)) {\n            String text = (String) doc.getFieldValue(fieldName);\n            List<DetectedLanguage> languagelist = detectLanguage(text);\n            fieldLang = resolveLanguage(languagelist, docLang);\n            docLangs.add(fieldLang);\n            log.debug(\"Mapping field \"+fieldName+\" using individually detected language \"+fieldLang);\n          } else {\n            fieldLang = docLang;\n            log.debug(\"Mapping field \"+fieldName+\" using document global language \"+fieldLang);\n          }\n          String mappedOutputField = getMappedField(fieldName, fieldLang);\n          if(enforceSchema && schema.getFieldOrNull(fieldName) == null) {\n            log.warn(\"Unsuccessful field name mapping to {}, field does not exist, skipping mapping.\", mappedOutputField, fieldName);\n            mappedOutputField = fieldName;\n          }\n            \n          if (mappedOutputField != null) {\n            log.debug(\"Mapping field {} to {}\", doc.getFieldValue(docIdField), fieldLang);\n            SolrInputField inField = doc.getField(fieldName);\n            doc.setField(mappedOutputField, inField.getValue(), inField.getBoost());\n            if(!mapKeepOrig) {\n              log.debug(\"Removing old field {}\", fieldName);\n              doc.removeField(fieldName);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid output field mapping for \"\n                    + fieldName + \" field and language: \" + fieldLang);\n          }\n        } else {\n          log.warn(\"Document {} does not contain input field {}. Skipping this field.\", doc.getFieldValue(docIdField), fieldName);\n        }\n      }\n    }\n    \n    // Set the languages field to an array of all detected languages\n    if(langsField != null && langsField.length() != 0) {\n      doc.setField(langsField, docLangs.toArray());\n    }\n    \n    return doc;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["a4da5f9e2a1f2ac76feac0c0796bdce4881cb687","3ff1a276d1c94e9393032df34ad607eda09ee3a6","0d6621eda6ffc681632153605ee20ed10dbb76b9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"46ae57a9ea3e7c9a47a3fc2548e1b32c060e3f8f","date":1351009382,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#process(SolrInputDocument).mjava","pathOld":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#process(SolrInputDocument).mjava","sourceNew":"  /**\n   * This is the main, testable process method called from processAdd()\n   * @param doc the SolrInputDocument to work on\n   * @return the modified SolrInputDocument\n   */\n  protected SolrInputDocument process(SolrInputDocument doc) {\n    String docLang = null;\n    HashSet<String> docLangs = new HashSet<String>();\n    String fallbackLang = getFallbackLang(doc, fallbackFields, fallbackValue);\n\n    if(langField == null || !doc.containsKey(langField) || (doc.containsKey(langField) && overwrite)) {\n      String allText = concatFields(doc, inputFields);\n      List<DetectedLanguage> languagelist = detectLanguage(allText);\n      docLang = resolveLanguage(languagelist, fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Detected main document language from fields \"+inputFields+\": \"+docLang);\n\n      if(doc.containsKey(langField) && overwrite) {\n        log.debug(\"Overwritten old value \"+doc.getFieldValue(langField));\n      }\n      if(langField != null && langField.length() != 0) {\n        doc.setField(langField, docLang);\n      }\n    } else {\n      // langField is set, we sanity check it against whitelist and fallback\n      docLang = resolveLanguage((String) doc.getFieldValue(langField), fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Field \"+langField+\" already contained value \"+docLang+\", not overwriting.\");\n    }\n\n    if(enableMapping) {\n      for (String fieldName : allMapFieldsSet) {\n        if(doc.containsKey(fieldName)) {\n          String fieldLang;\n          if(mapIndividual && mapIndividualFieldsSet.contains(fieldName)) {\n            String text = (String) doc.getFieldValue(fieldName);\n            List<DetectedLanguage> languagelist = detectLanguage(text);\n            fieldLang = resolveLanguage(languagelist, docLang);\n            docLangs.add(fieldLang);\n            log.debug(\"Mapping field \"+fieldName+\" using individually detected language \"+fieldLang);\n          } else {\n            fieldLang = docLang;\n            log.debug(\"Mapping field \"+fieldName+\" using document global language \"+fieldLang);\n          }\n          String mappedOutputField = getMappedField(fieldName, fieldLang);\n          if(enforceSchema && schema.getFieldOrNull(fieldName) == null) {\n            log.warn(\"Unsuccessful field name mapping to {}, field does not exist, skipping mapping.\", mappedOutputField, fieldName);\n            mappedOutputField = fieldName;\n          }\n\n          if (mappedOutputField != null) {\n            log.debug(\"Mapping field {} to {}\", doc.getFieldValue(docIdField), fieldLang);\n            SolrInputField inField = doc.getField(fieldName);\n            doc.setField(mappedOutputField, inField.getValue(), inField.getBoost());\n            if(!mapKeepOrig) {\n              log.debug(\"Removing old field {}\", fieldName);\n              doc.removeField(fieldName);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid output field mapping for \"\n                    + fieldName + \" field and language: \" + fieldLang);\n          }\n        }\n      }\n    }\n\n    // Set the languages field to an array of all detected languages\n    if(langsField != null && langsField.length() != 0) {\n      doc.setField(langsField, docLangs.toArray());\n    }\n\n    return doc;\n  }\n\n","sourceOld":"  /**\n   * This is the main, testable process method called from processAdd()\n   * @param doc the SolrInputDocument to work on\n   * @return the modified SolrInputDocument\n   */\n  protected SolrInputDocument process(SolrInputDocument doc) {\n    String docLang = null;\n    HashSet<String> docLangs = new HashSet<String>();\n    String fallbackLang = getFallbackLang(doc, fallbackFields, fallbackValue);\n      \n    if(langField == null || !doc.containsKey(langField) || (doc.containsKey(langField) && overwrite)) {\n      String allText = concatFields(doc, inputFields);\n      List<DetectedLanguage> languagelist = detectLanguage(allText);\n      docLang = resolveLanguage(languagelist, fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Detected main document language from fields \"+inputFields+\": \"+docLang);\n\n      if(doc.containsKey(langField) && overwrite) {\n        log.debug(\"Overwritten old value \"+doc.getFieldValue(langField));\n      }\n      if(langField != null && langField.length() != 0) {\n        doc.setField(langField, docLang);\n      }\n    } else {\n      // langField is set, we sanity check it against whitelist and fallback\n      docLang = resolveLanguage((String) doc.getFieldValue(langField), fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Field \"+langField+\" already contained value \"+docLang+\", not overwriting.\");\n    }\n\n    if(enableMapping) {\n      for (String fieldName : allMapFieldsSet) {\n        if(doc.containsKey(fieldName)) {        \n          String fieldLang;\n          if(mapIndividual && mapIndividualFieldsSet.contains(fieldName)) {\n            String text = (String) doc.getFieldValue(fieldName);\n            List<DetectedLanguage> languagelist = detectLanguage(text);\n            fieldLang = resolveLanguage(languagelist, docLang);\n            docLangs.add(fieldLang);\n            log.debug(\"Mapping field \"+fieldName+\" using individually detected language \"+fieldLang);\n          } else {\n            fieldLang = docLang;\n            log.debug(\"Mapping field \"+fieldName+\" using document global language \"+fieldLang);\n          }\n          String mappedOutputField = getMappedField(fieldName, fieldLang);\n          if(enforceSchema && schema.getFieldOrNull(fieldName) == null) {\n            log.warn(\"Unsuccessful field name mapping to {}, field does not exist, skipping mapping.\", mappedOutputField, fieldName);\n            mappedOutputField = fieldName;\n          }\n            \n          if (mappedOutputField != null) {\n            log.debug(\"Mapping field {} to {}\", doc.getFieldValue(docIdField), fieldLang);\n            SolrInputField inField = doc.getField(fieldName);\n            doc.setField(mappedOutputField, inField.getValue(), inField.getBoost());\n            if(!mapKeepOrig) {\n              log.debug(\"Removing old field {}\", fieldName);\n              doc.removeField(fieldName);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid output field mapping for \"\n                    + fieldName + \" field and language: \" + fieldLang);\n          }\n        } else {\n          log.warn(\"Document {} does not contain input field {}. Skipping this field.\", doc.getFieldValue(docIdField), fieldName);\n        }\n      }\n    }\n    \n    // Set the languages field to an array of all detected languages\n    if(langsField != null && langsField.length() != 0) {\n      doc.setField(langsField, docLangs.toArray());\n    }\n    \n    return doc;\n  }\n\n","bugFix":null,"bugIntro":["a4da5f9e2a1f2ac76feac0c0796bdce4881cb687"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"62e52115b56781006682fd92c6938efaf174304d","date":1351014780,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#process(SolrInputDocument).mjava","pathOld":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#process(SolrInputDocument).mjava","sourceNew":"  /**\n   * This is the main, testable process method called from processAdd()\n   * @param doc the SolrInputDocument to work on\n   * @return the modified SolrInputDocument\n   */\n  protected SolrInputDocument process(SolrInputDocument doc) {\n    String docLang = null;\n    HashSet<String> docLangs = new HashSet<String>();\n    String fallbackLang = getFallbackLang(doc, fallbackFields, fallbackValue);\n\n    if(langField == null || !doc.containsKey(langField) || (doc.containsKey(langField) && overwrite)) {\n      String allText = concatFields(doc, inputFields);\n      List<DetectedLanguage> languagelist = detectLanguage(allText);\n      docLang = resolveLanguage(languagelist, fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Detected main document language from fields \"+inputFields+\": \"+docLang);\n\n      if(doc.containsKey(langField) && overwrite) {\n        log.debug(\"Overwritten old value \"+doc.getFieldValue(langField));\n      }\n      if(langField != null && langField.length() != 0) {\n        doc.setField(langField, docLang);\n      }\n    } else {\n      // langField is set, we sanity check it against whitelist and fallback\n      docLang = resolveLanguage((String) doc.getFieldValue(langField), fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Field \"+langField+\" already contained value \"+docLang+\", not overwriting.\");\n    }\n\n    if(enableMapping) {\n      for (String fieldName : allMapFieldsSet) {\n        if(doc.containsKey(fieldName)) {\n          String fieldLang;\n          if(mapIndividual && mapIndividualFieldsSet.contains(fieldName)) {\n            String text = (String) doc.getFieldValue(fieldName);\n            List<DetectedLanguage> languagelist = detectLanguage(text);\n            fieldLang = resolveLanguage(languagelist, docLang);\n            docLangs.add(fieldLang);\n            log.debug(\"Mapping field \"+fieldName+\" using individually detected language \"+fieldLang);\n          } else {\n            fieldLang = docLang;\n            log.debug(\"Mapping field \"+fieldName+\" using document global language \"+fieldLang);\n          }\n          String mappedOutputField = getMappedField(fieldName, fieldLang);\n          if(enforceSchema && schema.getFieldOrNull(fieldName) == null) {\n            log.warn(\"Unsuccessful field name mapping to {}, field does not exist, skipping mapping.\", mappedOutputField, fieldName);\n            mappedOutputField = fieldName;\n          }\n\n          if (mappedOutputField != null) {\n            log.debug(\"Mapping field {} to {}\", doc.getFieldValue(docIdField), fieldLang);\n            SolrInputField inField = doc.getField(fieldName);\n            doc.setField(mappedOutputField, inField.getValue(), inField.getBoost());\n            if(!mapKeepOrig) {\n              log.debug(\"Removing old field {}\", fieldName);\n              doc.removeField(fieldName);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid output field mapping for \"\n                    + fieldName + \" field and language: \" + fieldLang);\n          }\n        }\n      }\n    }\n\n    // Set the languages field to an array of all detected languages\n    if(langsField != null && langsField.length() != 0) {\n      doc.setField(langsField, docLangs.toArray());\n    }\n\n    return doc;\n  }\n\n","sourceOld":"  /**\n   * This is the main, testable process method called from processAdd()\n   * @param doc the SolrInputDocument to work on\n   * @return the modified SolrInputDocument\n   */\n  protected SolrInputDocument process(SolrInputDocument doc) {\n    String docLang = null;\n    HashSet<String> docLangs = new HashSet<String>();\n    String fallbackLang = getFallbackLang(doc, fallbackFields, fallbackValue);\n      \n    if(langField == null || !doc.containsKey(langField) || (doc.containsKey(langField) && overwrite)) {\n      String allText = concatFields(doc, inputFields);\n      List<DetectedLanguage> languagelist = detectLanguage(allText);\n      docLang = resolveLanguage(languagelist, fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Detected main document language from fields \"+inputFields+\": \"+docLang);\n\n      if(doc.containsKey(langField) && overwrite) {\n        log.debug(\"Overwritten old value \"+doc.getFieldValue(langField));\n      }\n      if(langField != null && langField.length() != 0) {\n        doc.setField(langField, docLang);\n      }\n    } else {\n      // langField is set, we sanity check it against whitelist and fallback\n      docLang = resolveLanguage((String) doc.getFieldValue(langField), fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Field \"+langField+\" already contained value \"+docLang+\", not overwriting.\");\n    }\n\n    if(enableMapping) {\n      for (String fieldName : allMapFieldsSet) {\n        if(doc.containsKey(fieldName)) {        \n          String fieldLang;\n          if(mapIndividual && mapIndividualFieldsSet.contains(fieldName)) {\n            String text = (String) doc.getFieldValue(fieldName);\n            List<DetectedLanguage> languagelist = detectLanguage(text);\n            fieldLang = resolveLanguage(languagelist, docLang);\n            docLangs.add(fieldLang);\n            log.debug(\"Mapping field \"+fieldName+\" using individually detected language \"+fieldLang);\n          } else {\n            fieldLang = docLang;\n            log.debug(\"Mapping field \"+fieldName+\" using document global language \"+fieldLang);\n          }\n          String mappedOutputField = getMappedField(fieldName, fieldLang);\n          if(enforceSchema && schema.getFieldOrNull(fieldName) == null) {\n            log.warn(\"Unsuccessful field name mapping to {}, field does not exist, skipping mapping.\", mappedOutputField, fieldName);\n            mappedOutputField = fieldName;\n          }\n            \n          if (mappedOutputField != null) {\n            log.debug(\"Mapping field {} to {}\", doc.getFieldValue(docIdField), fieldLang);\n            SolrInputField inField = doc.getField(fieldName);\n            doc.setField(mappedOutputField, inField.getValue(), inField.getBoost());\n            if(!mapKeepOrig) {\n              log.debug(\"Removing old field {}\", fieldName);\n              doc.removeField(fieldName);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid output field mapping for \"\n                    + fieldName + \" field and language: \" + fieldLang);\n          }\n        } else {\n          log.warn(\"Document {} does not contain input field {}. Skipping this field.\", doc.getFieldValue(docIdField), fieldName);\n        }\n      }\n    }\n    \n    // Set the languages field to an array of all detected languages\n    if(langsField != null && langsField.length() != 0) {\n      doc.setField(langsField, docLangs.toArray());\n    }\n    \n    return doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d6621eda6ffc681632153605ee20ed10dbb76b9","date":1359505599,"type":3,"author":"Jan HÃ¸ydahl","isMerge":false,"pathNew":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#process(SolrInputDocument).mjava","pathOld":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#process(SolrInputDocument).mjava","sourceNew":"  /**\n   * This is the main, testable process method called from processAdd()\n   * @param doc the SolrInputDocument to work on\n   * @return the modified SolrInputDocument\n   */\n  protected SolrInputDocument process(SolrInputDocument doc) {\n    String docLang = null;\n    HashSet<String> docLangs = new HashSet<String>();\n    String fallbackLang = getFallbackLang(doc, fallbackFields, fallbackValue);\n\n    if(langField == null || !doc.containsKey(langField) || (doc.containsKey(langField) && overwrite)) {\n      String allText = concatFields(doc, inputFields);\n      List<DetectedLanguage> languagelist = detectLanguage(allText);\n      docLang = resolveLanguage(languagelist, fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Detected main document language from fields \"+inputFields+\": \"+docLang);\n\n      if(doc.containsKey(langField) && overwrite) {\n        log.debug(\"Overwritten old value \"+doc.getFieldValue(langField));\n      }\n      if(langField != null && langField.length() != 0) {\n        doc.setField(langField, docLang);\n      }\n    } else {\n      // langField is set, we sanity check it against whitelist and fallback\n      docLang = resolveLanguage((String) doc.getFieldValue(langField), fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Field \"+langField+\" already contained value \"+docLang+\", not overwriting.\");\n    }\n\n    if(enableMapping) {\n      for (String fieldName : allMapFieldsSet) {\n        if(doc.containsKey(fieldName)) {\n          String fieldLang;\n          if(mapIndividual && mapIndividualFieldsSet.contains(fieldName)) {\n            String text = (String) doc.getFieldValue(fieldName);\n            List<DetectedLanguage> languagelist = detectLanguage(text);\n            fieldLang = resolveLanguage(languagelist, docLang);\n            docLangs.add(fieldLang);\n            log.debug(\"Mapping field \"+fieldName+\" using individually detected language \"+fieldLang);\n          } else {\n            fieldLang = docLang;\n            log.debug(\"Mapping field \"+fieldName+\" using document global language \"+fieldLang);\n          }\n          String mappedOutputField = getMappedField(fieldName, fieldLang);\n\n          if (mappedOutputField != null) {\n            log.debug(\"Mapping field {} to {}\", doc.getFieldValue(docIdField), fieldLang);\n            SolrInputField inField = doc.getField(fieldName);\n            doc.setField(mappedOutputField, inField.getValue(), inField.getBoost());\n            if(!mapKeepOrig) {\n              log.debug(\"Removing old field {}\", fieldName);\n              doc.removeField(fieldName);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid output field mapping for \"\n                    + fieldName + \" field and language: \" + fieldLang);\n          }\n        }\n      }\n    }\n\n    // Set the languages field to an array of all detected languages\n    if(langsField != null && langsField.length() != 0) {\n      doc.setField(langsField, docLangs.toArray());\n    }\n\n    return doc;\n  }\n\n","sourceOld":"  /**\n   * This is the main, testable process method called from processAdd()\n   * @param doc the SolrInputDocument to work on\n   * @return the modified SolrInputDocument\n   */\n  protected SolrInputDocument process(SolrInputDocument doc) {\n    String docLang = null;\n    HashSet<String> docLangs = new HashSet<String>();\n    String fallbackLang = getFallbackLang(doc, fallbackFields, fallbackValue);\n\n    if(langField == null || !doc.containsKey(langField) || (doc.containsKey(langField) && overwrite)) {\n      String allText = concatFields(doc, inputFields);\n      List<DetectedLanguage> languagelist = detectLanguage(allText);\n      docLang = resolveLanguage(languagelist, fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Detected main document language from fields \"+inputFields+\": \"+docLang);\n\n      if(doc.containsKey(langField) && overwrite) {\n        log.debug(\"Overwritten old value \"+doc.getFieldValue(langField));\n      }\n      if(langField != null && langField.length() != 0) {\n        doc.setField(langField, docLang);\n      }\n    } else {\n      // langField is set, we sanity check it against whitelist and fallback\n      docLang = resolveLanguage((String) doc.getFieldValue(langField), fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Field \"+langField+\" already contained value \"+docLang+\", not overwriting.\");\n    }\n\n    if(enableMapping) {\n      for (String fieldName : allMapFieldsSet) {\n        if(doc.containsKey(fieldName)) {\n          String fieldLang;\n          if(mapIndividual && mapIndividualFieldsSet.contains(fieldName)) {\n            String text = (String) doc.getFieldValue(fieldName);\n            List<DetectedLanguage> languagelist = detectLanguage(text);\n            fieldLang = resolveLanguage(languagelist, docLang);\n            docLangs.add(fieldLang);\n            log.debug(\"Mapping field \"+fieldName+\" using individually detected language \"+fieldLang);\n          } else {\n            fieldLang = docLang;\n            log.debug(\"Mapping field \"+fieldName+\" using document global language \"+fieldLang);\n          }\n          String mappedOutputField = getMappedField(fieldName, fieldLang);\n          if(enforceSchema && schema.getFieldOrNull(fieldName) == null) {\n            log.warn(\"Unsuccessful field name mapping to {}, field does not exist, skipping mapping.\", mappedOutputField, fieldName);\n            mappedOutputField = fieldName;\n          }\n\n          if (mappedOutputField != null) {\n            log.debug(\"Mapping field {} to {}\", doc.getFieldValue(docIdField), fieldLang);\n            SolrInputField inField = doc.getField(fieldName);\n            doc.setField(mappedOutputField, inField.getValue(), inField.getBoost());\n            if(!mapKeepOrig) {\n              log.debug(\"Removing old field {}\", fieldName);\n              doc.removeField(fieldName);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid output field mapping for \"\n                    + fieldName + \" field and language: \" + fieldLang);\n          }\n        }\n      }\n    }\n\n    // Set the languages field to an array of all detected languages\n    if(langsField != null && langsField.length() != 0) {\n      doc.setField(langsField, docLangs.toArray());\n    }\n\n    return doc;\n  }\n\n","bugFix":["0f45f65b8ca4312a6880cc80396c35205dc21543"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"61d5f95d14e5b9b046998c51e16709a398c15226","date":1359603451,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#process(SolrInputDocument).mjava","pathOld":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#process(SolrInputDocument).mjava","sourceNew":"  /**\n   * This is the main, testable process method called from processAdd()\n   * @param doc the SolrInputDocument to work on\n   * @return the modified SolrInputDocument\n   */\n  protected SolrInputDocument process(SolrInputDocument doc) {\n    String docLang = null;\n    HashSet<String> docLangs = new HashSet<String>();\n    String fallbackLang = getFallbackLang(doc, fallbackFields, fallbackValue);\n\n    if(langField == null || !doc.containsKey(langField) || (doc.containsKey(langField) && overwrite)) {\n      String allText = concatFields(doc, inputFields);\n      List<DetectedLanguage> languagelist = detectLanguage(allText);\n      docLang = resolveLanguage(languagelist, fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Detected main document language from fields \"+inputFields+\": \"+docLang);\n\n      if(doc.containsKey(langField) && overwrite) {\n        log.debug(\"Overwritten old value \"+doc.getFieldValue(langField));\n      }\n      if(langField != null && langField.length() != 0) {\n        doc.setField(langField, docLang);\n      }\n    } else {\n      // langField is set, we sanity check it against whitelist and fallback\n      docLang = resolveLanguage((String) doc.getFieldValue(langField), fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Field \"+langField+\" already contained value \"+docLang+\", not overwriting.\");\n    }\n\n    if(enableMapping) {\n      for (String fieldName : allMapFieldsSet) {\n        if(doc.containsKey(fieldName)) {\n          String fieldLang;\n          if(mapIndividual && mapIndividualFieldsSet.contains(fieldName)) {\n            String text = (String) doc.getFieldValue(fieldName);\n            List<DetectedLanguage> languagelist = detectLanguage(text);\n            fieldLang = resolveLanguage(languagelist, docLang);\n            docLangs.add(fieldLang);\n            log.debug(\"Mapping field \"+fieldName+\" using individually detected language \"+fieldLang);\n          } else {\n            fieldLang = docLang;\n            log.debug(\"Mapping field \"+fieldName+\" using document global language \"+fieldLang);\n          }\n          String mappedOutputField = getMappedField(fieldName, fieldLang);\n\n          if (mappedOutputField != null) {\n            log.debug(\"Mapping field {} to {}\", doc.getFieldValue(docIdField), fieldLang);\n            SolrInputField inField = doc.getField(fieldName);\n            doc.setField(mappedOutputField, inField.getValue(), inField.getBoost());\n            if(!mapKeepOrig) {\n              log.debug(\"Removing old field {}\", fieldName);\n              doc.removeField(fieldName);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid output field mapping for \"\n                    + fieldName + \" field and language: \" + fieldLang);\n          }\n        }\n      }\n    }\n\n    // Set the languages field to an array of all detected languages\n    if(langsField != null && langsField.length() != 0) {\n      doc.setField(langsField, docLangs.toArray());\n    }\n\n    return doc;\n  }\n\n","sourceOld":"  /**\n   * This is the main, testable process method called from processAdd()\n   * @param doc the SolrInputDocument to work on\n   * @return the modified SolrInputDocument\n   */\n  protected SolrInputDocument process(SolrInputDocument doc) {\n    String docLang = null;\n    HashSet<String> docLangs = new HashSet<String>();\n    String fallbackLang = getFallbackLang(doc, fallbackFields, fallbackValue);\n\n    if(langField == null || !doc.containsKey(langField) || (doc.containsKey(langField) && overwrite)) {\n      String allText = concatFields(doc, inputFields);\n      List<DetectedLanguage> languagelist = detectLanguage(allText);\n      docLang = resolveLanguage(languagelist, fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Detected main document language from fields \"+inputFields+\": \"+docLang);\n\n      if(doc.containsKey(langField) && overwrite) {\n        log.debug(\"Overwritten old value \"+doc.getFieldValue(langField));\n      }\n      if(langField != null && langField.length() != 0) {\n        doc.setField(langField, docLang);\n      }\n    } else {\n      // langField is set, we sanity check it against whitelist and fallback\n      docLang = resolveLanguage((String) doc.getFieldValue(langField), fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Field \"+langField+\" already contained value \"+docLang+\", not overwriting.\");\n    }\n\n    if(enableMapping) {\n      for (String fieldName : allMapFieldsSet) {\n        if(doc.containsKey(fieldName)) {\n          String fieldLang;\n          if(mapIndividual && mapIndividualFieldsSet.contains(fieldName)) {\n            String text = (String) doc.getFieldValue(fieldName);\n            List<DetectedLanguage> languagelist = detectLanguage(text);\n            fieldLang = resolveLanguage(languagelist, docLang);\n            docLangs.add(fieldLang);\n            log.debug(\"Mapping field \"+fieldName+\" using individually detected language \"+fieldLang);\n          } else {\n            fieldLang = docLang;\n            log.debug(\"Mapping field \"+fieldName+\" using document global language \"+fieldLang);\n          }\n          String mappedOutputField = getMappedField(fieldName, fieldLang);\n          if(enforceSchema && schema.getFieldOrNull(fieldName) == null) {\n            log.warn(\"Unsuccessful field name mapping to {}, field does not exist, skipping mapping.\", mappedOutputField, fieldName);\n            mappedOutputField = fieldName;\n          }\n\n          if (mappedOutputField != null) {\n            log.debug(\"Mapping field {} to {}\", doc.getFieldValue(docIdField), fieldLang);\n            SolrInputField inField = doc.getField(fieldName);\n            doc.setField(mappedOutputField, inField.getValue(), inField.getBoost());\n            if(!mapKeepOrig) {\n              log.debug(\"Removing old field {}\", fieldName);\n              doc.removeField(fieldName);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid output field mapping for \"\n                    + fieldName + \" field and language: \" + fieldLang);\n          }\n        }\n      }\n    }\n\n    // Set the languages field to an array of all detected languages\n    if(langsField != null && langsField.length() != 0) {\n      doc.setField(langsField, docLangs.toArray());\n    }\n\n    return doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#process(SolrInputDocument).mjava","pathOld":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#process(SolrInputDocument).mjava","sourceNew":"  /**\n   * This is the main, testable process method called from processAdd()\n   * @param doc the SolrInputDocument to work on\n   * @return the modified SolrInputDocument\n   */\n  protected SolrInputDocument process(SolrInputDocument doc) {\n    String docLang = null;\n    HashSet<String> docLangs = new HashSet<>();\n    String fallbackLang = getFallbackLang(doc, fallbackFields, fallbackValue);\n\n    if(langField == null || !doc.containsKey(langField) || (doc.containsKey(langField) && overwrite)) {\n      String allText = concatFields(doc, inputFields);\n      List<DetectedLanguage> languagelist = detectLanguage(allText);\n      docLang = resolveLanguage(languagelist, fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Detected main document language from fields \"+inputFields+\": \"+docLang);\n\n      if(doc.containsKey(langField) && overwrite) {\n        log.debug(\"Overwritten old value \"+doc.getFieldValue(langField));\n      }\n      if(langField != null && langField.length() != 0) {\n        doc.setField(langField, docLang);\n      }\n    } else {\n      // langField is set, we sanity check it against whitelist and fallback\n      docLang = resolveLanguage((String) doc.getFieldValue(langField), fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Field \"+langField+\" already contained value \"+docLang+\", not overwriting.\");\n    }\n\n    if(enableMapping) {\n      for (String fieldName : allMapFieldsSet) {\n        if(doc.containsKey(fieldName)) {\n          String fieldLang;\n          if(mapIndividual && mapIndividualFieldsSet.contains(fieldName)) {\n            String text = (String) doc.getFieldValue(fieldName);\n            List<DetectedLanguage> languagelist = detectLanguage(text);\n            fieldLang = resolveLanguage(languagelist, docLang);\n            docLangs.add(fieldLang);\n            log.debug(\"Mapping field \"+fieldName+\" using individually detected language \"+fieldLang);\n          } else {\n            fieldLang = docLang;\n            log.debug(\"Mapping field \"+fieldName+\" using document global language \"+fieldLang);\n          }\n          String mappedOutputField = getMappedField(fieldName, fieldLang);\n\n          if (mappedOutputField != null) {\n            log.debug(\"Mapping field {} to {}\", doc.getFieldValue(docIdField), fieldLang);\n            SolrInputField inField = doc.getField(fieldName);\n            doc.setField(mappedOutputField, inField.getValue(), inField.getBoost());\n            if(!mapKeepOrig) {\n              log.debug(\"Removing old field {}\", fieldName);\n              doc.removeField(fieldName);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid output field mapping for \"\n                    + fieldName + \" field and language: \" + fieldLang);\n          }\n        }\n      }\n    }\n\n    // Set the languages field to an array of all detected languages\n    if(langsField != null && langsField.length() != 0) {\n      doc.setField(langsField, docLangs.toArray());\n    }\n\n    return doc;\n  }\n\n","sourceOld":"  /**\n   * This is the main, testable process method called from processAdd()\n   * @param doc the SolrInputDocument to work on\n   * @return the modified SolrInputDocument\n   */\n  protected SolrInputDocument process(SolrInputDocument doc) {\n    String docLang = null;\n    HashSet<String> docLangs = new HashSet<String>();\n    String fallbackLang = getFallbackLang(doc, fallbackFields, fallbackValue);\n\n    if(langField == null || !doc.containsKey(langField) || (doc.containsKey(langField) && overwrite)) {\n      String allText = concatFields(doc, inputFields);\n      List<DetectedLanguage> languagelist = detectLanguage(allText);\n      docLang = resolveLanguage(languagelist, fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Detected main document language from fields \"+inputFields+\": \"+docLang);\n\n      if(doc.containsKey(langField) && overwrite) {\n        log.debug(\"Overwritten old value \"+doc.getFieldValue(langField));\n      }\n      if(langField != null && langField.length() != 0) {\n        doc.setField(langField, docLang);\n      }\n    } else {\n      // langField is set, we sanity check it against whitelist and fallback\n      docLang = resolveLanguage((String) doc.getFieldValue(langField), fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Field \"+langField+\" already contained value \"+docLang+\", not overwriting.\");\n    }\n\n    if(enableMapping) {\n      for (String fieldName : allMapFieldsSet) {\n        if(doc.containsKey(fieldName)) {\n          String fieldLang;\n          if(mapIndividual && mapIndividualFieldsSet.contains(fieldName)) {\n            String text = (String) doc.getFieldValue(fieldName);\n            List<DetectedLanguage> languagelist = detectLanguage(text);\n            fieldLang = resolveLanguage(languagelist, docLang);\n            docLangs.add(fieldLang);\n            log.debug(\"Mapping field \"+fieldName+\" using individually detected language \"+fieldLang);\n          } else {\n            fieldLang = docLang;\n            log.debug(\"Mapping field \"+fieldName+\" using document global language \"+fieldLang);\n          }\n          String mappedOutputField = getMappedField(fieldName, fieldLang);\n\n          if (mappedOutputField != null) {\n            log.debug(\"Mapping field {} to {}\", doc.getFieldValue(docIdField), fieldLang);\n            SolrInputField inField = doc.getField(fieldName);\n            doc.setField(mappedOutputField, inField.getValue(), inField.getBoost());\n            if(!mapKeepOrig) {\n              log.debug(\"Removing old field {}\", fieldName);\n              doc.removeField(fieldName);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid output field mapping for \"\n                    + fieldName + \" field and language: \" + fieldLang);\n          }\n        }\n      }\n    }\n\n    // Set the languages field to an array of all detected languages\n    if(langsField != null && langsField.length() != 0) {\n      doc.setField(langsField, docLangs.toArray());\n    }\n\n    return doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3ff1a276d1c94e9393032df34ad607eda09ee3a6","date":1417803750,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#process(SolrInputDocument).mjava","pathOld":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#process(SolrInputDocument).mjava","sourceNew":"  /**\n   * This is the main, testable process method called from processAdd()\n   * @param doc the SolrInputDocument to work on\n   * @return the modified SolrInputDocument\n   */\n  protected SolrInputDocument process(SolrInputDocument doc) {\n    String docLang = null;\n    HashSet<String> docLangs = new HashSet<>();\n    String fallbackLang = getFallbackLang(doc, fallbackFields, fallbackValue);\n\n    if(langField == null || !doc.containsKey(langField) || (doc.containsKey(langField) && overwrite)) {\n      List<DetectedLanguage> languagelist = detectLanguage(doc);\n      docLang = resolveLanguage(languagelist, fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Detected main document language from fields \"+ Arrays.toString(inputFields) +\": \"+docLang);\n\n      if(doc.containsKey(langField) && overwrite) {\n        log.debug(\"Overwritten old value \"+doc.getFieldValue(langField));\n      }\n      if(langField != null && langField.length() != 0) {\n        doc.setField(langField, docLang);\n      }\n    } else {\n      // langField is set, we sanity check it against whitelist and fallback\n      docLang = resolveLanguage((String) doc.getFieldValue(langField), fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Field \"+langField+\" already contained value \"+docLang+\", not overwriting.\");\n    }\n\n    if(enableMapping) {\n      for (String fieldName : allMapFieldsSet) {\n        if(doc.containsKey(fieldName)) {\n          String fieldLang;\n          if(mapIndividual && mapIndividualFieldsSet.contains(fieldName)) {\n            List<DetectedLanguage> languagelist = detectLanguage(doc);\n            fieldLang = resolveLanguage(languagelist, docLang);\n            docLangs.add(fieldLang);\n            log.debug(\"Mapping field \"+fieldName+\" using individually detected language \"+fieldLang);\n          } else {\n            fieldLang = docLang;\n            log.debug(\"Mapping field \"+fieldName+\" using document global language \"+fieldLang);\n          }\n          String mappedOutputField = getMappedField(fieldName, fieldLang);\n\n          if (mappedOutputField != null) {\n            log.debug(\"Mapping field {} to {}\", doc.getFieldValue(docIdField), fieldLang);\n            SolrInputField inField = doc.getField(fieldName);\n            doc.setField(mappedOutputField, inField.getValue(), inField.getBoost());\n            if(!mapKeepOrig) {\n              log.debug(\"Removing old field {}\", fieldName);\n              doc.removeField(fieldName);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid output field mapping for \"\n                    + fieldName + \" field and language: \" + fieldLang);\n          }\n        }\n      }\n    }\n\n    // Set the languages field to an array of all detected languages\n    if(langsField != null && langsField.length() != 0) {\n      doc.setField(langsField, docLangs.toArray());\n    }\n\n    return doc;\n  }\n\n","sourceOld":"  /**\n   * This is the main, testable process method called from processAdd()\n   * @param doc the SolrInputDocument to work on\n   * @return the modified SolrInputDocument\n   */\n  protected SolrInputDocument process(SolrInputDocument doc) {\n    String docLang = null;\n    HashSet<String> docLangs = new HashSet<>();\n    String fallbackLang = getFallbackLang(doc, fallbackFields, fallbackValue);\n\n    if(langField == null || !doc.containsKey(langField) || (doc.containsKey(langField) && overwrite)) {\n      String allText = concatFields(doc, inputFields);\n      List<DetectedLanguage> languagelist = detectLanguage(allText);\n      docLang = resolveLanguage(languagelist, fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Detected main document language from fields \"+inputFields+\": \"+docLang);\n\n      if(doc.containsKey(langField) && overwrite) {\n        log.debug(\"Overwritten old value \"+doc.getFieldValue(langField));\n      }\n      if(langField != null && langField.length() != 0) {\n        doc.setField(langField, docLang);\n      }\n    } else {\n      // langField is set, we sanity check it against whitelist and fallback\n      docLang = resolveLanguage((String) doc.getFieldValue(langField), fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Field \"+langField+\" already contained value \"+docLang+\", not overwriting.\");\n    }\n\n    if(enableMapping) {\n      for (String fieldName : allMapFieldsSet) {\n        if(doc.containsKey(fieldName)) {\n          String fieldLang;\n          if(mapIndividual && mapIndividualFieldsSet.contains(fieldName)) {\n            String text = (String) doc.getFieldValue(fieldName);\n            List<DetectedLanguage> languagelist = detectLanguage(text);\n            fieldLang = resolveLanguage(languagelist, docLang);\n            docLangs.add(fieldLang);\n            log.debug(\"Mapping field \"+fieldName+\" using individually detected language \"+fieldLang);\n          } else {\n            fieldLang = docLang;\n            log.debug(\"Mapping field \"+fieldName+\" using document global language \"+fieldLang);\n          }\n          String mappedOutputField = getMappedField(fieldName, fieldLang);\n\n          if (mappedOutputField != null) {\n            log.debug(\"Mapping field {} to {}\", doc.getFieldValue(docIdField), fieldLang);\n            SolrInputField inField = doc.getField(fieldName);\n            doc.setField(mappedOutputField, inField.getValue(), inField.getBoost());\n            if(!mapKeepOrig) {\n              log.debug(\"Removing old field {}\", fieldName);\n              doc.removeField(fieldName);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid output field mapping for \"\n                    + fieldName + \" field and language: \" + fieldLang);\n          }\n        }\n      }\n    }\n\n    // Set the languages field to an array of all detected languages\n    if(langsField != null && langsField.length() != 0) {\n      doc.setField(langsField, docLangs.toArray());\n    }\n\n    return doc;\n  }\n\n","bugFix":["0f45f65b8ca4312a6880cc80396c35205dc21543"],"bugIntro":["a4da5f9e2a1f2ac76feac0c0796bdce4881cb687"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"acd9883560fd89e6448b2b447302fe543040cd4f","date":1488478696,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#process(SolrInputDocument).mjava","pathOld":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#process(SolrInputDocument).mjava","sourceNew":"  /**\n   * This is the main, testable process method called from processAdd()\n   * @param doc the SolrInputDocument to work on\n   * @return the modified SolrInputDocument\n   */\n  protected SolrInputDocument process(SolrInputDocument doc) {\n    String docLang = null;\n    HashSet<String> docLangs = new HashSet<>();\n    String fallbackLang = getFallbackLang(doc, fallbackFields, fallbackValue);\n\n    if(langField == null || !doc.containsKey(langField) || (doc.containsKey(langField) && overwrite)) {\n      List<DetectedLanguage> languagelist = detectLanguage(doc);\n      docLang = resolveLanguage(languagelist, fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Detected main document language from fields \"+ Arrays.toString(inputFields) +\": \"+docLang);\n\n      if(doc.containsKey(langField) && overwrite) {\n        log.debug(\"Overwritten old value \"+doc.getFieldValue(langField));\n      }\n      if(langField != null && langField.length() != 0) {\n        doc.setField(langField, docLang);\n      }\n    } else {\n      // langField is set, we sanity check it against whitelist and fallback\n      docLang = resolveLanguage((String) doc.getFieldValue(langField), fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Field \"+langField+\" already contained value \"+docLang+\", not overwriting.\");\n    }\n\n    if(enableMapping) {\n      for (String fieldName : allMapFieldsSet) {\n        if(doc.containsKey(fieldName)) {\n          String fieldLang;\n          if(mapIndividual && mapIndividualFieldsSet.contains(fieldName)) {\n            List<DetectedLanguage> languagelist = detectLanguage(doc);\n            fieldLang = resolveLanguage(languagelist, docLang);\n            docLangs.add(fieldLang);\n            log.debug(\"Mapping field \"+fieldName+\" using individually detected language \"+fieldLang);\n          } else {\n            fieldLang = docLang;\n            log.debug(\"Mapping field \"+fieldName+\" using document global language \"+fieldLang);\n          }\n          String mappedOutputField = getMappedField(fieldName, fieldLang);\n\n          if (mappedOutputField != null) {\n            log.debug(\"Mapping field {} to {}\", doc.getFieldValue(docIdField), fieldLang);\n            SolrInputField inField = doc.getField(fieldName);\n            doc.setField(mappedOutputField, inField.getValue());\n            if(!mapKeepOrig) {\n              log.debug(\"Removing old field {}\", fieldName);\n              doc.removeField(fieldName);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid output field mapping for \"\n                    + fieldName + \" field and language: \" + fieldLang);\n          }\n        }\n      }\n    }\n\n    // Set the languages field to an array of all detected languages\n    if(langsField != null && langsField.length() != 0) {\n      doc.setField(langsField, docLangs.toArray());\n    }\n\n    return doc;\n  }\n\n","sourceOld":"  /**\n   * This is the main, testable process method called from processAdd()\n   * @param doc the SolrInputDocument to work on\n   * @return the modified SolrInputDocument\n   */\n  protected SolrInputDocument process(SolrInputDocument doc) {\n    String docLang = null;\n    HashSet<String> docLangs = new HashSet<>();\n    String fallbackLang = getFallbackLang(doc, fallbackFields, fallbackValue);\n\n    if(langField == null || !doc.containsKey(langField) || (doc.containsKey(langField) && overwrite)) {\n      List<DetectedLanguage> languagelist = detectLanguage(doc);\n      docLang = resolveLanguage(languagelist, fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Detected main document language from fields \"+ Arrays.toString(inputFields) +\": \"+docLang);\n\n      if(doc.containsKey(langField) && overwrite) {\n        log.debug(\"Overwritten old value \"+doc.getFieldValue(langField));\n      }\n      if(langField != null && langField.length() != 0) {\n        doc.setField(langField, docLang);\n      }\n    } else {\n      // langField is set, we sanity check it against whitelist and fallback\n      docLang = resolveLanguage((String) doc.getFieldValue(langField), fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Field \"+langField+\" already contained value \"+docLang+\", not overwriting.\");\n    }\n\n    if(enableMapping) {\n      for (String fieldName : allMapFieldsSet) {\n        if(doc.containsKey(fieldName)) {\n          String fieldLang;\n          if(mapIndividual && mapIndividualFieldsSet.contains(fieldName)) {\n            List<DetectedLanguage> languagelist = detectLanguage(doc);\n            fieldLang = resolveLanguage(languagelist, docLang);\n            docLangs.add(fieldLang);\n            log.debug(\"Mapping field \"+fieldName+\" using individually detected language \"+fieldLang);\n          } else {\n            fieldLang = docLang;\n            log.debug(\"Mapping field \"+fieldName+\" using document global language \"+fieldLang);\n          }\n          String mappedOutputField = getMappedField(fieldName, fieldLang);\n\n          if (mappedOutputField != null) {\n            log.debug(\"Mapping field {} to {}\", doc.getFieldValue(docIdField), fieldLang);\n            SolrInputField inField = doc.getField(fieldName);\n            doc.setField(mappedOutputField, inField.getValue(), inField.getBoost());\n            if(!mapKeepOrig) {\n              log.debug(\"Removing old field {}\", fieldName);\n              doc.removeField(fieldName);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid output field mapping for \"\n                    + fieldName + \" field and language: \" + fieldLang);\n          }\n        }\n      }\n    }\n\n    // Set the languages field to an array of all detected languages\n    if(langsField != null && langsField.length() != 0) {\n      doc.setField(langsField, docLangs.toArray());\n    }\n\n    return doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a4da5f9e2a1f2ac76feac0c0796bdce4881cb687","date":1546536444,"type":3,"author":"Jan HÃ¸ydahl","isMerge":false,"pathNew":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#process(SolrInputDocument).mjava","pathOld":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#process(SolrInputDocument).mjava","sourceNew":"  /**\n   * This is the main process method called from processAdd()\n   * @param doc the SolrInputDocument to modify\n   */\n  protected void process(SolrInputDocument doc) {\n    String docLang = null;\n    HashSet<String> docLangs = new HashSet<>();\n    String fallbackLang = getFallbackLang(doc, fallbackFields, fallbackValue);\n\n    if(langField == null || !doc.containsKey(langField) || (doc.containsKey(langField) && overwrite)) {\n      List<DetectedLanguage> languagelist = detectLanguage(doc);\n      docLang = resolveLanguage(languagelist, fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Detected main document language from fields \"+ Arrays.toString(inputFields) +\": \"+docLang);\n\n      if(doc.containsKey(langField) && overwrite) {\n        log.debug(\"Overwritten old value \"+doc.getFieldValue(langField));\n      }\n      if(langField != null && langField.length() != 0) {\n        doc.setField(langField, docLang);\n      }\n    } else {\n      // langField is set, we sanity check it against whitelist and fallback\n      docLang = resolveLanguage((String) doc.getFieldValue(langField), fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Field \"+langField+\" already contained value \"+docLang+\", not overwriting.\");\n    }\n\n    if(enableMapping) {\n      for (String fieldName : allMapFieldsSet) {\n        if(doc.containsKey(fieldName)) {\n          String fieldLang;\n          if(mapIndividual && mapIndividualFieldsSet.contains(fieldName)) {\n            List<DetectedLanguage> languagelist = detectLanguage(solrDocReader(doc, new String[]{fieldName}));\n            fieldLang = resolveLanguage(languagelist, docLang);\n            docLangs.add(fieldLang);\n            log.debug(\"Mapping field \"+fieldName+\" using individually detected language \"+fieldLang);\n          } else {\n            fieldLang = docLang;\n            log.debug(\"Mapping field \"+fieldName+\" using document global language \"+fieldLang);\n          }\n          String mappedOutputField = getMappedField(fieldName, fieldLang);\n\n          if (mappedOutputField != null) {\n            log.debug(\"Mapping field {} to {}\", doc.getFieldValue(docIdField), fieldLang);\n            SolrInputField inField = doc.getField(fieldName);\n            doc.setField(mappedOutputField, inField.getValue());\n            if(!mapKeepOrig) {\n              log.debug(\"Removing old field {}\", fieldName);\n              doc.removeField(fieldName);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid output field mapping for \"\n                    + fieldName + \" field and language: \" + fieldLang);\n          }\n        }\n      }\n    }\n\n    // Set the languages field to an array of all detected languages\n    if(langsField != null && langsField.length() != 0) {\n      doc.setField(langsField, docLangs.toArray());\n    }\n  }\n\n","sourceOld":"  /**\n   * This is the main, testable process method called from processAdd()\n   * @param doc the SolrInputDocument to work on\n   * @return the modified SolrInputDocument\n   */\n  protected SolrInputDocument process(SolrInputDocument doc) {\n    String docLang = null;\n    HashSet<String> docLangs = new HashSet<>();\n    String fallbackLang = getFallbackLang(doc, fallbackFields, fallbackValue);\n\n    if(langField == null || !doc.containsKey(langField) || (doc.containsKey(langField) && overwrite)) {\n      List<DetectedLanguage> languagelist = detectLanguage(doc);\n      docLang = resolveLanguage(languagelist, fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Detected main document language from fields \"+ Arrays.toString(inputFields) +\": \"+docLang);\n\n      if(doc.containsKey(langField) && overwrite) {\n        log.debug(\"Overwritten old value \"+doc.getFieldValue(langField));\n      }\n      if(langField != null && langField.length() != 0) {\n        doc.setField(langField, docLang);\n      }\n    } else {\n      // langField is set, we sanity check it against whitelist and fallback\n      docLang = resolveLanguage((String) doc.getFieldValue(langField), fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Field \"+langField+\" already contained value \"+docLang+\", not overwriting.\");\n    }\n\n    if(enableMapping) {\n      for (String fieldName : allMapFieldsSet) {\n        if(doc.containsKey(fieldName)) {\n          String fieldLang;\n          if(mapIndividual && mapIndividualFieldsSet.contains(fieldName)) {\n            List<DetectedLanguage> languagelist = detectLanguage(doc);\n            fieldLang = resolveLanguage(languagelist, docLang);\n            docLangs.add(fieldLang);\n            log.debug(\"Mapping field \"+fieldName+\" using individually detected language \"+fieldLang);\n          } else {\n            fieldLang = docLang;\n            log.debug(\"Mapping field \"+fieldName+\" using document global language \"+fieldLang);\n          }\n          String mappedOutputField = getMappedField(fieldName, fieldLang);\n\n          if (mappedOutputField != null) {\n            log.debug(\"Mapping field {} to {}\", doc.getFieldValue(docIdField), fieldLang);\n            SolrInputField inField = doc.getField(fieldName);\n            doc.setField(mappedOutputField, inField.getValue());\n            if(!mapKeepOrig) {\n              log.debug(\"Removing old field {}\", fieldName);\n              doc.removeField(fieldName);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid output field mapping for \"\n                    + fieldName + \" field and language: \" + fieldLang);\n          }\n        }\n      }\n    }\n\n    // Set the languages field to an array of all detected languages\n    if(langsField != null && langsField.length() != 0) {\n      doc.setField(langsField, docLangs.toArray());\n    }\n\n    return doc;\n  }\n\n","bugFix":["46ae57a9ea3e7c9a47a3fc2548e1b32c060e3f8f","3ff1a276d1c94e9393032df34ad607eda09ee3a6","0f45f65b8ca4312a6880cc80396c35205dc21543"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3665b66adafb1514bba04cd1d5c477fcaa93d592","date":1576153597,"type":3,"author":"noble","isMerge":false,"pathNew":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#process(SolrInputDocument).mjava","pathOld":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#process(SolrInputDocument).mjava","sourceNew":"  /**\n   * This is the main process method called from processAdd()\n   * @param doc the SolrInputDocument to modify\n   */\n  protected void process(SolrInputDocument doc) {\n    String docLang = null;\n    HashSet<String> docLangs = new HashSet<>();\n    String fallbackLang = getFallbackLang(doc, fallbackFields, fallbackValue);\n\n    if(langField == null || !doc.containsKey(langField) || (doc.containsKey(langField) && overwrite)) {\n      List<DetectedLanguage> languagelist = detectLanguage(doc);\n      docLang = resolveLanguage(languagelist, fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Detected main document language from fields \"+ Arrays.toString(inputFields) +\": \"+docLang);\n\n      if(doc.containsKey(langField) && overwrite) {\n        log.debug(\"Overwritten old value \"+doc.getFieldValue(langField));\n      }\n      if(langField != null && langField.length() != 0) {\n        doc.setField(langField, docLang);\n      }\n    } else {\n      // langField is set, we sanity check it against whitelist and fallback\n      docLang = resolveLanguage(doc.getFieldValue(langField).toString(), fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Field \"+langField+\" already contained value \"+docLang+\", not overwriting.\");\n    }\n\n    if(enableMapping) {\n      for (String fieldName : allMapFieldsSet) {\n        if(doc.containsKey(fieldName)) {\n          String fieldLang;\n          if(mapIndividual && mapIndividualFieldsSet.contains(fieldName)) {\n            List<DetectedLanguage> languagelist = detectLanguage(solrDocReader(doc, new String[]{fieldName}));\n            fieldLang = resolveLanguage(languagelist, docLang);\n            docLangs.add(fieldLang);\n            log.debug(\"Mapping field \"+fieldName+\" using individually detected language \"+fieldLang);\n          } else {\n            fieldLang = docLang;\n            log.debug(\"Mapping field \"+fieldName+\" using document global language \"+fieldLang);\n          }\n          String mappedOutputField = getMappedField(fieldName, fieldLang);\n\n          if (mappedOutputField != null) {\n            log.debug(\"Mapping field {} to {}\", doc.getFieldValue(docIdField), fieldLang);\n            SolrInputField inField = doc.getField(fieldName);\n            doc.setField(mappedOutputField, inField.getValue());\n            if(!mapKeepOrig) {\n              log.debug(\"Removing old field {}\", fieldName);\n              doc.removeField(fieldName);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid output field mapping for \"\n                    + fieldName + \" field and language: \" + fieldLang);\n          }\n        }\n      }\n    }\n\n    // Set the languages field to an array of all detected languages\n    if(langsField != null && langsField.length() != 0) {\n      doc.setField(langsField, docLangs.toArray());\n    }\n  }\n\n","sourceOld":"  /**\n   * This is the main process method called from processAdd()\n   * @param doc the SolrInputDocument to modify\n   */\n  protected void process(SolrInputDocument doc) {\n    String docLang = null;\n    HashSet<String> docLangs = new HashSet<>();\n    String fallbackLang = getFallbackLang(doc, fallbackFields, fallbackValue);\n\n    if(langField == null || !doc.containsKey(langField) || (doc.containsKey(langField) && overwrite)) {\n      List<DetectedLanguage> languagelist = detectLanguage(doc);\n      docLang = resolveLanguage(languagelist, fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Detected main document language from fields \"+ Arrays.toString(inputFields) +\": \"+docLang);\n\n      if(doc.containsKey(langField) && overwrite) {\n        log.debug(\"Overwritten old value \"+doc.getFieldValue(langField));\n      }\n      if(langField != null && langField.length() != 0) {\n        doc.setField(langField, docLang);\n      }\n    } else {\n      // langField is set, we sanity check it against whitelist and fallback\n      docLang = resolveLanguage((String) doc.getFieldValue(langField), fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Field \"+langField+\" already contained value \"+docLang+\", not overwriting.\");\n    }\n\n    if(enableMapping) {\n      for (String fieldName : allMapFieldsSet) {\n        if(doc.containsKey(fieldName)) {\n          String fieldLang;\n          if(mapIndividual && mapIndividualFieldsSet.contains(fieldName)) {\n            List<DetectedLanguage> languagelist = detectLanguage(solrDocReader(doc, new String[]{fieldName}));\n            fieldLang = resolveLanguage(languagelist, docLang);\n            docLangs.add(fieldLang);\n            log.debug(\"Mapping field \"+fieldName+\" using individually detected language \"+fieldLang);\n          } else {\n            fieldLang = docLang;\n            log.debug(\"Mapping field \"+fieldName+\" using document global language \"+fieldLang);\n          }\n          String mappedOutputField = getMappedField(fieldName, fieldLang);\n\n          if (mappedOutputField != null) {\n            log.debug(\"Mapping field {} to {}\", doc.getFieldValue(docIdField), fieldLang);\n            SolrInputField inField = doc.getField(fieldName);\n            doc.setField(mappedOutputField, inField.getValue());\n            if(!mapKeepOrig) {\n              log.debug(\"Removing old field {}\", fieldName);\n              doc.removeField(fieldName);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid output field mapping for \"\n                    + fieldName + \" field and language: \" + fieldLang);\n          }\n        }\n      }\n    }\n\n    // Set the languages field to an array of all detected languages\n    if(langsField != null && langsField.length() != 0) {\n      doc.setField(langsField, docLangs.toArray());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df724d84dab24a0cc54bec95a8680867adc7f171","date":1576156608,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#process(SolrInputDocument).mjava","pathOld":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#process(SolrInputDocument).mjava","sourceNew":"  /**\n   * This is the main process method called from processAdd()\n   * @param doc the SolrInputDocument to modify\n   */\n  protected void process(SolrInputDocument doc) {\n    String docLang = null;\n    HashSet<String> docLangs = new HashSet<>();\n    String fallbackLang = getFallbackLang(doc, fallbackFields, fallbackValue);\n\n    if(langField == null || !doc.containsKey(langField) || (doc.containsKey(langField) && overwrite)) {\n      List<DetectedLanguage> languagelist = detectLanguage(doc);\n      docLang = resolveLanguage(languagelist, fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Detected main document language from fields \"+ Arrays.toString(inputFields) +\": \"+docLang);\n\n      if(doc.containsKey(langField) && overwrite) {\n        log.debug(\"Overwritten old value \"+doc.getFieldValue(langField));\n      }\n      if(langField != null && langField.length() != 0) {\n        doc.setField(langField, docLang);\n      }\n    } else {\n      // langField is set, we sanity check it against whitelist and fallback\n      docLang = resolveLanguage(doc.getFieldValue(langField).toString(), fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Field \"+langField+\" already contained value \"+docLang+\", not overwriting.\");\n    }\n\n    if(enableMapping) {\n      for (String fieldName : allMapFieldsSet) {\n        if(doc.containsKey(fieldName)) {\n          String fieldLang;\n          if(mapIndividual && mapIndividualFieldsSet.contains(fieldName)) {\n            List<DetectedLanguage> languagelist = detectLanguage(solrDocReader(doc, new String[]{fieldName}));\n            fieldLang = resolveLanguage(languagelist, docLang);\n            docLangs.add(fieldLang);\n            log.debug(\"Mapping field \"+fieldName+\" using individually detected language \"+fieldLang);\n          } else {\n            fieldLang = docLang;\n            log.debug(\"Mapping field \"+fieldName+\" using document global language \"+fieldLang);\n          }\n          String mappedOutputField = getMappedField(fieldName, fieldLang);\n\n          if (mappedOutputField != null) {\n            log.debug(\"Mapping field {} to {}\", doc.getFieldValue(docIdField), fieldLang);\n            SolrInputField inField = doc.getField(fieldName);\n            doc.setField(mappedOutputField, inField.getValue());\n            if(!mapKeepOrig) {\n              log.debug(\"Removing old field {}\", fieldName);\n              doc.removeField(fieldName);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid output field mapping for \"\n                    + fieldName + \" field and language: \" + fieldLang);\n          }\n        }\n      }\n    }\n\n    // Set the languages field to an array of all detected languages\n    if(langsField != null && langsField.length() != 0) {\n      doc.setField(langsField, docLangs.toArray());\n    }\n  }\n\n","sourceOld":"  /**\n   * This is the main process method called from processAdd()\n   * @param doc the SolrInputDocument to modify\n   */\n  protected void process(SolrInputDocument doc) {\n    String docLang = null;\n    HashSet<String> docLangs = new HashSet<>();\n    String fallbackLang = getFallbackLang(doc, fallbackFields, fallbackValue);\n\n    if(langField == null || !doc.containsKey(langField) || (doc.containsKey(langField) && overwrite)) {\n      List<DetectedLanguage> languagelist = detectLanguage(doc);\n      docLang = resolveLanguage(languagelist, fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Detected main document language from fields \"+ Arrays.toString(inputFields) +\": \"+docLang);\n\n      if(doc.containsKey(langField) && overwrite) {\n        log.debug(\"Overwritten old value \"+doc.getFieldValue(langField));\n      }\n      if(langField != null && langField.length() != 0) {\n        doc.setField(langField, docLang);\n      }\n    } else {\n      // langField is set, we sanity check it against whitelist and fallback\n      docLang = resolveLanguage((String) doc.getFieldValue(langField), fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Field \"+langField+\" already contained value \"+docLang+\", not overwriting.\");\n    }\n\n    if(enableMapping) {\n      for (String fieldName : allMapFieldsSet) {\n        if(doc.containsKey(fieldName)) {\n          String fieldLang;\n          if(mapIndividual && mapIndividualFieldsSet.contains(fieldName)) {\n            List<DetectedLanguage> languagelist = detectLanguage(solrDocReader(doc, new String[]{fieldName}));\n            fieldLang = resolveLanguage(languagelist, docLang);\n            docLangs.add(fieldLang);\n            log.debug(\"Mapping field \"+fieldName+\" using individually detected language \"+fieldLang);\n          } else {\n            fieldLang = docLang;\n            log.debug(\"Mapping field \"+fieldName+\" using document global language \"+fieldLang);\n          }\n          String mappedOutputField = getMappedField(fieldName, fieldLang);\n\n          if (mappedOutputField != null) {\n            log.debug(\"Mapping field {} to {}\", doc.getFieldValue(docIdField), fieldLang);\n            SolrInputField inField = doc.getField(fieldName);\n            doc.setField(mappedOutputField, inField.getValue());\n            if(!mapKeepOrig) {\n              log.debug(\"Removing old field {}\", fieldName);\n              doc.removeField(fieldName);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid output field mapping for \"\n                    + fieldName + \" field and language: \" + fieldLang);\n          }\n        }\n      }\n    }\n\n    // Set the languages field to an array of all detected languages\n    if(langsField != null && langsField.length() != 0) {\n      doc.setField(langsField, docLangs.toArray());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#process(SolrInputDocument).mjava","pathOld":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#process(SolrInputDocument).mjava","sourceNew":"  /**\n   * This is the main process method called from processAdd()\n   * @param doc the SolrInputDocument to modify\n   */\n  protected void process(SolrInputDocument doc) {\n    String docLang = null;\n    HashSet<String> docLangs = new HashSet<>();\n    String fallbackLang = getFallbackLang(doc, fallbackFields, fallbackValue);\n\n    if(langField == null || !doc.containsKey(langField) || (doc.containsKey(langField) && overwrite)) {\n      List<DetectedLanguage> languagelist = detectLanguage(doc);\n      docLang = resolveLanguage(languagelist, fallbackLang);\n      docLangs.add(docLang);\n      if (log.isDebugEnabled()) {\n        log.debug(\"Detected main document language from fields {}: {}\", Arrays.toString(inputFields), docLang);\n      }\n\n      if(doc.containsKey(langField) && overwrite) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"Overwritten old value {}\", doc.getFieldValue(langField));\n        }\n      }\n      if(langField != null && langField.length() != 0) {\n        doc.setField(langField, docLang);\n      }\n    } else {\n      // langField is set, we sanity check it against whitelist and fallback\n      docLang = resolveLanguage(doc.getFieldValue(langField).toString(), fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Field {} already contained value {}, not overwriting.\", langField, docLang);\n    }\n\n    if(enableMapping) {\n      for (String fieldName : allMapFieldsSet) {\n        if(doc.containsKey(fieldName)) {\n          String fieldLang;\n          if(mapIndividual && mapIndividualFieldsSet.contains(fieldName)) {\n            List<DetectedLanguage> languagelist = detectLanguage(solrDocReader(doc, new String[]{fieldName}));\n            fieldLang = resolveLanguage(languagelist, docLang);\n            docLangs.add(fieldLang);\n            log.debug(\"Mapping field {} using individually detected language {}\", fieldName, fieldLang);\n          } else {\n            fieldLang = docLang;\n            log.debug(\"Mapping field {} using document global language {}\", fieldName, fieldLang);\n          }\n          String mappedOutputField = getMappedField(fieldName, fieldLang);\n\n          if (mappedOutputField != null) {\n            if (log.isDebugEnabled()) {\n              log.debug(\"Mapping field {} to {}\", doc.getFieldValue(docIdField), fieldLang);\n            }\n            SolrInputField inField = doc.getField(fieldName);\n            doc.setField(mappedOutputField, inField.getValue());\n            if(!mapKeepOrig) {\n              log.debug(\"Removing old field {}\", fieldName);\n              doc.removeField(fieldName);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid output field mapping for \"\n                    + fieldName + \" field and language: \" + fieldLang);\n          }\n        }\n      }\n    }\n\n    // Set the languages field to an array of all detected languages\n    if(langsField != null && langsField.length() != 0) {\n      doc.setField(langsField, docLangs.toArray());\n    }\n  }\n\n","sourceOld":"  /**\n   * This is the main process method called from processAdd()\n   * @param doc the SolrInputDocument to modify\n   */\n  protected void process(SolrInputDocument doc) {\n    String docLang = null;\n    HashSet<String> docLangs = new HashSet<>();\n    String fallbackLang = getFallbackLang(doc, fallbackFields, fallbackValue);\n\n    if(langField == null || !doc.containsKey(langField) || (doc.containsKey(langField) && overwrite)) {\n      List<DetectedLanguage> languagelist = detectLanguage(doc);\n      docLang = resolveLanguage(languagelist, fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Detected main document language from fields \"+ Arrays.toString(inputFields) +\": \"+docLang);\n\n      if(doc.containsKey(langField) && overwrite) {\n        log.debug(\"Overwritten old value \"+doc.getFieldValue(langField));\n      }\n      if(langField != null && langField.length() != 0) {\n        doc.setField(langField, docLang);\n      }\n    } else {\n      // langField is set, we sanity check it against whitelist and fallback\n      docLang = resolveLanguage(doc.getFieldValue(langField).toString(), fallbackLang);\n      docLangs.add(docLang);\n      log.debug(\"Field \"+langField+\" already contained value \"+docLang+\", not overwriting.\");\n    }\n\n    if(enableMapping) {\n      for (String fieldName : allMapFieldsSet) {\n        if(doc.containsKey(fieldName)) {\n          String fieldLang;\n          if(mapIndividual && mapIndividualFieldsSet.contains(fieldName)) {\n            List<DetectedLanguage> languagelist = detectLanguage(solrDocReader(doc, new String[]{fieldName}));\n            fieldLang = resolveLanguage(languagelist, docLang);\n            docLangs.add(fieldLang);\n            log.debug(\"Mapping field \"+fieldName+\" using individually detected language \"+fieldLang);\n          } else {\n            fieldLang = docLang;\n            log.debug(\"Mapping field \"+fieldName+\" using document global language \"+fieldLang);\n          }\n          String mappedOutputField = getMappedField(fieldName, fieldLang);\n\n          if (mappedOutputField != null) {\n            log.debug(\"Mapping field {} to {}\", doc.getFieldValue(docIdField), fieldLang);\n            SolrInputField inField = doc.getField(fieldName);\n            doc.setField(mappedOutputField, inField.getValue());\n            if(!mapKeepOrig) {\n              log.debug(\"Removing old field {}\", fieldName);\n              doc.removeField(fieldName);\n            }\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Invalid output field mapping for \"\n                    + fieldName + \" field and language: \" + fieldLang);\n          }\n        }\n      }\n    }\n\n    // Set the languages field to an array of all detected languages\n    if(langsField != null && langsField.length() != 0) {\n      doc.setField(langsField, docLangs.toArray());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["0d6621eda6ffc681632153605ee20ed10dbb76b9"],"3665b66adafb1514bba04cd1d5c477fcaa93d592":["a4da5f9e2a1f2ac76feac0c0796bdce4881cb687"],"a4da5f9e2a1f2ac76feac0c0796bdce4881cb687":["acd9883560fd89e6448b2b447302fe543040cd4f"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["3665b66adafb1514bba04cd1d5c477fcaa93d592"],"df724d84dab24a0cc54bec95a8680867adc7f171":["a4da5f9e2a1f2ac76feac0c0796bdce4881cb687","3665b66adafb1514bba04cd1d5c477fcaa93d592"],"46ae57a9ea3e7c9a47a3fc2548e1b32c060e3f8f":["0f45f65b8ca4312a6880cc80396c35205dc21543"],"61d5f95d14e5b9b046998c51e16709a398c15226":["46ae57a9ea3e7c9a47a3fc2548e1b32c060e3f8f","0d6621eda6ffc681632153605ee20ed10dbb76b9"],"0f45f65b8ca4312a6880cc80396c35205dc21543":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"62e52115b56781006682fd92c6938efaf174304d":["0f45f65b8ca4312a6880cc80396c35205dc21543","46ae57a9ea3e7c9a47a3fc2548e1b32c060e3f8f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"acd9883560fd89e6448b2b447302fe543040cd4f":["3ff1a276d1c94e9393032df34ad607eda09ee3a6"],"3ff1a276d1c94e9393032df34ad607eda09ee3a6":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"0d6621eda6ffc681632153605ee20ed10dbb76b9":["46ae57a9ea3e7c9a47a3fc2548e1b32c060e3f8f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a966532d92cf9ba2856f15a8140151bb6b518e4b"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["3ff1a276d1c94e9393032df34ad607eda09ee3a6"],"3665b66adafb1514bba04cd1d5c477fcaa93d592":["a966532d92cf9ba2856f15a8140151bb6b518e4b","df724d84dab24a0cc54bec95a8680867adc7f171"],"a4da5f9e2a1f2ac76feac0c0796bdce4881cb687":["3665b66adafb1514bba04cd1d5c477fcaa93d592","df724d84dab24a0cc54bec95a8680867adc7f171"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"df724d84dab24a0cc54bec95a8680867adc7f171":[],"46ae57a9ea3e7c9a47a3fc2548e1b32c060e3f8f":["61d5f95d14e5b9b046998c51e16709a398c15226","62e52115b56781006682fd92c6938efaf174304d","0d6621eda6ffc681632153605ee20ed10dbb76b9"],"61d5f95d14e5b9b046998c51e16709a398c15226":[],"0f45f65b8ca4312a6880cc80396c35205dc21543":["46ae57a9ea3e7c9a47a3fc2548e1b32c060e3f8f","62e52115b56781006682fd92c6938efaf174304d"],"62e52115b56781006682fd92c6938efaf174304d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0f45f65b8ca4312a6880cc80396c35205dc21543"],"acd9883560fd89e6448b2b447302fe543040cd4f":["a4da5f9e2a1f2ac76feac0c0796bdce4881cb687"],"0d6621eda6ffc681632153605ee20ed10dbb76b9":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","61d5f95d14e5b9b046998c51e16709a398c15226"],"3ff1a276d1c94e9393032df34ad607eda09ee3a6":["acd9883560fd89e6448b2b447302fe543040cd4f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["df724d84dab24a0cc54bec95a8680867adc7f171","61d5f95d14e5b9b046998c51e16709a398c15226","62e52115b56781006682fd92c6938efaf174304d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}