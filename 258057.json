{"path":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == SegmentInfos.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == SegmentInfos.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == SegmentInfos.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == SegmentInfos.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == SegmentInfos.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < SegmentInfos.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > SegmentInfos.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.docCount - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.docCount-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.docCount-reader.numDocs()));\n          }\n          if (info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == SegmentInfos.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == SegmentInfos.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == SegmentInfos.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == SegmentInfos.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == SegmentInfos.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < SegmentInfos.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > SegmentInfos.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.docCount - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.docCount-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.docCount-reader.numDocs()));\n          }\n          if (info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"438e995b4e32916f631722aab36254146830fefb","date":1328903827,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == SegmentInfos.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == SegmentInfos.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == SegmentInfos.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == SegmentInfos.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == SegmentInfos.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < SegmentInfos.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > SegmentInfos.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.docCount - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.docCount-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.docCount-reader.numDocs()));\n          }\n          if (info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == SegmentInfos.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == SegmentInfos.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == SegmentInfos.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == SegmentInfos.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == SegmentInfos.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < SegmentInfos.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > SegmentInfos.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.docCount - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.docCount-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.docCount-reader.numDocs()));\n          }\n          if (info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"368714b5b6663ca71a0cba34a94e6032ccdff3f2","date":1329821210,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == SegmentInfos.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == SegmentInfos.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == SegmentInfos.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == SegmentInfos.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == SegmentInfos.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < SegmentInfos.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > SegmentInfos.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.docCount - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.docCount-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.docCount-reader.numDocs()));\n          }\n          if (info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == SegmentInfos.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == SegmentInfos.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == SegmentInfos.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == SegmentInfos.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == SegmentInfos.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < SegmentInfos.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > SegmentInfos.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.docCount - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.docCount-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.docCount-reader.numDocs()));\n          }\n          if (info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == SegmentInfos.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == SegmentInfos.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == SegmentInfos.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == SegmentInfos.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == SegmentInfos.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < SegmentInfos.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > SegmentInfos.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.docCount - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.docCount-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.docCount-reader.numDocs()));\n          }\n          if (info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == SegmentInfos.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == SegmentInfos.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == SegmentInfos.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == SegmentInfos.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == SegmentInfos.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < SegmentInfos.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > SegmentInfos.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.docCount - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.docCount-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.docCount-reader.numDocs()));\n          }\n          if (info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09d4afa2df10006646959dfd135786e815d48ffa","date":1331917657,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == SegmentInfos.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == SegmentInfos.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == SegmentInfos.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == SegmentInfos.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == SegmentInfos.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < SegmentInfos.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > SegmentInfos.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.docCount - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.docCount-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.docCount-reader.numDocs()));\n          }\n          if (info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == SegmentInfos.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == SegmentInfos.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == SegmentInfos.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == SegmentInfos.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == SegmentInfos.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < SegmentInfos.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > SegmentInfos.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.docCount - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.docCount-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.docCount-reader.numDocs()));\n          }\n          if (info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"814339e4b1ce2063ccbc6cacc6443a6446c7718b","date":1331991774,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == SegmentInfos.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == SegmentInfos.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == SegmentInfos.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == SegmentInfos.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == SegmentInfos.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < SegmentInfos.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > SegmentInfos.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.docCount - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.docCount-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.docCount-reader.numDocs()));\n          }\n          if (info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == SegmentInfos.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == SegmentInfos.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == SegmentInfos.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == SegmentInfos.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == SegmentInfos.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < SegmentInfos.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > SegmentInfos.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.docCount - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.docCount-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.docCount-reader.numDocs()));\n          }\n          if (info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"399d5903979ca52514d2bc7e3a362e1c45885c94","date":1333042474,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == SegmentInfos.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == SegmentInfos.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == SegmentInfos.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == SegmentInfos.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == SegmentInfos.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < SegmentInfos.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > SegmentInfos.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.docCount - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.docCount-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.docCount-reader.numDocs()));\n          }\n          if (info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == SegmentInfos.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == SegmentInfos.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == SegmentInfos.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == SegmentInfos.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == SegmentInfos.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < SegmentInfos.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > SegmentInfos.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.docCount - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.docCount-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.docCount-reader.numDocs()));\n          }\n          if (info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d2dee33619431ada2a7a07f5fe2dbd94bac6a460","date":1337274029,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == SegmentInfos.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == SegmentInfos.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == SegmentInfos.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == SegmentInfos.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == SegmentInfos.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < SegmentInfos.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > SegmentInfos.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.docCount - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.docCount-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.docCount-reader.numDocs()));\n          }\n          if (info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == SegmentInfos.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == SegmentInfos.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == SegmentInfos.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == SegmentInfos.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == SegmentInfos.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < SegmentInfos.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > SegmentInfos.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.docCount - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.docCount-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.docCount-reader.numDocs()));\n          }\n          if (info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dc97c61094c5498702b29cc2e8309beac50c23dc","date":1337293692,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == SegmentInfos.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == SegmentInfos.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == SegmentInfos.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == SegmentInfos.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == SegmentInfos.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < SegmentInfos.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > SegmentInfos.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.docCount - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.docCount-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.docCount-reader.numDocs()));\n          }\n          if (info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == SegmentInfos.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == SegmentInfos.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == SegmentInfos.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == SegmentInfos.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == SegmentInfos.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < SegmentInfos.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > SegmentInfos.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.docCount - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.docCount-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.docCount-reader.numDocs()));\n          }\n          if (info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4356000e349e38c9fb48034695b7c309abd54557","date":1337460341,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    // nocommit fixme\n    /*\n    if (format == SegmentInfos.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == SegmentInfos.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == SegmentInfos.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == SegmentInfos.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == SegmentInfos.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < SegmentInfos.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > SegmentInfos.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n    */\n    sFormat = \"nocommit not working yet\";\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.docCount - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.docCount-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.docCount-reader.numDocs()));\n          }\n          if (info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == SegmentInfos.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == SegmentInfos.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == SegmentInfos.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == SegmentInfos.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == SegmentInfos.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < SegmentInfos.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > SegmentInfos.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.docCount - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.docCount-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.docCount-reader.numDocs()));\n          }\n          if (info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4b512a6470fbb93c320e0cc8519ec0fe94efa13e","date":1337522360,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.docCount - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.docCount-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.docCount-reader.numDocs()));\n          }\n          if (info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    // nocommit fixme\n    /*\n    if (format == SegmentInfos.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == SegmentInfos.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == SegmentInfos.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == SegmentInfos.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == SegmentInfos.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < SegmentInfos.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > SegmentInfos.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n    */\n    sFormat = \"nocommit not working yet\";\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.docCount - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.docCount-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.docCount-reader.numDocs()));\n          }\n          if (info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9d153abcf92dc5329d98571a8c3035df9bd80648","date":1337702630,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.docCount);\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.docCount;\n\n      int toLoseDocCount = info.info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(\"    numFiles=\" + info.info.files().size());\n        segInfoStat.numFiles = info.info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.info.getDocStoreIsCompoundFile();\n        }\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.docCount - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.docCount-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.docCount-reader.numDocs()));\n          }\n          if (info.info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.info.docCount) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.docCount);\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.docCount - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.docCount-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.docCount-reader.numDocs()));\n          }\n          if (info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4","0617d2d25b13b9a49450ea49ceb06123ebd6542a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fb5728b83dbb3e002cdd22adfe6caf103a96ef15","date":1337791289,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.docCount);\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.docCount;\n\n      int toLoseDocCount = info.info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.info.getDocStoreIsCompoundFile();\n        }\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.docCount - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.docCount-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.docCount-reader.numDocs()));\n          }\n          if (info.info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.info.docCount) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.docCount);\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.docCount);\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.docCount;\n\n      int toLoseDocCount = info.info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(\"    numFiles=\" + info.info.files().size());\n        segInfoStat.numFiles = info.info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.info.getDocStoreIsCompoundFile();\n        }\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.docCount - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.docCount-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.docCount-reader.numDocs()));\n          }\n          if (info.info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.info.docCount) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.docCount);\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"203d7d3cb7712e10ef33009a63247ae40c302d7a","date":1337798111,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.info.getDocStoreIsCompoundFile();\n        }\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.docCount);\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.docCount;\n\n      int toLoseDocCount = info.info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.info.getDocStoreIsCompoundFile();\n        }\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.docCount - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.docCount-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.docCount-reader.numDocs()));\n          }\n          if (info.info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.info.docCount) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.docCount);\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6a917aca07a305ab70118a83e84d931503441271","date":1337826487,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        // TODO: we could append the info attributes() to the msg?\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.info.getDocStoreIsCompoundFile();\n        }\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        // TODO: we could append the info attributes() to the msg?\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == SegmentInfos.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == SegmentInfos.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == SegmentInfos.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == SegmentInfos.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == SegmentInfos.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < SegmentInfos.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > SegmentInfos.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.docCount - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.docCount-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.docCount-reader.numDocs()));\n          }\n          if (info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5dc83d085f83b38c31736c494913c0c75265ce02","date":1341762281,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        // TODO: we could append the info attributes() to the msg?\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        // TODO: we could append the info attributes() to the msg?\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2acf500f78aa12b92e371fd89c719291986b6b90","date":1341846236,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        // TODO: we could append the info attributes() to the msg?\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        // TODO: we could append the info attributes() to the msg?\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"46d8ada1fff8d18cb197c38c7983225162599948","date":1341853497,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        // TODO: we could append the info attributes() to the msg?\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        // TODO: we could append the info attributes() to the msg?\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        // TODO: we could append the info attributes() to the msg?\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        // TODO: we could append the info attributes() to the msg?\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"90dfa8ee4e9e118b4c2c1c042bf57d9b460613de","date":1349114144,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        // TODO: we could append the info attributes() to the msg?\n\n        if (!info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        // TODO: we could append the info attributes() to the msg?\n\n        if (info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":["c01bf951751b6dabfd53cb1429a659b28cd6ab4b"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7cd329bd749496f6c58b586a6c0dd0dc8201206f","date":1353092226,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        // TODO: we could append the info attributes() to the msg?\n\n        if (!info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n\n        // nocommit re-enable\n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        // TODO: we could append the info attributes() to the msg?\n\n        if (!info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f7178a82d1134111f4511f28bb9ad57573a57d93","date":1354112608,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        // TODO: we could append the info attributes() to the msg?\n\n        if (!info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n\n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        // TODO: we could append the info attributes() to the msg?\n\n        if (!info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n\n        // nocommit re-enable\n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"addc47115aa3376d79985cd4abc9f8c6e212a032","date":1354202882,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        Map<String,String> atts = info.info.attributes();\n        if (atts != null && !atts.isEmpty()) {\n          msg(\"    attributes = \" + atts);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n\n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        // TODO: we could append the info attributes() to the msg?\n\n        if (!info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n\n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e99275efa2c9c9ae3bdba986218af82f2bf3dc30","date":1354658499,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        Map<String,String> atts = info.info.attributes();\n        if (atts != null && !atts.isEmpty()) {\n          msg(infoStream, \"    attributes = \" + atts);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        Map<String,String> atts = info.info.attributes();\n        if (atts != null && !atts.isEmpty()) {\n          msg(\"    attributes = \" + atts);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n\n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":["985e1291b5f205ff2a21385eb7092c8a513a56eb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        Map<String,String> atts = info.info.attributes();\n        if (atts != null && !atts.isEmpty()) {\n          msg(infoStream, \"    attributes = \" + atts);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        // TODO: we could append the info attributes() to the msg?\n\n        if (!info.hasDeletions()) {\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(\"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(fieldInfos, reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(fieldInfos, info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, fieldInfos, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":["c01bf951751b6dabfd53cb1429a659b28cd6ab4b","203d7d3cb7712e10ef33009a63247ae40c302d7a","368714b5b6663ca71a0cba34a94e6032ccdff3f2","7b91922b55d15444d554721b352861d028eb8278","6a917aca07a305ab70118a83e84d931503441271","d2dee33619431ada2a7a07f5fe2dbd94bac6a460","fb5728b83dbb3e002cdd22adfe6caf103a96ef15","3321cfbf7f8aba27e37e7a4d6901531a97ac2b06","814339e4b1ce2063ccbc6cacc6443a6446c7718b","9d153abcf92dc5329d98571a8c3035df9bd80648"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e44db636314d8ec17d54d6d28e6054fa4566e6c9","date":1370536279,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        Map<String,String> atts = info.info.attributes();\n        if (atts != null && !atts.isEmpty()) {\n          msg(infoStream, \"    attributes = \" + atts);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        Map<String,String> atts = info.info.attributes();\n        if (atts != null && !atts.isEmpty()) {\n          msg(infoStream, \"    attributes = \" + atts);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":["7b91922b55d15444d554721b352861d028eb8278"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a45bec74b98f6fc05f52770cfb425739e6563960","date":1375119292,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        Map<String,String> atts = info.info.attributes();\n        if (atts != null && !atts.isEmpty()) {\n          msg(infoStream, \"    attributes = \" + atts);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        Map<String,String> atts = info.info.attributes();\n        if (atts != null && !atts.isEmpty()) {\n          msg(infoStream, \"    attributes = \" + atts);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        Map<String,String> atts = info.info.attributes();\n        if (atts != null && !atts.isEmpty()) {\n          msg(infoStream, \"    attributes = \" + atts);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        Map<String,String> atts = info.info.attributes();\n        if (atts != null && !atts.isEmpty()) {\n          msg(infoStream, \"    attributes = \" + atts);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0859dec0aa7a485aa0081147f533c5987b4b47ac","date":1376498602,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final String version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && versionComparator.compare(version, \"4.5\") >= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        Map<String,String> atts = info.info.attributes();\n        if (atts != null && !atts.isEmpty()) {\n          msg(infoStream, \"    attributes = \" + atts);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        Map<String,String> atts = info.info.attributes();\n        if (atts != null && !atts.isEmpty()) {\n          msg(infoStream, \"    attributes = \" + atts);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final String version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && versionComparator.compare(version, \"4.5\") >= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        Map<String,String> atts = info.info.attributes();\n        if (atts != null && !atts.isEmpty()) {\n          msg(infoStream, \"    attributes = \" + atts);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        Map<String,String> atts = info.info.attributes();\n        if (atts != null && !atts.isEmpty()) {\n          msg(infoStream, \"    attributes = \" + atts);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"82ffd58510acfc0e2e788a90a10002e689ec9145","date":1379018753,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final String version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && versionComparator.compare(version, \"4.5\") >= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        Map<String,String> atts = info.info.attributes();\n        if (atts != null && !atts.isEmpty()) {\n          msg(infoStream, \"    attributes = \" + atts);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final String version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && versionComparator.compare(version, \"4.5\") >= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        Map<String,String> atts = info.info.attributes();\n        if (atts != null && !atts.isEmpty()) {\n          msg(infoStream, \"    attributes = \" + atts);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":["985e1291b5f205ff2a21385eb7092c8a513a56eb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"77f264c55cbf75404f8601ae7290d69157273a56","date":1380484282,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final String version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && versionComparator.compare(version, \"4.5\") >= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final String version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && versionComparator.compare(version, \"4.5\") >= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        Map<String,String> atts = info.info.attributes();\n        if (atts != null && !atts.isEmpty()) {\n          msg(infoStream, \"    attributes = \" + atts);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","date":1383367127,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentCommitInfo si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final String version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && versionComparator.compare(version, \"4.5\") >= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfoPerCommit si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfoPerCommit info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final String version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && versionComparator.compare(version, \"4.5\") >= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1f3b037cd083286b2af89f96e768f85dcd8072d6","date":1396337805,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentCommitInfo si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final String version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && versionComparator.compare(version, \"4.5\") >= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.........\");\n        reader.checkIntegrity();\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentCommitInfo si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final String version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && versionComparator.compare(version, \"4.5\") >= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentCommitInfo si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final String version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && versionComparator.compare(version, \"4.5\") >= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.........\");\n        reader.checkIntegrity();\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentCommitInfo si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final String version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && versionComparator.compare(version, \"4.5\") >= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dde1aca34305d40b94ca3fab46ab2b39153f8e53","date":1397149498,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentCommitInfo si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final String version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && versionComparator.compare(version, \"4.5\") >= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, \"OK\");\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, \"OK\");\n\n        if (infoStream != null)\n          infoStream.print(\"    test: check live docs.....\");\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentCommitInfo si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final String version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && versionComparator.compare(version, \"4.5\") >= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.........\");\n        reader.checkIntegrity();\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":["6b64ceb507ba9aa71920c0bfad91032e2c03d42f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0cdf9cc6702d60334a616bd7db3ae91501d1dce7","date":1405858112,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentCommitInfo si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final String version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && versionComparator.compare(version, \"4.5\") >= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, \"OK\");\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, \"OK\");\n\n        if (infoStream != null)\n          infoStream.print(\"    test: check live docs.....\");\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentCommitInfo si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final String version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && versionComparator.compare(version, \"4.5\") >= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, \"OK\");\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, \"OK\");\n\n        if (infoStream != null)\n          infoStream.print(\"    test: check live docs.....\");\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":["985e1291b5f205ff2a21385eb7092c8a513a56eb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b75c8811b9d17d93b79f382fc49e8cbd2b220c90","date":1406576889,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentCommitInfo si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final String version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && versionComparator.compare(version, \"4.5\") >= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, \"OK\");\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, \"OK\");\n\n        if (infoStream != null)\n          infoStream.print(\"    test: check live docs.....\");\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentCommitInfo si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final String version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && versionComparator.compare(version, \"4.5\") >= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, \"OK\");\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, \"OK\");\n\n        if (infoStream != null)\n          infoStream.print(\"    test: check live docs.....\");\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"057a1793765d068ea9302f1a29e21734ee58d41e","date":1408130117,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && version.onOrAfter(Version.LUCENE_4_5_0)) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, \"OK\");\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, \"OK\");\n\n        if (infoStream != null)\n          infoStream.print(\"    test: check live docs.....\");\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentCommitInfo si : sis) {\n      String version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final String version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && versionComparator.compare(version, \"4.5\") >= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, \"OK\");\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, \"OK\");\n\n        if (infoStream != null)\n          infoStream.print(\"    test: check live docs.....\");\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e3cc329405ce41b8ef462b4cd30611eca1567620","date":1408661910,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + sis.getId() + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && version.onOrAfter(Version.LUCENE_4_5_0)) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + info.info.getId());\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, \"OK\");\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, \"OK\");\n\n        if (infoStream != null)\n          infoStream.print(\"    test: check live docs.....\");\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && version.onOrAfter(Version.LUCENE_4_5_0)) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, \"OK\");\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, \"OK\");\n\n        if (infoStream != null)\n          infoStream.print(\"    test: check live docs.....\");\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":["5f6bd27530a2846413fe2d00030493c0e2d3a072"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0936055c0eed56be3e4ae5c9db5b0e355390736a","date":1410874015,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + sis.getId() + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && version.onOrAfter(Version.LUCENE_4_5_0)) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + info.info.getId());\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, \"OK\");\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, \"OK\");\n\n        if (infoStream != null)\n          infoStream.print(\"    test: check live docs.....\");\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + sis.getId() + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && version.onOrAfter(Version.LUCENE_4_5_0)) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      AtomicReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + info.info.getId());\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, \"OK\");\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, \"OK\");\n\n        if (infoStream != null)\n          infoStream.print(\"    test: check live docs.....\");\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"500867f0f15393f6b2c38c3366e414fccba04ed6","date":1411520390,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + sis.getId() + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && version.onOrAfter(Version.LUCENE_4_5_0)) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + info.info.getId());\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, \"OK\");\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, \"OK\");\n\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n          if (info.info.getDocCount() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        }\n        \n        // Test Livedocs\n        segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n        // Test Fieldinfos\n        segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.liveDocStatus.error != null) {\n          throw new RuntimeException(\"Live docs test failed\");\n        } else if (segInfoStat.fieldInfoStatus.error != null) {\n          throw new RuntimeException(\"Field Info test failed\");\n        } else if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + sis.getId() + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && version.onOrAfter(Version.LUCENE_4_5_0)) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + info.info.getId());\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, \"OK\");\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, \"OK\");\n\n        if (infoStream != null)\n          infoStream.print(\"    test: check live docs.....\");\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount()-reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount()-reader.numDocs()));\n          }\n          if (info.info.getDocCount() - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs == null) {\n            throw new RuntimeException(\"segment should have deletions, but liveDocs is null\");\n          } else {\n            int numLive = 0;\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (liveDocs.get(j)) {\n                numLive++;\n              }\n            }\n            if (numLive != numDocs) {\n              throw new RuntimeException(\"liveDocs count mismatch: info=\" + numDocs + \", vs bits=\" + numLive);\n            }\n          }\n          \n          segInfoStat.numDeleted = info.info.getDocCount() - numDocs;\n          msg(infoStream, \"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - numDocs));\n          }\n          Bits liveDocs = reader.getLiveDocs();\n          if (liveDocs != null) {\n            // its ok for it to be non-null here, as long as none are set right?\n            for (int j = 0; j < liveDocs.length(); j++) {\n              if (!liveDocs.get(j)) {\n                throw new RuntimeException(\"liveDocs mismatch: info says no deletions but doc \" + j + \" is deleted.\");\n              }\n            }\n          }\n          msg(infoStream, \"OK\");\n        }\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n\n        // Test getFieldInfos()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        FieldInfos fieldInfos = reader.getFieldInfos();\n        msg(infoStream, \"OK [\" + fieldInfos.size() + \" fields]\");\n        segInfoStat.numFields = fieldInfos.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a5d957b3a23cce91c77a2c9971ecf0c9f99dd503","date":1411708843,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && version.onOrAfter(Version.LUCENE_4_5_0)) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, \"OK\");\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, \"OK\");\n\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n          if (info.info.getDocCount() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        }\n        \n        // Test Livedocs\n        segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n        // Test Fieldinfos\n        segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.liveDocStatus.error != null) {\n          throw new RuntimeException(\"Live docs test failed\");\n        } else if (segInfoStat.fieldInfoStatus.error != null) {\n          throw new RuntimeException(\"Field Info test failed\");\n        } else if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + sis.getId() + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && version.onOrAfter(Version.LUCENE_4_5_0)) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + info.info.getId());\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, \"OK\");\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, \"OK\");\n\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n          if (info.info.getDocCount() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        }\n        \n        // Test Livedocs\n        segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n        // Test Fieldinfos\n        segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.liveDocStatus.error != null) {\n          throw new RuntimeException(\"Live docs test failed\");\n        } else if (segInfoStat.fieldInfoStatus.error != null) {\n          throw new RuntimeException(\"Field Info test failed\");\n        } else if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5f6bd27530a2846413fe2d00030493c0e2d3a072","date":1411811855,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && version.onOrAfter(Version.LUCENE_4_5_0)) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, \"OK\");\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, \"OK\");\n\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n          if (info.info.getDocCount() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        }\n        \n        // Test Livedocs\n        segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n        // Test Fieldinfos\n        segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.liveDocStatus.error != null) {\n          throw new RuntimeException(\"Live docs test failed\");\n        } else if (segInfoStat.fieldInfoStatus.error != null) {\n          throw new RuntimeException(\"Field Info test failed\");\n        } else if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + sis.getId() + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && version.onOrAfter(Version.LUCENE_4_5_0)) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + info.info.getId());\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, \"OK\");\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, \"OK\");\n\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n          if (info.info.getDocCount() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        }\n        \n        // Test Livedocs\n        segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n        // Test Fieldinfos\n        segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.liveDocStatus.error != null) {\n          throw new RuntimeException(\"Live docs test failed\");\n        } else if (segInfoStat.fieldInfoStatus.error != null) {\n          throw new RuntimeException(\"Field Info test failed\");\n        } else if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":["e3cc329405ce41b8ef462b4cd30611eca1567620"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8eaedf240fab95c428d5f496a274256d2053ad37","date":1412122376,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && version.onOrAfter(Version.LUCENE_4_5_0)) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, \"OK\");\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, \"OK\");\n\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n          if (info.info.getDocCount() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        }\n        \n        // Test Livedocs\n        segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n        // Test Fieldinfos\n        segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.liveDocStatus.error != null) {\n          throw new RuntimeException(\"Live docs test failed\");\n        } else if (segInfoStat.fieldInfoStatus.error != null) {\n          throw new RuntimeException(\"Field Info test failed\");\n        } else if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && version.onOrAfter(Version.LUCENE_4_5_0)) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, \"OK\");\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, \"OK\");\n\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n          if (info.info.getDocCount() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        }\n        \n        // Test Livedocs\n        segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n        // Test Fieldinfos\n        segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.liveDocStatus.error != null) {\n          throw new RuntimeException(\"Live docs test failed\");\n        } else if (segInfoStat.fieldInfoStatus.error != null) {\n          throw new RuntimeException(\"Field Info test failed\");\n        } else if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":["7b91922b55d15444d554721b352861d028eb8278"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f7523916a1350712e1ae710affd4e88ccd7c431d","date":1412161942,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && version.onOrAfter(Version.LUCENE_4_5_0)) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, \"OK\");\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, \"OK\");\n\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n          if (info.info.getDocCount() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        }\n        \n        // Test Livedocs\n        segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n        // Test Fieldinfos\n        segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.liveDocStatus.error != null) {\n          throw new RuntimeException(\"Live docs test failed\");\n        } else if (segInfoStat.fieldInfoStatus.error != null) {\n          throw new RuntimeException(\"Field Info test failed\");\n        } else if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && version.onOrAfter(Version.LUCENE_4_5_0)) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, \"OK\");\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, \"OK\");\n\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n          if (info.info.getDocCount() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        }\n        \n        // Test Livedocs\n        segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n        // Test Fieldinfos\n        segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.liveDocStatus.error != null) {\n          throw new RuntimeException(\"Live docs test failed\");\n        } else if (segInfoStat.fieldInfoStatus.error != null) {\n          throw new RuntimeException(\"Field Info test failed\");\n        } else if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":["7b91922b55d15444d554721b352861d028eb8278"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"13eb667d6e65203cf0d6d783f25a6b410e8935ec","date":1412186148,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis.read(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && version.onOrAfter(Version.LUCENE_4_5_0)) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, \"OK\");\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, \"OK\");\n\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n          if (info.info.getDocCount() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        }\n        \n        // Test Livedocs\n        segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n        // Test Fieldinfos\n        segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.liveDocStatus.error != null) {\n          throw new RuntimeException(\"Live docs test failed\");\n        } else if (segInfoStat.fieldInfoStatus.error != null) {\n          throw new RuntimeException(\"Field Info test failed\");\n        } else if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && version.onOrAfter(Version.LUCENE_4_5_0)) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, \"OK\");\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, \"OK\");\n\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n          if (info.info.getDocCount() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        }\n        \n        // Test Livedocs\n        segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n        // Test Fieldinfos\n        segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.liveDocStatus.error != null) {\n          throw new RuntimeException(\"Live docs test failed\");\n        } else if (segInfoStat.fieldInfoStatus.error != null) {\n          throw new RuntimeException(\"Field Info test failed\");\n        } else if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d9a47902d6207303f5ed3e7aaca62ca33433af66","date":1412435312,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis.read(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && version.onOrAfter(Version.LUCENE_4_5_0)) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, \"OK\");\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, \"OK\");\n\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n          if (info.info.getDocCount() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        }\n        \n        // Test Livedocs\n        segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n        // Test Fieldinfos\n        segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.liveDocStatus.error != null) {\n          throw new RuntimeException(\"Live docs test failed\");\n        } else if (segInfoStat.fieldInfoStatus.error != null) {\n          throw new RuntimeException(\"Field Info test failed\");\n        } else if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && version.onOrAfter(Version.LUCENE_4_5_0)) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, \"OK\");\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, \"OK\");\n\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n          if (info.info.getDocCount() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        }\n        \n        // Test Livedocs\n        segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n        // Test Fieldinfos\n        segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.liveDocStatus.error != null) {\n          throw new RuntimeException(\"Live docs test failed\");\n        } else if (segInfoStat.fieldInfoStatus.error != null) {\n          throw new RuntimeException(\"Field Info test failed\");\n        } else if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3384e6013a93e4d11b7d75388693f8d0388602bf","date":1413951663,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && version.onOrAfter(Version.LUCENE_4_5_0)) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, \"OK\");\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, \"OK\");\n\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n          if (info.info.getDocCount() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        }\n        \n        // Test Livedocs\n        segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n        // Test Fieldinfos\n        segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.liveDocStatus.error != null) {\n          throw new RuntimeException(\"Live docs test failed\");\n        } else if (segInfoStat.fieldInfoStatus.error != null) {\n          throw new RuntimeException(\"Field Info test failed\");\n        } else if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis.read(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && version.onOrAfter(Version.LUCENE_4_5_0)) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, \"OK\");\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, \"OK\");\n\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n          if (info.info.getDocCount() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        }\n        \n        // Test Livedocs\n        segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n        // Test Fieldinfos\n        segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.liveDocStatus.error != null) {\n          throw new RuntimeException(\"Live docs test failed\");\n        } else if (segInfoStat.fieldInfoStatus.error != null) {\n          throw new RuntimeException(\"Field Info test failed\");\n        } else if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"db68c63cbfaa8698b9c4475f75ed2b9c9696d238","date":1414118621,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && version.onOrAfter(Version.LUCENE_4_5_0)) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, \"OK\");\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, \"OK\");\n\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n          if (info.info.getDocCount() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        }\n        \n        // Test Livedocs\n        segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n        // Test Fieldinfos\n        segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.liveDocStatus.error != null) {\n          throw new RuntimeException(\"Live docs test failed\");\n        } else if (segInfoStat.fieldInfoStatus.error != null) {\n          throw new RuntimeException(\"Field Info test failed\");\n        } else if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis.read(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && version.onOrAfter(Version.LUCENE_4_5_0)) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, \"OK\");\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, \"OK\");\n\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n          if (info.info.getDocCount() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        }\n        \n        // Test Livedocs\n        segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n        // Test Fieldinfos\n        segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.liveDocStatus.error != null) {\n          throw new RuntimeException(\"Live docs test failed\");\n        } else if (segInfoStat.fieldInfoStatus.error != null) {\n          throw new RuntimeException(\"Field Info test failed\");\n        } else if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"71387d8cb6923eb831b17a8b734608ba2e21c653","date":1414126093,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, \"OK\");\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, \"OK\");\n\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n          if (info.info.getDocCount() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        }\n        \n        // Test Livedocs\n        segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n        // Test Fieldinfos\n        segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.liveDocStatus.error != null) {\n          throw new RuntimeException(\"Live docs test failed\");\n        } else if (segInfoStat.fieldInfoStatus.error != null) {\n          throw new RuntimeException(\"Field Info test failed\");\n        } else if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0 && version != null && version.onOrAfter(Version.LUCENE_4_5_0)) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, \"OK\");\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, \"OK\");\n\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n          if (info.info.getDocCount() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        }\n        \n        // Test Livedocs\n        segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n        // Test Fieldinfos\n        segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.liveDocStatus.error != null) {\n          throw new RuntimeException(\"Live docs test failed\");\n        } else if (segInfoStat.fieldInfoStatus.error != null) {\n          throw new RuntimeException(\"Field Info test failed\");\n        } else if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6b64ceb507ba9aa71920c0bfad91032e2c03d42f","date":1423608862,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n          if (info.info.getDocCount() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        }\n        \n        // Test Livedocs\n        segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n        // Test Fieldinfos\n        segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.liveDocStatus.error != null) {\n          throw new RuntimeException(\"Live docs test failed\");\n        } else if (segInfoStat.fieldInfoStatus.error != null) {\n          throw new RuntimeException(\"Field Info test failed\");\n        } else if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, \"OK\");\n\n        segInfoStat.openReaderPassed = true;\n        \n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, \"OK\");\n\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n          if (info.info.getDocCount() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        }\n        \n        // Test Livedocs\n        segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n        // Test Fieldinfos\n        segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.liveDocStatus.error != null) {\n          throw new RuntimeException(\"Live docs test failed\");\n        } else if (segInfoStat.fieldInfoStatus.error != null) {\n          throw new RuntimeException(\"Field Info test failed\");\n        } else if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":["dde1aca34305d40b94ca3fab46ab2b39153f8e53"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b0267c69e2456a3477a1ad785723f2135da3117e","date":1425317087,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        // Test Livedocs\n        segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n        // Test Fieldinfos\n        segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.liveDocStatus.error != null) {\n          throw new RuntimeException(\"Live docs test failed\");\n        } else if (segInfoStat.fieldInfoStatus.error != null) {\n          throw new RuntimeException(\"Field Info test failed\");\n        } else if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n          if (info.info.getDocCount() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        }\n        \n        // Test Livedocs\n        segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n        // Test Fieldinfos\n        segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.liveDocStatus.error != null) {\n          throw new RuntimeException(\"Live docs test failed\");\n        } else if (segInfoStat.fieldInfoStatus.error != null) {\n          throw new RuntimeException(\"Field Info test failed\");\n        } else if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b06445ae1731e049327712db0454e5643ca9b7fe","date":1425329139,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        // Test Livedocs\n        segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n        // Test Fieldinfos\n        segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.liveDocStatus.error != null) {\n          throw new RuntimeException(\"Live docs test failed\");\n        } else if (segInfoStat.fieldInfoStatus.error != null) {\n          throw new RuntimeException(\"Field Info test failed\");\n        } else if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n          if (info.info.getDocCount() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        }\n        \n        // Test Livedocs\n        segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n        // Test Fieldinfos\n        segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.liveDocStatus.error != null) {\n          throw new RuntimeException(\"Live docs test failed\");\n        } else if (segInfoStat.fieldInfoStatus.error != null) {\n          throw new RuntimeException(\"Field Info test failed\");\n        } else if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f0e48f2ee58a552eeaa92f52953efdf3b88b6580","date":1425652664,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          }  else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        // Test Livedocs\n        segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n        // Test Fieldinfos\n        segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.liveDocStatus.error != null) {\n          throw new RuntimeException(\"Live docs test failed\");\n        } else if (segInfoStat.fieldInfoStatus.error != null) {\n          throw new RuntimeException(\"Field Info test failed\");\n        } else if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          }  else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" docCount=\" + info.info.getDocCount());\n      segInfoStat.name = info.info.name;\n      segInfoStat.docCount = info.info.getDocCount();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.getDocCount() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.getDocCount());\n      }\n\n      int toLoseDocCount = info.info.getDocCount();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.getDocCount()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.info.getDocCount());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.getDocCount() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.getDocCount() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.getDocCount() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n          if (info.info.getDocCount() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.getDocCount() - reader.numDocs()));\n          }\n        }\n        \n        // Test Livedocs\n        segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n        // Test Fieldinfos\n        segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.liveDocStatus.error != null) {\n          throw new RuntimeException(\"Live docs test failed\");\n        } else if (segInfoStat.fieldInfoStatus.error != null) {\n          throw new RuntimeException(\"Field Info test failed\");\n        } else if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          }  else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          }  else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":["985e1291b5f205ff2a21385eb7092c8a513a56eb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1eee4175312c41f89aa23427f9e4edfc00deeaac","date":1446373190,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test DimensionalValues\n          segInfoStat.dimensionalValuesStatus = testDimensionalValues(reader, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          }  else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          }  else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a8461c89ad41f7f66c06cfce018c31c03394d7d2","date":1449161553,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test DimensionalValues\n          segInfoStat.dimensionalValuesStatus = testDimensionalValues(reader, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          }  else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n    if (skip) {\n      msg(infoStream, \"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test DimensionalValues\n          segInfoStat.dimensionalValuesStatus = testDimensionalValues(reader, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          }  else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cab7a79353f33d1a94cd307bf33aa5148601ebe6","date":1453391888,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          }  else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test DimensionalValues\n          segInfoStat.dimensionalValuesStatus = testDimensionalValues(reader, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          }  else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17a252099a0f136df3a482ae9df39d0b757d394d","date":1457219570,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          }  else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          }  else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fbe8fc0e68a5e2e7acce82ba880a982bd15cfab8","date":1462567286,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          }  else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          }  else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"45bfb4d30b7e62ec7d645a5e0113362636ac4981","date":1462660573,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          }  else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          }  else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3d33e731a93d4b57e662ff094f64f94a745422d4","date":1463128289,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          }  else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          }  else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ad30c6a479e764150a3316e57263319775f1df2","date":1463395403,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          }  else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          }  else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          }  else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          }  else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          }  else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          }  else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"313b9c84057c3a31294cbcd794ea84c4e81646d9","date":1478080099,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          }  else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9720b151fde2073f4e401450f4574e5f31c2d0ff","date":1478184029,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          }  else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"762c80e29fe0c3bb83aabe2e64af6379273cec7b","date":1484347562,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast, version);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast, version);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"507e7decdf00981d09a74632ea30299a4ce6ba72","date":1484600874,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast, version);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast, version);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31741cf1390044e38a2ec3127cf302ba841bfd75","date":1491292636,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast, version);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast, version);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast, version);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast, version);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"92212fd254551a0b1156aafc3a1a6ed1a43932ad","date":1491296431,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast, version);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast, version);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast, version);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast, version);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"97fc96e6cc460e0ec1fb904a9c7ecd80680780c2","date":1493374641,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast, version);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast, version);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast, version);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast, version);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":["985e1291b5f205ff2a21385eb7092c8a513a56eb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast, version);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast, version);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        IOUtils.reThrow(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast, version);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast, version);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          IOUtils.reThrow(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cd7538cbbd9c304bc5396980e9802cd3a5bcf8e4","date":1499084229,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast, version);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast, version);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cc018b79379c67835b40b1259cd3dc931df60944","date":1499109112,"type":3,"author":"Anshum Gupta","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast, version);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast, version);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"30c8e5574b55d57947e989443dfde611646530ee","date":1499131153,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast, version);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast, version);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0617d2d25b13b9a49450ea49ceb06123ebd6542a","date":1508865221,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      long segmentName = Long.parseLong(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":["9d153abcf92dc5329d98571a8c3035df9bd80648"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9a0e5953a07337cd41bcde610503024c07073b26","date":1519143251,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      long segmentName = Long.parseLong(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      long segmentName = Long.parseLong(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, crossCheckTermVectors, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"071935ce120b55517dcd86b9f985dbda028ba94e","date":1525265372,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      long segmentName = Long.parseLong(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n\n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      long segmentName = Long.parseLong(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n        \n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8f2203cb8ae87188877cfbf6ad170c5738a0aad5","date":1528117512,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      long segmentName = Long.parseLong(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n\n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n        final String softDeletesField = reader.getFieldInfos().getSoftDeletesField();\n        if (softDeletesField != null) {\n          checkSoftDeletes(softDeletesField, info, reader, infoStream, failFast);\n        }\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      long segmentName = Long.parseLong(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n\n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      long segmentName = Long.parseLong(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n\n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n        final String softDeletesField = reader.getFieldInfos().getSoftDeletesField();\n        if (softDeletesField != null) {\n          checkSoftDeletes(softDeletesField, info, reader, infoStream, failFast);\n        }\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      long segmentName = Long.parseLong(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n\n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      long segmentName = Long.parseLong(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n\n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n        final String softDeletesField = reader.getFieldInfos().getSoftDeletesField();\n        if (softDeletesField != null) {\n          checkSoftDeletes(softDeletesField, info, reader, infoStream, failFast);\n        }\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      long segmentName = Long.parseLong(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n\n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8be9dc9e17c1046a542423f69130abddef886f16","date":1530129441,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    if (infoStream != null) {\n      int maxDoc = 0;\n      int delCount = 0;\n      for (SegmentCommitInfo info : sis) {\n        maxDoc += info.info.maxDoc();\n        delCount += info.getDelCount();\n      }\n      infoStream.println(String.format(Locale.ROOT, \"%.2f%% total deletions; %d documents; %d deleteions\",\n                                       100.*delCount/maxDoc,\n                                       maxDoc,\n                                       delCount));\n    }\n    \n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      long segmentName = Long.parseLong(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n\n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n        final String softDeletesField = reader.getFieldInfos().getSoftDeletesField();\n        if (softDeletesField != null) {\n          checkSoftDeletes(softDeletesField, info, reader, infoStream, failFast);\n        }\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      long segmentName = Long.parseLong(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n\n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n        final String softDeletesField = reader.getFieldInfos().getSoftDeletesField();\n        if (softDeletesField != null) {\n          checkSoftDeletes(softDeletesField, info, reader, infoStream, failFast);\n        }\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    if (infoStream != null) {\n      int maxDoc = 0;\n      int delCount = 0;\n      for (SegmentCommitInfo info : sis) {\n        maxDoc += info.info.maxDoc();\n        delCount += info.getDelCount();\n      }\n      infoStream.println(String.format(Locale.ROOT, \"%.2f%% total deletions; %d documents; %d deleteions\",\n                                       100.*delCount/maxDoc,\n                                       maxDoc,\n                                       delCount));\n    }\n    \n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      long segmentName = Long.parseLong(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n\n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n        final String softDeletesField = reader.getFieldInfos().getSoftDeletesField();\n        if (softDeletesField != null) {\n          checkSoftDeletes(softDeletesField, info, reader, infoStream, failFast);\n        }\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      long segmentName = Long.parseLong(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n\n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n        final String softDeletesField = reader.getFieldInfos().getSoftDeletesField();\n        if (softDeletesField != null) {\n          checkSoftDeletes(softDeletesField, info, reader, infoStream, failFast);\n        }\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    if (infoStream != null) {\n      int maxDoc = 0;\n      int delCount = 0;\n      for (SegmentCommitInfo info : sis) {\n        maxDoc += info.info.maxDoc();\n        delCount += info.getDelCount();\n      }\n      infoStream.println(String.format(Locale.ROOT, \"%.2f%% total deletions; %d documents; %d deleteions\",\n                                       100.*delCount/maxDoc,\n                                       maxDoc,\n                                       delCount));\n    }\n    \n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      long segmentName = Long.parseLong(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n\n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n        final String softDeletesField = reader.getFieldInfos().getSoftDeletesField();\n        if (softDeletesField != null) {\n          checkSoftDeletes(softDeletesField, info, reader, infoStream, failFast);\n        }\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      long segmentName = Long.parseLong(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n\n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n        final String softDeletesField = reader.getFieldInfos().getSoftDeletesField();\n        if (softDeletesField != null) {\n          checkSoftDeletes(softDeletesField, info, reader, infoStream, failFast);\n        }\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"985e1291b5f205ff2a21385eb7092c8a513a56eb","date":1533111100,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    if (infoStream != null) {\n      int maxDoc = 0;\n      int delCount = 0;\n      for (SegmentCommitInfo info : sis) {\n        maxDoc += info.info.maxDoc();\n        delCount += info.getDelCount();\n      }\n      infoStream.println(String.format(Locale.ROOT, \"%.2f%% total deletions; %d documents; %d deleteions\",\n                                       100.*delCount/maxDoc,\n                                       maxDoc,\n                                       delCount));\n    }\n    \n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      long segmentName = Long.parseLong(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n\n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n        final String softDeletesField = reader.getFieldInfos().getSoftDeletesField();\n        if (softDeletesField != null) {\n          checkSoftDeletes(softDeletesField, info, reader, infoStream, failFast);\n        }\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    if (infoStream != null) {\n      int maxDoc = 0;\n      int delCount = 0;\n      for (SegmentCommitInfo info : sis) {\n        maxDoc += info.info.maxDoc();\n        delCount += info.getDelCount();\n      }\n      infoStream.println(String.format(Locale.ROOT, \"%.2f%% total deletions; %d documents; %d deleteions\",\n                                       100.*delCount/maxDoc,\n                                       maxDoc,\n                                       delCount));\n    }\n    \n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    // note: we only read the format byte (required preamble) here!\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.READONCE);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not open segments file in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.cantOpenSegments = true;\n      return result;\n    }\n    try {\n      /*int format =*/ input.readInt();\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read segment file version in directory\");\n      if (infoStream != null) {\n        t.printStackTrace(infoStream);\n      }\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      long segmentName = Long.parseLong(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n\n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n        final String softDeletesField = reader.getFieldInfos().getSoftDeletesField();\n        if (softDeletesField != null) {\n          checkSoftDeletes(softDeletesField, info, reader, infoStream, failFast);\n        }\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":["0f4464508ee83288c8c4585b533f9faaa93aa314","82ffd58510acfc0e2e788a90a10002e689ec9145","7b91922b55d15444d554721b352861d028eb8278","e99275efa2c9c9ae3bdba986218af82f2bf3dc30","97fc96e6cc460e0ec1fb904a9c7ecd80680780c2","0cdf9cc6702d60334a616bd7db3ae91501d1dce7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"790693f23f4e88a59fbb25e47cc25f6d493b03cb","date":1553077690,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    if (infoStream != null) {\n      int maxDoc = 0;\n      int delCount = 0;\n      for (SegmentCommitInfo info : sis) {\n        maxDoc += info.info.maxDoc();\n        delCount += info.getDelCount();\n      }\n      infoStream.println(String.format(Locale.ROOT, \"%.2f%% total deletions; %d documents; %d deleteions\",\n                                       100.*delCount/maxDoc,\n                                       maxDoc,\n                                       delCount));\n    }\n    \n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      long segmentName = Long.parseLong(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), false, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n\n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n        final String softDeletesField = reader.getFieldInfos().getSoftDeletesField();\n        if (softDeletesField != null) {\n          checkSoftDeletes(softDeletesField, info, reader, infoStream, failFast);\n        }\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    if (infoStream != null) {\n      int maxDoc = 0;\n      int delCount = 0;\n      for (SegmentCommitInfo info : sis) {\n        maxDoc += info.info.maxDoc();\n        delCount += info.getDelCount();\n      }\n      infoStream.println(String.format(Locale.ROOT, \"%.2f%% total deletions; %d documents; %d deleteions\",\n                                       100.*delCount/maxDoc,\n                                       maxDoc,\n                                       delCount));\n    }\n    \n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      long segmentName = Long.parseLong(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n\n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n        final String softDeletesField = reader.getFieldInfos().getSoftDeletesField();\n        if (softDeletesField != null) {\n          checkSoftDeletes(softDeletesField, info, reader, infoStream, failFast);\n        }\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"763da4a9605e47013078edc323b9d4b608f0f9e0","date":1555353576,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    if (infoStream != null) {\n      int maxDoc = 0;\n      int delCount = 0;\n      for (SegmentCommitInfo info : sis) {\n        maxDoc += info.info.maxDoc();\n        delCount += info.getDelCount();\n      }\n      infoStream.println(String.format(Locale.ROOT, \"%.2f%% total deletions; %d documents; %d deleteions\",\n                                       100.*delCount/maxDoc,\n                                       maxDoc,\n                                       delCount));\n    }\n    \n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      long segmentName = Long.parseLong(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), false, IOContext.DEFAULT,\n            Collections.singletonMap(BlockTreeTermsReader.FST_MODE_KEY, BlockTreeTermsReader.FSTLoadMode.OFF_HEAP.name())); // lets keep stuff on disk for check-index\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n\n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n        final String softDeletesField = reader.getFieldInfos().getSoftDeletesField();\n        if (softDeletesField != null) {\n          checkSoftDeletes(softDeletesField, info, reader, infoStream, failFast);\n        }\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    if (infoStream != null) {\n      int maxDoc = 0;\n      int delCount = 0;\n      for (SegmentCommitInfo info : sis) {\n        maxDoc += info.info.maxDoc();\n        delCount += info.getDelCount();\n      }\n      infoStream.println(String.format(Locale.ROOT, \"%.2f%% total deletions; %d documents; %d deleteions\",\n                                       100.*delCount/maxDoc,\n                                       maxDoc,\n                                       delCount));\n    }\n    \n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      long segmentName = Long.parseLong(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), false, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n\n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n        final String softDeletesField = reader.getFieldInfos().getSoftDeletesField();\n        if (softDeletesField != null) {\n          checkSoftDeletes(softDeletesField, info, reader, infoStream, failFast);\n        }\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a4e83191a3e02851a0b67e5335e6922f3e9ea86d","date":1583489709,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    if (infoStream != null) {\n      int maxDoc = 0;\n      int delCount = 0;\n      for (SegmentCommitInfo info : sis) {\n        maxDoc += info.info.maxDoc();\n        delCount += info.getDelCount();\n      }\n      infoStream.println(String.format(Locale.ROOT, \"%.2f%% total deletions; %d documents; %d deleteions\",\n                                       100.*delCount/maxDoc,\n                                       maxDoc,\n                                       delCount));\n    }\n    \n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      long segmentName = Long.parseLong(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), false, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n\n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n        final String softDeletesField = reader.getFieldInfos().getSoftDeletesField();\n        if (softDeletesField != null) {\n          checkSoftDeletes(softDeletesField, info, reader, infoStream, failFast);\n        }\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    if (infoStream != null) {\n      int maxDoc = 0;\n      int delCount = 0;\n      for (SegmentCommitInfo info : sis) {\n        maxDoc += info.info.maxDoc();\n        delCount += info.getDelCount();\n      }\n      infoStream.println(String.format(Locale.ROOT, \"%.2f%% total deletions; %d documents; %d deleteions\",\n                                       100.*delCount/maxDoc,\n                                       maxDoc,\n                                       delCount));\n    }\n    \n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      long segmentName = Long.parseLong(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), false, IOContext.DEFAULT,\n            Collections.singletonMap(BlockTreeTermsReader.FST_MODE_KEY, BlockTreeTermsReader.FSTLoadMode.OFF_HEAP.name())); // lets keep stuff on disk for check-index\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n\n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n        final String softDeletesField = reader.getFieldInfos().getSoftDeletesField();\n        if (softDeletesField != null) {\n          checkSoftDeletes(softDeletesField, info, reader, infoStream, failFast);\n        }\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bec68e7c41fed133827595747d853cad504e481e","date":1583501052,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String]).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    if (infoStream != null) {\n      int maxDoc = 0;\n      int delCount = 0;\n      for (SegmentCommitInfo info : sis) {\n        maxDoc += info.info.maxDoc();\n        delCount += info.getDelCount();\n      }\n      infoStream.println(String.format(Locale.ROOT, \"%.2f%% total deletions; %d documents; %d deleteions\",\n                                       100.*delCount/maxDoc,\n                                       maxDoc,\n                                       delCount));\n    }\n    \n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      long segmentName = Long.parseLong(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n\n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n        final String softDeletesField = reader.getFieldInfos().getSoftDeletesField();\n        if (softDeletesField != null) {\n          checkSoftDeletes(softDeletesField, info, reader, infoStream, failFast);\n        }\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run. */\n  public Status checkIndex(List<String> onlySegments) throws IOException {\n    ensureOpen();\n    long startNS = System.nanoTime();\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\n    SegmentInfos sis = null;\n    Status result = new Status();\n    result.dir = dir;\n    String[] files = dir.listAll();\n    String lastSegmentsFile = SegmentInfos.getLastCommitSegmentsFileName(files);\n    if (lastSegmentsFile == null) {\n      throw new IndexNotFoundException(\"no segments* file found in \" + dir + \": files: \" + Arrays.toString(files));\n    }\n    try {\n      // Do not use SegmentInfos.read(Directory) since the spooky\n      // retrying it does is not necessary here (we hold the write lock):\n      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);\n    } catch (Throwable t) {\n      if (failFast) {\n        throw IOUtils.rethrowAlways(t);\n      }\n      msg(infoStream, \"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    if (infoStream != null) {\n      int maxDoc = 0;\n      int delCount = 0;\n      for (SegmentCommitInfo info : sis) {\n        maxDoc += info.info.maxDoc();\n        delCount += info.getDelCount();\n      }\n      infoStream.println(String.format(Locale.ROOT, \"%.2f%% total deletions; %d documents; %d deleteions\",\n                                       100.*delCount/maxDoc,\n                                       maxDoc,\n                                       delCount));\n    }\n    \n    // find the oldest and newest segment versions\n    Version oldest = null;\n    Version newest = null;\n    String oldSegs = null;\n    for (SegmentCommitInfo si : sis) {\n      Version version = si.info.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        if (oldest == null || version.onOrAfter(oldest) == false) {\n          oldest = version;\n        }\n        if (newest == null || version.onOrAfter(newest)) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getSegmentsFileName();\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = \"\";\n    if (oldSegs != null) {\n      if (newest != null) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else if (newest != null) { // implies oldest != null\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(infoStream, \"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" id=\" + StringHelper.idToString(sis.getId()) + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null) {\n        infoStream.print(\"\\nChecking only these segments:\");\n        for (String s : onlySegments) {\n          infoStream.print(\" \" + s);\n        }\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(infoStream, \":\");\n    }\n\n\n\n    result.newSegments = sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = sis.info(i);\n      long segmentName = Long.parseLong(info.info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.info.name)) {\n        continue;\n      }\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(infoStream, \"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.info.name + \" maxDoc=\" + info.info.maxDoc());\n      segInfoStat.name = info.info.name;\n      segInfoStat.maxDoc = info.info.maxDoc();\n      \n      final Version version = info.info.getVersion();\n      if (info.info.maxDoc() <= 0) {\n        throw new RuntimeException(\"illegal number of documents: maxDoc=\" + info.info.maxDoc());\n      }\n\n      int toLoseDocCount = info.info.maxDoc();\n\n      SegmentReader reader = null;\n      Sort previousIndexSort = null;\n\n      try {\n        msg(infoStream, \"    version=\" + (version == null ? \"3.0\" : version));\n        msg(infoStream, \"    id=\" + StringHelper.idToString(info.info.getId()));\n        final Codec codec = info.info.getCodec();\n        msg(infoStream, \"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(infoStream, \"    compound=\" + info.info.getUseCompoundFile());\n        segInfoStat.compound = info.info.getUseCompoundFile();\n        msg(infoStream, \"    numFiles=\" + info.files().size());\n        Sort indexSort = info.info.getIndexSort();\n        if (indexSort != null) {\n          msg(infoStream, \"    sort=\" + indexSort);\n          if (previousIndexSort != null) {\n            if (previousIndexSort.equals(indexSort) == false) {\n              throw new RuntimeException(\"index sort changed from \" + previousIndexSort + \" to \" + indexSort);\n            }\n          } else {\n            previousIndexSort = indexSort;\n          }\n        }\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        msg(infoStream, \"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(infoStream, \"    diagnostics = \" + diagnostics);\n        }\n\n        if (!info.hasDeletions()) {\n          msg(infoStream, \"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        } else {\n          msg(infoStream, \"    has deletions [delGen=\" + info.getDelGen() + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsGen = info.getDelGen();\n        }\n        \n        long startOpenReaderNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), false, IOContext.DEFAULT);\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startOpenReaderNS)));\n\n        segInfoStat.openReaderPassed = true;\n        \n        long startIntegrityNS = System.nanoTime();\n        if (infoStream != null)\n          infoStream.print(\"    test: check integrity.....\");\n        reader.checkIntegrity();\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startIntegrityNS)));\n\n        if (reader.maxDoc() != info.info.maxDoc()) {\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfo.maxDoc \" + info.info.maxDoc());\n        }\n        \n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        \n        if (reader.hasDeletions()) {\n          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.info.maxDoc() - info.getDelCount()) + \" vs reader=\" + reader.numDocs());\n          }\n          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.info.maxDoc() - reader.numDocs()));\n          }\n        }\n        \n        if (checksumsOnly == false) {\n          // Test Livedocs\n          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);\n\n          // Test Fieldinfos\n          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);\n\n          // Test Field Norms\n          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);\n\n          // Test the Term Index\n          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Stored Fields\n          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);\n\n          // Test Term Vectors\n          segInfoStat.termVectorStatus = testTermVectors(reader, infoStream, verbose, doSlowChecks, failFast);\n\n          // Test Docvalues\n          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);\n\n          // Test PointValues\n          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);\n\n          // Test index sort\n          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);\n\n          // Rethrow the first exception we encountered\n          //  This will cause stats for failed segments to be incremented properly\n          if (segInfoStat.liveDocStatus.error != null) {\n            throw new RuntimeException(\"Live docs test failed\");\n          } else if (segInfoStat.fieldInfoStatus.error != null) {\n            throw new RuntimeException(\"Field Info test failed\");\n          } else if (segInfoStat.fieldNormStatus.error != null) {\n            throw new RuntimeException(\"Field Norm test failed\");\n          } else if (segInfoStat.termIndexStatus.error != null) {\n            throw new RuntimeException(\"Term Index test failed\");\n          } else if (segInfoStat.storedFieldStatus.error != null) {\n            throw new RuntimeException(\"Stored Field test failed\");\n          } else if (segInfoStat.termVectorStatus.error != null) {\n            throw new RuntimeException(\"Term Vector test failed\");\n          } else if (segInfoStat.docValuesStatus.error != null) {\n            throw new RuntimeException(\"DocValues test failed\");\n          } else if (segInfoStat.pointsStatus.error != null) {\n            throw new RuntimeException(\"Points test failed\");\n          }\n        }\n        final String softDeletesField = reader.getFieldInfos().getSoftDeletesField();\n        if (softDeletesField != null) {\n          checkSoftDeletes(softDeletesField, info, reader, infoStream, failFast);\n        }\n        msg(infoStream, \"\");\n        \n        if (verbose) {\n          msg(infoStream, \"detailed segment RAM usage: \");\n          msg(infoStream, Accountables.toString(reader));\n        }\n\n      } catch (Throwable t) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(t);\n        }\n        msg(infoStream, \"FAILED\");\n        String comment;\n        comment = \"exorciseIndex() would remove reference to this segment\";\n        msg(infoStream, \"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(infoStream, \"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add(info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(infoStream, \"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(infoStream, \"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(infoStream, \"No problems were detected with this index.\\n\");\n    }\n\n    msg(infoStream, String.format(Locale.ROOT, \"Took %.3f sec total.\", nsToSec(System.nanoTime()-startNS)));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1f3b037cd083286b2af89f96e768f85dcd8072d6":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"addc47115aa3376d79985cd4abc9f8c6e212a032":["f7178a82d1134111f4511f28bb9ad57573a57d93"],"97fc96e6cc460e0ec1fb904a9c7ecd80680780c2":["31741cf1390044e38a2ec3127cf302ba841bfd75"],"82ffd58510acfc0e2e788a90a10002e689ec9145":["0859dec0aa7a485aa0081147f533c5987b4b47ac"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["438e995b4e32916f631722aab36254146830fefb","368714b5b6663ca71a0cba34a94e6032ccdff3f2"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9720b151fde2073f4e401450f4574e5f31c2d0ff":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","313b9c84057c3a31294cbcd794ea84c4e81646d9"],"f7523916a1350712e1ae710affd4e88ccd7c431d":["8eaedf240fab95c428d5f496a274256d2053ad37"],"6b64ceb507ba9aa71920c0bfad91032e2c03d42f":["71387d8cb6923eb831b17a8b734608ba2e21c653"],"2acf500f78aa12b92e371fd89c719291986b6b90":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","5dc83d085f83b38c31736c494913c0c75265ce02"],"0617d2d25b13b9a49450ea49ceb06123ebd6542a":["cc018b79379c67835b40b1259cd3dc931df60944"],"a4e83191a3e02851a0b67e5335e6922f3e9ea86d":["763da4a9605e47013078edc323b9d4b608f0f9e0"],"17a252099a0f136df3a482ae9df39d0b757d394d":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["92212fd254551a0b1156aafc3a1a6ed1a43932ad","97fc96e6cc460e0ec1fb904a9c7ecd80680780c2"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["b70042a8a492f7054d480ccdd2be9796510d4327","8be9dc9e17c1046a542423f69130abddef886f16"],"f0e48f2ee58a552eeaa92f52953efdf3b88b6580":["b0267c69e2456a3477a1ad785723f2135da3117e"],"b70042a8a492f7054d480ccdd2be9796510d4327":["071935ce120b55517dcd86b9f985dbda028ba94e","8f2203cb8ae87188877cfbf6ad170c5738a0aad5"],"5dc83d085f83b38c31736c494913c0c75265ce02":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"77f264c55cbf75404f8601ae7290d69157273a56":["82ffd58510acfc0e2e788a90a10002e689ec9145"],"9a0e5953a07337cd41bcde610503024c07073b26":["0617d2d25b13b9a49450ea49ceb06123ebd6542a"],"313b9c84057c3a31294cbcd794ea84c4e81646d9":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"203d7d3cb7712e10ef33009a63247ae40c302d7a":["fb5728b83dbb3e002cdd22adfe6caf103a96ef15"],"fbe8fc0e68a5e2e7acce82ba880a982bd15cfab8":["17a252099a0f136df3a482ae9df39d0b757d394d"],"790693f23f4e88a59fbb25e47cc25f6d493b03cb":["985e1291b5f205ff2a21385eb7092c8a513a56eb"],"0cdf9cc6702d60334a616bd7db3ae91501d1dce7":["dde1aca34305d40b94ca3fab46ab2b39153f8e53"],"b75c8811b9d17d93b79f382fc49e8cbd2b220c90":["0cdf9cc6702d60334a616bd7db3ae91501d1dce7"],"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["a8461c89ad41f7f66c06cfce018c31c03394d7d2"],"fb5728b83dbb3e002cdd22adfe6caf103a96ef15":["9d153abcf92dc5329d98571a8c3035df9bd80648"],"a45bec74b98f6fc05f52770cfb425739e6563960":["e44db636314d8ec17d54d6d28e6054fa4566e6c9"],"f7178a82d1134111f4511f28bb9ad57573a57d93":["7cd329bd749496f6c58b586a6c0dd0dc8201206f"],"b0267c69e2456a3477a1ad785723f2135da3117e":["6b64ceb507ba9aa71920c0bfad91032e2c03d42f"],"bec68e7c41fed133827595747d853cad504e481e":["a4e83191a3e02851a0b67e5335e6922f3e9ea86d"],"368714b5b6663ca71a0cba34a94e6032ccdff3f2":["438e995b4e32916f631722aab36254146830fefb"],"3384e6013a93e4d11b7d75388693f8d0388602bf":["d9a47902d6207303f5ed3e7aaca62ca33433af66"],"d9a47902d6207303f5ed3e7aaca62ca33433af66":["a5d957b3a23cce91c77a2c9971ecf0c9f99dd503","13eb667d6e65203cf0d6d783f25a6b410e8935ec"],"30c8e5574b55d57947e989443dfde611646530ee":["e9017cf144952056066919f1ebc7897ff9bd71b1","cc018b79379c67835b40b1259cd3dc931df60944"],"500867f0f15393f6b2c38c3366e414fccba04ed6":["0936055c0eed56be3e4ae5c9db5b0e355390736a"],"d2dee33619431ada2a7a07f5fe2dbd94bac6a460":["399d5903979ca52514d2bc7e3a362e1c45885c94"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["f0e48f2ee58a552eeaa92f52953efdf3b88b6580"],"a8461c89ad41f7f66c06cfce018c31c03394d7d2":["1eee4175312c41f89aa23427f9e4edfc00deeaac"],"e3cc329405ce41b8ef462b4cd30611eca1567620":["057a1793765d068ea9302f1a29e21734ee58d41e"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["90dfa8ee4e9e118b4c2c1c042bf57d9b460613de","e99275efa2c9c9ae3bdba986218af82f2bf3dc30"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","2acf500f78aa12b92e371fd89c719291986b6b90"],"13eb667d6e65203cf0d6d783f25a6b410e8935ec":["f7523916a1350712e1ae710affd4e88ccd7c431d"],"f592209545c71895260367152601e9200399776d":["071935ce120b55517dcd86b9f985dbda028ba94e","8f2203cb8ae87188877cfbf6ad170c5738a0aad5"],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["77f264c55cbf75404f8601ae7290d69157273a56"],"6a917aca07a305ab70118a83e84d931503441271":["203d7d3cb7712e10ef33009a63247ae40c302d7a"],"763da4a9605e47013078edc323b9d4b608f0f9e0":["790693f23f4e88a59fbb25e47cc25f6d493b03cb"],"a5d957b3a23cce91c77a2c9971ecf0c9f99dd503":["500867f0f15393f6b2c38c3366e414fccba04ed6"],"e99275efa2c9c9ae3bdba986218af82f2bf3dc30":["addc47115aa3376d79985cd4abc9f8c6e212a032"],"5f6bd27530a2846413fe2d00030493c0e2d3a072":["500867f0f15393f6b2c38c3366e414fccba04ed6","a5d957b3a23cce91c77a2c9971ecf0c9f99dd503"],"0ad30c6a479e764150a3316e57263319775f1df2":["17a252099a0f136df3a482ae9df39d0b757d394d","3d33e731a93d4b57e662ff094f64f94a745422d4"],"057a1793765d068ea9302f1a29e21734ee58d41e":["b75c8811b9d17d93b79f382fc49e8cbd2b220c90"],"71387d8cb6923eb831b17a8b734608ba2e21c653":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"31741cf1390044e38a2ec3127cf302ba841bfd75":["762c80e29fe0c3bb83aabe2e64af6379273cec7b"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["17a252099a0f136df3a482ae9df39d0b757d394d","0ad30c6a479e764150a3316e57263319775f1df2"],"cd7538cbbd9c304bc5396980e9802cd3a5bcf8e4":["97fc96e6cc460e0ec1fb904a9c7ecd80680780c2"],"985e1291b5f205ff2a21385eb7092c8a513a56eb":["8be9dc9e17c1046a542423f69130abddef886f16"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["6b64ceb507ba9aa71920c0bfad91032e2c03d42f","f0e48f2ee58a552eeaa92f52953efdf3b88b6580"],"4356000e349e38c9fb48034695b7c309abd54557":["dc97c61094c5498702b29cc2e8309beac50c23dc"],"b06445ae1731e049327712db0454e5643ca9b7fe":["6b64ceb507ba9aa71920c0bfad91032e2c03d42f","b0267c69e2456a3477a1ad785723f2135da3117e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7cd329bd749496f6c58b586a6c0dd0dc8201206f":["90dfa8ee4e9e118b4c2c1c042bf57d9b460613de"],"1eee4175312c41f89aa23427f9e4edfc00deeaac":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"90dfa8ee4e9e118b4c2c1c042bf57d9b460613de":["2acf500f78aa12b92e371fd89c719291986b6b90"],"cc018b79379c67835b40b1259cd3dc931df60944":["97fc96e6cc460e0ec1fb904a9c7ecd80680780c2","cd7538cbbd9c304bc5396980e9802cd3a5bcf8e4"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["e44db636314d8ec17d54d6d28e6054fa4566e6c9"],"92212fd254551a0b1156aafc3a1a6ed1a43932ad":["762c80e29fe0c3bb83aabe2e64af6379273cec7b"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["f592209545c71895260367152601e9200399776d","8be9dc9e17c1046a542423f69130abddef886f16"],"5eb2511ababf862ea11e10761c70ee560cd84510":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","1f3b037cd083286b2af89f96e768f85dcd8072d6"],"45bfb4d30b7e62ec7d645a5e0113362636ac4981":["fbe8fc0e68a5e2e7acce82ba880a982bd15cfab8"],"814339e4b1ce2063ccbc6cacc6443a6446c7718b":["09d4afa2df10006646959dfd135786e815d48ffa"],"0859dec0aa7a485aa0081147f533c5987b4b47ac":["a45bec74b98f6fc05f52770cfb425739e6563960"],"071935ce120b55517dcd86b9f985dbda028ba94e":["9a0e5953a07337cd41bcde610503024c07073b26"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","0859dec0aa7a485aa0081147f533c5987b4b47ac"],"dde1aca34305d40b94ca3fab46ab2b39153f8e53":["1f3b037cd083286b2af89f96e768f85dcd8072d6"],"9d153abcf92dc5329d98571a8c3035df9bd80648":["4b512a6470fbb93c320e0cc8519ec0fe94efa13e"],"8eaedf240fab95c428d5f496a274256d2053ad37":["5f6bd27530a2846413fe2d00030493c0e2d3a072"],"399d5903979ca52514d2bc7e3a362e1c45885c94":["814339e4b1ce2063ccbc6cacc6443a6446c7718b"],"dc97c61094c5498702b29cc2e8309beac50c23dc":["d2dee33619431ada2a7a07f5fe2dbd94bac6a460"],"09d4afa2df10006646959dfd135786e815d48ffa":["368714b5b6663ca71a0cba34a94e6032ccdff3f2"],"507e7decdf00981d09a74632ea30299a4ce6ba72":["9720b151fde2073f4e401450f4574e5f31c2d0ff","762c80e29fe0c3bb83aabe2e64af6379273cec7b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["17a252099a0f136df3a482ae9df39d0b757d394d","d470c8182e92b264680e34081b75e70a9f2b3c89"],"46d8ada1fff8d18cb197c38c7983225162599948":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","2acf500f78aa12b92e371fd89c719291986b6b90"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["399d5903979ca52514d2bc7e3a362e1c45885c94","6a917aca07a305ab70118a83e84d931503441271"],"8be9dc9e17c1046a542423f69130abddef886f16":["8f2203cb8ae87188877cfbf6ad170c5738a0aad5"],"762c80e29fe0c3bb83aabe2e64af6379273cec7b":["313b9c84057c3a31294cbcd794ea84c4e81646d9"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["13eb667d6e65203cf0d6d783f25a6b410e8935ec","3384e6013a93e4d11b7d75388693f8d0388602bf"],"0936055c0eed56be3e4ae5c9db5b0e355390736a":["e3cc329405ce41b8ef462b4cd30611eca1567620"],"8f2203cb8ae87188877cfbf6ad170c5738a0aad5":["071935ce120b55517dcd86b9f985dbda028ba94e"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["17a252099a0f136df3a482ae9df39d0b757d394d","45bfb4d30b7e62ec7d645a5e0113362636ac4981"],"438e995b4e32916f631722aab36254146830fefb":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"e44db636314d8ec17d54d6d28e6054fa4566e6c9":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bec68e7c41fed133827595747d853cad504e481e"],"4b512a6470fbb93c320e0cc8519ec0fe94efa13e":["4356000e349e38c9fb48034695b7c309abd54557"]},"commit2Childs":{"1f3b037cd083286b2af89f96e768f85dcd8072d6":["5eb2511ababf862ea11e10761c70ee560cd84510","dde1aca34305d40b94ca3fab46ab2b39153f8e53"],"addc47115aa3376d79985cd4abc9f8c6e212a032":["e99275efa2c9c9ae3bdba986218af82f2bf3dc30"],"97fc96e6cc460e0ec1fb904a9c7ecd80680780c2":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd7538cbbd9c304bc5396980e9802cd3a5bcf8e4","cc018b79379c67835b40b1259cd3dc931df60944"],"82ffd58510acfc0e2e788a90a10002e689ec9145":["77f264c55cbf75404f8601ae7290d69157273a56"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["438e995b4e32916f631722aab36254146830fefb"],"9720b151fde2073f4e401450f4574e5f31c2d0ff":["507e7decdf00981d09a74632ea30299a4ce6ba72"],"f7523916a1350712e1ae710affd4e88ccd7c431d":["13eb667d6e65203cf0d6d783f25a6b410e8935ec"],"6b64ceb507ba9aa71920c0bfad91032e2c03d42f":["b0267c69e2456a3477a1ad785723f2135da3117e","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe"],"2acf500f78aa12b92e371fd89c719291986b6b90":["fe33227f6805edab2036cbb80645cc4e2d1fa424","90dfa8ee4e9e118b4c2c1c042bf57d9b460613de","46d8ada1fff8d18cb197c38c7983225162599948"],"0617d2d25b13b9a49450ea49ceb06123ebd6542a":["9a0e5953a07337cd41bcde610503024c07073b26"],"a4e83191a3e02851a0b67e5335e6922f3e9ea86d":["bec68e7c41fed133827595747d853cad504e481e"],"17a252099a0f136df3a482ae9df39d0b757d394d":["fbe8fc0e68a5e2e7acce82ba880a982bd15cfab8","0ad30c6a479e764150a3316e57263319775f1df2","d470c8182e92b264680e34081b75e70a9f2b3c89","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3d33e731a93d4b57e662ff094f64f94a745422d4"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["30c8e5574b55d57947e989443dfde611646530ee"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"f0e48f2ee58a552eeaa92f52953efdf3b88b6580":["0f4464508ee83288c8c4585b533f9faaa93aa314","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"b70042a8a492f7054d480ccdd2be9796510d4327":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5"],"5dc83d085f83b38c31736c494913c0c75265ce02":["2acf500f78aa12b92e371fd89c719291986b6b90"],"77f264c55cbf75404f8601ae7290d69157273a56":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"313b9c84057c3a31294cbcd794ea84c4e81646d9":["9720b151fde2073f4e401450f4574e5f31c2d0ff","762c80e29fe0c3bb83aabe2e64af6379273cec7b"],"9a0e5953a07337cd41bcde610503024c07073b26":["071935ce120b55517dcd86b9f985dbda028ba94e"],"203d7d3cb7712e10ef33009a63247ae40c302d7a":["6a917aca07a305ab70118a83e84d931503441271"],"fbe8fc0e68a5e2e7acce82ba880a982bd15cfab8":["45bfb4d30b7e62ec7d645a5e0113362636ac4981"],"790693f23f4e88a59fbb25e47cc25f6d493b03cb":["763da4a9605e47013078edc323b9d4b608f0f9e0"],"0cdf9cc6702d60334a616bd7db3ae91501d1dce7":["b75c8811b9d17d93b79f382fc49e8cbd2b220c90"],"b75c8811b9d17d93b79f382fc49e8cbd2b220c90":["057a1793765d068ea9302f1a29e21734ee58d41e"],"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["17a252099a0f136df3a482ae9df39d0b757d394d"],"fb5728b83dbb3e002cdd22adfe6caf103a96ef15":["203d7d3cb7712e10ef33009a63247ae40c302d7a"],"f7178a82d1134111f4511f28bb9ad57573a57d93":["addc47115aa3376d79985cd4abc9f8c6e212a032"],"a45bec74b98f6fc05f52770cfb425739e6563960":["0859dec0aa7a485aa0081147f533c5987b4b47ac"],"b0267c69e2456a3477a1ad785723f2135da3117e":["f0e48f2ee58a552eeaa92f52953efdf3b88b6580","b06445ae1731e049327712db0454e5643ca9b7fe"],"368714b5b6663ca71a0cba34a94e6032ccdff3f2":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","09d4afa2df10006646959dfd135786e815d48ffa"],"bec68e7c41fed133827595747d853cad504e481e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3384e6013a93e4d11b7d75388693f8d0388602bf":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"d9a47902d6207303f5ed3e7aaca62ca33433af66":["3384e6013a93e4d11b7d75388693f8d0388602bf"],"30c8e5574b55d57947e989443dfde611646530ee":[],"500867f0f15393f6b2c38c3366e414fccba04ed6":["a5d957b3a23cce91c77a2c9971ecf0c9f99dd503","5f6bd27530a2846413fe2d00030493c0e2d3a072"],"d2dee33619431ada2a7a07f5fe2dbd94bac6a460":["dc97c61094c5498702b29cc2e8309beac50c23dc"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["1eee4175312c41f89aa23427f9e4edfc00deeaac"],"a8461c89ad41f7f66c06cfce018c31c03394d7d2":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"e3cc329405ce41b8ef462b4cd30611eca1567620":["0936055c0eed56be3e4ae5c9db5b0e355390736a"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["e44db636314d8ec17d54d6d28e6054fa4566e6c9"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"13eb667d6e65203cf0d6d783f25a6b410e8935ec":["d9a47902d6207303f5ed3e7aaca62ca33433af66","db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"f592209545c71895260367152601e9200399776d":["7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["1f3b037cd083286b2af89f96e768f85dcd8072d6","5eb2511ababf862ea11e10761c70ee560cd84510"],"6a917aca07a305ab70118a83e84d931503441271":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"763da4a9605e47013078edc323b9d4b608f0f9e0":["a4e83191a3e02851a0b67e5335e6922f3e9ea86d"],"a5d957b3a23cce91c77a2c9971ecf0c9f99dd503":["d9a47902d6207303f5ed3e7aaca62ca33433af66","5f6bd27530a2846413fe2d00030493c0e2d3a072"],"e99275efa2c9c9ae3bdba986218af82f2bf3dc30":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"5f6bd27530a2846413fe2d00030493c0e2d3a072":["8eaedf240fab95c428d5f496a274256d2053ad37"],"0ad30c6a479e764150a3316e57263319775f1df2":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"057a1793765d068ea9302f1a29e21734ee58d41e":["e3cc329405ce41b8ef462b4cd30611eca1567620"],"71387d8cb6923eb831b17a8b734608ba2e21c653":["6b64ceb507ba9aa71920c0bfad91032e2c03d42f"],"31741cf1390044e38a2ec3127cf302ba841bfd75":["97fc96e6cc460e0ec1fb904a9c7ecd80680780c2"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["313b9c84057c3a31294cbcd794ea84c4e81646d9","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"cd7538cbbd9c304bc5396980e9802cd3a5bcf8e4":["cc018b79379c67835b40b1259cd3dc931df60944"],"985e1291b5f205ff2a21385eb7092c8a513a56eb":["790693f23f4e88a59fbb25e47cc25f6d493b03cb"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"4356000e349e38c9fb48034695b7c309abd54557":["4b512a6470fbb93c320e0cc8519ec0fe94efa13e"],"b06445ae1731e049327712db0454e5643ca9b7fe":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"7cd329bd749496f6c58b586a6c0dd0dc8201206f":["f7178a82d1134111f4511f28bb9ad57573a57d93"],"cc018b79379c67835b40b1259cd3dc931df60944":["0617d2d25b13b9a49450ea49ceb06123ebd6542a","30c8e5574b55d57947e989443dfde611646530ee"],"1eee4175312c41f89aa23427f9e4edfc00deeaac":["a8461c89ad41f7f66c06cfce018c31c03394d7d2"],"90dfa8ee4e9e118b4c2c1c042bf57d9b460613de":["d4d69c535930b5cce125cff868d40f6373dc27d4","7cd329bd749496f6c58b586a6c0dd0dc8201206f"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576"],"92212fd254551a0b1156aafc3a1a6ed1a43932ad":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[],"5eb2511ababf862ea11e10761c70ee560cd84510":[],"45bfb4d30b7e62ec7d645a5e0113362636ac4981":["3d33e731a93d4b57e662ff094f64f94a745422d4"],"814339e4b1ce2063ccbc6cacc6443a6446c7718b":["399d5903979ca52514d2bc7e3a362e1c45885c94"],"0859dec0aa7a485aa0081147f533c5987b4b47ac":["82ffd58510acfc0e2e788a90a10002e689ec9145","3dffec77fb8f7d0e9ca4869dddd6af94528b4576"],"071935ce120b55517dcd86b9f985dbda028ba94e":["b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","8f2203cb8ae87188877cfbf6ad170c5738a0aad5"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"dde1aca34305d40b94ca3fab46ab2b39153f8e53":["0cdf9cc6702d60334a616bd7db3ae91501d1dce7"],"9d153abcf92dc5329d98571a8c3035df9bd80648":["fb5728b83dbb3e002cdd22adfe6caf103a96ef15"],"8eaedf240fab95c428d5f496a274256d2053ad37":["f7523916a1350712e1ae710affd4e88ccd7c431d"],"399d5903979ca52514d2bc7e3a362e1c45885c94":["d2dee33619431ada2a7a07f5fe2dbd94bac6a460","615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"dc97c61094c5498702b29cc2e8309beac50c23dc":["4356000e349e38c9fb48034695b7c309abd54557"],"09d4afa2df10006646959dfd135786e815d48ffa":["814339e4b1ce2063ccbc6cacc6443a6446c7718b"],"507e7decdf00981d09a74632ea30299a4ce6ba72":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["9720b151fde2073f4e401450f4574e5f31c2d0ff"],"46d8ada1fff8d18cb197c38c7983225162599948":[],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["2acf500f78aa12b92e371fd89c719291986b6b90","5dc83d085f83b38c31736c494913c0c75265ce02","fe33227f6805edab2036cbb80645cc4e2d1fa424","46d8ada1fff8d18cb197c38c7983225162599948"],"8be9dc9e17c1046a542423f69130abddef886f16":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","985e1291b5f205ff2a21385eb7092c8a513a56eb","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"762c80e29fe0c3bb83aabe2e64af6379273cec7b":["31741cf1390044e38a2ec3127cf302ba841bfd75","92212fd254551a0b1156aafc3a1a6ed1a43932ad","507e7decdf00981d09a74632ea30299a4ce6ba72"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["71387d8cb6923eb831b17a8b734608ba2e21c653"],"0936055c0eed56be3e4ae5c9db5b0e355390736a":["500867f0f15393f6b2c38c3366e414fccba04ed6"],"8f2203cb8ae87188877cfbf6ad170c5738a0aad5":["b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","8be9dc9e17c1046a542423f69130abddef886f16"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["0ad30c6a479e764150a3316e57263319775f1df2"],"438e995b4e32916f631722aab36254146830fefb":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","368714b5b6663ca71a0cba34a94e6032ccdff3f2"],"e44db636314d8ec17d54d6d28e6054fa4566e6c9":["a45bec74b98f6fc05f52770cfb425739e6563960","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee"],"4b512a6470fbb93c320e0cc8519ec0fe94efa13e":["9d153abcf92dc5329d98571a8c3035df9bd80648"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","30c8e5574b55d57947e989443dfde611646530ee","fe33227f6805edab2036cbb80645cc4e2d1fa424","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","5eb2511ababf862ea11e10761c70ee560cd84510","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","507e7decdf00981d09a74632ea30299a4ce6ba72","46d8ada1fff8d18cb197c38c7983225162599948","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}