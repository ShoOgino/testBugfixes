{"path":"lucene/analysis/common/src/java/org/apache/lucene/analysis/en/KStemmer#ityEndings().mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/en/KStemmer#ityEndings().mjava","pathOld":"modules/analysis/common/src/java/org/apache/lucene/analysis/en/KStemmer#ityEndings().mjava","sourceNew":"  /*\n   * this routine deals with -ity endings. It accepts -ability, -ibility, and\n   * -ality, even without checking the dictionary because they are so\n   * productive. The first two are mapped to -ble, and the -ity is remove for\n   * the latter\n   */\n  private void ityEndings() {\n    int old_k = k;\n    \n    if (endsIn('i', 't', 'y')) {\n      word.setLength(j + 1); /* try just removing -ity */\n      k = j;\n      if (lookup()) return;\n      word.unsafeWrite('e'); /* try removing -ity and adding -e */\n      k = j + 1;\n      if (lookup()) return;\n      word.setCharAt(j + 1, 'i');\n      word.append(\"ty\");\n      k = old_k;\n      /*\n       * the -ability and -ibility endings are highly productive, so just accept\n       * them\n       */\n      if ((j > 0) && (word.charAt(j - 1) == 'i') && (word.charAt(j) == 'l')) {\n        word.setLength(j - 1);\n        word.append(\"le\"); /* convert to -ble */\n        k = j;\n        lookup();\n        return;\n      }\n      \n      /* ditto for -ivity */\n      if ((j > 0) && (word.charAt(j - 1) == 'i') && (word.charAt(j) == 'v')) {\n        word.setLength(j + 1);\n        word.unsafeWrite('e'); /* convert to -ive */\n        k = j + 1;\n        lookup();\n        return;\n      }\n      /* ditto for -ality */\n      if ((j > 0) && (word.charAt(j - 1) == 'a') && (word.charAt(j) == 'l')) {\n        word.setLength(j + 1);\n        k = j;\n        lookup();\n        return;\n      }\n      \n      /*\n       * if the root isn't in the dictionary, and the variant *is* there, then\n       * use the variant. This allows `immunity'->`immune', but prevents\n       * `capacity'->`capac'. If neither the variant nor the root form are in\n       * the dictionary, then remove the ending as a default\n       */\n\n      if (lookup()) return;\n      \n      /* the default is to remove -ity altogether */\n      word.setLength(j + 1);\n      k = j;\n      // nolookup(), we already did it.\n      return;\n    }\n  }\n\n","sourceOld":"  /*\n   * this routine deals with -ity endings. It accepts -ability, -ibility, and\n   * -ality, even without checking the dictionary because they are so\n   * productive. The first two are mapped to -ble, and the -ity is remove for\n   * the latter\n   */\n  private void ityEndings() {\n    int old_k = k;\n    \n    if (endsIn('i', 't', 'y')) {\n      word.setLength(j + 1); /* try just removing -ity */\n      k = j;\n      if (lookup()) return;\n      word.unsafeWrite('e'); /* try removing -ity and adding -e */\n      k = j + 1;\n      if (lookup()) return;\n      word.setCharAt(j + 1, 'i');\n      word.append(\"ty\");\n      k = old_k;\n      /*\n       * the -ability and -ibility endings are highly productive, so just accept\n       * them\n       */\n      if ((j > 0) && (word.charAt(j - 1) == 'i') && (word.charAt(j) == 'l')) {\n        word.setLength(j - 1);\n        word.append(\"le\"); /* convert to -ble */\n        k = j;\n        lookup();\n        return;\n      }\n      \n      /* ditto for -ivity */\n      if ((j > 0) && (word.charAt(j - 1) == 'i') && (word.charAt(j) == 'v')) {\n        word.setLength(j + 1);\n        word.unsafeWrite('e'); /* convert to -ive */\n        k = j + 1;\n        lookup();\n        return;\n      }\n      /* ditto for -ality */\n      if ((j > 0) && (word.charAt(j - 1) == 'a') && (word.charAt(j) == 'l')) {\n        word.setLength(j + 1);\n        k = j;\n        lookup();\n        return;\n      }\n      \n      /*\n       * if the root isn't in the dictionary, and the variant *is* there, then\n       * use the variant. This allows `immunity'->`immune', but prevents\n       * `capacity'->`capac'. If neither the variant nor the root form are in\n       * the dictionary, then remove the ending as a default\n       */\n\n      if (lookup()) return;\n      \n      /* the default is to remove -ity altogether */\n      word.setLength(j + 1);\n      k = j;\n      // nolookup(), we already did it.\n      return;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}