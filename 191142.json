{"path":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","commits":[{"id":"5e5dbf4268db532969cc84ef336b9988afce9843","date":1342199436,"type":1,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand).mjava","sourceNew":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    boolean update = false;\n    for (SolrInputField sif : sdoc.values()) {\n      if (sif.getValue() instanceof Map) {\n        update = true;\n        break;\n      }\n    }\n\n    if (!update) return false;\n\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(VERSION_FIELD);\n    }\n\n    for (SolrInputField sif : sdoc.values()) {\n      Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          if (\"add\".equals(key)) {\n            oldDoc.addField( sif.getName(), fieldVal, sif.getBoost());\n          } else if (\"set\".equals(key)) {\n            oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n          } else if (\"inc\".equals(key)) {\n            SolrInputField numericField = oldDoc.get(sif.getName());\n            if (numericField == null) {\n              oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n            } else {\n              // TODO: fieldtype needs externalToObject?\n              String oldValS = numericField.getFirstValue().toString();\n              SchemaField sf = cmd.getReq().getSchema().getField(sif.getName());\n              BytesRef term = new BytesRef();\n              sf.getType().readableToIndexed(oldValS, term);\n              Object oldVal = sf.getType().toObject(sf, term);\n\n              String fieldValS = fieldVal.toString();\n              Number result;\n              if (oldVal instanceof Long) {\n                result = ((Long) oldVal).longValue() + Long.parseLong(fieldValS);\n              } else if (oldVal instanceof Float) {\n                result = ((Float) oldVal).floatValue() + Float.parseFloat(fieldValS);\n              } else if (oldVal instanceof Double) {\n                result = ((Double) oldVal).doubleValue() + Double.parseDouble(fieldValS);\n              } else {\n                // int, short, byte\n                result = ((Integer) oldVal).intValue() + Integer.parseInt(fieldValS);\n              }\n\n              oldDoc.setField(sif.getName(),  result, sif.getBoost());\n            }\n\n          }\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        oldDoc.put(sif.getName(), sif);\n      }\n\n    }\n\n    cmd.solrDoc = oldDoc;\n    return true;\n  }\n\n","sourceOld":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    boolean update = false;\n    for (SolrInputField sif : sdoc.values()) {\n      if (sif.getValue() instanceof Map) {\n        update = true;\n        break;\n      }\n    }\n\n    if (!update) return false;\n\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // not found... allow this in the future (depending on the details of the update, or if the user explicitly sets it).\n      // could also just not change anything here and let the optimistic locking throw the error\n      throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n    }\n\n    oldDoc.remove(VERSION_FIELD);\n\n    for (SolrInputField sif : sdoc.values()) {\n      Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          if (\"add\".equals(key)) {\n            oldDoc.addField( sif.getName(), fieldVal, sif.getBoost());\n          } else if (\"set\".equals(key)) {\n            oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n          } else if (\"inc\".equals(key)) {\n            SolrInputField numericField = oldDoc.get(sif.getName());\n            if (numericField == null) {\n              oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n            } else {\n              // TODO: fieldtype needs externalToObject?\n              String oldValS = numericField.getFirstValue().toString();\n              SchemaField sf = cmd.getReq().getSchema().getField(sif.getName());\n              BytesRef term = new BytesRef();\n              sf.getType().readableToIndexed(oldValS, term);\n              Object oldVal = sf.getType().toObject(sf, term);\n\n              String fieldValS = fieldVal.toString();\n              Number result;\n              if (oldVal instanceof Long) {\n                result = ((Long) oldVal).longValue() + Long.parseLong(fieldValS);\n              } else if (oldVal instanceof Float) {\n                result = ((Float) oldVal).floatValue() + Float.parseFloat(fieldValS);\n              } else if (oldVal instanceof Double) {\n                result = ((Double) oldVal).doubleValue() + Double.parseDouble(fieldValS);\n              } else {\n                // int, short, byte\n                result = ((Integer) oldVal).intValue() + Integer.parseInt(fieldValS);\n              }\n\n              oldDoc.setField(sif.getName(),  result, sif.getBoost());\n            }\n\n          }\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        oldDoc.put(sif.getName(), sif);\n      }\n\n    }\n\n    cmd.solrDoc = oldDoc;\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","pathOld":"/dev/null","sourceNew":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    boolean update = false;\n    for (SolrInputField sif : sdoc.values()) {\n      if (sif.getValue() instanceof Map) {\n        update = true;\n        break;\n      }\n    }\n\n    if (!update) return false;\n\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(VERSION_FIELD);\n    }\n\n    for (SolrInputField sif : sdoc.values()) {\n      Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          if (\"add\".equals(key)) {\n            oldDoc.addField( sif.getName(), fieldVal, sif.getBoost());\n          } else if (\"set\".equals(key)) {\n            oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n          } else if (\"inc\".equals(key)) {\n            SolrInputField numericField = oldDoc.get(sif.getName());\n            if (numericField == null) {\n              oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n            } else {\n              // TODO: fieldtype needs externalToObject?\n              String oldValS = numericField.getFirstValue().toString();\n              SchemaField sf = cmd.getReq().getSchema().getField(sif.getName());\n              BytesRef term = new BytesRef();\n              sf.getType().readableToIndexed(oldValS, term);\n              Object oldVal = sf.getType().toObject(sf, term);\n\n              String fieldValS = fieldVal.toString();\n              Number result;\n              if (oldVal instanceof Long) {\n                result = ((Long) oldVal).longValue() + Long.parseLong(fieldValS);\n              } else if (oldVal instanceof Float) {\n                result = ((Float) oldVal).floatValue() + Float.parseFloat(fieldValS);\n              } else if (oldVal instanceof Double) {\n                result = ((Double) oldVal).doubleValue() + Double.parseDouble(fieldValS);\n              } else {\n                // int, short, byte\n                result = ((Integer) oldVal).intValue() + Integer.parseInt(fieldValS);\n              }\n\n              oldDoc.setField(sif.getName(),  result, sif.getBoost());\n            }\n\n          }\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        oldDoc.put(sif.getName(), sif);\n      }\n\n    }\n\n    cmd.solrDoc = oldDoc;\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","pathOld":"/dev/null","sourceNew":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    boolean update = false;\n    for (SolrInputField sif : sdoc.values()) {\n      if (sif.getValue() instanceof Map) {\n        update = true;\n        break;\n      }\n    }\n\n    if (!update) return false;\n\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(VERSION_FIELD);\n    }\n\n    for (SolrInputField sif : sdoc.values()) {\n      Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          if (\"add\".equals(key)) {\n            oldDoc.addField( sif.getName(), fieldVal, sif.getBoost());\n          } else if (\"set\".equals(key)) {\n            oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n          } else if (\"inc\".equals(key)) {\n            SolrInputField numericField = oldDoc.get(sif.getName());\n            if (numericField == null) {\n              oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n            } else {\n              // TODO: fieldtype needs externalToObject?\n              String oldValS = numericField.getFirstValue().toString();\n              SchemaField sf = cmd.getReq().getSchema().getField(sif.getName());\n              BytesRef term = new BytesRef();\n              sf.getType().readableToIndexed(oldValS, term);\n              Object oldVal = sf.getType().toObject(sf, term);\n\n              String fieldValS = fieldVal.toString();\n              Number result;\n              if (oldVal instanceof Long) {\n                result = ((Long) oldVal).longValue() + Long.parseLong(fieldValS);\n              } else if (oldVal instanceof Float) {\n                result = ((Float) oldVal).floatValue() + Float.parseFloat(fieldValS);\n              } else if (oldVal instanceof Double) {\n                result = ((Double) oldVal).doubleValue() + Double.parseDouble(fieldValS);\n              } else {\n                // int, short, byte\n                result = ((Integer) oldVal).intValue() + Integer.parseInt(fieldValS);\n              }\n\n              oldDoc.setField(sif.getName(),  result, sif.getBoost());\n            }\n\n          }\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        oldDoc.put(sif.getName(), sif);\n      }\n\n    }\n\n    cmd.solrDoc = oldDoc;\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ab0c7114238ae604663efca0f46e65fff2a6c28","date":1351315793,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","sourceNew":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    boolean update = false;\n    for (SolrInputField sif : sdoc.values()) {\n      if (sif.getValue() instanceof Map) {\n        update = true;\n        break;\n      }\n    }\n\n    if (!update) return false;\n\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(VERSION_FIELD);\n    }\n\n    for (SolrInputField sif : sdoc.values()) {\n      Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          boolean updateField = false;\n          if (\"add\".equals(key)) {\n            updateField = true;\n            oldDoc.addField( sif.getName(), fieldVal, sif.getBoost());\n          } else if (\"set\".equals(key)) {\n            updateField = true;\n            oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n          } else if (\"inc\".equals(key)) {\n            updateField = true;\n            SolrInputField numericField = oldDoc.get(sif.getName());\n            if (numericField == null) {\n              oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n            } else {\n              // TODO: fieldtype needs externalToObject?\n              String oldValS = numericField.getFirstValue().toString();\n              SchemaField sf = cmd.getReq().getSchema().getField(sif.getName());\n              BytesRef term = new BytesRef();\n              sf.getType().readableToIndexed(oldValS, term);\n              Object oldVal = sf.getType().toObject(sf, term);\n\n              String fieldValS = fieldVal.toString();\n              Number result;\n              if (oldVal instanceof Long) {\n                result = ((Long) oldVal).longValue() + Long.parseLong(fieldValS);\n              } else if (oldVal instanceof Float) {\n                result = ((Float) oldVal).floatValue() + Float.parseFloat(fieldValS);\n              } else if (oldVal instanceof Double) {\n                result = ((Double) oldVal).doubleValue() + Double.parseDouble(fieldValS);\n              } else {\n                // int, short, byte\n                result = ((Integer) oldVal).intValue() + Integer.parseInt(fieldValS);\n              }\n\n              oldDoc.setField(sif.getName(),  result, sif.getBoost());\n            }\n\n          }\n\n          // validate that the field being modified is not the id field.\n          if (updateField && idField.getName().equals(sif.getName())) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid update of id field: \" + sif);\n          }\n\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        oldDoc.put(sif.getName(), sif);\n      }\n\n    }\n\n    cmd.solrDoc = oldDoc;\n    return true;\n  }\n\n","sourceOld":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    boolean update = false;\n    for (SolrInputField sif : sdoc.values()) {\n      if (sif.getValue() instanceof Map) {\n        update = true;\n        break;\n      }\n    }\n\n    if (!update) return false;\n\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(VERSION_FIELD);\n    }\n\n    for (SolrInputField sif : sdoc.values()) {\n      Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          if (\"add\".equals(key)) {\n            oldDoc.addField( sif.getName(), fieldVal, sif.getBoost());\n          } else if (\"set\".equals(key)) {\n            oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n          } else if (\"inc\".equals(key)) {\n            SolrInputField numericField = oldDoc.get(sif.getName());\n            if (numericField == null) {\n              oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n            } else {\n              // TODO: fieldtype needs externalToObject?\n              String oldValS = numericField.getFirstValue().toString();\n              SchemaField sf = cmd.getReq().getSchema().getField(sif.getName());\n              BytesRef term = new BytesRef();\n              sf.getType().readableToIndexed(oldValS, term);\n              Object oldVal = sf.getType().toObject(sf, term);\n\n              String fieldValS = fieldVal.toString();\n              Number result;\n              if (oldVal instanceof Long) {\n                result = ((Long) oldVal).longValue() + Long.parseLong(fieldValS);\n              } else if (oldVal instanceof Float) {\n                result = ((Float) oldVal).floatValue() + Float.parseFloat(fieldValS);\n              } else if (oldVal instanceof Double) {\n                result = ((Double) oldVal).doubleValue() + Double.parseDouble(fieldValS);\n              } else {\n                // int, short, byte\n                result = ((Integer) oldVal).intValue() + Integer.parseInt(fieldValS);\n              }\n\n              oldDoc.setField(sif.getName(),  result, sif.getBoost());\n            }\n\n          }\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        oldDoc.put(sif.getName(), sif);\n      }\n\n    }\n\n    cmd.solrDoc = oldDoc;\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f2126b84bd093fa3d921582a109a0ee578c28126","date":1351522501,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","sourceNew":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    boolean update = false;\n    for (SolrInputField sif : sdoc.values()) {\n      if (sif.getValue() instanceof Map) {\n        update = true;\n        break;\n      }\n    }\n\n    if (!update) return false;\n\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(VERSION_FIELD);\n    }\n\n    for (SolrInputField sif : sdoc.values()) {\n      Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          boolean updateField = false;\n          if (\"add\".equals(key)) {\n            updateField = true;\n            oldDoc.addField( sif.getName(), fieldVal, sif.getBoost());\n          } else if (\"set\".equals(key)) {\n            updateField = true;\n            oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n          } else if (\"inc\".equals(key)) {\n            updateField = true;\n            SolrInputField numericField = oldDoc.get(sif.getName());\n            if (numericField == null) {\n              oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n            } else {\n              // TODO: fieldtype needs externalToObject?\n              String oldValS = numericField.getFirstValue().toString();\n              SchemaField sf = cmd.getReq().getSchema().getField(sif.getName());\n              BytesRef term = new BytesRef();\n              sf.getType().readableToIndexed(oldValS, term);\n              Object oldVal = sf.getType().toObject(sf, term);\n\n              String fieldValS = fieldVal.toString();\n              Number result;\n              if (oldVal instanceof Long) {\n                result = ((Long) oldVal).longValue() + Long.parseLong(fieldValS);\n              } else if (oldVal instanceof Float) {\n                result = ((Float) oldVal).floatValue() + Float.parseFloat(fieldValS);\n              } else if (oldVal instanceof Double) {\n                result = ((Double) oldVal).doubleValue() + Double.parseDouble(fieldValS);\n              } else {\n                // int, short, byte\n                result = ((Integer) oldVal).intValue() + Integer.parseInt(fieldValS);\n              }\n\n              oldDoc.setField(sif.getName(),  result, sif.getBoost());\n            }\n\n          }\n\n          // validate that the field being modified is not the id field.\n          if (updateField && idField.getName().equals(sif.getName())) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid update of id field: \" + sif);\n          }\n\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        oldDoc.put(sif.getName(), sif);\n      }\n\n    }\n\n    cmd.solrDoc = oldDoc;\n    return true;\n  }\n\n","sourceOld":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    boolean update = false;\n    for (SolrInputField sif : sdoc.values()) {\n      if (sif.getValue() instanceof Map) {\n        update = true;\n        break;\n      }\n    }\n\n    if (!update) return false;\n\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(VERSION_FIELD);\n    }\n\n    for (SolrInputField sif : sdoc.values()) {\n      Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          if (\"add\".equals(key)) {\n            oldDoc.addField( sif.getName(), fieldVal, sif.getBoost());\n          } else if (\"set\".equals(key)) {\n            oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n          } else if (\"inc\".equals(key)) {\n            SolrInputField numericField = oldDoc.get(sif.getName());\n            if (numericField == null) {\n              oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n            } else {\n              // TODO: fieldtype needs externalToObject?\n              String oldValS = numericField.getFirstValue().toString();\n              SchemaField sf = cmd.getReq().getSchema().getField(sif.getName());\n              BytesRef term = new BytesRef();\n              sf.getType().readableToIndexed(oldValS, term);\n              Object oldVal = sf.getType().toObject(sf, term);\n\n              String fieldValS = fieldVal.toString();\n              Number result;\n              if (oldVal instanceof Long) {\n                result = ((Long) oldVal).longValue() + Long.parseLong(fieldValS);\n              } else if (oldVal instanceof Float) {\n                result = ((Float) oldVal).floatValue() + Float.parseFloat(fieldValS);\n              } else if (oldVal instanceof Double) {\n                result = ((Double) oldVal).doubleValue() + Double.parseDouble(fieldValS);\n              } else {\n                // int, short, byte\n                result = ((Integer) oldVal).intValue() + Integer.parseInt(fieldValS);\n              }\n\n              oldDoc.setField(sif.getName(),  result, sif.getBoost());\n            }\n\n          }\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        oldDoc.put(sif.getName(), sif);\n      }\n\n    }\n\n    cmd.solrDoc = oldDoc;\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e212b98d0f919993a50d5d662d73517f1f180ec2","date":1355246702,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","sourceNew":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    if (!isAtomicUpdate(cmd)) return false;\n\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(VERSION_FIELD);\n    }\n\n    for (SolrInputField sif : sdoc.values()) {\n      Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          boolean updateField = false;\n          if (\"add\".equals(key)) {\n            updateField = true;\n            oldDoc.addField( sif.getName(), fieldVal, sif.getBoost());\n          } else if (\"set\".equals(key)) {\n            updateField = true;\n            oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n          } else if (\"inc\".equals(key)) {\n            updateField = true;\n            SolrInputField numericField = oldDoc.get(sif.getName());\n            if (numericField == null) {\n              oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n            } else {\n              // TODO: fieldtype needs externalToObject?\n              String oldValS = numericField.getFirstValue().toString();\n              SchemaField sf = cmd.getReq().getSchema().getField(sif.getName());\n              BytesRef term = new BytesRef();\n              sf.getType().readableToIndexed(oldValS, term);\n              Object oldVal = sf.getType().toObject(sf, term);\n\n              String fieldValS = fieldVal.toString();\n              Number result;\n              if (oldVal instanceof Long) {\n                result = ((Long) oldVal).longValue() + Long.parseLong(fieldValS);\n              } else if (oldVal instanceof Float) {\n                result = ((Float) oldVal).floatValue() + Float.parseFloat(fieldValS);\n              } else if (oldVal instanceof Double) {\n                result = ((Double) oldVal).doubleValue() + Double.parseDouble(fieldValS);\n              } else {\n                // int, short, byte\n                result = ((Integer) oldVal).intValue() + Integer.parseInt(fieldValS);\n              }\n\n              oldDoc.setField(sif.getName(),  result, sif.getBoost());\n            }\n\n          }\n\n          // validate that the field being modified is not the id field.\n          if (updateField && idField.getName().equals(sif.getName())) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid update of id field: \" + sif);\n          }\n\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        oldDoc.put(sif.getName(), sif);\n      }\n\n    }\n\n    cmd.solrDoc = oldDoc;\n    return true;\n  }\n\n","sourceOld":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    boolean update = false;\n    for (SolrInputField sif : sdoc.values()) {\n      if (sif.getValue() instanceof Map) {\n        update = true;\n        break;\n      }\n    }\n\n    if (!update) return false;\n\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(VERSION_FIELD);\n    }\n\n    for (SolrInputField sif : sdoc.values()) {\n      Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          boolean updateField = false;\n          if (\"add\".equals(key)) {\n            updateField = true;\n            oldDoc.addField( sif.getName(), fieldVal, sif.getBoost());\n          } else if (\"set\".equals(key)) {\n            updateField = true;\n            oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n          } else if (\"inc\".equals(key)) {\n            updateField = true;\n            SolrInputField numericField = oldDoc.get(sif.getName());\n            if (numericField == null) {\n              oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n            } else {\n              // TODO: fieldtype needs externalToObject?\n              String oldValS = numericField.getFirstValue().toString();\n              SchemaField sf = cmd.getReq().getSchema().getField(sif.getName());\n              BytesRef term = new BytesRef();\n              sf.getType().readableToIndexed(oldValS, term);\n              Object oldVal = sf.getType().toObject(sf, term);\n\n              String fieldValS = fieldVal.toString();\n              Number result;\n              if (oldVal instanceof Long) {\n                result = ((Long) oldVal).longValue() + Long.parseLong(fieldValS);\n              } else if (oldVal instanceof Float) {\n                result = ((Float) oldVal).floatValue() + Float.parseFloat(fieldValS);\n              } else if (oldVal instanceof Double) {\n                result = ((Double) oldVal).doubleValue() + Double.parseDouble(fieldValS);\n              } else {\n                // int, short, byte\n                result = ((Integer) oldVal).intValue() + Integer.parseInt(fieldValS);\n              }\n\n              oldDoc.setField(sif.getName(),  result, sif.getBoost());\n            }\n\n          }\n\n          // validate that the field being modified is not the id field.\n          if (updateField && idField.getName().equals(sif.getName())) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid update of id field: \" + sif);\n          }\n\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        oldDoc.put(sif.getName(), sif);\n      }\n\n    }\n\n    cmd.solrDoc = oldDoc;\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","sourceNew":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    if (!isAtomicUpdate(cmd)) return false;\n\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(VERSION_FIELD);\n    }\n\n    for (SolrInputField sif : sdoc.values()) {\n      Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          boolean updateField = false;\n          if (\"add\".equals(key)) {\n            updateField = true;\n            oldDoc.addField( sif.getName(), fieldVal, sif.getBoost());\n          } else if (\"set\".equals(key)) {\n            updateField = true;\n            oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n          } else if (\"inc\".equals(key)) {\n            updateField = true;\n            SolrInputField numericField = oldDoc.get(sif.getName());\n            if (numericField == null) {\n              oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n            } else {\n              // TODO: fieldtype needs externalToObject?\n              String oldValS = numericField.getFirstValue().toString();\n              SchemaField sf = cmd.getReq().getSchema().getField(sif.getName());\n              BytesRef term = new BytesRef();\n              sf.getType().readableToIndexed(oldValS, term);\n              Object oldVal = sf.getType().toObject(sf, term);\n\n              String fieldValS = fieldVal.toString();\n              Number result;\n              if (oldVal instanceof Long) {\n                result = ((Long) oldVal).longValue() + Long.parseLong(fieldValS);\n              } else if (oldVal instanceof Float) {\n                result = ((Float) oldVal).floatValue() + Float.parseFloat(fieldValS);\n              } else if (oldVal instanceof Double) {\n                result = ((Double) oldVal).doubleValue() + Double.parseDouble(fieldValS);\n              } else {\n                // int, short, byte\n                result = ((Integer) oldVal).intValue() + Integer.parseInt(fieldValS);\n              }\n\n              oldDoc.setField(sif.getName(),  result, sif.getBoost());\n            }\n\n          }\n\n          // validate that the field being modified is not the id field.\n          if (updateField && idField.getName().equals(sif.getName())) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid update of id field: \" + sif);\n          }\n\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        oldDoc.put(sif.getName(), sif);\n      }\n\n    }\n\n    cmd.solrDoc = oldDoc;\n    return true;\n  }\n\n","sourceOld":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    boolean update = false;\n    for (SolrInputField sif : sdoc.values()) {\n      if (sif.getValue() instanceof Map) {\n        update = true;\n        break;\n      }\n    }\n\n    if (!update) return false;\n\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(VERSION_FIELD);\n    }\n\n    for (SolrInputField sif : sdoc.values()) {\n      Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          boolean updateField = false;\n          if (\"add\".equals(key)) {\n            updateField = true;\n            oldDoc.addField( sif.getName(), fieldVal, sif.getBoost());\n          } else if (\"set\".equals(key)) {\n            updateField = true;\n            oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n          } else if (\"inc\".equals(key)) {\n            updateField = true;\n            SolrInputField numericField = oldDoc.get(sif.getName());\n            if (numericField == null) {\n              oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n            } else {\n              // TODO: fieldtype needs externalToObject?\n              String oldValS = numericField.getFirstValue().toString();\n              SchemaField sf = cmd.getReq().getSchema().getField(sif.getName());\n              BytesRef term = new BytesRef();\n              sf.getType().readableToIndexed(oldValS, term);\n              Object oldVal = sf.getType().toObject(sf, term);\n\n              String fieldValS = fieldVal.toString();\n              Number result;\n              if (oldVal instanceof Long) {\n                result = ((Long) oldVal).longValue() + Long.parseLong(fieldValS);\n              } else if (oldVal instanceof Float) {\n                result = ((Float) oldVal).floatValue() + Float.parseFloat(fieldValS);\n              } else if (oldVal instanceof Double) {\n                result = ((Double) oldVal).doubleValue() + Double.parseDouble(fieldValS);\n              } else {\n                // int, short, byte\n                result = ((Integer) oldVal).intValue() + Integer.parseInt(fieldValS);\n              }\n\n              oldDoc.setField(sif.getName(),  result, sif.getBoost());\n            }\n\n          }\n\n          // validate that the field being modified is not the id field.\n          if (updateField && idField.getName().equals(sif.getName())) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid update of id field: \" + sif);\n          }\n\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        oldDoc.put(sif.getName(), sif);\n      }\n\n    }\n\n    cmd.solrDoc = oldDoc;\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"08970e5b8411182a29412c177eff67ec1110095b","date":1366640815,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","sourceNew":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    if (!isAtomicUpdate(cmd)) return false;\n\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(VERSION_FIELD);\n    }\n\n    IndexSchema schema = cmd.getReq().getSchema();\n    for (SolrInputField sif : sdoc.values()) {\n      Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          boolean updateField = false;\n          if (\"add\".equals(key)) {\n            updateField = true;\n            oldDoc.addField( sif.getName(), fieldVal, sif.getBoost());\n          } else if (\"set\".equals(key)) {\n            updateField = true;\n            oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n          } else if (\"inc\".equals(key)) {\n            updateField = true;\n            SolrInputField numericField = oldDoc.get(sif.getName());\n            if (numericField == null) {\n              oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n            } else {\n              // TODO: fieldtype needs externalToObject?\n              String oldValS = numericField.getFirstValue().toString();\n              SchemaField sf = schema.getField(sif.getName());\n              BytesRef term = new BytesRef();\n              sf.getType().readableToIndexed(oldValS, term);\n              Object oldVal = sf.getType().toObject(sf, term);\n\n              String fieldValS = fieldVal.toString();\n              Number result;\n              if (oldVal instanceof Long) {\n                result = ((Long) oldVal).longValue() + Long.parseLong(fieldValS);\n              } else if (oldVal instanceof Float) {\n                result = ((Float) oldVal).floatValue() + Float.parseFloat(fieldValS);\n              } else if (oldVal instanceof Double) {\n                result = ((Double) oldVal).doubleValue() + Double.parseDouble(fieldValS);\n              } else {\n                // int, short, byte\n                result = ((Integer) oldVal).intValue() + Integer.parseInt(fieldValS);\n              }\n\n              oldDoc.setField(sif.getName(),  result, sif.getBoost());\n            }\n\n          }\n\n          // validate that the field being modified is not the id field.\n          if (updateField && idField.getName().equals(sif.getName())) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid update of id field: \" + sif);\n          }\n\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        oldDoc.put(sif.getName(), sif);\n      }\n\n    }\n\n    cmd.solrDoc = oldDoc;\n    return true;\n  }\n\n","sourceOld":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    if (!isAtomicUpdate(cmd)) return false;\n\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(VERSION_FIELD);\n    }\n\n    for (SolrInputField sif : sdoc.values()) {\n      Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          boolean updateField = false;\n          if (\"add\".equals(key)) {\n            updateField = true;\n            oldDoc.addField( sif.getName(), fieldVal, sif.getBoost());\n          } else if (\"set\".equals(key)) {\n            updateField = true;\n            oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n          } else if (\"inc\".equals(key)) {\n            updateField = true;\n            SolrInputField numericField = oldDoc.get(sif.getName());\n            if (numericField == null) {\n              oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n            } else {\n              // TODO: fieldtype needs externalToObject?\n              String oldValS = numericField.getFirstValue().toString();\n              SchemaField sf = cmd.getReq().getSchema().getField(sif.getName());\n              BytesRef term = new BytesRef();\n              sf.getType().readableToIndexed(oldValS, term);\n              Object oldVal = sf.getType().toObject(sf, term);\n\n              String fieldValS = fieldVal.toString();\n              Number result;\n              if (oldVal instanceof Long) {\n                result = ((Long) oldVal).longValue() + Long.parseLong(fieldValS);\n              } else if (oldVal instanceof Float) {\n                result = ((Float) oldVal).floatValue() + Float.parseFloat(fieldValS);\n              } else if (oldVal instanceof Double) {\n                result = ((Double) oldVal).doubleValue() + Double.parseDouble(fieldValS);\n              } else {\n                // int, short, byte\n                result = ((Integer) oldVal).intValue() + Integer.parseInt(fieldValS);\n              }\n\n              oldDoc.setField(sif.getName(),  result, sif.getBoost());\n            }\n\n          }\n\n          // validate that the field being modified is not the id field.\n          if (updateField && idField.getName().equals(sif.getName())) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid update of id field: \" + sif);\n          }\n\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        oldDoc.put(sif.getName(), sif);\n      }\n\n    }\n\n    cmd.solrDoc = oldDoc;\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3aa8a7a6dfbdba53bcf332c8a2154c3426a932d7","date":1397774798,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","sourceNew":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    if (!isAtomicUpdate(cmd)) return false;\n\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(VERSION_FIELD);\n    }\n\n    IndexSchema schema = cmd.getReq().getSchema();\n    for (SolrInputField sif : sdoc.values()) {\n     Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          boolean updateField = false;\n          switch (key) {\n            case \"add\":\n              updateField = true;\n              oldDoc.addField(sif.getName(), fieldVal, sif.getBoost());\n              break;\n            case \"set\":\n              updateField = true;\n              oldDoc.setField(sif.getName(), fieldVal, sif.getBoost());\n              break;\n            case \"remove\":\n              updateField = true;\n              doRemove(oldDoc, sif, fieldVal);\n              break;\n            case \"inc\":\n              updateField = true;\n              doInc(oldDoc, schema, sif, fieldVal);\n              break;\n            default:\n              //Perhaps throw an error here instead?\n              log.warn(\"Unknown operation for the an atomic update, operation ignored: \" + key);\n              break;\n          }\n          // validate that the field being modified is not the id field.\n          if (updateField && idField.getName().equals(sif.getName())) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid update of id field: \" + sif);\n          }\n\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        oldDoc.put(sif.getName(), sif);\n      }\n\n    }\n\n    cmd.solrDoc = oldDoc;\n    return true;\n  }\n\n","sourceOld":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    if (!isAtomicUpdate(cmd)) return false;\n\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(VERSION_FIELD);\n    }\n\n    IndexSchema schema = cmd.getReq().getSchema();\n    for (SolrInputField sif : sdoc.values()) {\n      Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          boolean updateField = false;\n          if (\"add\".equals(key)) {\n            updateField = true;\n            oldDoc.addField( sif.getName(), fieldVal, sif.getBoost());\n          } else if (\"set\".equals(key)) {\n            updateField = true;\n            oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n          } else if (\"inc\".equals(key)) {\n            updateField = true;\n            SolrInputField numericField = oldDoc.get(sif.getName());\n            if (numericField == null) {\n              oldDoc.setField(sif.getName(),  fieldVal, sif.getBoost());\n            } else {\n              // TODO: fieldtype needs externalToObject?\n              String oldValS = numericField.getFirstValue().toString();\n              SchemaField sf = schema.getField(sif.getName());\n              BytesRef term = new BytesRef();\n              sf.getType().readableToIndexed(oldValS, term);\n              Object oldVal = sf.getType().toObject(sf, term);\n\n              String fieldValS = fieldVal.toString();\n              Number result;\n              if (oldVal instanceof Long) {\n                result = ((Long) oldVal).longValue() + Long.parseLong(fieldValS);\n              } else if (oldVal instanceof Float) {\n                result = ((Float) oldVal).floatValue() + Float.parseFloat(fieldValS);\n              } else if (oldVal instanceof Double) {\n                result = ((Double) oldVal).doubleValue() + Double.parseDouble(fieldValS);\n              } else {\n                // int, short, byte\n                result = ((Integer) oldVal).intValue() + Integer.parseInt(fieldValS);\n              }\n\n              oldDoc.setField(sif.getName(),  result, sif.getBoost());\n            }\n\n          }\n\n          // validate that the field being modified is not the id field.\n          if (updateField && idField.getName().equals(sif.getName())) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid update of id field: \" + sif);\n          }\n\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        oldDoc.put(sif.getName(), sif);\n      }\n\n    }\n\n    cmd.solrDoc = oldDoc;\n    return true;\n  }\n\n","bugFix":null,"bugIntro":["1166b183ba6d2f30d8660b254c6a8255505a44c3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1166b183ba6d2f30d8660b254c6a8255505a44c3","date":1413452503,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","sourceNew":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    if (!isAtomicUpdate(cmd)) return false;\n\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(VERSION_FIELD);\n    }\n\n    IndexSchema schema = cmd.getReq().getSchema();\n    for (SolrInputField sif : sdoc.values()) {\n     Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          boolean updateField = false;\n          switch (key) {\n            case \"add\":\n              updateField = true;\n              oldDoc.addField(sif.getName(), fieldVal, sif.getBoost());\n              break;\n            case \"set\":\n              updateField = true;\n              oldDoc.setField(sif.getName(), fieldVal, sif.getBoost());\n              break;\n            case \"remove\":\n              updateField = true;\n              doRemove(oldDoc, sif, fieldVal, schema);\n              break;\n            case \"inc\":\n              updateField = true;\n              doInc(oldDoc, schema, sif, fieldVal);\n              break;\n            default:\n              //Perhaps throw an error here instead?\n              log.warn(\"Unknown operation for the an atomic update, operation ignored: \" + key);\n              break;\n          }\n          // validate that the field being modified is not the id field.\n          if (updateField && idField.getName().equals(sif.getName())) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid update of id field: \" + sif);\n          }\n\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        oldDoc.put(sif.getName(), sif);\n      }\n\n    }\n\n    cmd.solrDoc = oldDoc;\n    return true;\n  }\n\n","sourceOld":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    if (!isAtomicUpdate(cmd)) return false;\n\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(VERSION_FIELD);\n    }\n\n    IndexSchema schema = cmd.getReq().getSchema();\n    for (SolrInputField sif : sdoc.values()) {\n     Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          boolean updateField = false;\n          switch (key) {\n            case \"add\":\n              updateField = true;\n              oldDoc.addField(sif.getName(), fieldVal, sif.getBoost());\n              break;\n            case \"set\":\n              updateField = true;\n              oldDoc.setField(sif.getName(), fieldVal, sif.getBoost());\n              break;\n            case \"remove\":\n              updateField = true;\n              doRemove(oldDoc, sif, fieldVal);\n              break;\n            case \"inc\":\n              updateField = true;\n              doInc(oldDoc, schema, sif, fieldVal);\n              break;\n            default:\n              //Perhaps throw an error here instead?\n              log.warn(\"Unknown operation for the an atomic update, operation ignored: \" + key);\n              break;\n          }\n          // validate that the field being modified is not the id field.\n          if (updateField && idField.getName().equals(sif.getName())) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid update of id field: \" + sif);\n          }\n\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        oldDoc.put(sif.getName(), sif);\n      }\n\n    }\n\n    cmd.solrDoc = oldDoc;\n    return true;\n  }\n\n","bugFix":["3aa8a7a6dfbdba53bcf332c8a2154c3426a932d7"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84","date":1413458798,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","sourceNew":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    if (!isAtomicUpdate(cmd)) return false;\n\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(VERSION_FIELD);\n    }\n\n    IndexSchema schema = cmd.getReq().getSchema();\n    for (SolrInputField sif : sdoc.values()) {\n     Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          boolean updateField = false;\n          switch (key) {\n            case \"add\":\n              updateField = true;\n              oldDoc.addField(sif.getName(), fieldVal, sif.getBoost());\n              break;\n            case \"set\":\n              updateField = true;\n              oldDoc.setField(sif.getName(), fieldVal, sif.getBoost());\n              break;\n            case \"remove\":\n              updateField = true;\n              doRemove(oldDoc, sif, fieldVal, schema);\n              break;\n            case \"inc\":\n              updateField = true;\n              doInc(oldDoc, schema, sif, fieldVal);\n              break;\n            default:\n              //Perhaps throw an error here instead?\n              log.warn(\"Unknown operation for the an atomic update, operation ignored: \" + key);\n              break;\n          }\n          // validate that the field being modified is not the id field.\n          if (updateField && idField.getName().equals(sif.getName())) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid update of id field: \" + sif);\n          }\n\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        oldDoc.put(sif.getName(), sif);\n      }\n\n    }\n\n    cmd.solrDoc = oldDoc;\n    return true;\n  }\n\n","sourceOld":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    if (!isAtomicUpdate(cmd)) return false;\n\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(VERSION_FIELD);\n    }\n\n    IndexSchema schema = cmd.getReq().getSchema();\n    for (SolrInputField sif : sdoc.values()) {\n     Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          boolean updateField = false;\n          switch (key) {\n            case \"add\":\n              updateField = true;\n              oldDoc.addField(sif.getName(), fieldVal, sif.getBoost());\n              break;\n            case \"set\":\n              updateField = true;\n              oldDoc.setField(sif.getName(), fieldVal, sif.getBoost());\n              break;\n            case \"remove\":\n              updateField = true;\n              doRemove(oldDoc, sif, fieldVal);\n              break;\n            case \"inc\":\n              updateField = true;\n              doInc(oldDoc, schema, sif, fieldVal);\n              break;\n            default:\n              //Perhaps throw an error here instead?\n              log.warn(\"Unknown operation for the an atomic update, operation ignored: \" + key);\n              break;\n          }\n          // validate that the field being modified is not the id field.\n          if (updateField && idField.getName().equals(sif.getName())) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid update of id field: \" + sif);\n          }\n\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        oldDoc.put(sif.getName(), sif);\n      }\n\n    }\n\n    cmd.solrDoc = oldDoc;\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"92cd1849f2fc9035639005768ae063a253af7aae","date":1413758731,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","sourceNew":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    if (!isAtomicUpdate(cmd)) return false;\n\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(VERSION_FIELD);\n    }\n\n    IndexSchema schema = cmd.getReq().getSchema();\n    for (SolrInputField sif : sdoc.values()) {\n     Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          boolean updateField = false;\n          switch (key) {\n            case \"add\":\n              updateField = true;\n              oldDoc.addField(sif.getName(), fieldVal, sif.getBoost());\n              break;\n            case \"set\":\n              updateField = true;\n              oldDoc.setField(sif.getName(), fieldVal, sif.getBoost());\n              break;\n            case \"remove\":\n              updateField = true;\n              doRemove(oldDoc, sif, fieldVal, schema);\n              break;\n            case \"removeregex\":\n              updateField = true;\n              doRemoveRegex(oldDoc, sif, fieldVal);\n              break;\n            case \"inc\":\n              updateField = true;\n              doInc(oldDoc, schema, sif, fieldVal);\n              break;\n            default:\n              //Perhaps throw an error here instead?\n              log.warn(\"Unknown operation for the an atomic update, operation ignored: \" + key);\n              break;\n          }\n          // validate that the field being modified is not the id field.\n          if (updateField && idField.getName().equals(sif.getName())) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid update of id field: \" + sif);\n          }\n\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        oldDoc.put(sif.getName(), sif);\n      }\n\n    }\n\n    cmd.solrDoc = oldDoc;\n    return true;\n  }\n\n","sourceOld":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    if (!isAtomicUpdate(cmd)) return false;\n\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(VERSION_FIELD);\n    }\n\n    IndexSchema schema = cmd.getReq().getSchema();\n    for (SolrInputField sif : sdoc.values()) {\n     Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          boolean updateField = false;\n          switch (key) {\n            case \"add\":\n              updateField = true;\n              oldDoc.addField(sif.getName(), fieldVal, sif.getBoost());\n              break;\n            case \"set\":\n              updateField = true;\n              oldDoc.setField(sif.getName(), fieldVal, sif.getBoost());\n              break;\n            case \"remove\":\n              updateField = true;\n              doRemove(oldDoc, sif, fieldVal, schema);\n              break;\n            case \"inc\":\n              updateField = true;\n              doInc(oldDoc, schema, sif, fieldVal);\n              break;\n            default:\n              //Perhaps throw an error here instead?\n              log.warn(\"Unknown operation for the an atomic update, operation ignored: \" + key);\n              break;\n          }\n          // validate that the field being modified is not the id field.\n          if (updateField && idField.getName().equals(sif.getName())) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid update of id field: \" + sif);\n          }\n\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        oldDoc.put(sif.getName(), sif);\n      }\n\n    }\n\n    cmd.solrDoc = oldDoc;\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0a22eafe3f72a4c2945eaad9547e6c78816978f4","date":1413956657,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","sourceNew":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    if (!isAtomicUpdate(cmd)) return false;\n\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(VERSION_FIELD);\n    }\n\n    IndexSchema schema = cmd.getReq().getSchema();\n    for (SolrInputField sif : sdoc.values()) {\n     Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          boolean updateField = false;\n          switch (key) {\n            case \"add\":\n              updateField = true;\n              oldDoc.addField(sif.getName(), fieldVal, sif.getBoost());\n              break;\n            case \"set\":\n              updateField = true;\n              oldDoc.setField(sif.getName(), fieldVal, sif.getBoost());\n              break;\n            case \"remove\":\n              updateField = true;\n              doRemove(oldDoc, sif, fieldVal, schema);\n              break;\n            case \"removeregex\":\n              updateField = true;\n              doRemoveRegex(oldDoc, sif, fieldVal);\n              break;\n            case \"inc\":\n              updateField = true;\n              doInc(oldDoc, schema, sif, fieldVal);\n              break;\n            default:\n              //Perhaps throw an error here instead?\n              log.warn(\"Unknown operation for the an atomic update, operation ignored: \" + key);\n              break;\n          }\n          // validate that the field being modified is not the id field.\n          if (updateField && idField.getName().equals(sif.getName())) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid update of id field: \" + sif);\n          }\n\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        oldDoc.put(sif.getName(), sif);\n      }\n\n    }\n\n    cmd.solrDoc = oldDoc;\n    return true;\n  }\n\n","sourceOld":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    if (!isAtomicUpdate(cmd)) return false;\n\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(VERSION_FIELD);\n    }\n\n    IndexSchema schema = cmd.getReq().getSchema();\n    for (SolrInputField sif : sdoc.values()) {\n     Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          boolean updateField = false;\n          switch (key) {\n            case \"add\":\n              updateField = true;\n              oldDoc.addField(sif.getName(), fieldVal, sif.getBoost());\n              break;\n            case \"set\":\n              updateField = true;\n              oldDoc.setField(sif.getName(), fieldVal, sif.getBoost());\n              break;\n            case \"remove\":\n              updateField = true;\n              doRemove(oldDoc, sif, fieldVal, schema);\n              break;\n            case \"inc\":\n              updateField = true;\n              doInc(oldDoc, schema, sif, fieldVal);\n              break;\n            default:\n              //Perhaps throw an error here instead?\n              log.warn(\"Unknown operation for the an atomic update, operation ignored: \" + key);\n              break;\n          }\n          // validate that the field being modified is not the id field.\n          if (updateField && idField.getName().equals(sif.getName())) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid update of id field: \" + sif);\n          }\n\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        oldDoc.put(sif.getName(), sif);\n      }\n\n    }\n\n    cmd.solrDoc = oldDoc;\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2d3b450958a83a29a16e492fbff9d094a9a571b6","date":1421525067,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","sourceNew":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    if (!AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) return false;\n\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(VERSION_FIELD);\n    }\n    \n\n    cmd.solrDoc = docMerger.merge(sdoc, oldDoc);\n    return true;\n  }\n\n","sourceOld":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    if (!isAtomicUpdate(cmd)) return false;\n\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(VERSION_FIELD);\n    }\n\n    IndexSchema schema = cmd.getReq().getSchema();\n    for (SolrInputField sif : sdoc.values()) {\n     Object val = sif.getValue();\n      if (val instanceof Map) {\n        for (Entry<String,Object> entry : ((Map<String,Object>) val).entrySet()) {\n          String key = entry.getKey();\n          Object fieldVal = entry.getValue();\n          boolean updateField = false;\n          switch (key) {\n            case \"add\":\n              updateField = true;\n              oldDoc.addField(sif.getName(), fieldVal, sif.getBoost());\n              break;\n            case \"set\":\n              updateField = true;\n              oldDoc.setField(sif.getName(), fieldVal, sif.getBoost());\n              break;\n            case \"remove\":\n              updateField = true;\n              doRemove(oldDoc, sif, fieldVal, schema);\n              break;\n            case \"removeregex\":\n              updateField = true;\n              doRemoveRegex(oldDoc, sif, fieldVal);\n              break;\n            case \"inc\":\n              updateField = true;\n              doInc(oldDoc, schema, sif, fieldVal);\n              break;\n            default:\n              //Perhaps throw an error here instead?\n              log.warn(\"Unknown operation for the an atomic update, operation ignored: \" + key);\n              break;\n          }\n          // validate that the field being modified is not the id field.\n          if (updateField && idField.getName().equals(sif.getName())) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid update of id field: \" + sif);\n          }\n\n        }\n      } else {\n        // normal fields are treated as a \"set\"\n        oldDoc.put(sif.getName(), sif);\n      }\n\n    }\n\n    cmd.solrDoc = oldDoc;\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"415bbbe7da8065dd3c477bdc3c703c6425622998","date":1485393793,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","sourceNew":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    if (!AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) return false;\n\n    Set<String> inPlaceUpdatedFields = AtomicUpdateDocumentMerger.computeInPlaceUpdatableFields(cmd);\n    if (inPlaceUpdatedFields.size() > 0) { // non-empty means this is suitable for in-place updates\n      if (docMerger.doInPlaceUpdateMerge(cmd, inPlaceUpdatedFields)) {\n        return true;\n      } else {\n        // in-place update failed, so fall through and re-try the same with a full atomic update\n      }\n    }\n    \n    // full (non-inplace) atomic update\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(VERSION_FIELD);\n    }\n\n\n    cmd.solrDoc = docMerger.merge(sdoc, oldDoc);\n    return true;\n  }\n\n","sourceOld":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    if (!AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) return false;\n\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(VERSION_FIELD);\n    }\n    \n\n    cmd.solrDoc = docMerger.merge(sdoc, oldDoc);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"598b5d23aa7c9732bf473c21a9cd309c44599394","date":1485530378,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","sourceNew":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    if (!AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) return false;\n\n    Set<String> inPlaceUpdatedFields = AtomicUpdateDocumentMerger.computeInPlaceUpdatableFields(cmd);\n    if (inPlaceUpdatedFields.size() > 0) { // non-empty means this is suitable for in-place updates\n      if (docMerger.doInPlaceUpdateMerge(cmd, inPlaceUpdatedFields)) {\n        return true;\n      } else {\n        // in-place update failed, so fall through and re-try the same with a full atomic update\n      }\n    }\n    \n    // full (non-inplace) atomic update\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(VERSION_FIELD);\n    }\n\n\n    cmd.solrDoc = docMerger.merge(sdoc, oldDoc);\n    return true;\n  }\n\n","sourceOld":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    if (!AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) return false;\n\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(VERSION_FIELD);\n    }\n    \n\n    cmd.solrDoc = docMerger.merge(sdoc, oldDoc);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6d2dadc1f5ca8703d8659f4964961f9967935d75","date":1490231750,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","sourceNew":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    if (!AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) return false;\n\n    Set<String> inPlaceUpdatedFields = AtomicUpdateDocumentMerger.computeInPlaceUpdatableFields(cmd);\n    if (inPlaceUpdatedFields.size() > 0) { // non-empty means this is suitable for in-place updates\n      if (docMerger.doInPlaceUpdateMerge(cmd, inPlaceUpdatedFields)) {\n        return true;\n      } else {\n        // in-place update failed, so fall through and re-try the same with a full atomic update\n      }\n    }\n    \n    // full (non-inplace) atomic update\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(CommonParams.VERSION_FIELD);\n    }\n\n\n    cmd.solrDoc = docMerger.merge(sdoc, oldDoc);\n    return true;\n  }\n\n","sourceOld":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    if (!AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) return false;\n\n    Set<String> inPlaceUpdatedFields = AtomicUpdateDocumentMerger.computeInPlaceUpdatableFields(cmd);\n    if (inPlaceUpdatedFields.size() > 0) { // non-empty means this is suitable for in-place updates\n      if (docMerger.doInPlaceUpdateMerge(cmd, inPlaceUpdatedFields)) {\n        return true;\n      } else {\n        // in-place update failed, so fall through and re-try the same with a full atomic update\n      }\n    }\n    \n    // full (non-inplace) atomic update\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(VERSION_FIELD);\n    }\n\n\n    cmd.solrDoc = docMerger.merge(sdoc, oldDoc);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e5fa6615014cd2288fe930f8c8bb726f9504961d","date":1490280013,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","sourceNew":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    if (!AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) return false;\n\n    Set<String> inPlaceUpdatedFields = AtomicUpdateDocumentMerger.computeInPlaceUpdatableFields(cmd);\n    if (inPlaceUpdatedFields.size() > 0) { // non-empty means this is suitable for in-place updates\n      if (docMerger.doInPlaceUpdateMerge(cmd, inPlaceUpdatedFields)) {\n        return true;\n      } else {\n        // in-place update failed, so fall through and re-try the same with a full atomic update\n      }\n    }\n    \n    // full (non-inplace) atomic update\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(CommonParams.VERSION_FIELD);\n    }\n\n\n    cmd.solrDoc = docMerger.merge(sdoc, oldDoc);\n    return true;\n  }\n\n","sourceOld":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    if (!AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) return false;\n\n    Set<String> inPlaceUpdatedFields = AtomicUpdateDocumentMerger.computeInPlaceUpdatableFields(cmd);\n    if (inPlaceUpdatedFields.size() > 0) { // non-empty means this is suitable for in-place updates\n      if (docMerger.doInPlaceUpdateMerge(cmd, inPlaceUpdatedFields)) {\n        return true;\n      } else {\n        // in-place update failed, so fall through and re-try the same with a full atomic update\n      }\n    }\n    \n    // full (non-inplace) atomic update\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(VERSION_FIELD);\n    }\n\n\n    cmd.solrDoc = docMerger.merge(sdoc, oldDoc);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"07749612bed4eb54dd05255c1434c301133310c1","date":1554879779,"type":3,"author":"Moshe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","sourceNew":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    if (!AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) return false;\n\n    Set<String> inPlaceUpdatedFields = AtomicUpdateDocumentMerger.computeInPlaceUpdatableFields(cmd);\n    if (inPlaceUpdatedFields.size() > 0) { // non-empty means this is suitable for in-place updates\n      if (docMerger.doInPlaceUpdateMerge(cmd, inPlaceUpdatedFields)) {\n        return true;\n      } else {\n        // in-place update failed, so fall through and re-try the same with a full atomic update\n      }\n    }\n    \n    // full (non-inplace) atomic update\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldRootDocWithChildren = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id, RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN);\n\n    if (oldRootDocWithChildren == null) {\n      if (versionOnUpdate > 0) {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      } else if (req.getParams().get(ShardParams._ROUTE_) != null) {\n        // the specified document could not be found in this shard\n        // and was explicitly routed using _route_\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find document \" + idField.getName() + \":\" + id +\n                \", perhaps the wrong \\\"_route_\\\" param was supplied\");\n      }\n    } else {\n      oldRootDocWithChildren.remove(CommonParams.VERSION_FIELD);\n    }\n\n\n    SolrInputDocument mergedDoc;\n    if(idField == null || oldRootDocWithChildren == null) {\n      // create a new doc by default if an old one wasn't found\n      mergedDoc = docMerger.merge(sdoc, new SolrInputDocument());\n    } else {\n      if(req.getSchema().savesChildDocRelations() &&\n          !sdoc.getField(idField.getName()).getFirstValue().toString()\n              .equals((String) oldRootDocWithChildren.getFieldValue(IndexSchema.ROOT_FIELD_NAME))) {\n        // this is an update where the updated doc is not the root document\n        SolrInputDocument sdocWithChildren = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(),\n            id, RealTimeGetComponent.Resolution.DOC_WITH_CHILDREN);\n        mergedDoc = docMerger.mergeChildDoc(sdoc, oldRootDocWithChildren, sdocWithChildren);\n      } else {\n        mergedDoc = docMerger.merge(sdoc, oldRootDocWithChildren);\n      }\n    }\n    cmd.solrDoc = mergedDoc;\n    return true;\n  }\n\n","sourceOld":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    if (!AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) return false;\n\n    Set<String> inPlaceUpdatedFields = AtomicUpdateDocumentMerger.computeInPlaceUpdatableFields(cmd);\n    if (inPlaceUpdatedFields.size() > 0) { // non-empty means this is suitable for in-place updates\n      if (docMerger.doInPlaceUpdateMerge(cmd, inPlaceUpdatedFields)) {\n        return true;\n      } else {\n        // in-place update failed, so fall through and re-try the same with a full atomic update\n      }\n    }\n    \n    // full (non-inplace) atomic update\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(CommonParams.VERSION_FIELD);\n    }\n\n\n    cmd.solrDoc = docMerger.merge(sdoc, oldDoc);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":["817fc4762cd649397b27305970dad27295735f3a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"817fc4762cd649397b27305970dad27295735f3a","date":1561046362,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","sourceNew":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    if (!AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) return false;\n\n    Set<String> inPlaceUpdatedFields = AtomicUpdateDocumentMerger.computeInPlaceUpdatableFields(cmd);\n    if (inPlaceUpdatedFields.size() > 0) { // non-empty means this is suitable for in-place updates\n      if (docMerger.doInPlaceUpdateMerge(cmd, inPlaceUpdatedFields)) {\n        return true;\n      } else {\n        // in-place update failed, so fall through and re-try the same with a full atomic update\n      }\n    }\n    \n    // full (non-inplace) atomic update\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    BytesRef idBytes = cmd.getIndexedId();\n    String idString = cmd.getPrintableId();\n    SolrInputDocument oldRootDocWithChildren = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), idBytes, RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN);\n\n    if (oldRootDocWithChildren == null) {\n      if (versionOnUpdate > 0) {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + idString);\n      } else if (req.getParams().get(ShardParams._ROUTE_) != null) {\n        // the specified document could not be found in this shard\n        // and was explicitly routed using _route_\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find document id=\" + idString +\n                \", perhaps the wrong \\\"_route_\\\" param was supplied\");\n      }\n    } else {\n      oldRootDocWithChildren.remove(CommonParams.VERSION_FIELD);\n    }\n\n\n    SolrInputDocument mergedDoc;\n    if(idField == null || oldRootDocWithChildren == null) {\n      // create a new doc by default if an old one wasn't found\n      mergedDoc = docMerger.merge(sdoc, new SolrInputDocument());\n    } else {\n      String oldRootDocRootFieldVal = (String) oldRootDocWithChildren.getFieldValue(IndexSchema.ROOT_FIELD_NAME);\n      if(req.getSchema().savesChildDocRelations() && oldRootDocRootFieldVal != null &&\n          !idString.equals(oldRootDocRootFieldVal)) {\n        // this is an update where the updated doc is not the root document\n        SolrInputDocument sdocWithChildren = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(),\n            idBytes, RealTimeGetComponent.Resolution.DOC_WITH_CHILDREN);\n        mergedDoc = docMerger.mergeChildDoc(sdoc, oldRootDocWithChildren, sdocWithChildren);\n      } else {\n        mergedDoc = docMerger.merge(sdoc, oldRootDocWithChildren);\n      }\n    }\n    cmd.solrDoc = mergedDoc;\n    return true;\n  }\n\n","sourceOld":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    if (!AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) return false;\n\n    Set<String> inPlaceUpdatedFields = AtomicUpdateDocumentMerger.computeInPlaceUpdatableFields(cmd);\n    if (inPlaceUpdatedFields.size() > 0) { // non-empty means this is suitable for in-place updates\n      if (docMerger.doInPlaceUpdateMerge(cmd, inPlaceUpdatedFields)) {\n        return true;\n      } else {\n        // in-place update failed, so fall through and re-try the same with a full atomic update\n      }\n    }\n    \n    // full (non-inplace) atomic update\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldRootDocWithChildren = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id, RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN);\n\n    if (oldRootDocWithChildren == null) {\n      if (versionOnUpdate > 0) {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      } else if (req.getParams().get(ShardParams._ROUTE_) != null) {\n        // the specified document could not be found in this shard\n        // and was explicitly routed using _route_\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find document \" + idField.getName() + \":\" + id +\n                \", perhaps the wrong \\\"_route_\\\" param was supplied\");\n      }\n    } else {\n      oldRootDocWithChildren.remove(CommonParams.VERSION_FIELD);\n    }\n\n\n    SolrInputDocument mergedDoc;\n    if(idField == null || oldRootDocWithChildren == null) {\n      // create a new doc by default if an old one wasn't found\n      mergedDoc = docMerger.merge(sdoc, new SolrInputDocument());\n    } else {\n      if(req.getSchema().savesChildDocRelations() &&\n          !sdoc.getField(idField.getName()).getFirstValue().toString()\n              .equals((String) oldRootDocWithChildren.getFieldValue(IndexSchema.ROOT_FIELD_NAME))) {\n        // this is an update where the updated doc is not the root document\n        SolrInputDocument sdocWithChildren = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(),\n            id, RealTimeGetComponent.Resolution.DOC_WITH_CHILDREN);\n        mergedDoc = docMerger.mergeChildDoc(sdoc, oldRootDocWithChildren, sdocWithChildren);\n      } else {\n        mergedDoc = docMerger.merge(sdoc, oldRootDocWithChildren);\n      }\n    }\n    cmd.solrDoc = mergedDoc;\n    return true;\n  }\n\n","bugFix":["07749612bed4eb54dd05255c1434c301133310c1","1bea3922196318026c4274f2013416acb60c691e","5e5dbf4268db532969cc84ef336b9988afce9843"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2cf7236e10f20245f085d633e82f01bb27a974e0","date":1567739815,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#getUpdatedDocument(AddUpdateCommand,long).mjava","sourceNew":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    if (!AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) return false;\n\n    Set<String> inPlaceUpdatedFields = AtomicUpdateDocumentMerger.computeInPlaceUpdatableFields(cmd);\n    if (inPlaceUpdatedFields.size() > 0) { // non-empty means this is suitable for in-place updates\n      if (docMerger.doInPlaceUpdateMerge(cmd, inPlaceUpdatedFields)) {\n        return true;\n      } else {\n        // in-place update failed, so fall through and re-try the same with a full atomic update\n      }\n    }\n    \n    // full (non-inplace) atomic update\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    BytesRef idBytes = cmd.getIndexedId();\n    String idString = cmd.getPrintableId();\n    SolrInputDocument oldRootDocWithChildren = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), idBytes, RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN);\n\n    if (oldRootDocWithChildren == null) {\n      if (versionOnUpdate > 0) {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + idString);\n      } else if (req.getParams().get(ShardParams._ROUTE_) != null) {\n        // the specified document could not be found in this shard\n        // and was explicitly routed using _route_\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find document id=\" + idString +\n                \", perhaps the wrong \\\"_route_\\\" param was supplied\");\n      }\n    } else {\n      oldRootDocWithChildren.remove(CommonParams.VERSION_FIELD);\n    }\n\n\n    SolrInputDocument mergedDoc;\n    if(idField == null || oldRootDocWithChildren == null) {\n      // create a new doc by default if an old one wasn't found\n      mergedDoc = docMerger.merge(sdoc, new SolrInputDocument());\n    } else {\n      // Safety check: don't allow an update to an existing doc that has children, unless we actually support this.\n      if (req.getSchema().isUsableForChildDocs() // however, next line we see it doesn't support child docs\n          && req.getSchema().supportsPartialUpdatesOfChildDocs() == false\n          && req.getSearcher().count(new TermQuery(new Term(IndexSchema.ROOT_FIELD_NAME, idBytes))) > 1) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"This schema does not support partial updates to nested docs. See ref guide.\");\n      }\n\n      String oldRootDocRootFieldVal = (String) oldRootDocWithChildren.getFieldValue(IndexSchema.ROOT_FIELD_NAME);\n      if(req.getSchema().savesChildDocRelations() && oldRootDocRootFieldVal != null &&\n          !idString.equals(oldRootDocRootFieldVal)) {\n        // this is an update where the updated doc is not the root document\n        SolrInputDocument sdocWithChildren = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(),\n            idBytes, RealTimeGetComponent.Resolution.DOC_WITH_CHILDREN);\n        mergedDoc = docMerger.mergeChildDoc(sdoc, oldRootDocWithChildren, sdocWithChildren);\n      } else {\n        mergedDoc = docMerger.merge(sdoc, oldRootDocWithChildren);\n      }\n    }\n    cmd.solrDoc = mergedDoc;\n    return true;\n  }\n\n","sourceOld":"  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    if (!AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) return false;\n\n    Set<String> inPlaceUpdatedFields = AtomicUpdateDocumentMerger.computeInPlaceUpdatableFields(cmd);\n    if (inPlaceUpdatedFields.size() > 0) { // non-empty means this is suitable for in-place updates\n      if (docMerger.doInPlaceUpdateMerge(cmd, inPlaceUpdatedFields)) {\n        return true;\n      } else {\n        // in-place update failed, so fall through and re-try the same with a full atomic update\n      }\n    }\n    \n    // full (non-inplace) atomic update\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    BytesRef idBytes = cmd.getIndexedId();\n    String idString = cmd.getPrintableId();\n    SolrInputDocument oldRootDocWithChildren = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), idBytes, RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN);\n\n    if (oldRootDocWithChildren == null) {\n      if (versionOnUpdate > 0) {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + idString);\n      } else if (req.getParams().get(ShardParams._ROUTE_) != null) {\n        // the specified document could not be found in this shard\n        // and was explicitly routed using _route_\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find document id=\" + idString +\n                \", perhaps the wrong \\\"_route_\\\" param was supplied\");\n      }\n    } else {\n      oldRootDocWithChildren.remove(CommonParams.VERSION_FIELD);\n    }\n\n\n    SolrInputDocument mergedDoc;\n    if(idField == null || oldRootDocWithChildren == null) {\n      // create a new doc by default if an old one wasn't found\n      mergedDoc = docMerger.merge(sdoc, new SolrInputDocument());\n    } else {\n      String oldRootDocRootFieldVal = (String) oldRootDocWithChildren.getFieldValue(IndexSchema.ROOT_FIELD_NAME);\n      if(req.getSchema().savesChildDocRelations() && oldRootDocRootFieldVal != null &&\n          !idString.equals(oldRootDocRootFieldVal)) {\n        // this is an update where the updated doc is not the root document\n        SolrInputDocument sdocWithChildren = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(),\n            idBytes, RealTimeGetComponent.Resolution.DOC_WITH_CHILDREN);\n        mergedDoc = docMerger.mergeChildDoc(sdoc, oldRootDocWithChildren, sdocWithChildren);\n      } else {\n        mergedDoc = docMerger.merge(sdoc, oldRootDocWithChildren);\n      }\n    }\n    cmd.solrDoc = mergedDoc;\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["2d3b450958a83a29a16e492fbff9d094a9a571b6"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["4ab0c7114238ae604663efca0f46e65fff2a6c28","e212b98d0f919993a50d5d662d73517f1f180ec2"],"c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84":["3aa8a7a6dfbdba53bcf332c8a2154c3426a932d7","1166b183ba6d2f30d8660b254c6a8255505a44c3"],"598b5d23aa7c9732bf473c21a9cd309c44599394":["2d3b450958a83a29a16e492fbff9d094a9a571b6","415bbbe7da8065dd3c477bdc3c703c6425622998"],"e212b98d0f919993a50d5d662d73517f1f180ec2":["4ab0c7114238ae604663efca0f46e65fff2a6c28"],"6d2dadc1f5ca8703d8659f4964961f9967935d75":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"2cf7236e10f20245f085d633e82f01bb27a974e0":["817fc4762cd649397b27305970dad27295735f3a"],"817fc4762cd649397b27305970dad27295735f3a":["07749612bed4eb54dd05255c1434c301133310c1"],"07749612bed4eb54dd05255c1434c301133310c1":["6d2dadc1f5ca8703d8659f4964961f9967935d75"],"08970e5b8411182a29412c177eff67ec1110095b":["e212b98d0f919993a50d5d662d73517f1f180ec2"],"4ab0c7114238ae604663efca0f46e65fff2a6c28":["5e5dbf4268db532969cc84ef336b9988afce9843"],"e5fa6615014cd2288fe930f8c8bb726f9504961d":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":["c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84","92cd1849f2fc9035639005768ae063a253af7aae"],"aba371508186796cc6151d8223a5b4e16d02e26e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5e5dbf4268db532969cc84ef336b9988afce9843"],"5e5dbf4268db532969cc84ef336b9988afce9843":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5e5dbf4268db532969cc84ef336b9988afce9843"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1166b183ba6d2f30d8660b254c6a8255505a44c3":["3aa8a7a6dfbdba53bcf332c8a2154c3426a932d7"],"f2126b84bd093fa3d921582a109a0ee578c28126":["5e5dbf4268db532969cc84ef336b9988afce9843","4ab0c7114238ae604663efca0f46e65fff2a6c28"],"2d3b450958a83a29a16e492fbff9d094a9a571b6":["92cd1849f2fc9035639005768ae063a253af7aae"],"92cd1849f2fc9035639005768ae063a253af7aae":["1166b183ba6d2f30d8660b254c6a8255505a44c3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2cf7236e10f20245f085d633e82f01bb27a974e0"],"3aa8a7a6dfbdba53bcf332c8a2154c3426a932d7":["08970e5b8411182a29412c177eff67ec1110095b"]},"commit2Childs":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["598b5d23aa7c9732bf473c21a9cd309c44599394","6d2dadc1f5ca8703d8659f4964961f9967935d75","e5fa6615014cd2288fe930f8c8bb726f9504961d"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84":["0a22eafe3f72a4c2945eaad9547e6c78816978f4"],"598b5d23aa7c9732bf473c21a9cd309c44599394":[],"e212b98d0f919993a50d5d662d73517f1f180ec2":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","08970e5b8411182a29412c177eff67ec1110095b"],"6d2dadc1f5ca8703d8659f4964961f9967935d75":["07749612bed4eb54dd05255c1434c301133310c1"],"2cf7236e10f20245f085d633e82f01bb27a974e0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"817fc4762cd649397b27305970dad27295735f3a":["2cf7236e10f20245f085d633e82f01bb27a974e0"],"07749612bed4eb54dd05255c1434c301133310c1":["817fc4762cd649397b27305970dad27295735f3a"],"08970e5b8411182a29412c177eff67ec1110095b":["3aa8a7a6dfbdba53bcf332c8a2154c3426a932d7"],"4ab0c7114238ae604663efca0f46e65fff2a6c28":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","e212b98d0f919993a50d5d662d73517f1f180ec2","f2126b84bd093fa3d921582a109a0ee578c28126"],"e5fa6615014cd2288fe930f8c8bb726f9504961d":[],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":[],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"5e5dbf4268db532969cc84ef336b9988afce9843":["4ab0c7114238ae604663efca0f46e65fff2a6c28","aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424","f2126b84bd093fa3d921582a109a0ee578c28126"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["aba371508186796cc6151d8223a5b4e16d02e26e","5e5dbf4268db532969cc84ef336b9988afce9843","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"1166b183ba6d2f30d8660b254c6a8255505a44c3":["c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84","92cd1849f2fc9035639005768ae063a253af7aae"],"f2126b84bd093fa3d921582a109a0ee578c28126":[],"2d3b450958a83a29a16e492fbff9d094a9a571b6":["415bbbe7da8065dd3c477bdc3c703c6425622998","598b5d23aa7c9732bf473c21a9cd309c44599394"],"92cd1849f2fc9035639005768ae063a253af7aae":["0a22eafe3f72a4c2945eaad9547e6c78816978f4","2d3b450958a83a29a16e492fbff9d094a9a571b6"],"3aa8a7a6dfbdba53bcf332c8a2154c3426a932d7":["c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84","1166b183ba6d2f30d8660b254c6a8255505a44c3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","598b5d23aa7c9732bf473c21a9cd309c44599394","e5fa6615014cd2288fe930f8c8bb726f9504961d","0a22eafe3f72a4c2945eaad9547e6c78816978f4","aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424","f2126b84bd093fa3d921582a109a0ee578c28126","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}