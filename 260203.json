{"path":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","commits":[{"id":"f4ead54bbd0d8cf4a0b5f025fbad65581b8cd349","date":1224582283,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a\n   * snapshot. Only changed files are downloaded.\n   *\n   * @param core the SolrCore\n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    HttpClient client = null;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      client = new HttpClient();\n      client.setHttpConnectionManager(new MultiThreadedHttpConnectionManager());\n      NamedList response = getLatestVersion(client);\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getSearcher();\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      fetchFileList(latestVersion, client);\n      LOG.info(\"Number of files in latest snapshot in master: \" + filesToDownload.size());\n\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      boolean isSnapNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isSnapNeeded = true;\n      boolean successfulInstall = false;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isSnapNeeded, tmpIndexDir, client);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(client, confFilesToDownload);\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          LOG.info(\"Conf files are not downloaded or are in sync\");\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        delTree(tmpIndexDir);\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        delTree(tmpIndexDir);\n        throw e;\n      } catch (Exception e) {\n        delTree(tmpIndexDir);\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Snappull failed : \", e);\n      }\n      return successfulInstall;\n    } finally {\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      stop = false;\n      client.getHttpConnectionManager().closeIdleConnections(0);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["93a06dc5d8e12b2956002d1f01a924d7adee6a26","114670ecb9adf4ed6e7a80d6f0ce64fec0c91fb1","68a5c887424a2c6209bb3e87715125a2d398f6b9","4f1a1d7f1604a41328b566b1be0c5ad6038117e8"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1d6028dbe4a16095efe9f1651fe1a8e88d683e92","date":1224723463,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","pathOld":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a\n   * snapshot. Only changed files are downloaded.\n   *\n   * @param core the SolrCore\n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    HttpClient client = null;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      client = new HttpClient();\n      client.setHttpConnectionManager(new MultiThreadedHttpConnectionManager());\n      NamedList response = getLatestVersion(client);\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getSearcher();\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      fetchFileList(latestVersion, client);\n      LOG.info(\"Number of files in latest snapshot in master: \" + filesToDownload.size());\n\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      boolean isSnapNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isSnapNeeded = true;\n      boolean successfulInstall = false;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isSnapNeeded, tmpIndexDir, client, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(client, confFilesToDownload, latestVersion);\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          LOG.info(\"Conf files are not downloaded or are in sync\");\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        delTree(tmpIndexDir);\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        delTree(tmpIndexDir);\n        throw e;\n      } catch (Exception e) {\n        delTree(tmpIndexDir);\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Snappull failed : \", e);\n      }\n      return successfulInstall;\n    } finally {\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      stop = false;\n      client.getHttpConnectionManager().closeIdleConnections(0);\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a\n   * snapshot. Only changed files are downloaded.\n   *\n   * @param core the SolrCore\n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    HttpClient client = null;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      client = new HttpClient();\n      client.setHttpConnectionManager(new MultiThreadedHttpConnectionManager());\n      NamedList response = getLatestVersion(client);\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getSearcher();\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      fetchFileList(latestVersion, client);\n      LOG.info(\"Number of files in latest snapshot in master: \" + filesToDownload.size());\n\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      boolean isSnapNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isSnapNeeded = true;\n      boolean successfulInstall = false;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isSnapNeeded, tmpIndexDir, client);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(client, confFilesToDownload);\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          LOG.info(\"Conf files are not downloaded or are in sync\");\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        delTree(tmpIndexDir);\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        delTree(tmpIndexDir);\n        throw e;\n      } catch (Exception e) {\n        delTree(tmpIndexDir);\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Snappull failed : \", e);\n      }\n      return successfulInstall;\n    } finally {\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      stop = false;\n      client.getHttpConnectionManager().closeIdleConnections(0);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"243885d7a8da5b172092cfac738e33970bec02e1","date":1224867045,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","pathOld":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a\n   * snapshot. Only changed files are downloaded.\n   *\n   * @param core the SolrCore\n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    HttpClient client = null;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      client = new HttpClient();\n      client.setHttpConnectionManager(new MultiThreadedHttpConnectionManager());\n      NamedList response = getLatestVersion(client);\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      fetchFileList(latestVersion, client);\n      LOG.info(\"Number of files in latest snapshot in master: \" + filesToDownload.size());\n\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      boolean isSnapNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isSnapNeeded = true;\n      boolean successfulInstall = false;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isSnapNeeded, tmpIndexDir, client, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(client, confFilesToDownload, latestVersion);\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          LOG.info(\"Conf files are not downloaded or are in sync\");\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        delTree(tmpIndexDir);\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        delTree(tmpIndexDir);\n        throw e;\n      } catch (Exception e) {\n        delTree(tmpIndexDir);\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Snappull failed : \", e);\n      }\n      return successfulInstall;\n    } finally {\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      stop = false;\n      client.getHttpConnectionManager().closeIdleConnections(0);\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a\n   * snapshot. Only changed files are downloaded.\n   *\n   * @param core the SolrCore\n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    HttpClient client = null;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      client = new HttpClient();\n      client.setHttpConnectionManager(new MultiThreadedHttpConnectionManager());\n      NamedList response = getLatestVersion(client);\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getSearcher();\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      fetchFileList(latestVersion, client);\n      LOG.info(\"Number of files in latest snapshot in master: \" + filesToDownload.size());\n\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      boolean isSnapNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isSnapNeeded = true;\n      boolean successfulInstall = false;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isSnapNeeded, tmpIndexDir, client, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(client, confFilesToDownload, latestVersion);\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          LOG.info(\"Conf files are not downloaded or are in sync\");\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        delTree(tmpIndexDir);\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        delTree(tmpIndexDir);\n        throw e;\n      } catch (Exception e) {\n        delTree(tmpIndexDir);\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Snappull failed : \", e);\n      }\n      return successfulInstall;\n    } finally {\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      stop = false;\n      client.getHttpConnectionManager().closeIdleConnections(0);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6c89a4aebdbd208d5517a488e7dd7c1d164c3bc9","date":1225202752,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","pathOld":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a\n   * snapshot. Only changed files are downloaded. it also downloads the\n   * conf files (if they are modified)\n   *\n   * @param core the SolrCore\n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    HttpClient client = null;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      client = new HttpClient();\n      // The closing is done in a different thread. So use multiThreaded conn manager\n      // else it prints out a warning\n      client.setHttpConnectionManager(new MultiThreadedHttpConnectionManager());\n      //get the current 'replicateable' index version in the master\n      NamedList response = getLatestVersion(client);\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        //there is nothing to be replicated\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are alsready in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion, client);\n      LOG.info(\"Number of files in latest snapshot in master: \" + filesToDownload.size());\n\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isSnapNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isSnapNeeded = true;\n      boolean successfulInstall = false;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isSnapNeeded, tmpIndexDir, client, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(client, confFilesToDownload, latestVersion);\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          LOG.info(\"Conf files are not downloaded or are in sync\");\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        delTree(tmpIndexDir);\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        delTree(tmpIndexDir);\n        throw e;\n      } catch (Exception e) {\n        delTree(tmpIndexDir);\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Snappull failed : \", e);\n      }\n      return successfulInstall;\n    } finally {\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      stop = false;\n      client.getHttpConnectionManager().closeIdleConnections(0);\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a\n   * snapshot. Only changed files are downloaded.\n   *\n   * @param core the SolrCore\n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    HttpClient client = null;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      client = new HttpClient();\n      client.setHttpConnectionManager(new MultiThreadedHttpConnectionManager());\n      NamedList response = getLatestVersion(client);\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      fetchFileList(latestVersion, client);\n      LOG.info(\"Number of files in latest snapshot in master: \" + filesToDownload.size());\n\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      boolean isSnapNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isSnapNeeded = true;\n      boolean successfulInstall = false;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isSnapNeeded, tmpIndexDir, client, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(client, confFilesToDownload, latestVersion);\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          LOG.info(\"Conf files are not downloaded or are in sync\");\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        delTree(tmpIndexDir);\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        delTree(tmpIndexDir);\n        throw e;\n      } catch (Exception e) {\n        delTree(tmpIndexDir);\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Snappull failed : \", e);\n      }\n      return successfulInstall;\n    } finally {\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      stop = false;\n      client.getHttpConnectionManager().closeIdleConnections(0);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8620c64e323e74078214cf931e505179d14c888e","date":1225270494,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","pathOld":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a\n   * index commit point. Only changed files are downloaded. It also downloads the\n   * conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    HttpClient client = null;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      client = new HttpClient();\n      // The closing is done in a different thread. So use multiThreaded conn manager\n      // else it prints out a warning\n      client.setHttpConnectionManager(new MultiThreadedHttpConnectionManager());\n      //get the current 'replicateable' index version in the master\n      NamedList response = getLatestVersion(client);\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        //there is nothing to be replicated\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are alsready in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion, client);\n      LOG.info(\"Number of files in latest snapshot in master: \" + filesToDownload.size());\n\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isSnapNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isSnapNeeded = true;\n      boolean successfulInstall = false;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isSnapNeeded, tmpIndexDir, client, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(client, confFilesToDownload, latestVersion);\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          LOG.info(\"Conf files are not downloaded or are in sync\");\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        delTree(tmpIndexDir);\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        delTree(tmpIndexDir);\n        throw e;\n      } catch (Exception e) {\n        delTree(tmpIndexDir);\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Snappull failed : \", e);\n      }\n      return successfulInstall;\n    } finally {\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      stop = false;\n      client.getHttpConnectionManager().closeIdleConnections(0);\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a\n   * snapshot. Only changed files are downloaded. it also downloads the\n   * conf files (if they are modified)\n   *\n   * @param core the SolrCore\n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    HttpClient client = null;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      client = new HttpClient();\n      // The closing is done in a different thread. So use multiThreaded conn manager\n      // else it prints out a warning\n      client.setHttpConnectionManager(new MultiThreadedHttpConnectionManager());\n      //get the current 'replicateable' index version in the master\n      NamedList response = getLatestVersion(client);\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        //there is nothing to be replicated\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are alsready in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion, client);\n      LOG.info(\"Number of files in latest snapshot in master: \" + filesToDownload.size());\n\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isSnapNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isSnapNeeded = true;\n      boolean successfulInstall = false;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isSnapNeeded, tmpIndexDir, client, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(client, confFilesToDownload, latestVersion);\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          LOG.info(\"Conf files are not downloaded or are in sync\");\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        delTree(tmpIndexDir);\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        delTree(tmpIndexDir);\n        throw e;\n      } catch (Exception e) {\n        delTree(tmpIndexDir);\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Snappull failed : \", e);\n      }\n      return successfulInstall;\n    } finally {\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      stop = false;\n      client.getHttpConnectionManager().closeIdleConnections(0);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c6e1afc23adf8af4aa2dfc781b02b63710546b33","date":1227622754,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","pathOld":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a\n   * index commit point. Only changed files are downloaded. It also downloads the\n   * conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = getLatestVersion();\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        //there is nothing to be replicated\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are alsready in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      LOG.info(\"Number of files in latest snapshot in master: \" + filesToDownload.size());\n\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isSnapNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isSnapNeeded = true;\n      boolean successfulInstall = false;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isSnapNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          LOG.info(\"Conf files are not downloaded or are in sync\");\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        delTree(tmpIndexDir);\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        delTree(tmpIndexDir);\n        throw e;\n      } catch (Exception e) {\n        delTree(tmpIndexDir);\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Snappull failed : \", e);\n      }\n      return successfulInstall;\n    } finally {\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      stop = false;\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a\n   * index commit point. Only changed files are downloaded. It also downloads the\n   * conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    HttpClient client = null;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      client = new HttpClient();\n      // The closing is done in a different thread. So use multiThreaded conn manager\n      // else it prints out a warning\n      client.setHttpConnectionManager(new MultiThreadedHttpConnectionManager());\n      //get the current 'replicateable' index version in the master\n      NamedList response = getLatestVersion(client);\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        //there is nothing to be replicated\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are alsready in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion, client);\n      LOG.info(\"Number of files in latest snapshot in master: \" + filesToDownload.size());\n\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isSnapNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isSnapNeeded = true;\n      boolean successfulInstall = false;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isSnapNeeded, tmpIndexDir, client, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(client, confFilesToDownload, latestVersion);\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          LOG.info(\"Conf files are not downloaded or are in sync\");\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        delTree(tmpIndexDir);\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        delTree(tmpIndexDir);\n        throw e;\n      } catch (Exception e) {\n        delTree(tmpIndexDir);\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Snappull failed : \", e);\n      }\n      return successfulInstall;\n    } finally {\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      stop = false;\n      client.getHttpConnectionManager().closeIdleConnections(0);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9be231d18ef58129524215a1d30331523320b744","date":1229505566,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","pathOld":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   *\n   * @return true on success, false if slave is already in sync\n   *\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = getLatestVersion();\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        //there is nothing to be replicated\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are alsready in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      LOG.info(\"Number of files in latest snapshot in master: \" + filesToDownload.size());\n\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isSnapNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isSnapNeeded = true;\n      boolean successfulInstall = false;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isSnapNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          LOG.info(\"Conf files are not downloaded or are in sync\");\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        delTree(tmpIndexDir);\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        delTree(tmpIndexDir);\n        throw e;\n      } catch (Exception e) {\n        delTree(tmpIndexDir);\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Snappull failed : \", e);\n      }\n      return successfulInstall;\n    } finally {\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      stop = false;\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a\n   * index commit point. Only changed files are downloaded. It also downloads the\n   * conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = getLatestVersion();\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        //there is nothing to be replicated\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are alsready in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      LOG.info(\"Number of files in latest snapshot in master: \" + filesToDownload.size());\n\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isSnapNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isSnapNeeded = true;\n      boolean successfulInstall = false;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isSnapNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          LOG.info(\"Conf files are not downloaded or are in sync\");\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        delTree(tmpIndexDir);\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        delTree(tmpIndexDir);\n        throw e;\n      } catch (Exception e) {\n        delTree(tmpIndexDir);\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Snappull failed : \", e);\n      }\n      return successfulInstall;\n    } finally {\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      stop = false;\n    }\n  }\n\n","bugFix":null,"bugIntro":["4f1a1d7f1604a41328b566b1be0c5ad6038117e8"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"114670ecb9adf4ed6e7a80d6f0ce64fec0c91fb1","date":1232905968,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","pathOld":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   *\n   * @return true on success, false if slave is already in sync\n   *\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = getLatestVersion();\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        //there is nothing to be replicated\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are alsready in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      LOG.info(\"Number of files in latest snapshot in master: \" + filesToDownload.size());\n\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isSnapNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isSnapNeeded = true;\n      boolean successfulInstall = false;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isSnapNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          LOG.info(\"Conf files are not downloaded or are in sync\");\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        throw e;\n      } catch (Exception e) {\n        delTree(tmpIndexDir);\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Snappull failed : \", e);\n      } finally {\n        delTree(tmpIndexDir);\n      }\n      return successfulInstall;\n    } finally {\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      stop = false;\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   *\n   * @return true on success, false if slave is already in sync\n   *\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = getLatestVersion();\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        //there is nothing to be replicated\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are alsready in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      LOG.info(\"Number of files in latest snapshot in master: \" + filesToDownload.size());\n\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isSnapNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isSnapNeeded = true;\n      boolean successfulInstall = false;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isSnapNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          LOG.info(\"Conf files are not downloaded or are in sync\");\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        delTree(tmpIndexDir);\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        delTree(tmpIndexDir);\n        throw e;\n      } catch (Exception e) {\n        delTree(tmpIndexDir);\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Snappull failed : \", e);\n      }\n      return successfulInstall;\n    } finally {\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      stop = false;\n    }\n  }\n\n","bugFix":["f4ead54bbd0d8cf4a0b5f025fbad65581b8cd349"],"bugIntro":["68a5c887424a2c6209bb3e87715125a2d398f6b9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2e55076e61db91006ece238ac2ebd07eae222206","date":1236340108,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","pathOld":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   *\n   * @return true on success, false if slave is already in sync\n   *\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \"+masterUrl + \" is not available. Snappull failed. Exception: \" + e.getMessage());\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        //there is nothing to be replicated\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are alsready in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      LOG.info(\"Number of files in latest snapshot in master: \" + filesToDownload.size());\n\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isSnapNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isSnapNeeded = true;\n      boolean successfulInstall = false;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isSnapNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          LOG.info(\"Conf files are not downloaded or are in sync\");\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        throw e;\n      } catch (Exception e) {\n        delTree(tmpIndexDir);\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Snappull failed : \", e);\n      } finally {\n        delTree(tmpIndexDir);\n      }\n      return successfulInstall;\n    } finally {\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      stop = false;\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   *\n   * @return true on success, false if slave is already in sync\n   *\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = getLatestVersion();\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        //there is nothing to be replicated\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are alsready in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      LOG.info(\"Number of files in latest snapshot in master: \" + filesToDownload.size());\n\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isSnapNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isSnapNeeded = true;\n      boolean successfulInstall = false;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isSnapNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          LOG.info(\"Conf files are not downloaded or are in sync\");\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        throw e;\n      } catch (Exception e) {\n        delTree(tmpIndexDir);\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Snappull failed : \", e);\n      } finally {\n        delTree(tmpIndexDir);\n      }\n      return successfulInstall;\n    } finally {\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      stop = false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aab56102a66ad6123bbc7a10ec65d998b5e6117a","date":1238749717,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","pathOld":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   *\n   * @return true on success, false if slave is already in sync\n   *\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \"+masterUrl + \" is not available. Snappull failed. Exception: \" + e.getMessage());\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        //there is nothing to be replicated\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are alsready in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      LOG.info(\"Number of files in latest snapshot in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isSnapNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isSnapNeeded = true;\n      boolean successfulInstall = false;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isSnapNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          LOG.info(\"Conf files are not downloaded or are in sync\");\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        throw e;\n      } catch (Exception e) {\n        delTree(tmpIndexDir);\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Snappull failed : \", e);\n      } finally {\n        delTree(tmpIndexDir);\n      }\n      return successfulInstall;\n    } finally {\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   *\n   * @return true on success, false if slave is already in sync\n   *\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \"+masterUrl + \" is not available. Snappull failed. Exception: \" + e.getMessage());\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        //there is nothing to be replicated\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are alsready in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      LOG.info(\"Number of files in latest snapshot in master: \" + filesToDownload.size());\n\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isSnapNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isSnapNeeded = true;\n      boolean successfulInstall = false;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isSnapNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          LOG.info(\"Conf files are not downloaded or are in sync\");\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        throw e;\n      } catch (Exception e) {\n        delTree(tmpIndexDir);\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Snappull failed : \", e);\n      } finally {\n        delTree(tmpIndexDir);\n      }\n      return successfulInstall;\n    } finally {\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      stop = false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"43ce094cd81e184512f8c59c2334e55ec4ed7d7e","date":1238749920,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","pathOld":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   *\n   * @return true on success, false if slave is already in sync\n   *\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \"+masterUrl + \" is not available. Snappull failed. Exception: \" + e.getMessage());\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        //there is nothing to be replicated\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are alsready in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      LOG.info(\"Number of files in latest snapshot in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isSnapNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isSnapNeeded = true;\n      boolean successfulInstall = false;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isSnapNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          LOG.info(\"Conf files are not downloaded or are in sync\");\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        throw e;\n      } catch (Exception e) {\n        delTree(tmpIndexDir);\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Snappull failed : \", e);\n      } finally {\n        delTree(tmpIndexDir);\n      }\n      return successfulInstall;\n    } finally {\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   *\n   * @return true on success, false if slave is already in sync\n   *\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \"+masterUrl + \" is not available. Snappull failed. Exception: \" + e.getMessage());\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        //there is nothing to be replicated\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are alsready in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      LOG.info(\"Number of files in latest snapshot in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isSnapNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isSnapNeeded = true;\n      boolean successfulInstall = false;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isSnapNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          LOG.info(\"Conf files are not downloaded or are in sync\");\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        throw e;\n      } catch (Exception e) {\n        delTree(tmpIndexDir);\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Snappull failed : \", e);\n      } finally {\n        delTree(tmpIndexDir);\n      }\n      return successfulInstall;\n    } finally {\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7a55a51904384c9802149eb2ce3050fb564770b7","date":1243001938,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","pathOld":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   *\n   * @return true on success, false if slave is already in sync\n   *\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \"+masterUrl + \" is not available. Snappull failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        //there is nothing to be replicated\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are alsready in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      LOG.info(\"Number of files in latest snapshot in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isSnapNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isSnapNeeded = true;\n      boolean successfulInstall = false;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isSnapNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          LOG.info(\"Conf files are not downloaded or are in sync\");\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        throw e;\n      } catch (Exception e) {\n        delTree(tmpIndexDir);\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Snappull failed : \", e);\n      } finally {\n        delTree(tmpIndexDir);\n      }\n      return successfulInstall;\n    } finally {\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   *\n   * @return true on success, false if slave is already in sync\n   *\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \"+masterUrl + \" is not available. Snappull failed. Exception: \" + e.getMessage());\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        //there is nothing to be replicated\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are alsready in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      LOG.info(\"Number of files in latest snapshot in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isSnapNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isSnapNeeded = true;\n      boolean successfulInstall = false;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isSnapNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          LOG.info(\"Conf files are not downloaded or are in sync\");\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        throw e;\n      } catch (Exception e) {\n        delTree(tmpIndexDir);\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Snappull failed : \", e);\n      } finally {\n        delTree(tmpIndexDir);\n      }\n      return successfulInstall;\n    } finally {\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b1d4115d58bc5d3a2a98f005f14f93c382e874c1","date":1246604190,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","pathOld":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   *\n   * @return true on success, false if slave is already in sync\n   *\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \"+masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        //there is nothing to be replicated\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are alsready in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isSnapNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isSnapNeeded = true;\n      boolean successfulInstall = false;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isSnapNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        throw e;\n      } catch (Exception e) {\n        delTree(tmpIndexDir);\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        delTree(tmpIndexDir);\n      }\n      return successfulInstall;\n    } finally {\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   *\n   * @return true on success, false if slave is already in sync\n   *\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \"+masterUrl + \" is not available. Snappull failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        //there is nothing to be replicated\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are alsready in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      LOG.info(\"Number of files in latest snapshot in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isSnapNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isSnapNeeded = true;\n      boolean successfulInstall = false;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isSnapNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          LOG.info(\"Conf files are not downloaded or are in sync\");\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        throw e;\n      } catch (Exception e) {\n        delTree(tmpIndexDir);\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Snappull failed : \", e);\n      } finally {\n        delTree(tmpIndexDir);\n      }\n      return successfulInstall;\n    } finally {\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":["4f1a1d7f1604a41328b566b1be0c5ad6038117e8"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"68a5c887424a2c6209bb3e87715125a2d398f6b9","date":1247133435,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","pathOld":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   *\n   * @return true on success, false if slave is already in sync\n   *\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \"+masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        //there is nothing to be replicated\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are alsready in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isSnapNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isSnapNeeded = true;\n      boolean successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isSnapNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isSnapNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        throw e;\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if(deleteTmpIdxDir) delTree(tmpIndexDir);\n      }\n      return successfulInstall;\n    } finally {\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   *\n   * @return true on success, false if slave is already in sync\n   *\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \"+masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        //there is nothing to be replicated\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are alsready in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isSnapNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isSnapNeeded = true;\n      boolean successfulInstall = false;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isSnapNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        throw e;\n      } catch (Exception e) {\n        delTree(tmpIndexDir);\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        delTree(tmpIndexDir);\n      }\n      return successfulInstall;\n    } finally {\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":["114670ecb9adf4ed6e7a80d6f0ce64fec0c91fb1","f4ead54bbd0d8cf4a0b5f025fbad65581b8cd349"],"bugIntro":["93a06dc5d8e12b2956002d1f01a924d7adee6a26"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c7e0049b151d932b18c3acc1ef8366262ae9809d","date":1247648156,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","pathOld":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   *\n   * @return true on success, false if slave is already in sync\n   *\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \"+masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        //there is nothing to be replicated\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are alsready in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      boolean successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isFullCopyNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        throw e;\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if(deleteTmpIdxDir) delTree(tmpIndexDir);\n      }\n      return successfulInstall;\n    } finally {\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   *\n   * @return true on success, false if slave is already in sync\n   *\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \"+masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        //there is nothing to be replicated\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are alsready in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isSnapNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isSnapNeeded = true;\n      boolean successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isSnapNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isSnapNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isSnapNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        throw e;\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if(deleteTmpIdxDir) delTree(tmpIndexDir);\n      }\n      return successfulInstall;\n    } finally {\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4f1a1d7f1604a41328b566b1be0c5ad6038117e8","date":1252499131,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","pathOld":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","sourceNew":"  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        //there is nothing to be replicated\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are alsready in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isFullCopyNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        throw e;\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if(deleteTmpIdxDir) delTree(tmpIndexDir);\n      }\n      return successfulInstall;\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   *\n   * @return true on success, false if slave is already in sync\n   *\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \"+masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        //there is nothing to be replicated\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are alsready in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      boolean successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isFullCopyNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        throw e;\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if(deleteTmpIdxDir) delTree(tmpIndexDir);\n      }\n      return successfulInstall;\n    } finally {\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":["b1d4115d58bc5d3a2a98f005f14f93c382e874c1","f4ead54bbd0d8cf4a0b5f025fbad65581b8cd349","9be231d18ef58129524215a1d30331523320b744"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7cdac6591b64f43f87663e70518d79dd137454b4","date":1254069460,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","pathOld":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","sourceNew":"  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        //there is nothing to be replicated\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are alsready in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isFullCopyNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        throw e;\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if(deleteTmpIdxDir) delTree(tmpIndexDir);\n      }\n      return successfulInstall;\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":"  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        //there is nothing to be replicated\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are alsready in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isFullCopyNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        throw e;\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if(deleteTmpIdxDir) delTree(tmpIndexDir);\n      }\n      return successfulInstall;\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","pathOld":"src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore).mjava","sourceNew":"  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        //there is nothing to be replicated\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are alsready in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isFullCopyNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        throw e;\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if(deleteTmpIdxDir) delTree(tmpIndexDir);\n      }\n      return successfulInstall;\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":"  boolean fetchLatestIndex(SolrCore core) throws IOException {\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n      if (latestVersion == 0L) {\n        //there is nothing to be replicated\n        return false;\n      }\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        commit = searcherRefCounted.get().getReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are alsready in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        return false;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = commit.getGeneration() >= latestGeneration;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      try {\n        File indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isFullCopyNeeded) {\n            modifyIndexProps(tmpIndexDir.getName());\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n      } catch (SolrException e) {\n        throw e;\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if(deleteTmpIdxDir) delTree(tmpIndexDir);\n      }\n      return successfulInstall;\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"f4ead54bbd0d8cf4a0b5f025fbad65581b8cd349":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"2e55076e61db91006ece238ac2ebd07eae222206":["114670ecb9adf4ed6e7a80d6f0ce64fec0c91fb1"],"9be231d18ef58129524215a1d30331523320b744":["c6e1afc23adf8af4aa2dfc781b02b63710546b33"],"1d6028dbe4a16095efe9f1651fe1a8e88d683e92":["f4ead54bbd0d8cf4a0b5f025fbad65581b8cd349"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"aab56102a66ad6123bbc7a10ec65d998b5e6117a":["2e55076e61db91006ece238ac2ebd07eae222206"],"8620c64e323e74078214cf931e505179d14c888e":["6c89a4aebdbd208d5517a488e7dd7c1d164c3bc9"],"4f1a1d7f1604a41328b566b1be0c5ad6038117e8":["c7e0049b151d932b18c3acc1ef8366262ae9809d"],"c7e0049b151d932b18c3acc1ef8366262ae9809d":["68a5c887424a2c6209bb3e87715125a2d398f6b9"],"243885d7a8da5b172092cfac738e33970bec02e1":["1d6028dbe4a16095efe9f1651fe1a8e88d683e92"],"114670ecb9adf4ed6e7a80d6f0ce64fec0c91fb1":["9be231d18ef58129524215a1d30331523320b744"],"68a5c887424a2c6209bb3e87715125a2d398f6b9":["b1d4115d58bc5d3a2a98f005f14f93c382e874c1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b1d4115d58bc5d3a2a98f005f14f93c382e874c1":["7a55a51904384c9802149eb2ce3050fb564770b7"],"7a55a51904384c9802149eb2ce3050fb564770b7":["43ce094cd81e184512f8c59c2334e55ec4ed7d7e"],"ad94625fb8d088209f46650c8097196fec67f00c":["7cdac6591b64f43f87663e70518d79dd137454b4"],"c6e1afc23adf8af4aa2dfc781b02b63710546b33":["8620c64e323e74078214cf931e505179d14c888e"],"6c89a4aebdbd208d5517a488e7dd7c1d164c3bc9":["243885d7a8da5b172092cfac738e33970bec02e1"],"7cdac6591b64f43f87663e70518d79dd137454b4":["4f1a1d7f1604a41328b566b1be0c5ad6038117e8"],"43ce094cd81e184512f8c59c2334e55ec4ed7d7e":["aab56102a66ad6123bbc7a10ec65d998b5e6117a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"f4ead54bbd0d8cf4a0b5f025fbad65581b8cd349":["1d6028dbe4a16095efe9f1651fe1a8e88d683e92"],"2e55076e61db91006ece238ac2ebd07eae222206":["aab56102a66ad6123bbc7a10ec65d998b5e6117a"],"9be231d18ef58129524215a1d30331523320b744":["114670ecb9adf4ed6e7a80d6f0ce64fec0c91fb1"],"1d6028dbe4a16095efe9f1651fe1a8e88d683e92":["243885d7a8da5b172092cfac738e33970bec02e1"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["f4ead54bbd0d8cf4a0b5f025fbad65581b8cd349"],"aab56102a66ad6123bbc7a10ec65d998b5e6117a":["43ce094cd81e184512f8c59c2334e55ec4ed7d7e"],"8620c64e323e74078214cf931e505179d14c888e":["c6e1afc23adf8af4aa2dfc781b02b63710546b33"],"4f1a1d7f1604a41328b566b1be0c5ad6038117e8":["7cdac6591b64f43f87663e70518d79dd137454b4"],"c7e0049b151d932b18c3acc1ef8366262ae9809d":["4f1a1d7f1604a41328b566b1be0c5ad6038117e8"],"243885d7a8da5b172092cfac738e33970bec02e1":["6c89a4aebdbd208d5517a488e7dd7c1d164c3bc9"],"114670ecb9adf4ed6e7a80d6f0ce64fec0c91fb1":["2e55076e61db91006ece238ac2ebd07eae222206"],"68a5c887424a2c6209bb3e87715125a2d398f6b9":["c7e0049b151d932b18c3acc1ef8366262ae9809d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b1d4115d58bc5d3a2a98f005f14f93c382e874c1":["68a5c887424a2c6209bb3e87715125a2d398f6b9"],"7a55a51904384c9802149eb2ce3050fb564770b7":["b1d4115d58bc5d3a2a98f005f14f93c382e874c1"],"c6e1afc23adf8af4aa2dfc781b02b63710546b33":["9be231d18ef58129524215a1d30331523320b744"],"6c89a4aebdbd208d5517a488e7dd7c1d164c3bc9":["8620c64e323e74078214cf931e505179d14c888e"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"43ce094cd81e184512f8c59c2334e55ec4ed7d7e":["7a55a51904384c9802149eb2ce3050fb564770b7"],"7cdac6591b64f43f87663e70518d79dd137454b4":["ad94625fb8d088209f46650c8097196fec67f00c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}