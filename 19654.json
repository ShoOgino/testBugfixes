{"path":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","commits":[{"id":"3f767f8c99eaedb984df754fe61f21c5de260f94","date":1344105153,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(CloudState,ZkNodeProps).mjava","sourceNew":"  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {\n    \n    // look at the replication factor and see if it matches reality\n    // if it does not, find best nodes to create more cores\n    \n    String numReplicasString = message.get(\"numReplicas\");\n    int numReplicas;\n    try {\n      numReplicas = numReplicasString == null ? 0 : Integer.parseInt(numReplicasString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numReplicas\", ex);\n      return false;\n    }\n    String numShardsString = message.get(\"numShards\");\n    int numShards;\n    try {\n      numShards = numShardsString == null ? 0 : Integer.parseInt(numShardsString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numShards\", ex);\n      return false;\n    }\n    \n    String name = message.get(\"name\");\n    String configName = message.get(\"collection.configName\");\n    \n    // we need to look at every node and see how many cores it serves\n    // add our new cores to existing nodes serving the least number of cores\n    // but (for now) require that each core goes on a distinct node.\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    \n    \n    // TODO: add smarter options that look at the current number of cores per node?\n    // for now we just go random\n    Set<String> nodes = clusterState.getLiveNodes();\n    List<String> nodeList = new ArrayList<String>(nodes.size());\n    nodeList.addAll(nodes);\n    Collections.shuffle(nodeList);\n    \n    int numNodes = numShards * (numReplicas + 1);\n    List<String> createOnNodes = nodeList.subList(0, Math.min(nodeList.size(), numNodes));\n    \n    log.info(\"Create collection \" + name + \" on \" + createOnNodes);\n    \n    for (String replica : createOnNodes) {\n      // TODO: this does not work if original url had _ in it\n      // We should have a master list\n      replica = replica.replaceAll(\"_\", \"/\");\n      params.set(CoreAdminParams.NAME, name);\n      params.set(\"collection.configName\", configName);\n      params.set(\"numShards\", numShards);\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      // TODO: this sucks\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean createCollection(CloudState cloudState, ZkNodeProps message) {\n    \n    // look at the replication factor and see if it matches reality\n    // if it does not, find best nodes to create more cores\n    \n    String numReplicasString = message.get(\"numReplicas\");\n    int numReplicas;\n    try {\n      numReplicas = numReplicasString == null ? 0 : Integer.parseInt(numReplicasString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numReplicas\", ex);\n      return false;\n    }\n    String numShardsString = message.get(\"numShards\");\n    int numShards;\n    try {\n      numShards = numShardsString == null ? 0 : Integer.parseInt(numShardsString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numShards\", ex);\n      return false;\n    }\n    \n    String name = message.get(\"name\");\n    String configName = message.get(\"collection.configName\");\n    \n    // we need to look at every node and see how many cores it serves\n    // add our new cores to existing nodes serving the least number of cores\n    // but (for now) require that each core goes on a distinct node.\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    \n    \n    // TODO: add smarter options that look at the current number of cores per node?\n    // for now we just go random\n    Set<String> nodes = cloudState.getLiveNodes();\n    List<String> nodeList = new ArrayList<String>(nodes.size());\n    nodeList.addAll(nodes);\n    Collections.shuffle(nodeList);\n    \n    int numNodes = numShards * (numReplicas + 1);\n    List<String> createOnNodes = nodeList.subList(0, Math.min(nodeList.size(), numNodes));\n    \n    log.info(\"Create collection \" + name + \" on \" + createOnNodes);\n    \n    for (String replica : createOnNodes) {\n      // TODO: this does not work if original url had _ in it\n      // We should have a master list\n      replica = replica.replaceAll(\"_\", \"/\");\n      params.set(CoreAdminParams.NAME, name);\n      params.set(\"collection.configName\", configName);\n      params.set(\"numShards\", numShards);\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      // TODO: this sucks\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8fd5be977c105554c6a7b68afcdbc511439723ab","date":1344115570,"type":1,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(CloudState,ZkNodeProps).mjava","sourceNew":"  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {\n    \n    // look at the replication factor and see if it matches reality\n    // if it does not, find best nodes to create more cores\n    \n    String numReplicasString = message.get(\"numReplicas\");\n    int numReplicas;\n    try {\n      numReplicas = numReplicasString == null ? 0 : Integer.parseInt(numReplicasString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numReplicas\", ex);\n      return false;\n    }\n    String numShardsString = message.get(\"numShards\");\n    int numShards;\n    try {\n      numShards = numShardsString == null ? 0 : Integer.parseInt(numShardsString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numShards\", ex);\n      return false;\n    }\n    \n    String name = message.get(\"name\");\n    String configName = message.get(\"collection.configName\");\n    \n    // we need to look at every node and see how many cores it serves\n    // add our new cores to existing nodes serving the least number of cores\n    // but (for now) require that each core goes on a distinct node.\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    \n    \n    // TODO: add smarter options that look at the current number of cores per node?\n    // for now we just go random\n    Set<String> nodes = clusterState.getLiveNodes();\n    List<String> nodeList = new ArrayList<String>(nodes.size());\n    nodeList.addAll(nodes);\n    Collections.shuffle(nodeList);\n    \n    int numNodes = numShards * (numReplicas + 1);\n    List<String> createOnNodes = nodeList.subList(0, Math.min(nodeList.size(), numNodes));\n    \n    log.info(\"Create collection \" + name + \" on \" + createOnNodes);\n    \n    for (String replica : createOnNodes) {\n      // TODO: this does not work if original url had _ in it\n      // We should have a master list\n      replica = replica.replaceAll(\"_\", \"/\");\n      params.set(CoreAdminParams.NAME, name);\n      params.set(\"collection.configName\", configName);\n      params.set(\"numShards\", numShards);\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      // TODO: this sucks\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean createCollection(CloudState cloudState, ZkNodeProps message) {\n    \n    // look at the replication factor and see if it matches reality\n    // if it does not, find best nodes to create more cores\n    \n    String numReplicasString = message.get(\"numReplicas\");\n    int numReplicas;\n    try {\n      numReplicas = numReplicasString == null ? 0 : Integer.parseInt(numReplicasString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numReplicas\", ex);\n      return false;\n    }\n    String numShardsString = message.get(\"numShards\");\n    int numShards;\n    try {\n      numShards = numShardsString == null ? 0 : Integer.parseInt(numShardsString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numShards\", ex);\n      return false;\n    }\n    \n    String name = message.get(\"name\");\n    String configName = message.get(\"collection.configName\");\n    \n    // we need to look at every node and see how many cores it serves\n    // add our new cores to existing nodes serving the least number of cores\n    // but (for now) require that each core goes on a distinct node.\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    \n    \n    // TODO: add smarter options that look at the current number of cores per node?\n    // for now we just go random\n    Set<String> nodes = cloudState.getLiveNodes();\n    List<String> nodeList = new ArrayList<String>(nodes.size());\n    nodeList.addAll(nodes);\n    Collections.shuffle(nodeList);\n    \n    int numNodes = numShards * (numReplicas + 1);\n    List<String> createOnNodes = nodeList.subList(0, Math.min(nodeList.size(), numNodes));\n    \n    log.info(\"Create collection \" + name + \" on \" + createOnNodes);\n    \n    for (String replica : createOnNodes) {\n      // TODO: this does not work if original url had _ in it\n      // We should have a master list\n      replica = replica.replaceAll(\"_\", \"/\");\n      params.set(CoreAdminParams.NAME, name);\n      params.set(\"collection.configName\", configName);\n      params.set(\"numShards\", numShards);\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      // TODO: this sucks\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","pathOld":"/dev/null","sourceNew":"  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {\n    \n    // look at the replication factor and see if it matches reality\n    // if it does not, find best nodes to create more cores\n    \n    String numReplicasString = message.get(\"numReplicas\");\n    int numReplicas;\n    try {\n      numReplicas = numReplicasString == null ? 0 : Integer.parseInt(numReplicasString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numReplicas\", ex);\n      return false;\n    }\n    String numShardsString = message.get(\"numShards\");\n    int numShards;\n    try {\n      numShards = numShardsString == null ? 0 : Integer.parseInt(numShardsString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numShards\", ex);\n      return false;\n    }\n    \n    String name = message.get(\"name\");\n    String configName = message.get(\"collection.configName\");\n    \n    // we need to look at every node and see how many cores it serves\n    // add our new cores to existing nodes serving the least number of cores\n    // but (for now) require that each core goes on a distinct node.\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    \n    \n    // TODO: add smarter options that look at the current number of cores per node?\n    // for now we just go random\n    Set<String> nodes = clusterState.getLiveNodes();\n    List<String> nodeList = new ArrayList<String>(nodes.size());\n    nodeList.addAll(nodes);\n    Collections.shuffle(nodeList);\n    \n    int numNodes = numShards * (numReplicas + 1);\n    List<String> createOnNodes = nodeList.subList(0, Math.min(nodeList.size(), numNodes));\n    \n    log.info(\"Create collection \" + name + \" on \" + createOnNodes);\n    \n    for (String replica : createOnNodes) {\n      // TODO: this does not work if original url had _ in it\n      // We should have a master list\n      replica = replica.replaceAll(\"_\", \"/\");\n      params.set(CoreAdminParams.NAME, name);\n      params.set(\"collection.configName\", configName);\n      params.set(\"numShards\", numShards);\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      // TODO: this sucks\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa64435b5902ce266c23755a4a00691a3285dab8","date":1347243290,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","sourceNew":"  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {\n    \n    // look at the replication factor and see if it matches reality\n    // if it does not, find best nodes to create more cores\n    \n    String numReplicasString = message.getStr(\"numReplicas\");\n    int numReplicas;\n    try {\n      numReplicas = numReplicasString == null ? 0 : Integer.parseInt(numReplicasString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numReplicas\", ex);\n      return false;\n    }\n    String numShardsString = message.getStr(\"numShards\");\n    int numShards;\n    try {\n      numShards = numShardsString == null ? 0 : Integer.parseInt(numShardsString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numShards\", ex);\n      return false;\n    }\n    \n    String name = message.getStr(\"name\");\n    String configName = message.getStr(\"collection.configName\");\n    \n    // we need to look at every node and see how many cores it serves\n    // add our new cores to existing nodes serving the least number of cores\n    // but (for now) require that each core goes on a distinct node.\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    \n    \n    // TODO: add smarter options that look at the current number of cores per node?\n    // for now we just go random\n    Set<String> nodes = clusterState.getLiveNodes();\n    List<String> nodeList = new ArrayList<String>(nodes.size());\n    nodeList.addAll(nodes);\n    Collections.shuffle(nodeList);\n    \n    int numNodes = numShards * (numReplicas + 1);\n    List<String> createOnNodes = nodeList.subList(0, Math.min(nodeList.size(), numNodes));\n    \n    log.info(\"Create collection \" + name + \" on \" + createOnNodes);\n    \n    for (String replica : createOnNodes) {\n      // TODO: this does not work if original url had _ in it\n      // We should have a master list\n      replica = replica.replaceAll(\"_\", \"/\");\n      params.set(CoreAdminParams.NAME, name);\n      params.set(\"collection.configName\", configName);\n      params.set(\"numShards\", numShards);\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      // TODO: this sucks\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {\n    \n    // look at the replication factor and see if it matches reality\n    // if it does not, find best nodes to create more cores\n    \n    String numReplicasString = message.get(\"numReplicas\");\n    int numReplicas;\n    try {\n      numReplicas = numReplicasString == null ? 0 : Integer.parseInt(numReplicasString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numReplicas\", ex);\n      return false;\n    }\n    String numShardsString = message.get(\"numShards\");\n    int numShards;\n    try {\n      numShards = numShardsString == null ? 0 : Integer.parseInt(numShardsString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numShards\", ex);\n      return false;\n    }\n    \n    String name = message.get(\"name\");\n    String configName = message.get(\"collection.configName\");\n    \n    // we need to look at every node and see how many cores it serves\n    // add our new cores to existing nodes serving the least number of cores\n    // but (for now) require that each core goes on a distinct node.\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    \n    \n    // TODO: add smarter options that look at the current number of cores per node?\n    // for now we just go random\n    Set<String> nodes = clusterState.getLiveNodes();\n    List<String> nodeList = new ArrayList<String>(nodes.size());\n    nodeList.addAll(nodes);\n    Collections.shuffle(nodeList);\n    \n    int numNodes = numShards * (numReplicas + 1);\n    List<String> createOnNodes = nodeList.subList(0, Math.min(nodeList.size(), numNodes));\n    \n    log.info(\"Create collection \" + name + \" on \" + createOnNodes);\n    \n    for (String replica : createOnNodes) {\n      // TODO: this does not work if original url had _ in it\n      // We should have a master list\n      replica = replica.replaceAll(\"_\", \"/\");\n      params.set(CoreAdminParams.NAME, name);\n      params.set(\"collection.configName\", configName);\n      params.set(\"numShards\", numShards);\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      // TODO: this sucks\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":["aa16b24e8441c80ef7c503119e979670698c7233"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aa16b24e8441c80ef7c503119e979670698c7233","date":1347735556,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","sourceNew":"  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {\n    \n    // look at the replication factor and see if it matches reality\n    // if it does not, find best nodes to create more cores\n    \n    String numReplicasString = message.getStr(REPLICATION_FACTOR);\n    int numReplicas;\n    try {\n      numReplicas = numReplicasString == null ? 0 : Integer.parseInt(numReplicasString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse \" + REPLICATION_FACTOR, ex);\n      return false;\n    }\n    String numShardsString = message.getStr(\"numShards\");\n    int numShards;\n    try {\n      numShards = numShardsString == null ? 0 : Integer.parseInt(numShardsString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numShards\", ex);\n      return false;\n    }\n    \n    String name = message.getStr(\"name\");\n    String configName = message.getStr(\"collection.configName\");\n    \n    // we need to look at every node and see how many cores it serves\n    // add our new cores to existing nodes serving the least number of cores\n    // but (for now) require that each core goes on a distinct node.\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    \n    \n    // TODO: add smarter options that look at the current number of cores per node?\n    // for now we just go random\n    Set<String> nodes = clusterState.getLiveNodes();\n    List<String> nodeList = new ArrayList<String>(nodes.size());\n    nodeList.addAll(nodes);\n    Collections.shuffle(nodeList);\n    \n    int numNodes = numShards * (numReplicas + 1);\n    List<String> createOnNodes = nodeList.subList(0, Math.min(nodeList.size(), numNodes));\n    \n    log.info(\"Create collection \" + name + \" on \" + createOnNodes);\n    \n    for (String replica : createOnNodes) {\n      // TODO: this does not work if original url had _ in it\n      // We should have a master list\n      replica = replica.replaceAll(\"_\", \"/\");\n      params.set(CoreAdminParams.NAME, name);\n      params.set(\"collection.configName\", configName);\n      params.set(\"numShards\", numShards);\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      // TODO: this sucks\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {\n    \n    // look at the replication factor and see if it matches reality\n    // if it does not, find best nodes to create more cores\n    \n    String numReplicasString = message.getStr(\"numReplicas\");\n    int numReplicas;\n    try {\n      numReplicas = numReplicasString == null ? 0 : Integer.parseInt(numReplicasString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numReplicas\", ex);\n      return false;\n    }\n    String numShardsString = message.getStr(\"numShards\");\n    int numShards;\n    try {\n      numShards = numShardsString == null ? 0 : Integer.parseInt(numShardsString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numShards\", ex);\n      return false;\n    }\n    \n    String name = message.getStr(\"name\");\n    String configName = message.getStr(\"collection.configName\");\n    \n    // we need to look at every node and see how many cores it serves\n    // add our new cores to existing nodes serving the least number of cores\n    // but (for now) require that each core goes on a distinct node.\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    \n    \n    // TODO: add smarter options that look at the current number of cores per node?\n    // for now we just go random\n    Set<String> nodes = clusterState.getLiveNodes();\n    List<String> nodeList = new ArrayList<String>(nodes.size());\n    nodeList.addAll(nodes);\n    Collections.shuffle(nodeList);\n    \n    int numNodes = numShards * (numReplicas + 1);\n    List<String> createOnNodes = nodeList.subList(0, Math.min(nodeList.size(), numNodes));\n    \n    log.info(\"Create collection \" + name + \" on \" + createOnNodes);\n    \n    for (String replica : createOnNodes) {\n      // TODO: this does not work if original url had _ in it\n      // We should have a master list\n      replica = replica.replaceAll(\"_\", \"/\");\n      params.set(CoreAdminParams.NAME, name);\n      params.set(\"collection.configName\", configName);\n      params.set(\"numShards\", numShards);\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      // TODO: this sucks\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":["33d0ed80b7b47e34ad3ff033a77544563aba3085","fa64435b5902ce266c23755a4a00691a3285dab8"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9460da0c2d9281eb6a595fbb0f54b3908e10855e","date":1353388087,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","sourceNew":"  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {\n\t  String collectionName = message.getStr(\"name\");\n\t  if(clusterState.getCollections().contains(collectionName)) {\n\t    SolrException.log(log, \"collection already exists: \" + collectionName);\n\t\t  return false;\n\t  }\n\t  \n    // look at the replication factor and see if it matches reality\n    // if it does not, find best nodes to create more cores\n    \n    String numReplicasString = message.getStr(REPLICATION_FACTOR);\n    int numReplicas;\n    try {\n      numReplicas = numReplicasString == null ? 0 : Integer.parseInt(numReplicasString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse \" + REPLICATION_FACTOR, ex);\n      return false;\n    }\n    String numShardsString = message.getStr(\"numShards\");\n    int numShards;\n    try {\n      numShards = numShardsString == null ? 0 : Integer.parseInt(numShardsString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numShards\", ex);\n      return false;\n    }\n    \n    if (numReplicas < 0) {\n      SolrException.log(log, REPLICATION_FACTOR + \" must be > 0\");\n      return false;\n    }\n    \n    if (numShards < 0) {\n      SolrException.log(log, \"numShards must be > 0\");\n      return false;\n    }\n    \n    \n    String name = message.getStr(\"name\");\n    String configName = message.getStr(\"collection.configName\");\n    \n    // we need to look at every node and see how many cores it serves\n    // add our new cores to existing nodes serving the least number of cores\n    // but (for now) require that each core goes on a distinct node.\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    \n    \n    // TODO: add smarter options that look at the current number of cores per node?\n    // for now we just go random\n    Set<String> nodes = clusterState.getLiveNodes();\n    List<String> nodeList = new ArrayList<String>(nodes.size());\n    nodeList.addAll(nodes);\n    Collections.shuffle(nodeList);\n    \n    int numNodes = numShards * (numReplicas + 1);\n    if (nodeList.size() < numNodes) {\n      log.warn(\"Not enough nodes available to satisfy create collection request for collection:\"\n                  + collectionName\n                  + \" nodes needed:\"\n                  + numNodes\n                  + \" nodes available:\" + nodeList.size() + \" - using nodes available\");\n    }\n\n    List<String> createOnNodes = nodeList.subList(0, Math.min(nodeList.size(), numNodes));\n    \n    log.info(\"Create collection \" + name + \" on \" + createOnNodes);\n    \n    for (String replica : createOnNodes) {\n      // TODO: this does not work if original url had _ in it\n      // We should have a master list\n      replica = replica.replaceAll(\"_\", \"/\");\n      params.set(CoreAdminParams.NAME, name);\n      params.set(\"collection.configName\", configName);\n      params.set(\"numShards\", numShards);\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      // TODO: this sucks\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {\n    \n    // look at the replication factor and see if it matches reality\n    // if it does not, find best nodes to create more cores\n    \n    String numReplicasString = message.getStr(REPLICATION_FACTOR);\n    int numReplicas;\n    try {\n      numReplicas = numReplicasString == null ? 0 : Integer.parseInt(numReplicasString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse \" + REPLICATION_FACTOR, ex);\n      return false;\n    }\n    String numShardsString = message.getStr(\"numShards\");\n    int numShards;\n    try {\n      numShards = numShardsString == null ? 0 : Integer.parseInt(numShardsString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numShards\", ex);\n      return false;\n    }\n    \n    String name = message.getStr(\"name\");\n    String configName = message.getStr(\"collection.configName\");\n    \n    // we need to look at every node and see how many cores it serves\n    // add our new cores to existing nodes serving the least number of cores\n    // but (for now) require that each core goes on a distinct node.\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    \n    \n    // TODO: add smarter options that look at the current number of cores per node?\n    // for now we just go random\n    Set<String> nodes = clusterState.getLiveNodes();\n    List<String> nodeList = new ArrayList<String>(nodes.size());\n    nodeList.addAll(nodes);\n    Collections.shuffle(nodeList);\n    \n    int numNodes = numShards * (numReplicas + 1);\n    List<String> createOnNodes = nodeList.subList(0, Math.min(nodeList.size(), numNodes));\n    \n    log.info(\"Create collection \" + name + \" on \" + createOnNodes);\n    \n    for (String replica : createOnNodes) {\n      // TODO: this does not work if original url had _ in it\n      // We should have a master list\n      replica = replica.replaceAll(\"_\", \"/\");\n      params.set(CoreAdminParams.NAME, name);\n      params.set(\"collection.configName\", configName);\n      params.set(\"numShards\", numShards);\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      // TODO: this sucks\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":["0381bf7061f92a7137c264b739b8f095ba124193"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0381bf7061f92a7137c264b739b8f095ba124193","date":1353389257,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","sourceNew":"  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {\n    String collectionName = message.getStr(\"name\");\n    if (clusterState.getCollections().contains(collectionName)) {\n      SolrException.log(log, \"collection already exists: \" + collectionName);\n      return false;\n    }\n\n    // look at the replication factor and see if it matches reality\n    // if it does not, find best nodes to create more cores\n    \n    String numReplicasString = message.getStr(REPLICATION_FACTOR);\n    int numReplicas;\n    try {\n      numReplicas = numReplicasString == null ? 0 : Integer.parseInt(numReplicasString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse \" + REPLICATION_FACTOR, ex);\n      return false;\n    }\n    String numShardsString = message.getStr(\"numShards\");\n    int numShards;\n    try {\n      numShards = numShardsString == null ? 0 : Integer.parseInt(numShardsString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numShards\", ex);\n      return false;\n    }\n    \n    if (numReplicas < 0) {\n      SolrException.log(log, REPLICATION_FACTOR + \" must be > 0\");\n      return false;\n    }\n    \n    if (numShards < 0) {\n      SolrException.log(log, \"numShards must be > 0\");\n      return false;\n    }\n    \n    \n    String name = message.getStr(\"name\");\n    String configName = message.getStr(\"collection.configName\");\n    \n    // we need to look at every node and see how many cores it serves\n    // add our new cores to existing nodes serving the least number of cores\n    // but (for now) require that each core goes on a distinct node.\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    \n    \n    // TODO: add smarter options that look at the current number of cores per node?\n    // for now we just go random\n    Set<String> nodes = clusterState.getLiveNodes();\n    List<String> nodeList = new ArrayList<String>(nodes.size());\n    nodeList.addAll(nodes);\n    Collections.shuffle(nodeList);\n    \n    int numNodes = numShards * (numReplicas + 1);\n    if (nodeList.size() < numNodes) {\n      log.warn(\"Not enough nodes available to satisfy create collection request for collection:\"\n          + collectionName\n          + \" nodes needed:\"\n          + numNodes\n          + \" nodes available:\"\n          + nodeList.size() + \" - using nodes available\");\n    }\n\n    List<String> createOnNodes = nodeList.subList(0, Math.min(nodeList.size(), numNodes));\n    \n    log.info(\"Create collection \" + name + \" on \" + createOnNodes);\n    \n    for (String replica : createOnNodes) {\n      // TODO: this does not work if original url had _ in it\n      // We should have a master list\n      replica = replica.replaceAll(\"_\", \"/\");\n      params.set(CoreAdminParams.NAME, name);\n      params.set(\"collection.configName\", configName);\n      params.set(\"numShards\", numShards);\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      // TODO: this sucks\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {\n\t  String collectionName = message.getStr(\"name\");\n\t  if(clusterState.getCollections().contains(collectionName)) {\n\t    SolrException.log(log, \"collection already exists: \" + collectionName);\n\t\t  return false;\n\t  }\n\t  \n    // look at the replication factor and see if it matches reality\n    // if it does not, find best nodes to create more cores\n    \n    String numReplicasString = message.getStr(REPLICATION_FACTOR);\n    int numReplicas;\n    try {\n      numReplicas = numReplicasString == null ? 0 : Integer.parseInt(numReplicasString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse \" + REPLICATION_FACTOR, ex);\n      return false;\n    }\n    String numShardsString = message.getStr(\"numShards\");\n    int numShards;\n    try {\n      numShards = numShardsString == null ? 0 : Integer.parseInt(numShardsString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numShards\", ex);\n      return false;\n    }\n    \n    if (numReplicas < 0) {\n      SolrException.log(log, REPLICATION_FACTOR + \" must be > 0\");\n      return false;\n    }\n    \n    if (numShards < 0) {\n      SolrException.log(log, \"numShards must be > 0\");\n      return false;\n    }\n    \n    \n    String name = message.getStr(\"name\");\n    String configName = message.getStr(\"collection.configName\");\n    \n    // we need to look at every node and see how many cores it serves\n    // add our new cores to existing nodes serving the least number of cores\n    // but (for now) require that each core goes on a distinct node.\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    \n    \n    // TODO: add smarter options that look at the current number of cores per node?\n    // for now we just go random\n    Set<String> nodes = clusterState.getLiveNodes();\n    List<String> nodeList = new ArrayList<String>(nodes.size());\n    nodeList.addAll(nodes);\n    Collections.shuffle(nodeList);\n    \n    int numNodes = numShards * (numReplicas + 1);\n    if (nodeList.size() < numNodes) {\n      log.warn(\"Not enough nodes available to satisfy create collection request for collection:\"\n                  + collectionName\n                  + \" nodes needed:\"\n                  + numNodes\n                  + \" nodes available:\" + nodeList.size() + \" - using nodes available\");\n    }\n\n    List<String> createOnNodes = nodeList.subList(0, Math.min(nodeList.size(), numNodes));\n    \n    log.info(\"Create collection \" + name + \" on \" + createOnNodes);\n    \n    for (String replica : createOnNodes) {\n      // TODO: this does not work if original url had _ in it\n      // We should have a master list\n      replica = replica.replaceAll(\"_\", \"/\");\n      params.set(CoreAdminParams.NAME, name);\n      params.set(\"collection.configName\", configName);\n      params.set(\"numShards\", numShards);\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      // TODO: this sucks\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":["9460da0c2d9281eb6a595fbb0f54b3908e10855e"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f7985b168f6fddf7c63c36bed85c47c16011c3cc","date":1354115327,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","sourceNew":"  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {\n    String collectionName = message.getStr(\"name\");\n    if (clusterState.getCollections().contains(collectionName)) {\n      SolrException.log(log, \"collection already exists: \" + collectionName);\n      return false;\n    }\n\n    // look at the replication factor and see if it matches reality\n    // if it does not, find best nodes to create more cores\n    \n    String numReplicasString = message.getStr(REPLICATION_FACTOR);\n    int numReplicas;\n    try {\n      numReplicas = numReplicasString == null ? 0 : Integer.parseInt(numReplicasString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse \" + REPLICATION_FACTOR, ex);\n      return false;\n    }\n    String numShardsString = message.getStr(\"numShards\");\n    int numShards;\n    try {\n      numShards = numShardsString == null ? 0 : Integer.parseInt(numShardsString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numShards\", ex);\n      return false;\n    }\n    \n    if (numReplicas < 0) {\n      SolrException.log(log, REPLICATION_FACTOR + \" must be > 0\");\n      return false;\n    }\n    \n    if (numShards < 0) {\n      SolrException.log(log, \"numShards must be > 0\");\n      return false;\n    }\n    \n    \n    String name = message.getStr(\"name\");\n    String configName = message.getStr(\"collection.configName\");\n    \n    // we need to look at every node and see how many cores it serves\n    // add our new cores to existing nodes serving the least number of cores\n    // but (for now) require that each core goes on a distinct node.\n\n    // TODO: add smarter options that look at the current number of cores per node?\n    // for now we just go random\n    Set<String> nodes = clusterState.getLiveNodes();\n    List<String> nodeList = new ArrayList<String>(nodes.size());\n    nodeList.addAll(nodes);\n    Collections.shuffle(nodeList);\n    \n    int numNodes = numShards * (numReplicas + 1);\n    if (nodeList.size() < numNodes) {\n      log.warn(\"Not enough nodes available to satisfy create collection request for collection:\"\n          + collectionName\n          + \" nodes needed:\"\n          + numNodes\n          + \" nodes available:\"\n          + nodeList.size() + \" - using nodes available\");\n    }\n\n    List<String> createOnNodes = nodeList.subList(0, Math.min(nodeList.size(), numNodes));\n    \n    log.info(\"Create collection \" + name + \" on \" + createOnNodes);\n    \n    for (String replica : createOnNodes) {\n      // TODO: this does not work if original url had _ in it\n      // We should have a master list\n      \n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n      \n      replica = replica.replaceAll(\"_\", \"/\");\n      params.set(CoreAdminParams.NAME, name);\n      params.set(\"collection.configName\", configName);\n      params.set(\"numShards\", numShards);\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      // TODO: this sucks\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {\n    String collectionName = message.getStr(\"name\");\n    if (clusterState.getCollections().contains(collectionName)) {\n      SolrException.log(log, \"collection already exists: \" + collectionName);\n      return false;\n    }\n\n    // look at the replication factor and see if it matches reality\n    // if it does not, find best nodes to create more cores\n    \n    String numReplicasString = message.getStr(REPLICATION_FACTOR);\n    int numReplicas;\n    try {\n      numReplicas = numReplicasString == null ? 0 : Integer.parseInt(numReplicasString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse \" + REPLICATION_FACTOR, ex);\n      return false;\n    }\n    String numShardsString = message.getStr(\"numShards\");\n    int numShards;\n    try {\n      numShards = numShardsString == null ? 0 : Integer.parseInt(numShardsString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numShards\", ex);\n      return false;\n    }\n    \n    if (numReplicas < 0) {\n      SolrException.log(log, REPLICATION_FACTOR + \" must be > 0\");\n      return false;\n    }\n    \n    if (numShards < 0) {\n      SolrException.log(log, \"numShards must be > 0\");\n      return false;\n    }\n    \n    \n    String name = message.getStr(\"name\");\n    String configName = message.getStr(\"collection.configName\");\n    \n    // we need to look at every node and see how many cores it serves\n    // add our new cores to existing nodes serving the least number of cores\n    // but (for now) require that each core goes on a distinct node.\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    \n    \n    // TODO: add smarter options that look at the current number of cores per node?\n    // for now we just go random\n    Set<String> nodes = clusterState.getLiveNodes();\n    List<String> nodeList = new ArrayList<String>(nodes.size());\n    nodeList.addAll(nodes);\n    Collections.shuffle(nodeList);\n    \n    int numNodes = numShards * (numReplicas + 1);\n    if (nodeList.size() < numNodes) {\n      log.warn(\"Not enough nodes available to satisfy create collection request for collection:\"\n          + collectionName\n          + \" nodes needed:\"\n          + numNodes\n          + \" nodes available:\"\n          + nodeList.size() + \" - using nodes available\");\n    }\n\n    List<String> createOnNodes = nodeList.subList(0, Math.min(nodeList.size(), numNodes));\n    \n    log.info(\"Create collection \" + name + \" on \" + createOnNodes);\n    \n    for (String replica : createOnNodes) {\n      // TODO: this does not work if original url had _ in it\n      // We should have a master list\n      replica = replica.replaceAll(\"_\", \"/\");\n      params.set(CoreAdminParams.NAME, name);\n      params.set(\"collection.configName\", configName);\n      params.set(\"numShards\", numShards);\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      // TODO: this sucks\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":["33d0ed80b7b47e34ad3ff033a77544563aba3085"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c215736a9e29403edd2132d9f0829a287b428df4","date":1354641965,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","sourceNew":"  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {\n    String collectionName = message.getStr(\"name\");\n    if (clusterState.getCollections().contains(collectionName)) {\n      SolrException.log(log, \"collection already exists: \" + collectionName);\n      return false;\n    }\n    \n    try {\n      // look at the replication factor and see if it matches reality\n      // if it does not, find best nodes to create more cores\n      \n      int numReplica = msgStrToInt(message, REPLICATION_FACTOR, 0);\n      int numSlices = msgStrToInt(message, NUM_SLICES, 0);\n      int maxShardsPerNode = msgStrToInt(message, MAX_SHARDS_PER_NODE, 1);\n      \n      if (numReplica < 0) {\n        SolrException.log(log, REPLICATION_FACTOR + \" must be > 0\");\n        return false;\n      }\n      \n      if (numSlices < 0) {\n        SolrException.log(log, NUM_SLICES + \" must be > 0\");\n        return false;\n      }\n      \n      String configName = message.getStr(\"collection.configName\");\n      \n      // we need to look at every node and see how many cores it serves\n      // add our new cores to existing nodes serving the least number of cores\n      // but (for now) require that each core goes on a distinct node.\n      \n      // TODO: add smarter options that look at the current number of cores per\n      // node?\n      // for now we just go random\n      Set<String> nodes = clusterState.getLiveNodes();\n      List<String> nodeList = new ArrayList<String>(nodes.size());\n      nodeList.addAll(nodes);\n      Collections.shuffle(nodeList);\n      \n      if (nodeList.size() <= 0) {\n        log.error(\"Cannot create collection \" + collectionName\n            + \". No live Solr-instaces\");\n        return false;\n      }\n      \n      int numShardsPerSlice = numReplica + 1;\n      if (numShardsPerSlice > nodeList.size()) {\n        log.warn(\"Specified \"\n            + REPLICATION_FACTOR\n            + \" of \"\n            + numReplica\n            + \" on collection \"\n            + collectionName\n            + \" is higher than or equal to the number of Solr instances currently live (\"\n            + nodeList.size()\n            + \"). Its unusual to run two replica of the same slice on the same Solr-instance.\");\n      }\n      \n      int maxShardsAllowedToCreate = maxShardsPerNode * nodeList.size();\n      int requestedShardsToCreate = numSlices * numShardsPerSlice;\n      if (maxShardsAllowedToCreate < requestedShardsToCreate) {\n        log.error(\"Cannot create collection \" + collectionName + \". Value of \"\n            + MAX_SHARDS_PER_NODE + \" is \" + maxShardsPerNode\n            + \", and the number of live nodes is \" + nodeList.size()\n            + \". This allows a maximum of \" + maxShardsAllowedToCreate\n            + \" to be created. Value of \" + NUM_SLICES + \" is \" + numSlices\n            + \" and value of \" + REPLICATION_FACTOR + \" is \" + numReplica\n            + \". This requires \" + requestedShardsToCreate\n            + \" shards to be created (higher than the allowed number)\");\n        return false;\n      }\n      \n      for (int i = 1; i <= numSlices; i++) {\n        for (int j = 1; j <= numShardsPerSlice; j++) {\n          String nodeName = nodeList.get(((i - 1) + (j - 1)) % nodeList.size());\n          String sliceName = \"shard\" + i;\n          String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n          log.info(\"Creating shard \" + shardName + \" as part of slice \"\n              + sliceName + \" of collection \" + collectionName + \" on \"\n              + nodeName);\n          \n          // Need to create new params for each request\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n          \n          params.set(CoreAdminParams.NAME, shardName);\n          params.set(\"collection.configName\", configName);\n          params.set(CoreAdminParams.COLLECTION, collectionName);\n          params.set(CoreAdminParams.SHARD, sliceName);\n          params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n          \n          ShardRequest sreq = new ShardRequest();\n          params.set(\"qt\", adminPath);\n          sreq.purpose = 1;\n          // TODO: this does not work if original url had _ in it\n          // We should have a master list\n          String replica = nodeName.replaceAll(\"_\", \"/\");\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = params;\n          \n          shardHandler.submit(sreq, replica, sreq.params);\n          \n        }\n      }\n      \n      int failed = 0;\n      ShardResponse srsp;\n      do {\n        srsp = shardHandler.takeCompletedOrError();\n        if (srsp != null) {\n          Throwable e = srsp.getException();\n          if (e != null) {\n            // should we retry?\n            // TODO: we should return errors to the client\n            // TODO: what if one fails and others succeed?\n            failed++;\n            log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n          }\n        }\n      } while (srsp != null);\n      \n      // if all calls succeeded, return true\n      if (failed > 0) {\n        return false;\n      }\n      log.info(\"Successfully created all shards for collection \"\n          + collectionName);\n      return true;\n    } catch (Exception ex) {\n      // Expecting that the necessary logging has already been performed\n      return false;\n    }\n  }\n\n","sourceOld":"  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {\n    String collectionName = message.getStr(\"name\");\n    if (clusterState.getCollections().contains(collectionName)) {\n      SolrException.log(log, \"collection already exists: \" + collectionName);\n      return false;\n    }\n\n    // look at the replication factor and see if it matches reality\n    // if it does not, find best nodes to create more cores\n    \n    String numReplicasString = message.getStr(REPLICATION_FACTOR);\n    int numReplicas;\n    try {\n      numReplicas = numReplicasString == null ? 0 : Integer.parseInt(numReplicasString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse \" + REPLICATION_FACTOR, ex);\n      return false;\n    }\n    String numShardsString = message.getStr(\"numShards\");\n    int numShards;\n    try {\n      numShards = numShardsString == null ? 0 : Integer.parseInt(numShardsString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numShards\", ex);\n      return false;\n    }\n    \n    if (numReplicas < 0) {\n      SolrException.log(log, REPLICATION_FACTOR + \" must be > 0\");\n      return false;\n    }\n    \n    if (numShards < 0) {\n      SolrException.log(log, \"numShards must be > 0\");\n      return false;\n    }\n    \n    \n    String name = message.getStr(\"name\");\n    String configName = message.getStr(\"collection.configName\");\n    \n    // we need to look at every node and see how many cores it serves\n    // add our new cores to existing nodes serving the least number of cores\n    // but (for now) require that each core goes on a distinct node.\n\n    // TODO: add smarter options that look at the current number of cores per node?\n    // for now we just go random\n    Set<String> nodes = clusterState.getLiveNodes();\n    List<String> nodeList = new ArrayList<String>(nodes.size());\n    nodeList.addAll(nodes);\n    Collections.shuffle(nodeList);\n    \n    int numNodes = numShards * (numReplicas + 1);\n    if (nodeList.size() < numNodes) {\n      log.warn(\"Not enough nodes available to satisfy create collection request for collection:\"\n          + collectionName\n          + \" nodes needed:\"\n          + numNodes\n          + \" nodes available:\"\n          + nodeList.size() + \" - using nodes available\");\n    }\n\n    List<String> createOnNodes = nodeList.subList(0, Math.min(nodeList.size(), numNodes));\n    \n    log.info(\"Create collection \" + name + \" on \" + createOnNodes);\n    \n    for (String replica : createOnNodes) {\n      // TODO: this does not work if original url had _ in it\n      // We should have a master list\n      \n      // Need to create new params for each request\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n      \n      replica = replica.replaceAll(\"_\", \"/\");\n      params.set(CoreAdminParams.NAME, name);\n      params.set(\"collection.configName\", configName);\n      params.set(\"numShards\", numShards);\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      // TODO: this sucks\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":["ccf4d8c4536f02247aec7edc26a89e19c5c05dd4","6ba2b0062c52d2287d625a2a3f922ed4f8697f4e","efefd19367eebaa6d911ba8f441a30b7b7564e26","103857ec20f79f31c7a00310a91ed001b9a6ef17"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","sourceNew":"  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {\n    String collectionName = message.getStr(\"name\");\n    if (clusterState.getCollections().contains(collectionName)) {\n      SolrException.log(log, \"collection already exists: \" + collectionName);\n      return false;\n    }\n    \n    try {\n      // look at the replication factor and see if it matches reality\n      // if it does not, find best nodes to create more cores\n      \n      int numReplica = msgStrToInt(message, REPLICATION_FACTOR, 0);\n      int numSlices = msgStrToInt(message, NUM_SLICES, 0);\n      int maxShardsPerNode = msgStrToInt(message, MAX_SHARDS_PER_NODE, 1);\n      \n      if (numReplica < 0) {\n        SolrException.log(log, REPLICATION_FACTOR + \" must be > 0\");\n        return false;\n      }\n      \n      if (numSlices < 0) {\n        SolrException.log(log, NUM_SLICES + \" must be > 0\");\n        return false;\n      }\n      \n      String configName = message.getStr(\"collection.configName\");\n      \n      // we need to look at every node and see how many cores it serves\n      // add our new cores to existing nodes serving the least number of cores\n      // but (for now) require that each core goes on a distinct node.\n      \n      // TODO: add smarter options that look at the current number of cores per\n      // node?\n      // for now we just go random\n      Set<String> nodes = clusterState.getLiveNodes();\n      List<String> nodeList = new ArrayList<String>(nodes.size());\n      nodeList.addAll(nodes);\n      Collections.shuffle(nodeList);\n      \n      if (nodeList.size() <= 0) {\n        log.error(\"Cannot create collection \" + collectionName\n            + \". No live Solr-instaces\");\n        return false;\n      }\n      \n      int numShardsPerSlice = numReplica + 1;\n      if (numShardsPerSlice > nodeList.size()) {\n        log.warn(\"Specified \"\n            + REPLICATION_FACTOR\n            + \" of \"\n            + numReplica\n            + \" on collection \"\n            + collectionName\n            + \" is higher than or equal to the number of Solr instances currently live (\"\n            + nodeList.size()\n            + \"). Its unusual to run two replica of the same slice on the same Solr-instance.\");\n      }\n      \n      int maxShardsAllowedToCreate = maxShardsPerNode * nodeList.size();\n      int requestedShardsToCreate = numSlices * numShardsPerSlice;\n      if (maxShardsAllowedToCreate < requestedShardsToCreate) {\n        log.error(\"Cannot create collection \" + collectionName + \". Value of \"\n            + MAX_SHARDS_PER_NODE + \" is \" + maxShardsPerNode\n            + \", and the number of live nodes is \" + nodeList.size()\n            + \". This allows a maximum of \" + maxShardsAllowedToCreate\n            + \" to be created. Value of \" + NUM_SLICES + \" is \" + numSlices\n            + \" and value of \" + REPLICATION_FACTOR + \" is \" + numReplica\n            + \". This requires \" + requestedShardsToCreate\n            + \" shards to be created (higher than the allowed number)\");\n        return false;\n      }\n      \n      for (int i = 1; i <= numSlices; i++) {\n        for (int j = 1; j <= numShardsPerSlice; j++) {\n          String nodeName = nodeList.get(((i - 1) + (j - 1)) % nodeList.size());\n          String sliceName = \"shard\" + i;\n          String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n          log.info(\"Creating shard \" + shardName + \" as part of slice \"\n              + sliceName + \" of collection \" + collectionName + \" on \"\n              + nodeName);\n          \n          // Need to create new params for each request\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n          \n          params.set(CoreAdminParams.NAME, shardName);\n          params.set(\"collection.configName\", configName);\n          params.set(CoreAdminParams.COLLECTION, collectionName);\n          params.set(CoreAdminParams.SHARD, sliceName);\n          params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n          \n          ShardRequest sreq = new ShardRequest();\n          params.set(\"qt\", adminPath);\n          sreq.purpose = 1;\n          // TODO: this does not work if original url had _ in it\n          // We should have a master list\n          String replica = nodeName.replaceAll(\"_\", \"/\");\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = params;\n          \n          shardHandler.submit(sreq, replica, sreq.params);\n          \n        }\n      }\n      \n      int failed = 0;\n      ShardResponse srsp;\n      do {\n        srsp = shardHandler.takeCompletedOrError();\n        if (srsp != null) {\n          Throwable e = srsp.getException();\n          if (e != null) {\n            // should we retry?\n            // TODO: we should return errors to the client\n            // TODO: what if one fails and others succeed?\n            failed++;\n            log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n          }\n        }\n      } while (srsp != null);\n      \n      // if all calls succeeded, return true\n      if (failed > 0) {\n        return false;\n      }\n      log.info(\"Successfully created all shards for collection \"\n          + collectionName);\n      return true;\n    } catch (Exception ex) {\n      // Expecting that the necessary logging has already been performed\n      return false;\n    }\n  }\n\n","sourceOld":"  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {\n    \n    // look at the replication factor and see if it matches reality\n    // if it does not, find best nodes to create more cores\n    \n    String numReplicasString = message.getStr(REPLICATION_FACTOR);\n    int numReplicas;\n    try {\n      numReplicas = numReplicasString == null ? 0 : Integer.parseInt(numReplicasString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse \" + REPLICATION_FACTOR, ex);\n      return false;\n    }\n    String numShardsString = message.getStr(\"numShards\");\n    int numShards;\n    try {\n      numShards = numShardsString == null ? 0 : Integer.parseInt(numShardsString);\n    } catch (Exception ex) {\n      SolrException.log(log, \"Could not parse numShards\", ex);\n      return false;\n    }\n    \n    String name = message.getStr(\"name\");\n    String configName = message.getStr(\"collection.configName\");\n    \n    // we need to look at every node and see how many cores it serves\n    // add our new cores to existing nodes serving the least number of cores\n    // but (for now) require that each core goes on a distinct node.\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n    \n    \n    // TODO: add smarter options that look at the current number of cores per node?\n    // for now we just go random\n    Set<String> nodes = clusterState.getLiveNodes();\n    List<String> nodeList = new ArrayList<String>(nodes.size());\n    nodeList.addAll(nodes);\n    Collections.shuffle(nodeList);\n    \n    int numNodes = numShards * (numReplicas + 1);\n    List<String> createOnNodes = nodeList.subList(0, Math.min(nodeList.size(), numNodes));\n    \n    log.info(\"Create collection \" + name + \" on \" + createOnNodes);\n    \n    for (String replica : createOnNodes) {\n      // TODO: this does not work if original url had _ in it\n      // We should have a master list\n      replica = replica.replaceAll(\"_\", \"/\");\n      params.set(CoreAdminParams.NAME, name);\n      params.set(\"collection.configName\", configName);\n      params.set(\"numShards\", numShards);\n      ShardRequest sreq = new ShardRequest();\n      params.set(\"qt\", adminPath);\n      sreq.purpose = 1;\n      // TODO: this sucks\n      if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n      sreq.shards = new String[] {replica};\n      sreq.actualShards = sreq.shards;\n      sreq.params = params;\n      \n      shardHandler.submit(sreq, replica, sreq.params);\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ccf4d8c4536f02247aec7edc26a89e19c5c05dd4","date":1355167764,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","sourceNew":"  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {\n    String collectionName = message.getStr(\"name\");\n    if (clusterState.getCollections().contains(collectionName)) {\n      SolrException.log(log, \"collection already exists: \" + collectionName);\n      return false;\n    }\n    \n    try {\n      // look at the replication factor and see if it matches reality\n      // if it does not, find best nodes to create more cores\n      \n      int repFactor = msgStrToInt(message, REPLICATION_FACTOR, 1);\n      int numSlices = msgStrToInt(message, NUM_SLICES, 0);\n      int maxShardsPerNode = msgStrToInt(message, MAX_SHARDS_PER_NODE, 1);\n      \n      if (repFactor <= 0) {\n        SolrException.log(log, REPLICATION_FACTOR + \" must be > 0\");\n        return false;\n      }\n      \n      if (numSlices < 0) {\n        SolrException.log(log, NUM_SLICES + \" must be > 0\");\n        return false;\n      }\n      \n      String configName = message.getStr(\"collection.configName\");\n      \n      // we need to look at every node and see how many cores it serves\n      // add our new cores to existing nodes serving the least number of cores\n      // but (for now) require that each core goes on a distinct node.\n      \n      // TODO: add smarter options that look at the current number of cores per\n      // node?\n      // for now we just go random\n      Set<String> nodes = clusterState.getLiveNodes();\n      List<String> nodeList = new ArrayList<String>(nodes.size());\n      nodeList.addAll(nodes);\n      Collections.shuffle(nodeList);\n      \n      if (nodeList.size() <= 0) {\n        log.error(\"Cannot create collection \" + collectionName\n            + \". No live Solr-instaces\");\n        return false;\n      }\n      \n      if (repFactor > nodeList.size()) {\n        log.warn(\"Specified \"\n            + REPLICATION_FACTOR\n            + \" of \"\n            + repFactor\n            + \" on collection \"\n            + collectionName\n            + \" is higher than or equal to the number of Solr instances currently live (\"\n            + nodeList.size()\n            + \"). Its unusual to run two replica of the same slice on the same Solr-instance.\");\n      }\n      \n      int maxShardsAllowedToCreate = maxShardsPerNode * nodeList.size();\n      int requestedShardsToCreate = numSlices * repFactor;\n      if (maxShardsAllowedToCreate < requestedShardsToCreate) {\n        log.error(\"Cannot create collection \" + collectionName + \". Value of \"\n            + MAX_SHARDS_PER_NODE + \" is \" + maxShardsPerNode\n            + \", and the number of live nodes is \" + nodeList.size()\n            + \". This allows a maximum of \" + maxShardsAllowedToCreate\n            + \" to be created. Value of \" + NUM_SLICES + \" is \" + numSlices\n            + \" and value of \" + REPLICATION_FACTOR + \" is \" + repFactor\n            + \". This requires \" + requestedShardsToCreate\n            + \" shards to be created (higher than the allowed number)\");\n        return false;\n      }\n      \n      for (int i = 1; i <= numSlices; i++) {\n        for (int j = 1; j <= repFactor; j++) {\n          String nodeName = nodeList.get(((i - 1) + (j - 1)) % nodeList.size());\n          String sliceName = \"shard\" + i;\n          String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n          log.info(\"Creating shard \" + shardName + \" as part of slice \"\n              + sliceName + \" of collection \" + collectionName + \" on \"\n              + nodeName);\n          \n          // Need to create new params for each request\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n          \n          params.set(CoreAdminParams.NAME, shardName);\n          params.set(\"collection.configName\", configName);\n          params.set(CoreAdminParams.COLLECTION, collectionName);\n          params.set(CoreAdminParams.SHARD, sliceName);\n          params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n          \n          ShardRequest sreq = new ShardRequest();\n          params.set(\"qt\", adminPath);\n          sreq.purpose = 1;\n          // TODO: this does not work if original url had _ in it\n          // We should have a master list\n          String replica = nodeName.replaceAll(\"_\", \"/\");\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = params;\n          \n          shardHandler.submit(sreq, replica, sreq.params);\n          \n        }\n      }\n      \n      int failed = 0;\n      ShardResponse srsp;\n      do {\n        srsp = shardHandler.takeCompletedOrError();\n        if (srsp != null) {\n          Throwable e = srsp.getException();\n          if (e != null) {\n            // should we retry?\n            // TODO: we should return errors to the client\n            // TODO: what if one fails and others succeed?\n            failed++;\n            log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n          }\n        }\n      } while (srsp != null);\n      \n      // if all calls succeeded, return true\n      if (failed > 0) {\n        return false;\n      }\n      log.info(\"Successfully created all shards for collection \"\n          + collectionName);\n      return true;\n    } catch (Exception ex) {\n      // Expecting that the necessary logging has already been performed\n      return false;\n    }\n  }\n\n","sourceOld":"  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {\n    String collectionName = message.getStr(\"name\");\n    if (clusterState.getCollections().contains(collectionName)) {\n      SolrException.log(log, \"collection already exists: \" + collectionName);\n      return false;\n    }\n    \n    try {\n      // look at the replication factor and see if it matches reality\n      // if it does not, find best nodes to create more cores\n      \n      int numReplica = msgStrToInt(message, REPLICATION_FACTOR, 0);\n      int numSlices = msgStrToInt(message, NUM_SLICES, 0);\n      int maxShardsPerNode = msgStrToInt(message, MAX_SHARDS_PER_NODE, 1);\n      \n      if (numReplica < 0) {\n        SolrException.log(log, REPLICATION_FACTOR + \" must be > 0\");\n        return false;\n      }\n      \n      if (numSlices < 0) {\n        SolrException.log(log, NUM_SLICES + \" must be > 0\");\n        return false;\n      }\n      \n      String configName = message.getStr(\"collection.configName\");\n      \n      // we need to look at every node and see how many cores it serves\n      // add our new cores to existing nodes serving the least number of cores\n      // but (for now) require that each core goes on a distinct node.\n      \n      // TODO: add smarter options that look at the current number of cores per\n      // node?\n      // for now we just go random\n      Set<String> nodes = clusterState.getLiveNodes();\n      List<String> nodeList = new ArrayList<String>(nodes.size());\n      nodeList.addAll(nodes);\n      Collections.shuffle(nodeList);\n      \n      if (nodeList.size() <= 0) {\n        log.error(\"Cannot create collection \" + collectionName\n            + \". No live Solr-instaces\");\n        return false;\n      }\n      \n      int numShardsPerSlice = numReplica + 1;\n      if (numShardsPerSlice > nodeList.size()) {\n        log.warn(\"Specified \"\n            + REPLICATION_FACTOR\n            + \" of \"\n            + numReplica\n            + \" on collection \"\n            + collectionName\n            + \" is higher than or equal to the number of Solr instances currently live (\"\n            + nodeList.size()\n            + \"). Its unusual to run two replica of the same slice on the same Solr-instance.\");\n      }\n      \n      int maxShardsAllowedToCreate = maxShardsPerNode * nodeList.size();\n      int requestedShardsToCreate = numSlices * numShardsPerSlice;\n      if (maxShardsAllowedToCreate < requestedShardsToCreate) {\n        log.error(\"Cannot create collection \" + collectionName + \". Value of \"\n            + MAX_SHARDS_PER_NODE + \" is \" + maxShardsPerNode\n            + \", and the number of live nodes is \" + nodeList.size()\n            + \". This allows a maximum of \" + maxShardsAllowedToCreate\n            + \" to be created. Value of \" + NUM_SLICES + \" is \" + numSlices\n            + \" and value of \" + REPLICATION_FACTOR + \" is \" + numReplica\n            + \". This requires \" + requestedShardsToCreate\n            + \" shards to be created (higher than the allowed number)\");\n        return false;\n      }\n      \n      for (int i = 1; i <= numSlices; i++) {\n        for (int j = 1; j <= numShardsPerSlice; j++) {\n          String nodeName = nodeList.get(((i - 1) + (j - 1)) % nodeList.size());\n          String sliceName = \"shard\" + i;\n          String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n          log.info(\"Creating shard \" + shardName + \" as part of slice \"\n              + sliceName + \" of collection \" + collectionName + \" on \"\n              + nodeName);\n          \n          // Need to create new params for each request\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n          \n          params.set(CoreAdminParams.NAME, shardName);\n          params.set(\"collection.configName\", configName);\n          params.set(CoreAdminParams.COLLECTION, collectionName);\n          params.set(CoreAdminParams.SHARD, sliceName);\n          params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n          \n          ShardRequest sreq = new ShardRequest();\n          params.set(\"qt\", adminPath);\n          sreq.purpose = 1;\n          // TODO: this does not work if original url had _ in it\n          // We should have a master list\n          String replica = nodeName.replaceAll(\"_\", \"/\");\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = params;\n          \n          shardHandler.submit(sreq, replica, sreq.params);\n          \n        }\n      }\n      \n      int failed = 0;\n      ShardResponse srsp;\n      do {\n        srsp = shardHandler.takeCompletedOrError();\n        if (srsp != null) {\n          Throwable e = srsp.getException();\n          if (e != null) {\n            // should we retry?\n            // TODO: we should return errors to the client\n            // TODO: what if one fails and others succeed?\n            failed++;\n            log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n          }\n        }\n      } while (srsp != null);\n      \n      // if all calls succeeded, return true\n      if (failed > 0) {\n        return false;\n      }\n      log.info(\"Successfully created all shards for collection \"\n          + collectionName);\n      return true;\n    } catch (Exception ex) {\n      // Expecting that the necessary logging has already been performed\n      return false;\n    }\n  }\n\n","bugFix":["c215736a9e29403edd2132d9f0829a287b428df4"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"042891089d57d0e6af18ea6cec15f9e9a7da7d25","date":1355271969,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","sourceNew":"  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {\n    String collectionName = message.getStr(\"name\");\n    if (clusterState.getCollections().contains(collectionName)) {\n      SolrException.log(log, \"collection already exists: \" + collectionName);\n      return false;\n    }\n    \n    try {\n      // look at the replication factor and see if it matches reality\n      // if it does not, find best nodes to create more cores\n      \n      int repFactor = msgStrToInt(message, REPLICATION_FACTOR, 1);\n      int numSlices = msgStrToInt(message, NUM_SLICES, 0);\n      int maxShardsPerNode = msgStrToInt(message, MAX_SHARDS_PER_NODE, 1);\n      \n      if (repFactor <= 0) {\n        SolrException.log(log, REPLICATION_FACTOR + \" must be > 0\");\n        return false;\n      }\n      \n      if (numSlices < 0) {\n        SolrException.log(log, NUM_SLICES + \" must be > 0\");\n        return false;\n      }\n      \n      String configName = message.getStr(\"collection.configName\");\n      \n      // we need to look at every node and see how many cores it serves\n      // add our new cores to existing nodes serving the least number of cores\n      // but (for now) require that each core goes on a distinct node.\n      \n      // TODO: add smarter options that look at the current number of cores per\n      // node?\n      // for now we just go random\n      Set<String> nodes = clusterState.getLiveNodes();\n      List<String> nodeList = new ArrayList<String>(nodes.size());\n      nodeList.addAll(nodes);\n      Collections.shuffle(nodeList);\n      \n      if (nodeList.size() <= 0) {\n        log.error(\"Cannot create collection \" + collectionName\n            + \". No live Solr-instaces\");\n        return false;\n      }\n      \n      if (repFactor > nodeList.size()) {\n        log.warn(\"Specified \"\n            + REPLICATION_FACTOR\n            + \" of \"\n            + repFactor\n            + \" on collection \"\n            + collectionName\n            + \" is higher than or equal to the number of Solr instances currently live (\"\n            + nodeList.size()\n            + \"). Its unusual to run two replica of the same slice on the same Solr-instance.\");\n      }\n      \n      int maxShardsAllowedToCreate = maxShardsPerNode * nodeList.size();\n      int requestedShardsToCreate = numSlices * repFactor;\n      if (maxShardsAllowedToCreate < requestedShardsToCreate) {\n        log.error(\"Cannot create collection \" + collectionName + \". Value of \"\n            + MAX_SHARDS_PER_NODE + \" is \" + maxShardsPerNode\n            + \", and the number of live nodes is \" + nodeList.size()\n            + \". This allows a maximum of \" + maxShardsAllowedToCreate\n            + \" to be created. Value of \" + NUM_SLICES + \" is \" + numSlices\n            + \" and value of \" + REPLICATION_FACTOR + \" is \" + repFactor\n            + \". This requires \" + requestedShardsToCreate\n            + \" shards to be created (higher than the allowed number)\");\n        return false;\n      }\n      \n      for (int i = 1; i <= numSlices; i++) {\n        for (int j = 1; j <= repFactor; j++) {\n          String nodeName = nodeList.get(((i - 1) + (j - 1)) % nodeList.size());\n          String sliceName = \"shard\" + i;\n          String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n          log.info(\"Creating shard \" + shardName + \" as part of slice \"\n              + sliceName + \" of collection \" + collectionName + \" on \"\n              + nodeName);\n          \n          // Need to create new params for each request\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n          \n          params.set(CoreAdminParams.NAME, shardName);\n          params.set(\"collection.configName\", configName);\n          params.set(CoreAdminParams.COLLECTION, collectionName);\n          params.set(CoreAdminParams.SHARD, sliceName);\n          params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n          \n          ShardRequest sreq = new ShardRequest();\n          params.set(\"qt\", adminPath);\n          sreq.purpose = 1;\n          String replica = zkStateReader.getZkClient()\n            .getBaseUrlForNodeName(nodeName);\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = params;\n          \n          shardHandler.submit(sreq, replica, sreq.params);\n          \n        }\n      }\n      \n      int failed = 0;\n      ShardResponse srsp;\n      do {\n        srsp = shardHandler.takeCompletedOrError();\n        if (srsp != null) {\n          Throwable e = srsp.getException();\n          if (e != null) {\n            // should we retry?\n            // TODO: we should return errors to the client\n            // TODO: what if one fails and others succeed?\n            failed++;\n            log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n          }\n        }\n      } while (srsp != null);\n      \n      // if all calls succeeded, return true\n      if (failed > 0) {\n        return false;\n      }\n      log.info(\"Successfully created all shards for collection \"\n          + collectionName);\n      return true;\n    } catch (Exception ex) {\n      // Expecting that the necessary logging has already been performed\n      return false;\n    }\n  }\n\n","sourceOld":"  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {\n    String collectionName = message.getStr(\"name\");\n    if (clusterState.getCollections().contains(collectionName)) {\n      SolrException.log(log, \"collection already exists: \" + collectionName);\n      return false;\n    }\n    \n    try {\n      // look at the replication factor and see if it matches reality\n      // if it does not, find best nodes to create more cores\n      \n      int repFactor = msgStrToInt(message, REPLICATION_FACTOR, 1);\n      int numSlices = msgStrToInt(message, NUM_SLICES, 0);\n      int maxShardsPerNode = msgStrToInt(message, MAX_SHARDS_PER_NODE, 1);\n      \n      if (repFactor <= 0) {\n        SolrException.log(log, REPLICATION_FACTOR + \" must be > 0\");\n        return false;\n      }\n      \n      if (numSlices < 0) {\n        SolrException.log(log, NUM_SLICES + \" must be > 0\");\n        return false;\n      }\n      \n      String configName = message.getStr(\"collection.configName\");\n      \n      // we need to look at every node and see how many cores it serves\n      // add our new cores to existing nodes serving the least number of cores\n      // but (for now) require that each core goes on a distinct node.\n      \n      // TODO: add smarter options that look at the current number of cores per\n      // node?\n      // for now we just go random\n      Set<String> nodes = clusterState.getLiveNodes();\n      List<String> nodeList = new ArrayList<String>(nodes.size());\n      nodeList.addAll(nodes);\n      Collections.shuffle(nodeList);\n      \n      if (nodeList.size() <= 0) {\n        log.error(\"Cannot create collection \" + collectionName\n            + \". No live Solr-instaces\");\n        return false;\n      }\n      \n      if (repFactor > nodeList.size()) {\n        log.warn(\"Specified \"\n            + REPLICATION_FACTOR\n            + \" of \"\n            + repFactor\n            + \" on collection \"\n            + collectionName\n            + \" is higher than or equal to the number of Solr instances currently live (\"\n            + nodeList.size()\n            + \"). Its unusual to run two replica of the same slice on the same Solr-instance.\");\n      }\n      \n      int maxShardsAllowedToCreate = maxShardsPerNode * nodeList.size();\n      int requestedShardsToCreate = numSlices * repFactor;\n      if (maxShardsAllowedToCreate < requestedShardsToCreate) {\n        log.error(\"Cannot create collection \" + collectionName + \". Value of \"\n            + MAX_SHARDS_PER_NODE + \" is \" + maxShardsPerNode\n            + \", and the number of live nodes is \" + nodeList.size()\n            + \". This allows a maximum of \" + maxShardsAllowedToCreate\n            + \" to be created. Value of \" + NUM_SLICES + \" is \" + numSlices\n            + \" and value of \" + REPLICATION_FACTOR + \" is \" + repFactor\n            + \". This requires \" + requestedShardsToCreate\n            + \" shards to be created (higher than the allowed number)\");\n        return false;\n      }\n      \n      for (int i = 1; i <= numSlices; i++) {\n        for (int j = 1; j <= repFactor; j++) {\n          String nodeName = nodeList.get(((i - 1) + (j - 1)) % nodeList.size());\n          String sliceName = \"shard\" + i;\n          String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n          log.info(\"Creating shard \" + shardName + \" as part of slice \"\n              + sliceName + \" of collection \" + collectionName + \" on \"\n              + nodeName);\n          \n          // Need to create new params for each request\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n          \n          params.set(CoreAdminParams.NAME, shardName);\n          params.set(\"collection.configName\", configName);\n          params.set(CoreAdminParams.COLLECTION, collectionName);\n          params.set(CoreAdminParams.SHARD, sliceName);\n          params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n          \n          ShardRequest sreq = new ShardRequest();\n          params.set(\"qt\", adminPath);\n          sreq.purpose = 1;\n          // TODO: this does not work if original url had _ in it\n          // We should have a master list\n          String replica = nodeName.replaceAll(\"_\", \"/\");\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = params;\n          \n          shardHandler.submit(sreq, replica, sreq.params);\n          \n        }\n      }\n      \n      int failed = 0;\n      ShardResponse srsp;\n      do {\n        srsp = shardHandler.takeCompletedOrError();\n        if (srsp != null) {\n          Throwable e = srsp.getException();\n          if (e != null) {\n            // should we retry?\n            // TODO: we should return errors to the client\n            // TODO: what if one fails and others succeed?\n            failed++;\n            log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n          }\n        }\n      } while (srsp != null);\n      \n      // if all calls succeeded, return true\n      if (failed > 0) {\n        return false;\n      }\n      log.info(\"Successfully created all shards for collection \"\n          + collectionName);\n      return true;\n    } catch (Exception ex) {\n      // Expecting that the necessary logging has already been performed\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9a57adc9bfabbc207ed17740dd86e0a2401ea385","date":1355507623,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","sourceNew":"  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {\n    String collectionName = message.getStr(\"name\");\n    if (clusterState.getCollections().contains(collectionName)) {\n      SolrException.log(log, \"collection already exists: \" + collectionName);\n      return false;\n    }\n    \n    try {\n      // look at the replication factor and see if it matches reality\n      // if it does not, find best nodes to create more cores\n      \n      int repFactor = msgStrToInt(message, REPLICATION_FACTOR, 1);\n      int numSlices = msgStrToInt(message, NUM_SLICES, 0);\n      int maxShardsPerNode = msgStrToInt(message, MAX_SHARDS_PER_NODE, 1);\n      String createNodeSetStr; \n      List<String> createNodeList = ((createNodeSetStr = message.getStr(CREATE_NODE_SET)) == null)?null:StrUtils.splitSmart(createNodeSetStr, \",\", true);\n      \n      if (repFactor <= 0) {\n        SolrException.log(log, REPLICATION_FACTOR + \" must be > 0\");\n        return false;\n      }\n      \n      if (numSlices < 0) {\n        SolrException.log(log, NUM_SLICES + \" must be > 0\");\n        return false;\n      }\n      \n      String configName = message.getStr(\"collection.configName\");\n      \n      // we need to look at every node and see how many cores it serves\n      // add our new cores to existing nodes serving the least number of cores\n      // but (for now) require that each core goes on a distinct node.\n      \n      // TODO: add smarter options that look at the current number of cores per\n      // node?\n      // for now we just go random\n      Set<String> nodes = clusterState.getLiveNodes();\n      List<String> nodeList = new ArrayList<String>(nodes.size());\n      nodeList.addAll(nodes);\n      if (createNodeList != null) nodeList.retainAll(createNodeList);\n      Collections.shuffle(nodeList);\n      \n      if (nodeList.size() <= 0) {\n        log.error(\"Cannot create collection \" + collectionName\n            + \". No live Solr-instaces\" + ((createNodeList != null)?\" among Solr-instances specified in \" + CREATE_NODE_SET:\"\"));\n        return false;\n      }\n      \n      if (repFactor > nodeList.size()) {\n        log.warn(\"Specified \"\n            + REPLICATION_FACTOR\n            + \" of \"\n            + repFactor\n            + \" on collection \"\n            + collectionName\n            + \" is higher than or equal to the number of Solr instances currently live (\"\n            + nodeList.size()\n            + \"). Its unusual to run two replica of the same slice on the same Solr-instance.\");\n      }\n      \n      int maxShardsAllowedToCreate = maxShardsPerNode * nodeList.size();\n      int requestedShardsToCreate = numSlices * repFactor;\n      if (maxShardsAllowedToCreate < requestedShardsToCreate) {\n        log.error(\"Cannot create collection \" + collectionName + \". Value of \"\n            + MAX_SHARDS_PER_NODE + \" is \" + maxShardsPerNode\n            + \", and the number of live nodes is \" + nodeList.size()\n            + \". This allows a maximum of \" + maxShardsAllowedToCreate\n            + \" to be created. Value of \" + NUM_SLICES + \" is \" + numSlices\n            + \" and value of \" + REPLICATION_FACTOR + \" is \" + repFactor\n            + \". This requires \" + requestedShardsToCreate\n            + \" shards to be created (higher than the allowed number)\");\n        return false;\n      }\n      \n      for (int i = 1; i <= numSlices; i++) {\n        for (int j = 1; j <= repFactor; j++) {\n          String nodeName = nodeList.get(((i - 1) + (j - 1)) % nodeList.size());\n          String sliceName = \"shard\" + i;\n          String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n          log.info(\"Creating shard \" + shardName + \" as part of slice \"\n              + sliceName + \" of collection \" + collectionName + \" on \"\n              + nodeName);\n          \n          // Need to create new params for each request\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n          \n          params.set(CoreAdminParams.NAME, shardName);\n          params.set(\"collection.configName\", configName);\n          params.set(CoreAdminParams.COLLECTION, collectionName);\n          params.set(CoreAdminParams.SHARD, sliceName);\n          params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n          \n          ShardRequest sreq = new ShardRequest();\n          params.set(\"qt\", adminPath);\n          sreq.purpose = 1;\n          String replica = zkStateReader.getZkClient()\n            .getBaseUrlForNodeName(nodeName);\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = params;\n          \n          shardHandler.submit(sreq, replica, sreq.params);\n          \n        }\n      }\n      \n      int failed = 0;\n      ShardResponse srsp;\n      do {\n        srsp = shardHandler.takeCompletedOrError();\n        if (srsp != null) {\n          Throwable e = srsp.getException();\n          if (e != null) {\n            // should we retry?\n            // TODO: we should return errors to the client\n            // TODO: what if one fails and others succeed?\n            failed++;\n            log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n          }\n        }\n      } while (srsp != null);\n      \n      // if all calls succeeded, return true\n      if (failed > 0) {\n        return false;\n      }\n      log.info(\"Successfully created all shards for collection \"\n          + collectionName);\n      return true;\n    } catch (Exception ex) {\n      // Expecting that the necessary logging has already been performed\n      return false;\n    }\n  }\n\n","sourceOld":"  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {\n    String collectionName = message.getStr(\"name\");\n    if (clusterState.getCollections().contains(collectionName)) {\n      SolrException.log(log, \"collection already exists: \" + collectionName);\n      return false;\n    }\n    \n    try {\n      // look at the replication factor and see if it matches reality\n      // if it does not, find best nodes to create more cores\n      \n      int repFactor = msgStrToInt(message, REPLICATION_FACTOR, 1);\n      int numSlices = msgStrToInt(message, NUM_SLICES, 0);\n      int maxShardsPerNode = msgStrToInt(message, MAX_SHARDS_PER_NODE, 1);\n      \n      if (repFactor <= 0) {\n        SolrException.log(log, REPLICATION_FACTOR + \" must be > 0\");\n        return false;\n      }\n      \n      if (numSlices < 0) {\n        SolrException.log(log, NUM_SLICES + \" must be > 0\");\n        return false;\n      }\n      \n      String configName = message.getStr(\"collection.configName\");\n      \n      // we need to look at every node and see how many cores it serves\n      // add our new cores to existing nodes serving the least number of cores\n      // but (for now) require that each core goes on a distinct node.\n      \n      // TODO: add smarter options that look at the current number of cores per\n      // node?\n      // for now we just go random\n      Set<String> nodes = clusterState.getLiveNodes();\n      List<String> nodeList = new ArrayList<String>(nodes.size());\n      nodeList.addAll(nodes);\n      Collections.shuffle(nodeList);\n      \n      if (nodeList.size() <= 0) {\n        log.error(\"Cannot create collection \" + collectionName\n            + \". No live Solr-instaces\");\n        return false;\n      }\n      \n      if (repFactor > nodeList.size()) {\n        log.warn(\"Specified \"\n            + REPLICATION_FACTOR\n            + \" of \"\n            + repFactor\n            + \" on collection \"\n            + collectionName\n            + \" is higher than or equal to the number of Solr instances currently live (\"\n            + nodeList.size()\n            + \"). Its unusual to run two replica of the same slice on the same Solr-instance.\");\n      }\n      \n      int maxShardsAllowedToCreate = maxShardsPerNode * nodeList.size();\n      int requestedShardsToCreate = numSlices * repFactor;\n      if (maxShardsAllowedToCreate < requestedShardsToCreate) {\n        log.error(\"Cannot create collection \" + collectionName + \". Value of \"\n            + MAX_SHARDS_PER_NODE + \" is \" + maxShardsPerNode\n            + \", and the number of live nodes is \" + nodeList.size()\n            + \". This allows a maximum of \" + maxShardsAllowedToCreate\n            + \" to be created. Value of \" + NUM_SLICES + \" is \" + numSlices\n            + \" and value of \" + REPLICATION_FACTOR + \" is \" + repFactor\n            + \". This requires \" + requestedShardsToCreate\n            + \" shards to be created (higher than the allowed number)\");\n        return false;\n      }\n      \n      for (int i = 1; i <= numSlices; i++) {\n        for (int j = 1; j <= repFactor; j++) {\n          String nodeName = nodeList.get(((i - 1) + (j - 1)) % nodeList.size());\n          String sliceName = \"shard\" + i;\n          String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n          log.info(\"Creating shard \" + shardName + \" as part of slice \"\n              + sliceName + \" of collection \" + collectionName + \" on \"\n              + nodeName);\n          \n          // Need to create new params for each request\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n          \n          params.set(CoreAdminParams.NAME, shardName);\n          params.set(\"collection.configName\", configName);\n          params.set(CoreAdminParams.COLLECTION, collectionName);\n          params.set(CoreAdminParams.SHARD, sliceName);\n          params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n          \n          ShardRequest sreq = new ShardRequest();\n          params.set(\"qt\", adminPath);\n          sreq.purpose = 1;\n          String replica = zkStateReader.getZkClient()\n            .getBaseUrlForNodeName(nodeName);\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = params;\n          \n          shardHandler.submit(sreq, replica, sreq.params);\n          \n        }\n      }\n      \n      int failed = 0;\n      ShardResponse srsp;\n      do {\n        srsp = shardHandler.takeCompletedOrError();\n        if (srsp != null) {\n          Throwable e = srsp.getException();\n          if (e != null) {\n            // should we retry?\n            // TODO: we should return errors to the client\n            // TODO: what if one fails and others succeed?\n            failed++;\n            log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n          }\n        }\n      } while (srsp != null);\n      \n      // if all calls succeeded, return true\n      if (failed > 0) {\n        return false;\n      }\n      log.info(\"Successfully created all shards for collection \"\n          + collectionName);\n      return true;\n    } catch (Exception ex) {\n      // Expecting that the necessary logging has already been performed\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","sourceNew":"  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {\n    String collectionName = message.getStr(\"name\");\n    if (clusterState.getCollections().contains(collectionName)) {\n      SolrException.log(log, \"collection already exists: \" + collectionName);\n      return false;\n    }\n    \n    try {\n      // look at the replication factor and see if it matches reality\n      // if it does not, find best nodes to create more cores\n      \n      int repFactor = msgStrToInt(message, REPLICATION_FACTOR, 1);\n      int numSlices = msgStrToInt(message, NUM_SLICES, 0);\n      int maxShardsPerNode = msgStrToInt(message, MAX_SHARDS_PER_NODE, 1);\n      String createNodeSetStr; \n      List<String> createNodeList = ((createNodeSetStr = message.getStr(CREATE_NODE_SET)) == null)?null:StrUtils.splitSmart(createNodeSetStr, \",\", true);\n      \n      if (repFactor <= 0) {\n        SolrException.log(log, REPLICATION_FACTOR + \" must be > 0\");\n        return false;\n      }\n      \n      if (numSlices < 0) {\n        SolrException.log(log, NUM_SLICES + \" must be > 0\");\n        return false;\n      }\n      \n      String configName = message.getStr(\"collection.configName\");\n      \n      // we need to look at every node and see how many cores it serves\n      // add our new cores to existing nodes serving the least number of cores\n      // but (for now) require that each core goes on a distinct node.\n      \n      // TODO: add smarter options that look at the current number of cores per\n      // node?\n      // for now we just go random\n      Set<String> nodes = clusterState.getLiveNodes();\n      List<String> nodeList = new ArrayList<String>(nodes.size());\n      nodeList.addAll(nodes);\n      if (createNodeList != null) nodeList.retainAll(createNodeList);\n      Collections.shuffle(nodeList);\n      \n      if (nodeList.size() <= 0) {\n        log.error(\"Cannot create collection \" + collectionName\n            + \". No live Solr-instaces\" + ((createNodeList != null)?\" among Solr-instances specified in \" + CREATE_NODE_SET:\"\"));\n        return false;\n      }\n      \n      if (repFactor > nodeList.size()) {\n        log.warn(\"Specified \"\n            + REPLICATION_FACTOR\n            + \" of \"\n            + repFactor\n            + \" on collection \"\n            + collectionName\n            + \" is higher than or equal to the number of Solr instances currently live (\"\n            + nodeList.size()\n            + \"). Its unusual to run two replica of the same slice on the same Solr-instance.\");\n      }\n      \n      int maxShardsAllowedToCreate = maxShardsPerNode * nodeList.size();\n      int requestedShardsToCreate = numSlices * repFactor;\n      if (maxShardsAllowedToCreate < requestedShardsToCreate) {\n        log.error(\"Cannot create collection \" + collectionName + \". Value of \"\n            + MAX_SHARDS_PER_NODE + \" is \" + maxShardsPerNode\n            + \", and the number of live nodes is \" + nodeList.size()\n            + \". This allows a maximum of \" + maxShardsAllowedToCreate\n            + \" to be created. Value of \" + NUM_SLICES + \" is \" + numSlices\n            + \" and value of \" + REPLICATION_FACTOR + \" is \" + repFactor\n            + \". This requires \" + requestedShardsToCreate\n            + \" shards to be created (higher than the allowed number)\");\n        return false;\n      }\n      \n      for (int i = 1; i <= numSlices; i++) {\n        for (int j = 1; j <= repFactor; j++) {\n          String nodeName = nodeList.get(((i - 1) + (j - 1)) % nodeList.size());\n          String sliceName = \"shard\" + i;\n          String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n          log.info(\"Creating shard \" + shardName + \" as part of slice \"\n              + sliceName + \" of collection \" + collectionName + \" on \"\n              + nodeName);\n          \n          // Need to create new params for each request\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n          \n          params.set(CoreAdminParams.NAME, shardName);\n          params.set(\"collection.configName\", configName);\n          params.set(CoreAdminParams.COLLECTION, collectionName);\n          params.set(CoreAdminParams.SHARD, sliceName);\n          params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n          \n          ShardRequest sreq = new ShardRequest();\n          params.set(\"qt\", adminPath);\n          sreq.purpose = 1;\n          String replica = zkStateReader.getZkClient()\n            .getBaseUrlForNodeName(nodeName);\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = params;\n          \n          shardHandler.submit(sreq, replica, sreq.params);\n          \n        }\n      }\n      \n      int failed = 0;\n      ShardResponse srsp;\n      do {\n        srsp = shardHandler.takeCompletedOrError();\n        if (srsp != null) {\n          Throwable e = srsp.getException();\n          if (e != null) {\n            // should we retry?\n            // TODO: we should return errors to the client\n            // TODO: what if one fails and others succeed?\n            failed++;\n            log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n          }\n        }\n      } while (srsp != null);\n      \n      // if all calls succeeded, return true\n      if (failed > 0) {\n        return false;\n      }\n      log.info(\"Successfully created all shards for collection \"\n          + collectionName);\n      return true;\n    } catch (Exception ex) {\n      // Expecting that the necessary logging has already been performed\n      return false;\n    }\n  }\n\n","sourceOld":"  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {\n    String collectionName = message.getStr(\"name\");\n    if (clusterState.getCollections().contains(collectionName)) {\n      SolrException.log(log, \"collection already exists: \" + collectionName);\n      return false;\n    }\n    \n    try {\n      // look at the replication factor and see if it matches reality\n      // if it does not, find best nodes to create more cores\n      \n      int numReplica = msgStrToInt(message, REPLICATION_FACTOR, 0);\n      int numSlices = msgStrToInt(message, NUM_SLICES, 0);\n      int maxShardsPerNode = msgStrToInt(message, MAX_SHARDS_PER_NODE, 1);\n      \n      if (numReplica < 0) {\n        SolrException.log(log, REPLICATION_FACTOR + \" must be > 0\");\n        return false;\n      }\n      \n      if (numSlices < 0) {\n        SolrException.log(log, NUM_SLICES + \" must be > 0\");\n        return false;\n      }\n      \n      String configName = message.getStr(\"collection.configName\");\n      \n      // we need to look at every node and see how many cores it serves\n      // add our new cores to existing nodes serving the least number of cores\n      // but (for now) require that each core goes on a distinct node.\n      \n      // TODO: add smarter options that look at the current number of cores per\n      // node?\n      // for now we just go random\n      Set<String> nodes = clusterState.getLiveNodes();\n      List<String> nodeList = new ArrayList<String>(nodes.size());\n      nodeList.addAll(nodes);\n      Collections.shuffle(nodeList);\n      \n      if (nodeList.size() <= 0) {\n        log.error(\"Cannot create collection \" + collectionName\n            + \". No live Solr-instaces\");\n        return false;\n      }\n      \n      int numShardsPerSlice = numReplica + 1;\n      if (numShardsPerSlice > nodeList.size()) {\n        log.warn(\"Specified \"\n            + REPLICATION_FACTOR\n            + \" of \"\n            + numReplica\n            + \" on collection \"\n            + collectionName\n            + \" is higher than or equal to the number of Solr instances currently live (\"\n            + nodeList.size()\n            + \"). Its unusual to run two replica of the same slice on the same Solr-instance.\");\n      }\n      \n      int maxShardsAllowedToCreate = maxShardsPerNode * nodeList.size();\n      int requestedShardsToCreate = numSlices * numShardsPerSlice;\n      if (maxShardsAllowedToCreate < requestedShardsToCreate) {\n        log.error(\"Cannot create collection \" + collectionName + \". Value of \"\n            + MAX_SHARDS_PER_NODE + \" is \" + maxShardsPerNode\n            + \", and the number of live nodes is \" + nodeList.size()\n            + \". This allows a maximum of \" + maxShardsAllowedToCreate\n            + \" to be created. Value of \" + NUM_SLICES + \" is \" + numSlices\n            + \" and value of \" + REPLICATION_FACTOR + \" is \" + numReplica\n            + \". This requires \" + requestedShardsToCreate\n            + \" shards to be created (higher than the allowed number)\");\n        return false;\n      }\n      \n      for (int i = 1; i <= numSlices; i++) {\n        for (int j = 1; j <= numShardsPerSlice; j++) {\n          String nodeName = nodeList.get(((i - 1) + (j - 1)) % nodeList.size());\n          String sliceName = \"shard\" + i;\n          String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n          log.info(\"Creating shard \" + shardName + \" as part of slice \"\n              + sliceName + \" of collection \" + collectionName + \" on \"\n              + nodeName);\n          \n          // Need to create new params for each request\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n          \n          params.set(CoreAdminParams.NAME, shardName);\n          params.set(\"collection.configName\", configName);\n          params.set(CoreAdminParams.COLLECTION, collectionName);\n          params.set(CoreAdminParams.SHARD, sliceName);\n          params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n          \n          ShardRequest sreq = new ShardRequest();\n          params.set(\"qt\", adminPath);\n          sreq.purpose = 1;\n          // TODO: this does not work if original url had _ in it\n          // We should have a master list\n          String replica = nodeName.replaceAll(\"_\", \"/\");\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = params;\n          \n          shardHandler.submit(sreq, replica, sreq.params);\n          \n        }\n      }\n      \n      int failed = 0;\n      ShardResponse srsp;\n      do {\n        srsp = shardHandler.takeCompletedOrError();\n        if (srsp != null) {\n          Throwable e = srsp.getException();\n          if (e != null) {\n            // should we retry?\n            // TODO: we should return errors to the client\n            // TODO: what if one fails and others succeed?\n            failed++;\n            log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n          }\n        }\n      } while (srsp != null);\n      \n      // if all calls succeeded, return true\n      if (failed > 0) {\n        return false;\n      }\n      log.info(\"Successfully created all shards for collection \"\n          + collectionName);\n      return true;\n    } catch (Exception ex) {\n      // Expecting that the necessary logging has already been performed\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6ba2b0062c52d2287d625a2a3f922ed4f8697f4e","date":1359040590,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","sourceNew":"  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {\n    String collectionName = message.getStr(\"name\");\n    if (clusterState.getCollections().contains(collectionName)) {\n      SolrException.log(log, \"collection already exists: \" + collectionName);\n      return false;\n    }\n    \n    try {\n      // look at the replication factor and see if it matches reality\n      // if it does not, find best nodes to create more cores\n      \n      int repFactor = msgStrToInt(message, REPLICATION_FACTOR, 1);\n      int numSlices = msgStrToInt(message, NUM_SLICES, 0);\n      int maxShardsPerNode = msgStrToInt(message, MAX_SHARDS_PER_NODE, 1);\n      String createNodeSetStr; \n      List<String> createNodeList = ((createNodeSetStr = message.getStr(CREATE_NODE_SET)) == null)?null:StrUtils.splitSmart(createNodeSetStr, \",\", true);\n      \n      if (repFactor <= 0) {\n        SolrException.log(log, REPLICATION_FACTOR + \" must be > 0\");\n        return false;\n      }\n      \n      if (numSlices < 0) {\n        SolrException.log(log, NUM_SLICES + \" must be > 0\");\n        return false;\n      }\n      \n      String configName = message.getStr(\"collection.configName\");\n      \n      // we need to look at every node and see how many cores it serves\n      // add our new cores to existing nodes serving the least number of cores\n      // but (for now) require that each core goes on a distinct node.\n      \n      // TODO: add smarter options that look at the current number of cores per\n      // node?\n      // for now we just go random\n      Set<String> nodes = clusterState.getLiveNodes();\n      List<String> nodeList = new ArrayList<String>(nodes.size());\n      nodeList.addAll(nodes);\n      if (createNodeList != null) nodeList.retainAll(createNodeList);\n      Collections.shuffle(nodeList);\n      \n      if (nodeList.size() <= 0) {\n        log.error(\"Cannot create collection \" + collectionName\n            + \". No live Solr-instaces\" + ((createNodeList != null)?\" among Solr-instances specified in \" + CREATE_NODE_SET:\"\"));\n        return false;\n      }\n      \n      if (repFactor > nodeList.size()) {\n        log.warn(\"Specified \"\n            + REPLICATION_FACTOR\n            + \" of \"\n            + repFactor\n            + \" on collection \"\n            + collectionName\n            + \" is higher than or equal to the number of Solr instances currently live (\"\n            + nodeList.size()\n            + \"). Its unusual to run two replica of the same slice on the same Solr-instance.\");\n      }\n      \n      int maxShardsAllowedToCreate = maxShardsPerNode * nodeList.size();\n      int requestedShardsToCreate = numSlices * repFactor;\n      if (maxShardsAllowedToCreate < requestedShardsToCreate) {\n        log.error(\"Cannot create collection \" + collectionName + \". Value of \"\n            + MAX_SHARDS_PER_NODE + \" is \" + maxShardsPerNode\n            + \", and the number of live nodes is \" + nodeList.size()\n            + \". This allows a maximum of \" + maxShardsAllowedToCreate\n            + \" to be created. Value of \" + NUM_SLICES + \" is \" + numSlices\n            + \" and value of \" + REPLICATION_FACTOR + \" is \" + repFactor\n            + \". This requires \" + requestedShardsToCreate\n            + \" shards to be created (higher than the allowed number)\");\n        return false;\n      }\n      \n      for (int i = 1; i <= numSlices; i++) {\n        for (int j = 1; j <= repFactor; j++) {\n          String nodeName = nodeList.get((repFactor * (i - 1) + (j - 1)) % nodeList.size());\n          String sliceName = \"shard\" + i;\n          String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n          log.info(\"Creating shard \" + shardName + \" as part of slice \"\n              + sliceName + \" of collection \" + collectionName + \" on \"\n              + nodeName);\n          \n          // Need to create new params for each request\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n          \n          params.set(CoreAdminParams.NAME, shardName);\n          params.set(\"collection.configName\", configName);\n          params.set(CoreAdminParams.COLLECTION, collectionName);\n          params.set(CoreAdminParams.SHARD, sliceName);\n          params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n          \n          ShardRequest sreq = new ShardRequest();\n          params.set(\"qt\", adminPath);\n          sreq.purpose = 1;\n          String replica = zkStateReader.getZkClient()\n            .getBaseUrlForNodeName(nodeName);\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = params;\n          \n          shardHandler.submit(sreq, replica, sreq.params);\n          \n        }\n      }\n      \n      int failed = 0;\n      ShardResponse srsp;\n      do {\n        srsp = shardHandler.takeCompletedOrError();\n        if (srsp != null) {\n          Throwable e = srsp.getException();\n          if (e != null) {\n            // should we retry?\n            // TODO: we should return errors to the client\n            // TODO: what if one fails and others succeed?\n            failed++;\n            log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n          }\n        }\n      } while (srsp != null);\n      \n      // if all calls succeeded, return true\n      if (failed > 0) {\n        return false;\n      }\n      log.info(\"Successfully created all shards for collection \"\n          + collectionName);\n      return true;\n    } catch (Exception ex) {\n      // Expecting that the necessary logging has already been performed\n      return false;\n    }\n  }\n\n","sourceOld":"  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {\n    String collectionName = message.getStr(\"name\");\n    if (clusterState.getCollections().contains(collectionName)) {\n      SolrException.log(log, \"collection already exists: \" + collectionName);\n      return false;\n    }\n    \n    try {\n      // look at the replication factor and see if it matches reality\n      // if it does not, find best nodes to create more cores\n      \n      int repFactor = msgStrToInt(message, REPLICATION_FACTOR, 1);\n      int numSlices = msgStrToInt(message, NUM_SLICES, 0);\n      int maxShardsPerNode = msgStrToInt(message, MAX_SHARDS_PER_NODE, 1);\n      String createNodeSetStr; \n      List<String> createNodeList = ((createNodeSetStr = message.getStr(CREATE_NODE_SET)) == null)?null:StrUtils.splitSmart(createNodeSetStr, \",\", true);\n      \n      if (repFactor <= 0) {\n        SolrException.log(log, REPLICATION_FACTOR + \" must be > 0\");\n        return false;\n      }\n      \n      if (numSlices < 0) {\n        SolrException.log(log, NUM_SLICES + \" must be > 0\");\n        return false;\n      }\n      \n      String configName = message.getStr(\"collection.configName\");\n      \n      // we need to look at every node and see how many cores it serves\n      // add our new cores to existing nodes serving the least number of cores\n      // but (for now) require that each core goes on a distinct node.\n      \n      // TODO: add smarter options that look at the current number of cores per\n      // node?\n      // for now we just go random\n      Set<String> nodes = clusterState.getLiveNodes();\n      List<String> nodeList = new ArrayList<String>(nodes.size());\n      nodeList.addAll(nodes);\n      if (createNodeList != null) nodeList.retainAll(createNodeList);\n      Collections.shuffle(nodeList);\n      \n      if (nodeList.size() <= 0) {\n        log.error(\"Cannot create collection \" + collectionName\n            + \". No live Solr-instaces\" + ((createNodeList != null)?\" among Solr-instances specified in \" + CREATE_NODE_SET:\"\"));\n        return false;\n      }\n      \n      if (repFactor > nodeList.size()) {\n        log.warn(\"Specified \"\n            + REPLICATION_FACTOR\n            + \" of \"\n            + repFactor\n            + \" on collection \"\n            + collectionName\n            + \" is higher than or equal to the number of Solr instances currently live (\"\n            + nodeList.size()\n            + \"). Its unusual to run two replica of the same slice on the same Solr-instance.\");\n      }\n      \n      int maxShardsAllowedToCreate = maxShardsPerNode * nodeList.size();\n      int requestedShardsToCreate = numSlices * repFactor;\n      if (maxShardsAllowedToCreate < requestedShardsToCreate) {\n        log.error(\"Cannot create collection \" + collectionName + \". Value of \"\n            + MAX_SHARDS_PER_NODE + \" is \" + maxShardsPerNode\n            + \", and the number of live nodes is \" + nodeList.size()\n            + \". This allows a maximum of \" + maxShardsAllowedToCreate\n            + \" to be created. Value of \" + NUM_SLICES + \" is \" + numSlices\n            + \" and value of \" + REPLICATION_FACTOR + \" is \" + repFactor\n            + \". This requires \" + requestedShardsToCreate\n            + \" shards to be created (higher than the allowed number)\");\n        return false;\n      }\n      \n      for (int i = 1; i <= numSlices; i++) {\n        for (int j = 1; j <= repFactor; j++) {\n          String nodeName = nodeList.get(((i - 1) + (j - 1)) % nodeList.size());\n          String sliceName = \"shard\" + i;\n          String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n          log.info(\"Creating shard \" + shardName + \" as part of slice \"\n              + sliceName + \" of collection \" + collectionName + \" on \"\n              + nodeName);\n          \n          // Need to create new params for each request\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n          \n          params.set(CoreAdminParams.NAME, shardName);\n          params.set(\"collection.configName\", configName);\n          params.set(CoreAdminParams.COLLECTION, collectionName);\n          params.set(CoreAdminParams.SHARD, sliceName);\n          params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n          \n          ShardRequest sreq = new ShardRequest();\n          params.set(\"qt\", adminPath);\n          sreq.purpose = 1;\n          String replica = zkStateReader.getZkClient()\n            .getBaseUrlForNodeName(nodeName);\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = params;\n          \n          shardHandler.submit(sreq, replica, sreq.params);\n          \n        }\n      }\n      \n      int failed = 0;\n      ShardResponse srsp;\n      do {\n        srsp = shardHandler.takeCompletedOrError();\n        if (srsp != null) {\n          Throwable e = srsp.getException();\n          if (e != null) {\n            // should we retry?\n            // TODO: we should return errors to the client\n            // TODO: what if one fails and others succeed?\n            failed++;\n            log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n          }\n        }\n      } while (srsp != null);\n      \n      // if all calls succeeded, return true\n      if (failed > 0) {\n        return false;\n      }\n      log.info(\"Successfully created all shards for collection \"\n          + collectionName);\n      return true;\n    } catch (Exception ex) {\n      // Expecting that the necessary logging has already been performed\n      return false;\n    }\n  }\n\n","bugFix":["c215736a9e29403edd2132d9f0829a287b428df4"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6ff0a5e4b4eeeb7a0faf4cdfba397bb540a04feb","date":1359060677,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","sourceNew":"  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {\n    String collectionName = message.getStr(\"name\");\n    if (clusterState.getCollections().contains(collectionName)) {\n      SolrException.log(log, \"collection already exists: \" + collectionName);\n      return false;\n    }\n    \n    try {\n      // look at the replication factor and see if it matches reality\n      // if it does not, find best nodes to create more cores\n      \n      int repFactor = msgStrToInt(message, REPLICATION_FACTOR, 1);\n      int numSlices = msgStrToInt(message, NUM_SLICES, 0);\n      int maxShardsPerNode = msgStrToInt(message, MAX_SHARDS_PER_NODE, 1);\n      String createNodeSetStr; \n      List<String> createNodeList = ((createNodeSetStr = message.getStr(CREATE_NODE_SET)) == null)?null:StrUtils.splitSmart(createNodeSetStr, \",\", true);\n      \n      if (repFactor <= 0) {\n        SolrException.log(log, REPLICATION_FACTOR + \" must be > 0\");\n        return false;\n      }\n      \n      if (numSlices < 0) {\n        SolrException.log(log, NUM_SLICES + \" must be > 0\");\n        return false;\n      }\n      \n      String configName = message.getStr(\"collection.configName\");\n      \n      // we need to look at every node and see how many cores it serves\n      // add our new cores to existing nodes serving the least number of cores\n      // but (for now) require that each core goes on a distinct node.\n      \n      // TODO: add smarter options that look at the current number of cores per\n      // node?\n      // for now we just go random\n      Set<String> nodes = clusterState.getLiveNodes();\n      List<String> nodeList = new ArrayList<String>(nodes.size());\n      nodeList.addAll(nodes);\n      if (createNodeList != null) nodeList.retainAll(createNodeList);\n      Collections.shuffle(nodeList);\n      \n      if (nodeList.size() <= 0) {\n        log.error(\"Cannot create collection \" + collectionName\n            + \". No live Solr-instaces\" + ((createNodeList != null)?\" among Solr-instances specified in \" + CREATE_NODE_SET:\"\"));\n        return false;\n      }\n      \n      if (repFactor > nodeList.size()) {\n        log.warn(\"Specified \"\n            + REPLICATION_FACTOR\n            + \" of \"\n            + repFactor\n            + \" on collection \"\n            + collectionName\n            + \" is higher than or equal to the number of Solr instances currently live (\"\n            + nodeList.size()\n            + \"). Its unusual to run two replica of the same slice on the same Solr-instance.\");\n      }\n      \n      int maxShardsAllowedToCreate = maxShardsPerNode * nodeList.size();\n      int requestedShardsToCreate = numSlices * repFactor;\n      if (maxShardsAllowedToCreate < requestedShardsToCreate) {\n        log.error(\"Cannot create collection \" + collectionName + \". Value of \"\n            + MAX_SHARDS_PER_NODE + \" is \" + maxShardsPerNode\n            + \", and the number of live nodes is \" + nodeList.size()\n            + \". This allows a maximum of \" + maxShardsAllowedToCreate\n            + \" to be created. Value of \" + NUM_SLICES + \" is \" + numSlices\n            + \" and value of \" + REPLICATION_FACTOR + \" is \" + repFactor\n            + \". This requires \" + requestedShardsToCreate\n            + \" shards to be created (higher than the allowed number)\");\n        return false;\n      }\n      \n      for (int i = 1; i <= numSlices; i++) {\n        for (int j = 1; j <= repFactor; j++) {\n          String nodeName = nodeList.get((repFactor * (i - 1) + (j - 1)) % nodeList.size());\n          String sliceName = \"shard\" + i;\n          String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n          log.info(\"Creating shard \" + shardName + \" as part of slice \"\n              + sliceName + \" of collection \" + collectionName + \" on \"\n              + nodeName);\n          \n          // Need to create new params for each request\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n          \n          params.set(CoreAdminParams.NAME, shardName);\n          params.set(\"collection.configName\", configName);\n          params.set(CoreAdminParams.COLLECTION, collectionName);\n          params.set(CoreAdminParams.SHARD, sliceName);\n          params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n          \n          ShardRequest sreq = new ShardRequest();\n          params.set(\"qt\", adminPath);\n          sreq.purpose = 1;\n          String replica = zkStateReader.getZkClient()\n            .getBaseUrlForNodeName(nodeName);\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = params;\n          \n          shardHandler.submit(sreq, replica, sreq.params);\n          \n        }\n      }\n      \n      int failed = 0;\n      ShardResponse srsp;\n      do {\n        srsp = shardHandler.takeCompletedOrError();\n        if (srsp != null) {\n          Throwable e = srsp.getException();\n          if (e != null) {\n            // should we retry?\n            // TODO: we should return errors to the client\n            // TODO: what if one fails and others succeed?\n            failed++;\n            log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n          }\n        }\n      } while (srsp != null);\n      \n      // if all calls succeeded, return true\n      if (failed > 0) {\n        return false;\n      }\n      log.info(\"Successfully created all shards for collection \"\n          + collectionName);\n      return true;\n    } catch (Exception ex) {\n      // Expecting that the necessary logging has already been performed\n      return false;\n    }\n  }\n\n","sourceOld":"  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {\n    String collectionName = message.getStr(\"name\");\n    if (clusterState.getCollections().contains(collectionName)) {\n      SolrException.log(log, \"collection already exists: \" + collectionName);\n      return false;\n    }\n    \n    try {\n      // look at the replication factor and see if it matches reality\n      // if it does not, find best nodes to create more cores\n      \n      int repFactor = msgStrToInt(message, REPLICATION_FACTOR, 1);\n      int numSlices = msgStrToInt(message, NUM_SLICES, 0);\n      int maxShardsPerNode = msgStrToInt(message, MAX_SHARDS_PER_NODE, 1);\n      String createNodeSetStr; \n      List<String> createNodeList = ((createNodeSetStr = message.getStr(CREATE_NODE_SET)) == null)?null:StrUtils.splitSmart(createNodeSetStr, \",\", true);\n      \n      if (repFactor <= 0) {\n        SolrException.log(log, REPLICATION_FACTOR + \" must be > 0\");\n        return false;\n      }\n      \n      if (numSlices < 0) {\n        SolrException.log(log, NUM_SLICES + \" must be > 0\");\n        return false;\n      }\n      \n      String configName = message.getStr(\"collection.configName\");\n      \n      // we need to look at every node and see how many cores it serves\n      // add our new cores to existing nodes serving the least number of cores\n      // but (for now) require that each core goes on a distinct node.\n      \n      // TODO: add smarter options that look at the current number of cores per\n      // node?\n      // for now we just go random\n      Set<String> nodes = clusterState.getLiveNodes();\n      List<String> nodeList = new ArrayList<String>(nodes.size());\n      nodeList.addAll(nodes);\n      if (createNodeList != null) nodeList.retainAll(createNodeList);\n      Collections.shuffle(nodeList);\n      \n      if (nodeList.size() <= 0) {\n        log.error(\"Cannot create collection \" + collectionName\n            + \". No live Solr-instaces\" + ((createNodeList != null)?\" among Solr-instances specified in \" + CREATE_NODE_SET:\"\"));\n        return false;\n      }\n      \n      if (repFactor > nodeList.size()) {\n        log.warn(\"Specified \"\n            + REPLICATION_FACTOR\n            + \" of \"\n            + repFactor\n            + \" on collection \"\n            + collectionName\n            + \" is higher than or equal to the number of Solr instances currently live (\"\n            + nodeList.size()\n            + \"). Its unusual to run two replica of the same slice on the same Solr-instance.\");\n      }\n      \n      int maxShardsAllowedToCreate = maxShardsPerNode * nodeList.size();\n      int requestedShardsToCreate = numSlices * repFactor;\n      if (maxShardsAllowedToCreate < requestedShardsToCreate) {\n        log.error(\"Cannot create collection \" + collectionName + \". Value of \"\n            + MAX_SHARDS_PER_NODE + \" is \" + maxShardsPerNode\n            + \", and the number of live nodes is \" + nodeList.size()\n            + \". This allows a maximum of \" + maxShardsAllowedToCreate\n            + \" to be created. Value of \" + NUM_SLICES + \" is \" + numSlices\n            + \" and value of \" + REPLICATION_FACTOR + \" is \" + repFactor\n            + \". This requires \" + requestedShardsToCreate\n            + \" shards to be created (higher than the allowed number)\");\n        return false;\n      }\n      \n      for (int i = 1; i <= numSlices; i++) {\n        for (int j = 1; j <= repFactor; j++) {\n          String nodeName = nodeList.get(((i - 1) + (j - 1)) % nodeList.size());\n          String sliceName = \"shard\" + i;\n          String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n          log.info(\"Creating shard \" + shardName + \" as part of slice \"\n              + sliceName + \" of collection \" + collectionName + \" on \"\n              + nodeName);\n          \n          // Need to create new params for each request\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n          \n          params.set(CoreAdminParams.NAME, shardName);\n          params.set(\"collection.configName\", configName);\n          params.set(CoreAdminParams.COLLECTION, collectionName);\n          params.set(CoreAdminParams.SHARD, sliceName);\n          params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n          \n          ShardRequest sreq = new ShardRequest();\n          params.set(\"qt\", adminPath);\n          sreq.purpose = 1;\n          String replica = zkStateReader.getZkClient()\n            .getBaseUrlForNodeName(nodeName);\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = params;\n          \n          shardHandler.submit(sreq, replica, sreq.params);\n          \n        }\n      }\n      \n      int failed = 0;\n      ShardResponse srsp;\n      do {\n        srsp = shardHandler.takeCompletedOrError();\n        if (srsp != null) {\n          Throwable e = srsp.getException();\n          if (e != null) {\n            // should we retry?\n            // TODO: we should return errors to the client\n            // TODO: what if one fails and others succeed?\n            failed++;\n            log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n          }\n        }\n      } while (srsp != null);\n      \n      // if all calls succeeded, return true\n      if (failed > 0) {\n        return false;\n      }\n      log.info(\"Successfully created all shards for collection \"\n          + collectionName);\n      return true;\n    } catch (Exception ex) {\n      // Expecting that the necessary logging has already been performed\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe999fc2d95d6fea71f960bf9556858387ba21f5","date":1363294860,"type":5,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#createCollection(ClusterState,ZkNodeProps).mjava","sourceNew":"  private void createCollection(ClusterState clusterState, ZkNodeProps message, NamedList results) {\n    String collectionName = message.getStr(\"name\");\n    if (clusterState.getCollections().contains(collectionName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    \n    try {\n      // look at the replication factor and see if it matches reality\n      // if it does not, find best nodes to create more cores\n      \n      int repFactor = msgStrToInt(message, REPLICATION_FACTOR, 1);\n      int numSlices = msgStrToInt(message, NUM_SLICES, 0);\n      int maxShardsPerNode = msgStrToInt(message, MAX_SHARDS_PER_NODE, 1);\n      String createNodeSetStr; \n      List<String> createNodeList = ((createNodeSetStr = message.getStr(CREATE_NODE_SET)) == null)?null:StrUtils.splitSmart(createNodeSetStr, \",\", true);\n      \n      if (repFactor <= 0) {\n        SolrException.log(log, REPLICATION_FACTOR + \" must be > 0\");\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n      }\n      \n      if (numSlices < 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, NUM_SLICES + \" must be > 0\");\n      }\n      \n      String configName = message.getStr(\"collection.configName\");\n      \n      // we need to look at every node and see how many cores it serves\n      // add our new cores to existing nodes serving the least number of cores\n      // but (for now) require that each core goes on a distinct node.\n      \n      // TODO: add smarter options that look at the current number of cores per\n      // node?\n      // for now we just go random\n      Set<String> nodes = clusterState.getLiveNodes();\n      List<String> nodeList = new ArrayList<String>(nodes.size());\n      nodeList.addAll(nodes);\n      if (createNodeList != null) nodeList.retainAll(createNodeList);\n      Collections.shuffle(nodeList);\n      \n      if (nodeList.size() <= 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot create collection \" + collectionName\n            + \". No live Solr-instances\" + ((createNodeList != null)?\" among Solr-instances specified in \" + CREATE_NODE_SET + \":\" + createNodeSetStr:\"\"));\n      }\n      \n      if (repFactor > nodeList.size()) {\n        log.warn(\"Specified \"\n            + REPLICATION_FACTOR\n            + \" of \"\n            + repFactor\n            + \" on collection \"\n            + collectionName\n            + \" is higher than or equal to the number of Solr instances currently live (\"\n            + nodeList.size()\n            + \"). Its unusual to run two replica of the same slice on the same Solr-instance.\");\n      }\n      \n      int maxShardsAllowedToCreate = maxShardsPerNode * nodeList.size();\n      int requestedShardsToCreate = numSlices * repFactor;\n      if (maxShardsAllowedToCreate < requestedShardsToCreate) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot create collection \" + collectionName + \". Value of \"\n            + MAX_SHARDS_PER_NODE + \" is \" + maxShardsPerNode\n            + \", and the number of live nodes is \" + nodeList.size()\n            + \". This allows a maximum of \" + maxShardsAllowedToCreate\n            + \" to be created. Value of \" + NUM_SLICES + \" is \" + numSlices\n            + \" and value of \" + REPLICATION_FACTOR + \" is \" + repFactor\n            + \". This requires \" + requestedShardsToCreate\n            + \" shards to be created (higher than the allowed number)\");\n      }\n      \n      for (int i = 1; i <= numSlices; i++) {\n        for (int j = 1; j <= repFactor; j++) {\n          String nodeName = nodeList.get((repFactor * (i - 1) + (j - 1)) % nodeList.size());\n          String sliceName = \"shard\" + i;\n          String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n          log.info(\"Creating shard \" + shardName + \" as part of slice \"\n              + sliceName + \" of collection \" + collectionName + \" on \"\n              + nodeName);\n          \n          // Need to create new params for each request\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n          \n          params.set(CoreAdminParams.NAME, shardName);\n          params.set(\"collection.configName\", configName);\n          params.set(CoreAdminParams.COLLECTION, collectionName);\n          params.set(CoreAdminParams.SHARD, sliceName);\n          params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n          \n          ShardRequest sreq = new ShardRequest();\n          sreq.nodeName = nodeName;\n          params.set(\"qt\", adminPath);\n          sreq.purpose = 1;\n          String replica = zkStateReader.getZkClient()\n            .getBaseUrlForNodeName(nodeName);\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = params;\n          \n          shardHandler.submit(sreq, replica, sreq.params);\n          \n        }\n      }\n      \n      ShardResponse srsp;\n      do {\n        srsp = shardHandler.takeCompletedOrError();\n        if (srsp != null) {\n          processResponse(results, srsp);\n        }\n      } while (srsp != null);\n\n      log.info(\"Finished create command on all shards for collection: \"\n          + collectionName);\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, null, ex);\n    }\n  }\n\n","sourceOld":"  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {\n    String collectionName = message.getStr(\"name\");\n    if (clusterState.getCollections().contains(collectionName)) {\n      SolrException.log(log, \"collection already exists: \" + collectionName);\n      return false;\n    }\n    \n    try {\n      // look at the replication factor and see if it matches reality\n      // if it does not, find best nodes to create more cores\n      \n      int repFactor = msgStrToInt(message, REPLICATION_FACTOR, 1);\n      int numSlices = msgStrToInt(message, NUM_SLICES, 0);\n      int maxShardsPerNode = msgStrToInt(message, MAX_SHARDS_PER_NODE, 1);\n      String createNodeSetStr; \n      List<String> createNodeList = ((createNodeSetStr = message.getStr(CREATE_NODE_SET)) == null)?null:StrUtils.splitSmart(createNodeSetStr, \",\", true);\n      \n      if (repFactor <= 0) {\n        SolrException.log(log, REPLICATION_FACTOR + \" must be > 0\");\n        return false;\n      }\n      \n      if (numSlices < 0) {\n        SolrException.log(log, NUM_SLICES + \" must be > 0\");\n        return false;\n      }\n      \n      String configName = message.getStr(\"collection.configName\");\n      \n      // we need to look at every node and see how many cores it serves\n      // add our new cores to existing nodes serving the least number of cores\n      // but (for now) require that each core goes on a distinct node.\n      \n      // TODO: add smarter options that look at the current number of cores per\n      // node?\n      // for now we just go random\n      Set<String> nodes = clusterState.getLiveNodes();\n      List<String> nodeList = new ArrayList<String>(nodes.size());\n      nodeList.addAll(nodes);\n      if (createNodeList != null) nodeList.retainAll(createNodeList);\n      Collections.shuffle(nodeList);\n      \n      if (nodeList.size() <= 0) {\n        log.error(\"Cannot create collection \" + collectionName\n            + \". No live Solr-instaces\" + ((createNodeList != null)?\" among Solr-instances specified in \" + CREATE_NODE_SET:\"\"));\n        return false;\n      }\n      \n      if (repFactor > nodeList.size()) {\n        log.warn(\"Specified \"\n            + REPLICATION_FACTOR\n            + \" of \"\n            + repFactor\n            + \" on collection \"\n            + collectionName\n            + \" is higher than or equal to the number of Solr instances currently live (\"\n            + nodeList.size()\n            + \"). Its unusual to run two replica of the same slice on the same Solr-instance.\");\n      }\n      \n      int maxShardsAllowedToCreate = maxShardsPerNode * nodeList.size();\n      int requestedShardsToCreate = numSlices * repFactor;\n      if (maxShardsAllowedToCreate < requestedShardsToCreate) {\n        log.error(\"Cannot create collection \" + collectionName + \". Value of \"\n            + MAX_SHARDS_PER_NODE + \" is \" + maxShardsPerNode\n            + \", and the number of live nodes is \" + nodeList.size()\n            + \". This allows a maximum of \" + maxShardsAllowedToCreate\n            + \" to be created. Value of \" + NUM_SLICES + \" is \" + numSlices\n            + \" and value of \" + REPLICATION_FACTOR + \" is \" + repFactor\n            + \". This requires \" + requestedShardsToCreate\n            + \" shards to be created (higher than the allowed number)\");\n        return false;\n      }\n      \n      for (int i = 1; i <= numSlices; i++) {\n        for (int j = 1; j <= repFactor; j++) {\n          String nodeName = nodeList.get((repFactor * (i - 1) + (j - 1)) % nodeList.size());\n          String sliceName = \"shard\" + i;\n          String shardName = collectionName + \"_\" + sliceName + \"_replica\" + j;\n          log.info(\"Creating shard \" + shardName + \" as part of slice \"\n              + sliceName + \" of collection \" + collectionName + \" on \"\n              + nodeName);\n          \n          // Need to create new params for each request\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());\n          \n          params.set(CoreAdminParams.NAME, shardName);\n          params.set(\"collection.configName\", configName);\n          params.set(CoreAdminParams.COLLECTION, collectionName);\n          params.set(CoreAdminParams.SHARD, sliceName);\n          params.set(ZkStateReader.NUM_SHARDS_PROP, numSlices);\n          \n          ShardRequest sreq = new ShardRequest();\n          params.set(\"qt\", adminPath);\n          sreq.purpose = 1;\n          String replica = zkStateReader.getZkClient()\n            .getBaseUrlForNodeName(nodeName);\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = params;\n          \n          shardHandler.submit(sreq, replica, sreq.params);\n          \n        }\n      }\n      \n      int failed = 0;\n      ShardResponse srsp;\n      do {\n        srsp = shardHandler.takeCompletedOrError();\n        if (srsp != null) {\n          Throwable e = srsp.getException();\n          if (e != null) {\n            // should we retry?\n            // TODO: we should return errors to the client\n            // TODO: what if one fails and others succeed?\n            failed++;\n            log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n          }\n        }\n      } while (srsp != null);\n      \n      // if all calls succeeded, return true\n      if (failed > 0) {\n        return false;\n      }\n      log.info(\"Successfully created all shards for collection \"\n          + collectionName);\n      return true;\n    } catch (Exception ex) {\n      // Expecting that the necessary logging has already been performed\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":["efefd19367eebaa6d911ba8f441a30b7b7564e26"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","9a57adc9bfabbc207ed17740dd86e0a2401ea385"],"f7985b168f6fddf7c63c36bed85c47c16011c3cc":["0381bf7061f92a7137c264b739b8f095ba124193"],"9460da0c2d9281eb6a595fbb0f54b3908e10855e":["aa16b24e8441c80ef7c503119e979670698c7233"],"fa64435b5902ce266c23755a4a00691a3285dab8":["3f767f8c99eaedb984df754fe61f21c5de260f94"],"ccf4d8c4536f02247aec7edc26a89e19c5c05dd4":["c215736a9e29403edd2132d9f0829a287b428df4"],"407687e67faf6e1f02a211ca078d8e3eed631027":["aa16b24e8441c80ef7c503119e979670698c7233","c215736a9e29403edd2132d9f0829a287b428df4"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3f767f8c99eaedb984df754fe61f21c5de260f94"],"aa16b24e8441c80ef7c503119e979670698c7233":["fa64435b5902ce266c23755a4a00691a3285dab8"],"3f767f8c99eaedb984df754fe61f21c5de260f94":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fe999fc2d95d6fea71f960bf9556858387ba21f5":["6ba2b0062c52d2287d625a2a3f922ed4f8697f4e"],"9a57adc9bfabbc207ed17740dd86e0a2401ea385":["042891089d57d0e6af18ea6cec15f9e9a7da7d25"],"042891089d57d0e6af18ea6cec15f9e9a7da7d25":["ccf4d8c4536f02247aec7edc26a89e19c5c05dd4"],"c215736a9e29403edd2132d9f0829a287b428df4":["f7985b168f6fddf7c63c36bed85c47c16011c3cc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3f767f8c99eaedb984df754fe61f21c5de260f94"],"0381bf7061f92a7137c264b739b8f095ba124193":["9460da0c2d9281eb6a595fbb0f54b3908e10855e"],"6ff0a5e4b4eeeb7a0faf4cdfba397bb540a04feb":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","6ba2b0062c52d2287d625a2a3f922ed4f8697f4e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fe999fc2d95d6fea71f960bf9556858387ba21f5"],"6ba2b0062c52d2287d625a2a3f922ed4f8697f4e":["9a57adc9bfabbc207ed17740dd86e0a2401ea385"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["6ff0a5e4b4eeeb7a0faf4cdfba397bb540a04feb"],"f7985b168f6fddf7c63c36bed85c47c16011c3cc":["c215736a9e29403edd2132d9f0829a287b428df4"],"9460da0c2d9281eb6a595fbb0f54b3908e10855e":["0381bf7061f92a7137c264b739b8f095ba124193"],"fa64435b5902ce266c23755a4a00691a3285dab8":["aa16b24e8441c80ef7c503119e979670698c7233"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"ccf4d8c4536f02247aec7edc26a89e19c5c05dd4":["042891089d57d0e6af18ea6cec15f9e9a7da7d25"],"8fd5be977c105554c6a7b68afcdbc511439723ab":[],"aa16b24e8441c80ef7c503119e979670698c7233":["9460da0c2d9281eb6a595fbb0f54b3908e10855e","407687e67faf6e1f02a211ca078d8e3eed631027"],"3f767f8c99eaedb984df754fe61f21c5de260f94":["fa64435b5902ce266c23755a4a00691a3285dab8","8fd5be977c105554c6a7b68afcdbc511439723ab","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"fe999fc2d95d6fea71f960bf9556858387ba21f5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9a57adc9bfabbc207ed17740dd86e0a2401ea385":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","6ba2b0062c52d2287d625a2a3f922ed4f8697f4e"],"042891089d57d0e6af18ea6cec15f9e9a7da7d25":["9a57adc9bfabbc207ed17740dd86e0a2401ea385"],"c215736a9e29403edd2132d9f0829a287b428df4":["ccf4d8c4536f02247aec7edc26a89e19c5c05dd4","407687e67faf6e1f02a211ca078d8e3eed631027"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8fd5be977c105554c6a7b68afcdbc511439723ab","3f767f8c99eaedb984df754fe61f21c5de260f94","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"0381bf7061f92a7137c264b739b8f095ba124193":["f7985b168f6fddf7c63c36bed85c47c16011c3cc"],"6ff0a5e4b4eeeb7a0faf4cdfba397bb540a04feb":[],"6ba2b0062c52d2287d625a2a3f922ed4f8697f4e":["fe999fc2d95d6fea71f960bf9556858387ba21f5","6ff0a5e4b4eeeb7a0faf4cdfba397bb540a04feb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8fd5be977c105554c6a7b68afcdbc511439723ab","d6f074e73200c07d54f242d3880a8da5a35ff97b","6ff0a5e4b4eeeb7a0faf4cdfba397bb540a04feb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}