{"path":"lucene/facet/src/test/org/apache/lucene/facet/TestRangeFacetCounts#testRandomFloats().mjava","commits":[{"id":"78522aad83283ca58fae08fd89406b65429d0229","date":1385573562,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestRangeFacetCounts#testRandomFloats().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestRangeFacets#testRandomFloats().mjava","sourceNew":"  public void testRandomFloats() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    int numDocs = atLeast(1000);\n    float[] values = new float[numDocs];\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      float v = random().nextFloat();\n      values[i] = v;\n      doc.add(new FloatDocValuesField(\"field\", v));\n      doc.add(new FloatField(\"field\", v, Field.Store.NO));\n      w.addDocument(doc);\n    }\n    IndexReader r = w.getReader();\n\n    IndexSearcher s = newSearcher(r);\n    FacetsConfig config = new FacetsConfig();\n    \n    int numIters = atLeast(10);\n    for(int iter=0;iter<numIters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      int numRange = _TestUtil.nextInt(random(), 1, 5);\n      FloatRange[] ranges = new FloatRange[numRange];\n      int[] expectedCounts = new int[numRange];\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        float min = random().nextFloat();\n        float max = random().nextFloat();\n        if (min > max) {\n          float x = min;\n          min = max;\n          max = x;\n        }\n        boolean minIncl = random().nextBoolean();\n        boolean maxIncl = random().nextBoolean();\n        ranges[rangeID] = new FloatRange(\"r\" + rangeID, min, minIncl, max, maxIncl);\n\n        // Do \"slow but hopefully correct\" computation of\n        // expected count:\n        for(int i=0;i<numDocs;i++) {\n          boolean accept = true;\n          if (minIncl) {\n            accept &= values[i] >= min;\n          } else {\n            accept &= values[i] > min;\n          }\n          if (maxIncl) {\n            accept &= values[i] <= max;\n          } else {\n            accept &= values[i] < max;\n          }\n          if (accept) {\n            expectedCounts[rangeID]++;\n          }\n        }\n      }\n\n      FacetsCollector sfc = new FacetsCollector();\n      s.search(new MatchAllDocsQuery(), sfc);\n      Facets facets = new RangeFacetCounts(\"field\", sfc, ranges);\n      FacetResult result = facets.getTopChildren(10, \"field\");\n      assertEquals(numRange, result.labelValues.length);\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        if (VERBOSE) {\n          System.out.println(\"  range \" + rangeID + \" expectedCount=\" + expectedCounts[rangeID]);\n        }\n        LabelAndValue subNode = result.labelValues[rangeID];\n        assertEquals(\"r\" + rangeID, subNode.label);\n        assertEquals(expectedCounts[rangeID], subNode.value.intValue());\n\n        FloatRange range = ranges[rangeID];\n\n        // Test drill-down:\n        DrillDownQuery ddq = new DrillDownQuery(config);\n        ddq.add(\"field\", NumericRangeQuery.newFloatRange(\"field\", range.min, range.max, range.minInclusive, range.maxInclusive));\n        assertEquals(expectedCounts[rangeID], s.search(ddq, 10).totalHits);\n      }\n    }\n\n    IOUtils.close(w, r, dir);\n  }\n\n","sourceOld":"  public void testRandomFloats() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    int numDocs = atLeast(1000);\n    float[] values = new float[numDocs];\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      float v = random().nextFloat();\n      values[i] = v;\n      doc.add(new FloatDocValuesField(\"field\", v));\n      doc.add(new FloatField(\"field\", v, Field.Store.NO));\n      w.addDocument(doc);\n    }\n    IndexReader r = w.getReader();\n\n    IndexSearcher s = newSearcher(r);\n    FacetsConfig config = new FacetsConfig();\n    \n    int numIters = atLeast(10);\n    for(int iter=0;iter<numIters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      int numRange = _TestUtil.nextInt(random(), 1, 5);\n      FloatRange[] ranges = new FloatRange[numRange];\n      int[] expectedCounts = new int[numRange];\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        float min = random().nextFloat();\n        float max = random().nextFloat();\n        if (min > max) {\n          float x = min;\n          min = max;\n          max = x;\n        }\n        boolean minIncl = random().nextBoolean();\n        boolean maxIncl = random().nextBoolean();\n        ranges[rangeID] = new FloatRange(\"r\" + rangeID, min, minIncl, max, maxIncl);\n\n        // Do \"slow but hopefully correct\" computation of\n        // expected count:\n        for(int i=0;i<numDocs;i++) {\n          boolean accept = true;\n          if (minIncl) {\n            accept &= values[i] >= min;\n          } else {\n            accept &= values[i] > min;\n          }\n          if (maxIncl) {\n            accept &= values[i] <= max;\n          } else {\n            accept &= values[i] < max;\n          }\n          if (accept) {\n            expectedCounts[rangeID]++;\n          }\n        }\n      }\n\n      FacetsCollector sfc = new FacetsCollector();\n      s.search(new MatchAllDocsQuery(), sfc);\n      Facets facets = new RangeFacetCounts(\"field\", sfc, ranges);\n      FacetResult result = facets.getTopChildren(10, \"field\");\n      assertEquals(numRange, result.labelValues.length);\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        if (VERBOSE) {\n          System.out.println(\"  range \" + rangeID + \" expectedCount=\" + expectedCounts[rangeID]);\n        }\n        LabelAndValue subNode = result.labelValues[rangeID];\n        assertEquals(\"r\" + rangeID, subNode.label);\n        assertEquals(expectedCounts[rangeID], subNode.value.intValue());\n\n        FloatRange range = ranges[rangeID];\n\n        // Test drill-down:\n        DrillDownQuery ddq = new DrillDownQuery(config);\n        ddq.add(\"field\", NumericRangeQuery.newFloatRange(\"field\", range.min, range.max, range.minInclusive, range.maxInclusive));\n        assertEquals(expectedCounts[rangeID], s.search(ddq, 10).totalHits);\n      }\n    }\n\n    IOUtils.close(w, r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd3ed8c8fa2a4b995f5dfca3f00e5ce80161de0e","date":1385900513,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestRangeFacetCounts#testRandomFloats().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestRangeFacetCounts#testRandomFloats().mjava","sourceNew":"  public void testRandomFloats() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    int numDocs = atLeast(1000);\n    float[] values = new float[numDocs];\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      float v = random().nextFloat();\n      values[i] = v;\n      doc.add(new FloatDocValuesField(\"field\", v));\n      doc.add(new FloatField(\"field\", v, Field.Store.NO));\n      w.addDocument(doc);\n    }\n    IndexReader r = w.getReader();\n\n    IndexSearcher s = newSearcher(r);\n    FacetsConfig config = new FacetsConfig();\n    \n    int numIters = atLeast(10);\n    for(int iter=0;iter<numIters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      int numRange = _TestUtil.nextInt(random(), 1, 5);\n      DoubleRange[] ranges = new DoubleRange[numRange];\n      int[] expectedCounts = new int[numRange];\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        double min = random().nextDouble();\n        double max = random().nextDouble();\n        if (min > max) {\n          double x = min;\n          min = max;\n          max = x;\n        }\n        boolean minIncl = random().nextBoolean();\n        boolean maxIncl = random().nextBoolean();\n        ranges[rangeID] = new DoubleRange(\"r\" + rangeID, min, minIncl, max, maxIncl);\n\n        // Do \"slow but hopefully correct\" computation of\n        // expected count:\n        for(int i=0;i<numDocs;i++) {\n          boolean accept = true;\n          if (minIncl) {\n            accept &= values[i] >= min;\n          } else {\n            accept &= values[i] > min;\n          }\n          if (maxIncl) {\n            accept &= values[i] <= max;\n          } else {\n            accept &= values[i] < max;\n          }\n          if (accept) {\n            expectedCounts[rangeID]++;\n          }\n        }\n      }\n\n      FacetsCollector sfc = new FacetsCollector();\n      s.search(new MatchAllDocsQuery(), sfc);\n      Facets facets = new DoubleRangeFacetCounts(\"field\", new FloatFieldSource(\"field\"), sfc, ranges);\n      FacetResult result = facets.getTopChildren(10, \"field\");\n      assertEquals(numRange, result.labelValues.length);\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        if (VERBOSE) {\n          System.out.println(\"  range \" + rangeID + \" expectedCount=\" + expectedCounts[rangeID]);\n        }\n        LabelAndValue subNode = result.labelValues[rangeID];\n        assertEquals(\"r\" + rangeID, subNode.label);\n        assertEquals(expectedCounts[rangeID], subNode.value.intValue());\n\n        DoubleRange range = ranges[rangeID];\n\n        // Test drill-down:\n        DrillDownQuery ddq = new DrillDownQuery(config);\n        ddq.add(\"field\", NumericRangeQuery.newFloatRange(\"field\", (float) range.min, (float) range.max, range.minInclusive, range.maxInclusive));\n        assertEquals(expectedCounts[rangeID], s.search(ddq, 10).totalHits);\n      }\n    }\n\n    IOUtils.close(w, r, dir);\n  }\n\n","sourceOld":"  public void testRandomFloats() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    int numDocs = atLeast(1000);\n    float[] values = new float[numDocs];\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      float v = random().nextFloat();\n      values[i] = v;\n      doc.add(new FloatDocValuesField(\"field\", v));\n      doc.add(new FloatField(\"field\", v, Field.Store.NO));\n      w.addDocument(doc);\n    }\n    IndexReader r = w.getReader();\n\n    IndexSearcher s = newSearcher(r);\n    FacetsConfig config = new FacetsConfig();\n    \n    int numIters = atLeast(10);\n    for(int iter=0;iter<numIters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      int numRange = _TestUtil.nextInt(random(), 1, 5);\n      FloatRange[] ranges = new FloatRange[numRange];\n      int[] expectedCounts = new int[numRange];\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        float min = random().nextFloat();\n        float max = random().nextFloat();\n        if (min > max) {\n          float x = min;\n          min = max;\n          max = x;\n        }\n        boolean minIncl = random().nextBoolean();\n        boolean maxIncl = random().nextBoolean();\n        ranges[rangeID] = new FloatRange(\"r\" + rangeID, min, minIncl, max, maxIncl);\n\n        // Do \"slow but hopefully correct\" computation of\n        // expected count:\n        for(int i=0;i<numDocs;i++) {\n          boolean accept = true;\n          if (minIncl) {\n            accept &= values[i] >= min;\n          } else {\n            accept &= values[i] > min;\n          }\n          if (maxIncl) {\n            accept &= values[i] <= max;\n          } else {\n            accept &= values[i] < max;\n          }\n          if (accept) {\n            expectedCounts[rangeID]++;\n          }\n        }\n      }\n\n      FacetsCollector sfc = new FacetsCollector();\n      s.search(new MatchAllDocsQuery(), sfc);\n      Facets facets = new RangeFacetCounts(\"field\", sfc, ranges);\n      FacetResult result = facets.getTopChildren(10, \"field\");\n      assertEquals(numRange, result.labelValues.length);\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        if (VERBOSE) {\n          System.out.println(\"  range \" + rangeID + \" expectedCount=\" + expectedCounts[rangeID]);\n        }\n        LabelAndValue subNode = result.labelValues[rangeID];\n        assertEquals(\"r\" + rangeID, subNode.label);\n        assertEquals(expectedCounts[rangeID], subNode.value.intValue());\n\n        FloatRange range = ranges[rangeID];\n\n        // Test drill-down:\n        DrillDownQuery ddq = new DrillDownQuery(config);\n        ddq.add(\"field\", NumericRangeQuery.newFloatRange(\"field\", range.min, range.max, range.minInclusive, range.maxInclusive));\n        assertEquals(expectedCounts[rangeID], s.search(ddq, 10).totalHits);\n      }\n    }\n\n    IOUtils.close(w, r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6119ef33e3fbd8582640c23b3f5b3fbb22ba8d30","date":1387399235,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestRangeFacetCounts#testRandomFloats().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestRangeFacetCounts#testRandomFloats().mjava","sourceNew":"  public void testRandomFloats() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    int numDocs = atLeast(1000);\n    float[] values = new float[numDocs];\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      float v = random().nextFloat();\n      values[i] = v;\n      doc.add(new FloatDocValuesField(\"field\", v));\n      doc.add(new FloatField(\"field\", v, Field.Store.NO));\n      w.addDocument(doc);\n    }\n    IndexReader r = w.getReader();\n\n    IndexSearcher s = newSearcher(r);\n    FacetsConfig config = new FacetsConfig();\n    \n    int numIters = atLeast(10);\n    for(int iter=0;iter<numIters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      int numRange = _TestUtil.nextInt(random(), 1, 5);\n      DoubleRange[] ranges = new DoubleRange[numRange];\n      int[] expectedCounts = new int[numRange];\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        double min;\n        if (rangeID > 0 && random().nextInt(10) == 7) {\n          // Use an existing boundary:\n          DoubleRange prevRange = ranges[random().nextInt(rangeID)];\n          if (random().nextBoolean()) {\n            min = prevRange.min;\n          } else {\n            min = prevRange.max;\n          }\n        } else {\n          min = random().nextDouble();\n        }\n        double max;\n        if (rangeID > 0 && random().nextInt(10) == 7) {\n          // Use an existing boundary:\n          DoubleRange prevRange = ranges[random().nextInt(rangeID)];\n          if (random().nextBoolean()) {\n            max = prevRange.min;\n          } else {\n            max = prevRange.max;\n          }\n        } else {\n          max = random().nextDouble();\n        }\n\n        if (min > max) {\n          double x = min;\n          min = max;\n          max = x;\n        }\n\n        boolean minIncl;\n        boolean maxIncl;\n        if (min == max) {\n          minIncl = true;\n          maxIncl = true;\n        } else {\n          minIncl = random().nextBoolean();\n          maxIncl = random().nextBoolean();\n        }\n        ranges[rangeID] = new DoubleRange(\"r\" + rangeID, min, minIncl, max, maxIncl);\n\n        // Do \"slow but hopefully correct\" computation of\n        // expected count:\n        for(int i=0;i<numDocs;i++) {\n          boolean accept = true;\n          if (minIncl) {\n            accept &= values[i] >= min;\n          } else {\n            accept &= values[i] > min;\n          }\n          if (maxIncl) {\n            accept &= values[i] <= max;\n          } else {\n            accept &= values[i] < max;\n          }\n          if (accept) {\n            expectedCounts[rangeID]++;\n          }\n        }\n      }\n\n      FacetsCollector sfc = new FacetsCollector();\n      s.search(new MatchAllDocsQuery(), sfc);\n      Facets facets = new DoubleRangeFacetCounts(\"field\", new FloatFieldSource(\"field\"), sfc, ranges);\n      FacetResult result = facets.getTopChildren(10, \"field\");\n      assertEquals(numRange, result.labelValues.length);\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        if (VERBOSE) {\n          System.out.println(\"  range \" + rangeID + \" expectedCount=\" + expectedCounts[rangeID]);\n        }\n        LabelAndValue subNode = result.labelValues[rangeID];\n        assertEquals(\"r\" + rangeID, subNode.label);\n        assertEquals(expectedCounts[rangeID], subNode.value.intValue());\n\n        DoubleRange range = ranges[rangeID];\n\n        // Test drill-down:\n        DrillDownQuery ddq = new DrillDownQuery(config);\n        ddq.add(\"field\", NumericRangeQuery.newFloatRange(\"field\", (float) range.min, (float) range.max, range.minInclusive, range.maxInclusive));\n        assertEquals(expectedCounts[rangeID], s.search(ddq, 10).totalHits);\n      }\n    }\n\n    IOUtils.close(w, r, dir);\n  }\n\n","sourceOld":"  public void testRandomFloats() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    int numDocs = atLeast(1000);\n    float[] values = new float[numDocs];\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      float v = random().nextFloat();\n      values[i] = v;\n      doc.add(new FloatDocValuesField(\"field\", v));\n      doc.add(new FloatField(\"field\", v, Field.Store.NO));\n      w.addDocument(doc);\n    }\n    IndexReader r = w.getReader();\n\n    IndexSearcher s = newSearcher(r);\n    FacetsConfig config = new FacetsConfig();\n    \n    int numIters = atLeast(10);\n    for(int iter=0;iter<numIters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      int numRange = _TestUtil.nextInt(random(), 1, 5);\n      DoubleRange[] ranges = new DoubleRange[numRange];\n      int[] expectedCounts = new int[numRange];\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        double min = random().nextDouble();\n        double max = random().nextDouble();\n        if (min > max) {\n          double x = min;\n          min = max;\n          max = x;\n        }\n        boolean minIncl = random().nextBoolean();\n        boolean maxIncl = random().nextBoolean();\n        ranges[rangeID] = new DoubleRange(\"r\" + rangeID, min, minIncl, max, maxIncl);\n\n        // Do \"slow but hopefully correct\" computation of\n        // expected count:\n        for(int i=0;i<numDocs;i++) {\n          boolean accept = true;\n          if (minIncl) {\n            accept &= values[i] >= min;\n          } else {\n            accept &= values[i] > min;\n          }\n          if (maxIncl) {\n            accept &= values[i] <= max;\n          } else {\n            accept &= values[i] < max;\n          }\n          if (accept) {\n            expectedCounts[rangeID]++;\n          }\n        }\n      }\n\n      FacetsCollector sfc = new FacetsCollector();\n      s.search(new MatchAllDocsQuery(), sfc);\n      Facets facets = new DoubleRangeFacetCounts(\"field\", new FloatFieldSource(\"field\"), sfc, ranges);\n      FacetResult result = facets.getTopChildren(10, \"field\");\n      assertEquals(numRange, result.labelValues.length);\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        if (VERBOSE) {\n          System.out.println(\"  range \" + rangeID + \" expectedCount=\" + expectedCounts[rangeID]);\n        }\n        LabelAndValue subNode = result.labelValues[rangeID];\n        assertEquals(\"r\" + rangeID, subNode.label);\n        assertEquals(expectedCounts[rangeID], subNode.value.intValue());\n\n        DoubleRange range = ranges[rangeID];\n\n        // Test drill-down:\n        DrillDownQuery ddq = new DrillDownQuery(config);\n        ddq.add(\"field\", NumericRangeQuery.newFloatRange(\"field\", (float) range.min, (float) range.max, range.minInclusive, range.maxInclusive));\n        assertEquals(expectedCounts[rangeID], s.search(ddq, 10).totalHits);\n      }\n    }\n\n    IOUtils.close(w, r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4edc984f0f4ac77c37e48ace2932f780f888453c","date":1388475218,"type":5,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/range/TestRangeFacetCounts#testRandomFloats().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestRangeFacetCounts#testRandomFloats().mjava","sourceNew":"  public void testRandomFloats() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    int numDocs = atLeast(1000);\n    float[] values = new float[numDocs];\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      float v = random().nextFloat();\n      values[i] = v;\n      doc.add(new FloatDocValuesField(\"field\", v));\n      doc.add(new FloatField(\"field\", v, Field.Store.NO));\n      w.addDocument(doc);\n    }\n    IndexReader r = w.getReader();\n\n    IndexSearcher s = newSearcher(r);\n    FacetsConfig config = new FacetsConfig();\n    \n    int numIters = atLeast(10);\n    for(int iter=0;iter<numIters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      int numRange = _TestUtil.nextInt(random(), 1, 5);\n      DoubleRange[] ranges = new DoubleRange[numRange];\n      int[] expectedCounts = new int[numRange];\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        double min;\n        if (rangeID > 0 && random().nextInt(10) == 7) {\n          // Use an existing boundary:\n          DoubleRange prevRange = ranges[random().nextInt(rangeID)];\n          if (random().nextBoolean()) {\n            min = prevRange.min;\n          } else {\n            min = prevRange.max;\n          }\n        } else {\n          min = random().nextDouble();\n        }\n        double max;\n        if (rangeID > 0 && random().nextInt(10) == 7) {\n          // Use an existing boundary:\n          DoubleRange prevRange = ranges[random().nextInt(rangeID)];\n          if (random().nextBoolean()) {\n            max = prevRange.min;\n          } else {\n            max = prevRange.max;\n          }\n        } else {\n          max = random().nextDouble();\n        }\n\n        if (min > max) {\n          double x = min;\n          min = max;\n          max = x;\n        }\n\n        boolean minIncl;\n        boolean maxIncl;\n        if (min == max) {\n          minIncl = true;\n          maxIncl = true;\n        } else {\n          minIncl = random().nextBoolean();\n          maxIncl = random().nextBoolean();\n        }\n        ranges[rangeID] = new DoubleRange(\"r\" + rangeID, min, minIncl, max, maxIncl);\n\n        // Do \"slow but hopefully correct\" computation of\n        // expected count:\n        for(int i=0;i<numDocs;i++) {\n          boolean accept = true;\n          if (minIncl) {\n            accept &= values[i] >= min;\n          } else {\n            accept &= values[i] > min;\n          }\n          if (maxIncl) {\n            accept &= values[i] <= max;\n          } else {\n            accept &= values[i] < max;\n          }\n          if (accept) {\n            expectedCounts[rangeID]++;\n          }\n        }\n      }\n\n      FacetsCollector sfc = new FacetsCollector();\n      s.search(new MatchAllDocsQuery(), sfc);\n      Facets facets = new DoubleRangeFacetCounts(\"field\", new FloatFieldSource(\"field\"), sfc, ranges);\n      FacetResult result = facets.getTopChildren(10, \"field\");\n      assertEquals(numRange, result.labelValues.length);\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        if (VERBOSE) {\n          System.out.println(\"  range \" + rangeID + \" expectedCount=\" + expectedCounts[rangeID]);\n        }\n        LabelAndValue subNode = result.labelValues[rangeID];\n        assertEquals(\"r\" + rangeID, subNode.label);\n        assertEquals(expectedCounts[rangeID], subNode.value.intValue());\n\n        DoubleRange range = ranges[rangeID];\n\n        // Test drill-down:\n        DrillDownQuery ddq = new DrillDownQuery(config);\n        ddq.add(\"field\", NumericRangeQuery.newFloatRange(\"field\", (float) range.min, (float) range.max, range.minInclusive, range.maxInclusive));\n        assertEquals(expectedCounts[rangeID], s.search(ddq, 10).totalHits);\n      }\n    }\n\n    IOUtils.close(w, r, dir);\n  }\n\n","sourceOld":"  public void testRandomFloats() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    int numDocs = atLeast(1000);\n    float[] values = new float[numDocs];\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      float v = random().nextFloat();\n      values[i] = v;\n      doc.add(new FloatDocValuesField(\"field\", v));\n      doc.add(new FloatField(\"field\", v, Field.Store.NO));\n      w.addDocument(doc);\n    }\n    IndexReader r = w.getReader();\n\n    IndexSearcher s = newSearcher(r);\n    FacetsConfig config = new FacetsConfig();\n    \n    int numIters = atLeast(10);\n    for(int iter=0;iter<numIters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      int numRange = _TestUtil.nextInt(random(), 1, 5);\n      DoubleRange[] ranges = new DoubleRange[numRange];\n      int[] expectedCounts = new int[numRange];\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        double min;\n        if (rangeID > 0 && random().nextInt(10) == 7) {\n          // Use an existing boundary:\n          DoubleRange prevRange = ranges[random().nextInt(rangeID)];\n          if (random().nextBoolean()) {\n            min = prevRange.min;\n          } else {\n            min = prevRange.max;\n          }\n        } else {\n          min = random().nextDouble();\n        }\n        double max;\n        if (rangeID > 0 && random().nextInt(10) == 7) {\n          // Use an existing boundary:\n          DoubleRange prevRange = ranges[random().nextInt(rangeID)];\n          if (random().nextBoolean()) {\n            max = prevRange.min;\n          } else {\n            max = prevRange.max;\n          }\n        } else {\n          max = random().nextDouble();\n        }\n\n        if (min > max) {\n          double x = min;\n          min = max;\n          max = x;\n        }\n\n        boolean minIncl;\n        boolean maxIncl;\n        if (min == max) {\n          minIncl = true;\n          maxIncl = true;\n        } else {\n          minIncl = random().nextBoolean();\n          maxIncl = random().nextBoolean();\n        }\n        ranges[rangeID] = new DoubleRange(\"r\" + rangeID, min, minIncl, max, maxIncl);\n\n        // Do \"slow but hopefully correct\" computation of\n        // expected count:\n        for(int i=0;i<numDocs;i++) {\n          boolean accept = true;\n          if (minIncl) {\n            accept &= values[i] >= min;\n          } else {\n            accept &= values[i] > min;\n          }\n          if (maxIncl) {\n            accept &= values[i] <= max;\n          } else {\n            accept &= values[i] < max;\n          }\n          if (accept) {\n            expectedCounts[rangeID]++;\n          }\n        }\n      }\n\n      FacetsCollector sfc = new FacetsCollector();\n      s.search(new MatchAllDocsQuery(), sfc);\n      Facets facets = new DoubleRangeFacetCounts(\"field\", new FloatFieldSource(\"field\"), sfc, ranges);\n      FacetResult result = facets.getTopChildren(10, \"field\");\n      assertEquals(numRange, result.labelValues.length);\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        if (VERBOSE) {\n          System.out.println(\"  range \" + rangeID + \" expectedCount=\" + expectedCounts[rangeID]);\n        }\n        LabelAndValue subNode = result.labelValues[rangeID];\n        assertEquals(\"r\" + rangeID, subNode.label);\n        assertEquals(expectedCounts[rangeID], subNode.value.intValue());\n\n        DoubleRange range = ranges[rangeID];\n\n        // Test drill-down:\n        DrillDownQuery ddq = new DrillDownQuery(config);\n        ddq.add(\"field\", NumericRangeQuery.newFloatRange(\"field\", (float) range.min, (float) range.max, range.minInclusive, range.maxInclusive));\n        assertEquals(expectedCounts[rangeID], s.search(ddq, 10).totalHits);\n      }\n    }\n\n    IOUtils.close(w, r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4edc984f0f4ac77c37e48ace2932f780f888453c":["6119ef33e3fbd8582640c23b3f5b3fbb22ba8d30"],"bd3ed8c8fa2a4b995f5dfca3f00e5ce80161de0e":["78522aad83283ca58fae08fd89406b65429d0229"],"6119ef33e3fbd8582640c23b3f5b3fbb22ba8d30":["bd3ed8c8fa2a4b995f5dfca3f00e5ce80161de0e"],"78522aad83283ca58fae08fd89406b65429d0229":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["78522aad83283ca58fae08fd89406b65429d0229","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4edc984f0f4ac77c37e48ace2932f780f888453c":[],"bd3ed8c8fa2a4b995f5dfca3f00e5ce80161de0e":["6119ef33e3fbd8582640c23b3f5b3fbb22ba8d30"],"6119ef33e3fbd8582640c23b3f5b3fbb22ba8d30":["4edc984f0f4ac77c37e48ace2932f780f888453c"],"78522aad83283ca58fae08fd89406b65429d0229":["bd3ed8c8fa2a4b995f5dfca3f00e5ce80161de0e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4edc984f0f4ac77c37e48ace2932f780f888453c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}