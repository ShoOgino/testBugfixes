{"path":"lucene/src/test/org/apache/lucene/store/TestMultiMMap#testSeeking().mjava","commits":[{"id":"68b4c6c95719e3020e407649a20b68538649beeb","date":1308055822,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/store/TestMultiMMap#testSeeking().mjava","pathOld":"/dev/null","sourceNew":"  public void testSeeking() throws Exception {\n    for (int i = 0; i < 10; i++) {\n      MMapDirectory mmapDir = new MMapDirectory(_TestUtil.getTempDir(\"testSeeking\"));\n      mmapDir.setMaxChunkSize(1<<i);\n      IndexOutput io = mmapDir.createOutput(\"bytes\");\n      byte bytes[] = new byte[1<<(i+1)]; // make sure we switch buffers\n      random.nextBytes(bytes);\n      io.writeBytes(bytes, bytes.length);\n      io.close();\n      IndexInput ii = mmapDir.openInput(\"bytes\");\n      byte actual[] = new byte[1<<(i+1)]; // first read all bytes\n      ii.readBytes(actual, 0, actual.length);\n      assertEquals(new BytesRef(bytes), new BytesRef(actual));\n      for (int sliceStart = 0; sliceStart < bytes.length; sliceStart++) {\n        for (int sliceLength = 0; sliceLength < bytes.length - sliceStart; sliceLength++) {\n          byte slice[] = new byte[sliceLength];\n          ii.seek(sliceStart);\n          ii.readBytes(slice, 0, slice.length);\n          assertEquals(new BytesRef(bytes, sliceStart, sliceLength), new BytesRef(slice));\n        }\n      }\n      ii.close();\n      mmapDir.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ed208afa1e7aa98899ddb1dedfddedddf898253","date":1308079587,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/store/TestMultiMMap#testSeeking().mjava","pathOld":"/dev/null","sourceNew":"  public void testSeeking() throws Exception {\n    for (int i = 0; i < 10; i++) {\n      MMapDirectory mmapDir = new MMapDirectory(_TestUtil.getTempDir(\"testSeeking\"));\n      mmapDir.setMaxChunkSize(1<<i);\n      IndexOutput io = mmapDir.createOutput(\"bytes\");\n      byte bytes[] = new byte[1<<(i+1)]; // make sure we switch buffers\n      random.nextBytes(bytes);\n      io.writeBytes(bytes, bytes.length);\n      io.close();\n      IndexInput ii = mmapDir.openInput(\"bytes\");\n      byte actual[] = new byte[1<<(i+1)]; // first read all bytes\n      ii.readBytes(actual, 0, actual.length);\n      assertEquals(new BytesRef(bytes), new BytesRef(actual));\n      for (int sliceStart = 0; sliceStart < bytes.length; sliceStart++) {\n        for (int sliceLength = 0; sliceLength < bytes.length - sliceStart; sliceLength++) {\n          byte slice[] = new byte[sliceLength];\n          ii.seek(sliceStart);\n          ii.readBytes(slice, 0, slice.length);\n          assertEquals(new BytesRef(bytes, sliceStart, sliceLength), new BytesRef(slice));\n        }\n      }\n      ii.close();\n      mmapDir.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"639c36565ce03aed5b0fce7c9e4448e53a1f7efd","date":1308580104,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/store/TestMultiMMap#testSeeking().mjava","pathOld":"lucene/src/test/org/apache/lucene/store/TestMultiMMap#testSeeking().mjava","sourceNew":"  public void testSeeking() throws Exception {\n    for (int i = 0; i < 10; i++) {\n      MMapDirectory mmapDir = new MMapDirectory(_TestUtil.getTempDir(\"testSeeking\"));\n      mmapDir.setMaxChunkSize(1<<i);\n      IndexOutput io = mmapDir.createOutput(\"bytes\", IOContext.DEFAULT);\n      byte bytes[] = new byte[1<<(i+1)]; // make sure we switch buffers\n      random.nextBytes(bytes);\n      io.writeBytes(bytes, bytes.length);\n      io.close();\n      IndexInput ii = mmapDir.openInput(\"bytes\", IOContext.DEFAULT);\n      byte actual[] = new byte[1<<(i+1)]; // first read all bytes\n      ii.readBytes(actual, 0, actual.length);\n      assertEquals(new BytesRef(bytes), new BytesRef(actual));\n      for (int sliceStart = 0; sliceStart < bytes.length; sliceStart++) {\n        for (int sliceLength = 0; sliceLength < bytes.length - sliceStart; sliceLength++) {\n          byte slice[] = new byte[sliceLength];\n          ii.seek(sliceStart);\n          ii.readBytes(slice, 0, slice.length);\n          assertEquals(new BytesRef(bytes, sliceStart, sliceLength), new BytesRef(slice));\n        }\n      }\n      ii.close();\n      mmapDir.close();\n    }\n  }\n\n","sourceOld":"  public void testSeeking() throws Exception {\n    for (int i = 0; i < 10; i++) {\n      MMapDirectory mmapDir = new MMapDirectory(_TestUtil.getTempDir(\"testSeeking\"));\n      mmapDir.setMaxChunkSize(1<<i);\n      IndexOutput io = mmapDir.createOutput(\"bytes\");\n      byte bytes[] = new byte[1<<(i+1)]; // make sure we switch buffers\n      random.nextBytes(bytes);\n      io.writeBytes(bytes, bytes.length);\n      io.close();\n      IndexInput ii = mmapDir.openInput(\"bytes\");\n      byte actual[] = new byte[1<<(i+1)]; // first read all bytes\n      ii.readBytes(actual, 0, actual.length);\n      assertEquals(new BytesRef(bytes), new BytesRef(actual));\n      for (int sliceStart = 0; sliceStart < bytes.length; sliceStart++) {\n        for (int sliceLength = 0; sliceLength < bytes.length - sliceStart; sliceLength++) {\n          byte slice[] = new byte[sliceLength];\n          ii.seek(sliceStart);\n          ii.readBytes(slice, 0, slice.length);\n          assertEquals(new BytesRef(bytes, sliceStart, sliceLength), new BytesRef(slice));\n        }\n      }\n      ii.close();\n      mmapDir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6f9be74ca7baaef11857ad002cad40419979516","date":1309449808,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/store/TestMultiMMap#testSeeking().mjava","pathOld":"lucene/src/test/org/apache/lucene/store/TestMultiMMap#testSeeking().mjava","sourceNew":"  public void testSeeking() throws Exception {\n    for (int i = 0; i < 10; i++) {\n      MMapDirectory mmapDir = new MMapDirectory(_TestUtil.getTempDir(\"testSeeking\"));\n      mmapDir.setMaxChunkSize(1<<i);\n      IndexOutput io = mmapDir.createOutput(\"bytes\", newIOContext(random));\n      byte bytes[] = new byte[1<<(i+1)]; // make sure we switch buffers\n      random.nextBytes(bytes);\n      io.writeBytes(bytes, bytes.length);\n      io.close();\n      IndexInput ii = mmapDir.openInput(\"bytes\", newIOContext(random));\n      byte actual[] = new byte[1<<(i+1)]; // first read all bytes\n      ii.readBytes(actual, 0, actual.length);\n      assertEquals(new BytesRef(bytes), new BytesRef(actual));\n      for (int sliceStart = 0; sliceStart < bytes.length; sliceStart++) {\n        for (int sliceLength = 0; sliceLength < bytes.length - sliceStart; sliceLength++) {\n          byte slice[] = new byte[sliceLength];\n          ii.seek(sliceStart);\n          ii.readBytes(slice, 0, slice.length);\n          assertEquals(new BytesRef(bytes, sliceStart, sliceLength), new BytesRef(slice));\n        }\n      }\n      ii.close();\n      mmapDir.close();\n    }\n  }\n\n","sourceOld":"  public void testSeeking() throws Exception {\n    for (int i = 0; i < 10; i++) {\n      MMapDirectory mmapDir = new MMapDirectory(_TestUtil.getTempDir(\"testSeeking\"));\n      mmapDir.setMaxChunkSize(1<<i);\n      IndexOutput io = mmapDir.createOutput(\"bytes\", IOContext.DEFAULT);\n      byte bytes[] = new byte[1<<(i+1)]; // make sure we switch buffers\n      random.nextBytes(bytes);\n      io.writeBytes(bytes, bytes.length);\n      io.close();\n      IndexInput ii = mmapDir.openInput(\"bytes\", IOContext.DEFAULT);\n      byte actual[] = new byte[1<<(i+1)]; // first read all bytes\n      ii.readBytes(actual, 0, actual.length);\n      assertEquals(new BytesRef(bytes), new BytesRef(actual));\n      for (int sliceStart = 0; sliceStart < bytes.length; sliceStart++) {\n        for (int sliceLength = 0; sliceLength < bytes.length - sliceStart; sliceLength++) {\n          byte slice[] = new byte[sliceLength];\n          ii.seek(sliceStart);\n          ii.readBytes(slice, 0, slice.length);\n          assertEquals(new BytesRef(bytes, sliceStart, sliceLength), new BytesRef(slice));\n        }\n      }\n      ii.close();\n      mmapDir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ddc4c914be86e34b54f70023f45a60fa7f04e929","date":1310115160,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/store/TestMultiMMap#testSeeking().mjava","pathOld":"lucene/src/test/org/apache/lucene/store/TestMultiMMap#testSeeking().mjava","sourceNew":"  public void testSeeking() throws Exception {\n    for (int i = 0; i < 10; i++) {\n      MMapDirectory mmapDir = new MMapDirectory(_TestUtil.getTempDir(\"testSeeking\"));\n      mmapDir.setMaxChunkSize(1<<i);\n      IndexOutput io = mmapDir.createOutput(\"bytes\", newIOContext(random));\n      byte bytes[] = new byte[1<<(i+1)]; // make sure we switch buffers\n      random.nextBytes(bytes);\n      io.writeBytes(bytes, bytes.length);\n      io.close();\n      IndexInput ii = mmapDir.openInput(\"bytes\", newIOContext(random));\n      byte actual[] = new byte[1<<(i+1)]; // first read all bytes\n      ii.readBytes(actual, 0, actual.length);\n      assertEquals(new BytesRef(bytes), new BytesRef(actual));\n      for (int sliceStart = 0; sliceStart < bytes.length; sliceStart++) {\n        for (int sliceLength = 0; sliceLength < bytes.length - sliceStart; sliceLength++) {\n          byte slice[] = new byte[sliceLength];\n          ii.seek(sliceStart);\n          ii.readBytes(slice, 0, slice.length);\n          assertEquals(new BytesRef(bytes, sliceStart, sliceLength), new BytesRef(slice));\n        }\n      }\n      ii.close();\n      mmapDir.close();\n    }\n  }\n\n","sourceOld":"  public void testSeeking() throws Exception {\n    for (int i = 0; i < 10; i++) {\n      MMapDirectory mmapDir = new MMapDirectory(_TestUtil.getTempDir(\"testSeeking\"));\n      mmapDir.setMaxChunkSize(1<<i);\n      IndexOutput io = mmapDir.createOutput(\"bytes\");\n      byte bytes[] = new byte[1<<(i+1)]; // make sure we switch buffers\n      random.nextBytes(bytes);\n      io.writeBytes(bytes, bytes.length);\n      io.close();\n      IndexInput ii = mmapDir.openInput(\"bytes\");\n      byte actual[] = new byte[1<<(i+1)]; // first read all bytes\n      ii.readBytes(actual, 0, actual.length);\n      assertEquals(new BytesRef(bytes), new BytesRef(actual));\n      for (int sliceStart = 0; sliceStart < bytes.length; sliceStart++) {\n        for (int sliceLength = 0; sliceLength < bytes.length - sliceStart; sliceLength++) {\n          byte slice[] = new byte[sliceLength];\n          ii.seek(sliceStart);\n          ii.readBytes(slice, 0, slice.length);\n          assertEquals(new BytesRef(bytes, sliceStart, sliceLength), new BytesRef(slice));\n        }\n      }\n      ii.close();\n      mmapDir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5d004d0e0b3f65bb40da76d476d659d7888270e8","date":1310158940,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/store/TestMultiMMap#testSeeking().mjava","pathOld":"lucene/src/test/org/apache/lucene/store/TestMultiMMap#testSeeking().mjava","sourceNew":"  public void testSeeking() throws Exception {\n    for (int i = 0; i < 10; i++) {\n      MMapDirectory mmapDir = new MMapDirectory(_TestUtil.getTempDir(\"testSeeking\"));\n      mmapDir.setMaxChunkSize(1<<i);\n      IndexOutput io = mmapDir.createOutput(\"bytes\", newIOContext(random));\n      byte bytes[] = new byte[1<<(i+1)]; // make sure we switch buffers\n      random.nextBytes(bytes);\n      io.writeBytes(bytes, bytes.length);\n      io.close();\n      IndexInput ii = mmapDir.openInput(\"bytes\", newIOContext(random));\n      byte actual[] = new byte[1<<(i+1)]; // first read all bytes\n      ii.readBytes(actual, 0, actual.length);\n      assertEquals(new BytesRef(bytes), new BytesRef(actual));\n      for (int sliceStart = 0; sliceStart < bytes.length; sliceStart++) {\n        for (int sliceLength = 0; sliceLength < bytes.length - sliceStart; sliceLength++) {\n          byte slice[] = new byte[sliceLength];\n          ii.seek(sliceStart);\n          ii.readBytes(slice, 0, slice.length);\n          assertEquals(new BytesRef(bytes, sliceStart, sliceLength), new BytesRef(slice));\n        }\n      }\n      ii.close();\n      mmapDir.close();\n    }\n  }\n\n","sourceOld":"  public void testSeeking() throws Exception {\n    for (int i = 0; i < 10; i++) {\n      MMapDirectory mmapDir = new MMapDirectory(_TestUtil.getTempDir(\"testSeeking\"));\n      mmapDir.setMaxChunkSize(1<<i);\n      IndexOutput io = mmapDir.createOutput(\"bytes\");\n      byte bytes[] = new byte[1<<(i+1)]; // make sure we switch buffers\n      random.nextBytes(bytes);\n      io.writeBytes(bytes, bytes.length);\n      io.close();\n      IndexInput ii = mmapDir.openInput(\"bytes\");\n      byte actual[] = new byte[1<<(i+1)]; // first read all bytes\n      ii.readBytes(actual, 0, actual.length);\n      assertEquals(new BytesRef(bytes), new BytesRef(actual));\n      for (int sliceStart = 0; sliceStart < bytes.length; sliceStart++) {\n        for (int sliceLength = 0; sliceLength < bytes.length - sliceStart; sliceLength++) {\n          byte slice[] = new byte[sliceLength];\n          ii.seek(sliceStart);\n          ii.readBytes(slice, 0, slice.length);\n          assertEquals(new BytesRef(bytes, sliceStart, sliceLength), new BytesRef(slice));\n        }\n      }\n      ii.close();\n      mmapDir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/store/TestMultiMMap#testSeeking().mjava","pathOld":"lucene/src/test/org/apache/lucene/store/TestMultiMMap#testSeeking().mjava","sourceNew":"  public void testSeeking() throws Exception {\n    for (int i = 0; i < 10; i++) {\n      MMapDirectory mmapDir = new MMapDirectory(_TestUtil.getTempDir(\"testSeeking\"));\n      mmapDir.setMaxChunkSize(1<<i);\n      IndexOutput io = mmapDir.createOutput(\"bytes\", newIOContext(random));\n      byte bytes[] = new byte[1<<(i+1)]; // make sure we switch buffers\n      random.nextBytes(bytes);\n      io.writeBytes(bytes, bytes.length);\n      io.close();\n      IndexInput ii = mmapDir.openInput(\"bytes\", newIOContext(random));\n      byte actual[] = new byte[1<<(i+1)]; // first read all bytes\n      ii.readBytes(actual, 0, actual.length);\n      assertEquals(new BytesRef(bytes), new BytesRef(actual));\n      for (int sliceStart = 0; sliceStart < bytes.length; sliceStart++) {\n        for (int sliceLength = 0; sliceLength < bytes.length - sliceStart; sliceLength++) {\n          byte slice[] = new byte[sliceLength];\n          ii.seek(sliceStart);\n          ii.readBytes(slice, 0, slice.length);\n          assertEquals(new BytesRef(bytes, sliceStart, sliceLength), new BytesRef(slice));\n        }\n      }\n      ii.close();\n      mmapDir.close();\n    }\n  }\n\n","sourceOld":"  public void testSeeking() throws Exception {\n    for (int i = 0; i < 10; i++) {\n      MMapDirectory mmapDir = new MMapDirectory(_TestUtil.getTempDir(\"testSeeking\"));\n      mmapDir.setMaxChunkSize(1<<i);\n      IndexOutput io = mmapDir.createOutput(\"bytes\", newIOContext(random));\n      byte bytes[] = new byte[1<<(i+1)]; // make sure we switch buffers\n      random.nextBytes(bytes);\n      io.writeBytes(bytes, bytes.length);\n      io.close();\n      IndexInput ii = mmapDir.openInput(\"bytes\", newIOContext(random));\n      byte actual[] = new byte[1<<(i+1)]; // first read all bytes\n      ii.readBytes(actual, 0, actual.length);\n      assertEquals(new BytesRef(bytes), new BytesRef(actual));\n      for (int sliceStart = 0; sliceStart < bytes.length; sliceStart++) {\n        for (int sliceLength = 0; sliceLength < bytes.length - sliceStart; sliceLength++) {\n          byte slice[] = new byte[sliceLength];\n          ii.seek(sliceStart);\n          ii.readBytes(slice, 0, slice.length);\n          assertEquals(new BytesRef(bytes, sliceStart, sliceLength), new BytesRef(slice));\n        }\n      }\n      ii.close();\n      mmapDir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"68b4c6c95719e3020e407649a20b68538649beeb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b6f9be74ca7baaef11857ad002cad40419979516":["639c36565ce03aed5b0fce7c9e4448e53a1f7efd"],"639c36565ce03aed5b0fce7c9e4448e53a1f7efd":["68b4c6c95719e3020e407649a20b68538649beeb"],"5d004d0e0b3f65bb40da76d476d659d7888270e8":["9ed208afa1e7aa98899ddb1dedfddedddf898253","ddc4c914be86e34b54f70023f45a60fa7f04e929"],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["68b4c6c95719e3020e407649a20b68538649beeb","b6f9be74ca7baaef11857ad002cad40419979516"],"9ed208afa1e7aa98899ddb1dedfddedddf898253":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","68b4c6c95719e3020e407649a20b68538649beeb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"68b4c6c95719e3020e407649a20b68538649beeb":["639c36565ce03aed5b0fce7c9e4448e53a1f7efd","ddc4c914be86e34b54f70023f45a60fa7f04e929","9ed208afa1e7aa98899ddb1dedfddedddf898253"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["68b4c6c95719e3020e407649a20b68538649beeb","9ed208afa1e7aa98899ddb1dedfddedddf898253"],"b6f9be74ca7baaef11857ad002cad40419979516":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"639c36565ce03aed5b0fce7c9e4448e53a1f7efd":["b6f9be74ca7baaef11857ad002cad40419979516"],"5d004d0e0b3f65bb40da76d476d659d7888270e8":[],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","5d004d0e0b3f65bb40da76d476d659d7888270e8"],"9ed208afa1e7aa98899ddb1dedfddedddf898253":["5d004d0e0b3f65bb40da76d476d659d7888270e8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5d004d0e0b3f65bb40da76d476d659d7888270e8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}