{"path":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterSSL#testSslWithInvalidPeerName().mjava","commits":[{"id":"e67ae138c1173c6193dbcfd9a94142b99ed2a0c5","date":1524429517,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterSSL#testSslWithInvalidPeerName().mjava","pathOld":"/dev/null","sourceNew":"  /** Sanity check that our test scaffolding for validating SSL peer names fails when it should */\n  public void testSslWithInvalidPeerName() throws Exception {\n    // NOTE: first initialize the cluster w/o peer name checks, which means our server will use\n    // certs with a bogus hostname/ip and clients shouldn't care...\n    final SSLTestConfig sslConfig = new SSLTestConfig(true, false, false);\n    HttpClientUtil.setSchemaRegistryProvider(sslConfig.buildClientSchemaRegistryProvider());\n    System.setProperty(ZkStateReader.URL_SCHEME, \"https\");\n    final JettyConfig config = JettyConfig.builder().withSSLConfig(sslConfig).build();\n    final MiniSolrCloudCluster cluster = new MiniSolrCloudCluster(NUM_SERVERS, createTempDir(), config);\n    try {\n      checkClusterWithCollectionCreations(cluster, sslConfig);\n      \n      // now initialize a client that still uses the existing SSLContext/Provider, so it will accept\n      // our existing certificate, but *does* care about validating the peer name\n      System.setProperty(HttpClientUtil.SYS_PROP_CHECK_PEER_NAME, \"true\");\n      HttpClientUtil.resetHttpClientBuilder();\n\n      // and validate we get failures when trying to talk to our cluster...\n      final List<JettySolrRunner> jettys = cluster.getJettySolrRunners();\n      for (JettySolrRunner jetty : jettys) {\n        final String baseURL = jetty.getBaseUrl().toString();\n        // verify new solr clients validate peer name and can't talk to this server\n        Exception ex = expectThrows(SolrServerException.class, () -> {\n            try (HttpSolrClient client = getRandomizedHttpSolrClient(baseURL)) {\n              CoreAdminRequest req = new CoreAdminRequest();\n              req.setAction( CoreAdminAction.STATUS );\n              client.request(req);\n            }\n          });\n        assertTrue(\"Expected an root cause SSL Exception, got: \" + ex.toString(),\n                   ex.getCause() instanceof SSLException);\n      }\n    } finally {\n      cluster.shutdown();\n    }\n\n\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1a77e5e21cbd575a8240b0e3926164f15295f4e8","date":1544979500,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterSSL#testSslWithInvalidPeerName().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterSSL#testSslWithInvalidPeerName().mjava","sourceNew":"  /** Sanity check that our test scaffolding for validating SSL peer names fails when it should */\n  public void testSslWithInvalidPeerName() throws Exception {\n    // NOTE: first initialize the cluster w/o peer name checks, which means our server will use\n    // certs with a bogus hostname/ip and clients shouldn't care...\n    final SSLTestConfig sslConfig = new SSLTestConfig(true, false, false);\n    HttpClientUtil.setSchemaRegistryProvider(sslConfig.buildClientSchemaRegistryProvider());\n    Http2SolrClient.setDefaultSSLConfig(sslConfig.buildClientSSLConfig());\n    System.setProperty(ZkStateReader.URL_SCHEME, \"https\");\n    final JettyConfig config = JettyConfig.builder().withSSLConfig(sslConfig.buildServerSSLConfig()).build();\n    final MiniSolrCloudCluster cluster = new MiniSolrCloudCluster(NUM_SERVERS, createTempDir(), config);\n    try {\n      checkClusterWithCollectionCreations(cluster, sslConfig);\n      \n      // now initialize a client that still uses the existing SSLContext/Provider, so it will accept\n      // our existing certificate, but *does* care about validating the peer name\n      System.setProperty(HttpClientUtil.SYS_PROP_CHECK_PEER_NAME, \"true\");\n      HttpClientUtil.resetHttpClientBuilder();\n      Http2SolrClient.resetSslContextFactory();\n\n      // and validate we get failures when trying to talk to our cluster...\n      final List<JettySolrRunner> jettys = cluster.getJettySolrRunners();\n      for (JettySolrRunner jetty : jettys) {\n        final String baseURL = jetty.getBaseUrl().toString();\n        // verify new solr clients validate peer name and can't talk to this server\n        Exception ex = expectThrows(SolrServerException.class, () -> {\n            try (HttpSolrClient client = getRandomizedHttpSolrClient(baseURL)) {\n              CoreAdminRequest req = new CoreAdminRequest();\n              req.setAction( CoreAdminAction.STATUS );\n              client.request(req);\n            }\n          });\n        assertTrue(\"Expected an root cause SSL Exception, got: \" + ex.toString(),\n                   ex.getCause() instanceof SSLException);\n      }\n    } finally {\n      cluster.shutdown();\n    }\n\n\n    \n  }\n\n","sourceOld":"  /** Sanity check that our test scaffolding for validating SSL peer names fails when it should */\n  public void testSslWithInvalidPeerName() throws Exception {\n    // NOTE: first initialize the cluster w/o peer name checks, which means our server will use\n    // certs with a bogus hostname/ip and clients shouldn't care...\n    final SSLTestConfig sslConfig = new SSLTestConfig(true, false, false);\n    HttpClientUtil.setSchemaRegistryProvider(sslConfig.buildClientSchemaRegistryProvider());\n    System.setProperty(ZkStateReader.URL_SCHEME, \"https\");\n    final JettyConfig config = JettyConfig.builder().withSSLConfig(sslConfig).build();\n    final MiniSolrCloudCluster cluster = new MiniSolrCloudCluster(NUM_SERVERS, createTempDir(), config);\n    try {\n      checkClusterWithCollectionCreations(cluster, sslConfig);\n      \n      // now initialize a client that still uses the existing SSLContext/Provider, so it will accept\n      // our existing certificate, but *does* care about validating the peer name\n      System.setProperty(HttpClientUtil.SYS_PROP_CHECK_PEER_NAME, \"true\");\n      HttpClientUtil.resetHttpClientBuilder();\n\n      // and validate we get failures when trying to talk to our cluster...\n      final List<JettySolrRunner> jettys = cluster.getJettySolrRunners();\n      for (JettySolrRunner jetty : jettys) {\n        final String baseURL = jetty.getBaseUrl().toString();\n        // verify new solr clients validate peer name and can't talk to this server\n        Exception ex = expectThrows(SolrServerException.class, () -> {\n            try (HttpSolrClient client = getRandomizedHttpSolrClient(baseURL)) {\n              CoreAdminRequest req = new CoreAdminRequest();\n              req.setAction( CoreAdminAction.STATUS );\n              client.request(req);\n            }\n          });\n        assertTrue(\"Expected an root cause SSL Exception, got: \" + ex.toString(),\n                   ex.getCause() instanceof SSLException);\n      }\n    } finally {\n      cluster.shutdown();\n    }\n\n\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9e856e5ac973044540959acff90fa900278d2692","date":1585275350,"type":3,"author":"Andy Throgmorton","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterSSL#testSslWithInvalidPeerName().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterSSL#testSslWithInvalidPeerName().mjava","sourceNew":"  /** Sanity check that our test scaffolding for validating SSL peer names fails when it should */\n  public void testSslWithInvalidPeerName() throws Exception {\n    // NOTE: first initialize the cluster w/o peer name checks, which means our server will use\n    // certs with a bogus hostname/ip and clients shouldn't care...\n    final SSLTestConfig sslConfig = new SSLTestConfig(true, false, false);\n    HttpClientUtil.setSocketFactoryRegistryProvider(sslConfig.buildClientSocketFactoryRegistryProvider());\n    Http2SolrClient.setDefaultSSLConfig(sslConfig.buildClientSSLConfig());\n    System.setProperty(ZkStateReader.URL_SCHEME, \"https\");\n    final JettyConfig config = JettyConfig.builder().withSSLConfig(sslConfig.buildServerSSLConfig()).build();\n    final MiniSolrCloudCluster cluster = new MiniSolrCloudCluster(NUM_SERVERS, createTempDir(), config);\n    try {\n      checkClusterWithCollectionCreations(cluster, sslConfig);\n      \n      // now initialize a client that still uses the existing SSLContext/Provider, so it will accept\n      // our existing certificate, but *does* care about validating the peer name\n      System.setProperty(HttpClientUtil.SYS_PROP_CHECK_PEER_NAME, \"true\");\n      HttpClientUtil.resetHttpClientBuilder();\n      Http2SolrClient.resetSslContextFactory();\n\n      // and validate we get failures when trying to talk to our cluster...\n      final List<JettySolrRunner> jettys = cluster.getJettySolrRunners();\n      for (JettySolrRunner jetty : jettys) {\n        final String baseURL = jetty.getBaseUrl().toString();\n        // verify new solr clients validate peer name and can't talk to this server\n        Exception ex = expectThrows(SolrServerException.class, () -> {\n            try (HttpSolrClient client = getRandomizedHttpSolrClient(baseURL)) {\n              CoreAdminRequest req = new CoreAdminRequest();\n              req.setAction( CoreAdminAction.STATUS );\n              client.request(req);\n            }\n          });\n        assertTrue(\"Expected an root cause SSL Exception, got: \" + ex.toString(),\n                   ex.getCause() instanceof SSLException);\n      }\n    } finally {\n      cluster.shutdown();\n    }\n\n\n    \n  }\n\n","sourceOld":"  /** Sanity check that our test scaffolding for validating SSL peer names fails when it should */\n  public void testSslWithInvalidPeerName() throws Exception {\n    // NOTE: first initialize the cluster w/o peer name checks, which means our server will use\n    // certs with a bogus hostname/ip and clients shouldn't care...\n    final SSLTestConfig sslConfig = new SSLTestConfig(true, false, false);\n    HttpClientUtil.setSchemaRegistryProvider(sslConfig.buildClientSchemaRegistryProvider());\n    Http2SolrClient.setDefaultSSLConfig(sslConfig.buildClientSSLConfig());\n    System.setProperty(ZkStateReader.URL_SCHEME, \"https\");\n    final JettyConfig config = JettyConfig.builder().withSSLConfig(sslConfig.buildServerSSLConfig()).build();\n    final MiniSolrCloudCluster cluster = new MiniSolrCloudCluster(NUM_SERVERS, createTempDir(), config);\n    try {\n      checkClusterWithCollectionCreations(cluster, sslConfig);\n      \n      // now initialize a client that still uses the existing SSLContext/Provider, so it will accept\n      // our existing certificate, but *does* care about validating the peer name\n      System.setProperty(HttpClientUtil.SYS_PROP_CHECK_PEER_NAME, \"true\");\n      HttpClientUtil.resetHttpClientBuilder();\n      Http2SolrClient.resetSslContextFactory();\n\n      // and validate we get failures when trying to talk to our cluster...\n      final List<JettySolrRunner> jettys = cluster.getJettySolrRunners();\n      for (JettySolrRunner jetty : jettys) {\n        final String baseURL = jetty.getBaseUrl().toString();\n        // verify new solr clients validate peer name and can't talk to this server\n        Exception ex = expectThrows(SolrServerException.class, () -> {\n            try (HttpSolrClient client = getRandomizedHttpSolrClient(baseURL)) {\n              CoreAdminRequest req = new CoreAdminRequest();\n              req.setAction( CoreAdminAction.STATUS );\n              client.request(req);\n            }\n          });\n        assertTrue(\"Expected an root cause SSL Exception, got: \" + ex.toString(),\n                   ex.getCause() instanceof SSLException);\n      }\n    } finally {\n      cluster.shutdown();\n    }\n\n\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["e67ae138c1173c6193dbcfd9a94142b99ed2a0c5"],"e67ae138c1173c6193dbcfd9a94142b99ed2a0c5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9e856e5ac973044540959acff90fa900278d2692":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9e856e5ac973044540959acff90fa900278d2692"]},"commit2Childs":{"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["9e856e5ac973044540959acff90fa900278d2692"],"e67ae138c1173c6193dbcfd9a94142b99ed2a0c5":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"],"9e856e5ac973044540959acff90fa900278d2692":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e67ae138c1173c6193dbcfd9a94142b99ed2a0c5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}