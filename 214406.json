{"path":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,long,Map[String,String],int,int,int,boolean).mjava","commits":[{"id":"1dbcafacd03baeb0f18199de611a1619606073c5","date":1546559081,"type":1,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,long,Map[String,String],int,int,int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,long,int,int,int,boolean).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n                                          DocValuesType docValues, long dvGen,\n                                          Map<String, String> attributes,\n                                          int dataDimensionCount, int indexDimensionCount, int dimensionNumBytes,\n                                          boolean isSoftDeletesField) {\n      assert assertNotFinished();\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      if (attributes != null) {\n        // original attributes is UnmodifiableMap\n        attributes = new HashMap<>(attributes);\n      }\n\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, indexOptions, docValues, dataDimensionCount, indexDimensionCount, dimensionNumBytes, isSoftDeletesField);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, dvGen, attributes, dataDimensionCount, indexDimensionCount, dimensionNumBytes, isSoftDeletesField);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, attributes, dataDimensionCount, indexDimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          fi.setDocValuesGen(dvGen);\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n                                          DocValuesType docValues, long dvGen,\n                                          int dataDimensionCount, int indexDimensionCount, int dimensionNumBytes,\n                                          boolean isSoftDeletesField) {\n      assert assertNotFinished();\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, indexOptions, docValues, dataDimensionCount, indexDimensionCount, dimensionNumBytes, isSoftDeletesField);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, dvGen, new HashMap<>(), dataDimensionCount, indexDimensionCount, dimensionNumBytes, isSoftDeletesField);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dataDimensionCount, indexDimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          fi.setDocValuesGen(dvGen);\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1dbcafacd03baeb0f18199de611a1619606073c5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1dbcafacd03baeb0f18199de611a1619606073c5"]},"commit2Childs":{"1dbcafacd03baeb0f18199de611a1619606073c5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1dbcafacd03baeb0f18199de611a1619606073c5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}