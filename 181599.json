{"path":"solr/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","commits":[{"id":"893269407f5c988a4b2ee13c7ffc01ec43136c1d","date":1268598046,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"/dev/null","sourceNew":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    boolean doPersist = false;\n    SolrParams params = req.getParams();\n    SolrParams required = params.required();\n    String cname = required.get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    if (core != null) {\n      try {\n        doPersist = coreContainer.isPersistent();\n\n        String[] dirNames = required.getParams(CoreAdminParams.INDEX_DIR);\n\n        DirectoryFactory dirFactory = core.getDirectoryFactory();\n        Directory[] dirs = new Directory[dirNames.length];\n        for (int i = 0; i < dirNames.length; i++) {\n          dirs[i] = dirFactory.open(dirNames[i]);\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_PROCESSOR));\n        SolrQueryRequest wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(dirs));\n      } finally {\n        core.close();\n      }\n    }\n    return doPersist;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","date":1268599006,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":null,"sourceOld":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    boolean doPersist = false;\n    SolrParams params = req.getParams();\n    SolrParams required = params.required();\n    String cname = required.get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    if (core != null) {\n      try {\n        doPersist = coreContainer.isPersistent();\n\n        String[] dirNames = required.getParams(CoreAdminParams.INDEX_DIR);\n\n        DirectoryFactory dirFactory = core.getDirectoryFactory();\n        Directory[] dirs = new Directory[dirNames.length];\n        for (int i = 0; i < dirNames.length; i++) {\n          dirs[i] = dirFactory.open(dirNames[i]);\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_PROCESSOR));\n        SolrQueryRequest wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(dirs));\n      } finally {\n        core.close();\n      }\n    }\n    return doPersist;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    boolean doPersist = false;\n    SolrParams params = req.getParams();\n    SolrParams required = params.required();\n    String cname = required.get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    if (core != null) {\n      try {\n        doPersist = coreContainer.isPersistent();\n\n        String[] dirNames = required.getParams(CoreAdminParams.INDEX_DIR);\n\n        DirectoryFactory dirFactory = core.getDirectoryFactory();\n        Directory[] dirs = new Directory[dirNames.length];\n        for (int i = 0; i < dirNames.length; i++) {\n          dirs[i] = dirFactory.open(dirNames[i]);\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_PROCESSOR));\n        SolrQueryRequest wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(dirs));\n      } finally {\n        core.close();\n      }\n    }\n    return doPersist;\n  }\n\n","sourceOld":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    boolean doPersist = false;\n    SolrParams params = req.getParams();\n    SolrParams required = params.required();\n    String cname = required.get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    if (core != null) {\n      try {\n        doPersist = coreContainer.isPersistent();\n\n        String[] dirNames = required.getParams(CoreAdminParams.INDEX_DIR);\n\n        DirectoryFactory dirFactory = core.getDirectoryFactory();\n        Directory[] dirs = new Directory[dirNames.length];\n        for (int i = 0; i < dirNames.length; i++) {\n          dirs[i] = dirFactory.open(dirNames[i]);\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_PROCESSOR));\n        SolrQueryRequest wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(dirs));\n      } finally {\n        core.close();\n      }\n    }\n    return doPersist;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da8d55113b689b06716246649de6f62430f15c0","date":1453508340,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"/dev/null","sourceNew":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    boolean doPersist = false;\n    SolrParams params = req.getParams();\n    SolrParams required = params.required();\n    String cname = required.get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    if (core != null) {\n      try {\n        doPersist = coreContainer.isPersistent();\n\n        String[] dirNames = required.getParams(CoreAdminParams.INDEX_DIR);\n\n        DirectoryFactory dirFactory = core.getDirectoryFactory();\n        Directory[] dirs = new Directory[dirNames.length];\n        for (int i = 0; i < dirNames.length; i++) {\n          dirs[i] = dirFactory.open(dirNames[i]);\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_PROCESSOR));\n        SolrQueryRequest wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(dirs));\n      } finally {\n        core.close();\n      }\n    }\n    return doPersist;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"00318b5ccee52f434e86d8e89ec9a065985b62df","date":1287345061,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    boolean doPersist = false;\n    SolrParams params = req.getParams();\n    SolrParams required = params.required();\n    String cname = required.get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest wrappedReq = null;\n    if (core != null) {\n      try {\n        doPersist = coreContainer.isPersistent();\n\n        String[] dirNames = required.getParams(CoreAdminParams.INDEX_DIR);\n\n        DirectoryFactory dirFactory = core.getDirectoryFactory();\n        Directory[] dirs = new Directory[dirNames.length];\n        for (int i = 0; i < dirNames.length; i++) {\n          dirs[i] = dirFactory.open(dirNames[i]);\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_PROCESSOR));\n        wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(dirs));\n      } finally {\n        core.close();\n        wrappedReq.close();\n      }\n    }\n    return doPersist;\n  }\n\n","sourceOld":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    boolean doPersist = false;\n    SolrParams params = req.getParams();\n    SolrParams required = params.required();\n    String cname = required.get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    if (core != null) {\n      try {\n        doPersist = coreContainer.isPersistent();\n\n        String[] dirNames = required.getParams(CoreAdminParams.INDEX_DIR);\n\n        DirectoryFactory dirFactory = core.getDirectoryFactory();\n        Directory[] dirs = new Directory[dirNames.length];\n        for (int i = 0; i < dirNames.length; i++) {\n          dirs[i] = dirFactory.open(dirNames[i]);\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_PROCESSOR));\n        SolrQueryRequest wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(dirs));\n      } finally {\n        core.close();\n      }\n    }\n    return doPersist;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ecea1664e8617d82eca3b8055a3c37cb4da8511","date":1287578668,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    boolean doPersist = false;\n    SolrParams params = req.getParams();\n    SolrParams required = params.required();\n    String cname = required.get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest wrappedReq = null;\n    if (core != null) {\n      try {\n        doPersist = coreContainer.isPersistent();\n\n        String[] dirNames = required.getParams(CoreAdminParams.INDEX_DIR);\n\n        DirectoryFactory dirFactory = core.getDirectoryFactory();\n        Directory[] dirs = new Directory[dirNames.length];\n        for (int i = 0; i < dirNames.length; i++) {\n          dirs[i] = dirFactory.open(dirNames[i]);\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_PROCESSOR));\n        wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(dirs));\n      } finally {\n        core.close();\n        wrappedReq.close();\n      }\n    }\n    return doPersist;\n  }\n\n","sourceOld":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    boolean doPersist = false;\n    SolrParams params = req.getParams();\n    SolrParams required = params.required();\n    String cname = required.get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    if (core != null) {\n      try {\n        doPersist = coreContainer.isPersistent();\n\n        String[] dirNames = required.getParams(CoreAdminParams.INDEX_DIR);\n\n        DirectoryFactory dirFactory = core.getDirectoryFactory();\n        Directory[] dirs = new Directory[dirNames.length];\n        for (int i = 0; i < dirNames.length; i++) {\n          dirs[i] = dirFactory.open(dirNames[i]);\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_PROCESSOR));\n        SolrQueryRequest wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(dirs));\n      } finally {\n        core.close();\n      }\n    }\n    return doPersist;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    boolean doPersist = false;\n    SolrParams params = req.getParams();\n    SolrParams required = params.required();\n    String cname = required.get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest wrappedReq = null;\n    if (core != null) {\n      try {\n        doPersist = coreContainer.isPersistent();\n\n        String[] dirNames = required.getParams(CoreAdminParams.INDEX_DIR);\n\n        DirectoryFactory dirFactory = core.getDirectoryFactory();\n        Directory[] dirs = new Directory[dirNames.length];\n        for (int i = 0; i < dirNames.length; i++) {\n          dirs[i] = dirFactory.open(dirNames[i]);\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_PROCESSOR));\n        wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(dirs));\n      } finally {\n        core.close();\n        wrappedReq.close();\n      }\n    }\n    return doPersist;\n  }\n\n","sourceOld":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    boolean doPersist = false;\n    SolrParams params = req.getParams();\n    SolrParams required = params.required();\n    String cname = required.get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    if (core != null) {\n      try {\n        doPersist = coreContainer.isPersistent();\n\n        String[] dirNames = required.getParams(CoreAdminParams.INDEX_DIR);\n\n        DirectoryFactory dirFactory = core.getDirectoryFactory();\n        Directory[] dirs = new Directory[dirNames.length];\n        for (int i = 0; i < dirNames.length; i++) {\n          dirs[i] = dirFactory.open(dirNames[i]);\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_PROCESSOR));\n        SolrQueryRequest wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(dirs));\n      } finally {\n        core.close();\n      }\n    }\n    return doPersist;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ae62bcdfd4a0689a745ab1d38c6bd1c7c390cfa","date":1293733647,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    boolean doPersist = false;\n    SolrParams params = req.getParams();\n    SolrParams required = params.required();\n    String cname = required.get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest wrappedReq = null;\n    if (core != null) {\n      try {\n        doPersist = coreContainer.isPersistent();\n\n        String[] dirNames = required.getParams(CoreAdminParams.INDEX_DIR);\n\n        DirectoryFactory dirFactory = core.getDirectoryFactory();\n        Directory[] dirs = new Directory[dirNames.length];\n        for (int i = 0; i < dirNames.length; i++) {\n          dirs[i] = dirFactory.open(dirNames[i]);\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_PROCESSOR));\n        wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(dirs, req));\n      } finally {\n        core.close();\n        wrappedReq.close();\n      }\n    }\n    return doPersist;\n  }\n\n","sourceOld":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    boolean doPersist = false;\n    SolrParams params = req.getParams();\n    SolrParams required = params.required();\n    String cname = required.get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest wrappedReq = null;\n    if (core != null) {\n      try {\n        doPersist = coreContainer.isPersistent();\n\n        String[] dirNames = required.getParams(CoreAdminParams.INDEX_DIR);\n\n        DirectoryFactory dirFactory = core.getDirectoryFactory();\n        Directory[] dirs = new Directory[dirNames.length];\n        for (int i = 0; i < dirNames.length; i++) {\n          dirs[i] = dirFactory.open(dirNames[i]);\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_PROCESSOR));\n        wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(dirs));\n      } finally {\n        core.close();\n        wrappedReq.close();\n      }\n    }\n    return doPersist;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c","date":1294014627,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    boolean doPersist = false;\n    SolrParams params = req.getParams();\n    SolrParams required = params.required();\n    String cname = required.get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest wrappedReq = null;\n    if (core != null) {\n      try {\n        doPersist = coreContainer.isPersistent();\n\n        String[] dirNames = required.getParams(CoreAdminParams.INDEX_DIR);\n\n        DirectoryFactory dirFactory = core.getDirectoryFactory();\n        Directory[] dirs = new Directory[dirNames.length];\n        for (int i = 0; i < dirNames.length; i++) {\n          dirs[i] = dirFactory.open(dirNames[i]);\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_PROCESSOR));\n        wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(dirs, req));\n      } finally {\n        core.close();\n        wrappedReq.close();\n      }\n    }\n    return doPersist;\n  }\n\n","sourceOld":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    boolean doPersist = false;\n    SolrParams params = req.getParams();\n    SolrParams required = params.required();\n    String cname = required.get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest wrappedReq = null;\n    if (core != null) {\n      try {\n        doPersist = coreContainer.isPersistent();\n\n        String[] dirNames = required.getParams(CoreAdminParams.INDEX_DIR);\n\n        DirectoryFactory dirFactory = core.getDirectoryFactory();\n        Directory[] dirs = new Directory[dirNames.length];\n        for (int i = 0; i < dirNames.length; i++) {\n          dirs[i] = dirFactory.open(dirNames[i]);\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_PROCESSOR));\n        wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(dirs));\n      } finally {\n        core.close();\n        wrappedReq.close();\n      }\n    }\n    return doPersist;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70ad682703b8585f5d0a637efec044d57ec05efb","date":1294259117,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    boolean doPersist = false;\n    SolrParams params = req.getParams();\n    SolrParams required = params.required();\n    String cname = required.get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest wrappedReq = null;\n    if (core != null) {\n      try {\n        doPersist = coreContainer.isPersistent();\n\n        String[] dirNames = required.getParams(CoreAdminParams.INDEX_DIR);\n\n        DirectoryFactory dirFactory = core.getDirectoryFactory();\n        Directory[] dirs = new Directory[dirNames.length];\n        for (int i = 0; i < dirNames.length; i++) {\n          dirs[i] = dirFactory.open(dirNames[i]);\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_PROCESSOR));\n        wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(dirs, req));\n      } finally {\n        core.close();\n        wrappedReq.close();\n      }\n    }\n    return doPersist;\n  }\n\n","sourceOld":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    boolean doPersist = false;\n    SolrParams params = req.getParams();\n    SolrParams required = params.required();\n    String cname = required.get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest wrappedReq = null;\n    if (core != null) {\n      try {\n        doPersist = coreContainer.isPersistent();\n\n        String[] dirNames = required.getParams(CoreAdminParams.INDEX_DIR);\n\n        DirectoryFactory dirFactory = core.getDirectoryFactory();\n        Directory[] dirs = new Directory[dirNames.length];\n        for (int i = 0; i < dirNames.length; i++) {\n          dirs[i] = dirFactory.open(dirNames[i]);\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_PROCESSOR));\n        wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(dirs));\n      } finally {\n        core.close();\n        wrappedReq.close();\n      }\n    }\n    return doPersist;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"64cae353de680169c133e0a9f4debee071ad3241","date":1303312298,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    boolean doPersist = false;\n    SolrParams params = req.getParams();\n    SolrParams required = params.required();\n    String cname = required.get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest wrappedReq = null;\n    if (core != null) {\n      try {\n        doPersist = coreContainer.isPersistent();\n\n        String[] dirNames = required.getParams(CoreAdminParams.INDEX_DIR);\n\n        DirectoryFactory dirFactory = core.getDirectoryFactory();\n        Directory[] dirs = new Directory[dirNames.length];\n        for (int i = 0; i < dirNames.length; i++) {\n          dirs[i] = dirFactory.open(dirNames[i]);\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_CHAIN));\n        wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(dirs, req));\n      } finally {\n        core.close();\n        wrappedReq.close();\n      }\n    }\n    return doPersist;\n  }\n\n","sourceOld":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    boolean doPersist = false;\n    SolrParams params = req.getParams();\n    SolrParams required = params.required();\n    String cname = required.get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest wrappedReq = null;\n    if (core != null) {\n      try {\n        doPersist = coreContainer.isPersistent();\n\n        String[] dirNames = required.getParams(CoreAdminParams.INDEX_DIR);\n\n        DirectoryFactory dirFactory = core.getDirectoryFactory();\n        Directory[] dirs = new Directory[dirNames.length];\n        for (int i = 0; i < dirNames.length; i++) {\n          dirs[i] = dirFactory.open(dirNames[i]);\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_PROCESSOR));\n        wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(dirs, req));\n      } finally {\n        core.close();\n        wrappedReq.close();\n      }\n    }\n    return doPersist;\n  }\n\n","bugFix":null,"bugIntro":["38cf2ff411b3f7342febd22163907bafb5342a6f","38cf2ff411b3f7342febd22163907bafb5342a6f","38cf2ff411b3f7342febd22163907bafb5342a6f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d493718201f0d0c54c773fb323d87bbd2fbffe41","date":1303546048,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    boolean doPersist = false;\n    SolrParams params = req.getParams();\n    SolrParams required = params.required();\n    String cname = required.get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest wrappedReq = null;\n    if (core != null) {\n      try {\n        doPersist = coreContainer.isPersistent();\n\n        String[] dirNames = required.getParams(CoreAdminParams.INDEX_DIR);\n\n        DirectoryFactory dirFactory = core.getDirectoryFactory();\n        Directory[] dirs = new Directory[dirNames.length];\n        for (int i = 0; i < dirNames.length; i++) {\n          dirs[i] = dirFactory.open(dirNames[i]);\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_CHAIN));\n        wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(dirs, req));\n      } finally {\n        core.close();\n        wrappedReq.close();\n      }\n    }\n    return doPersist;\n  }\n\n","sourceOld":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    boolean doPersist = false;\n    SolrParams params = req.getParams();\n    SolrParams required = params.required();\n    String cname = required.get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest wrappedReq = null;\n    if (core != null) {\n      try {\n        doPersist = coreContainer.isPersistent();\n\n        String[] dirNames = required.getParams(CoreAdminParams.INDEX_DIR);\n\n        DirectoryFactory dirFactory = core.getDirectoryFactory();\n        Directory[] dirs = new Directory[dirNames.length];\n        for (int i = 0; i < dirNames.length; i++) {\n          dirs[i] = dirFactory.open(dirNames[i]);\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_PROCESSOR));\n        wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(dirs, req));\n      } finally {\n        core.close();\n        wrappedReq.close();\n      }\n    }\n    return doPersist;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    boolean doPersist = false;\n    SolrParams params = req.getParams();\n    SolrParams required = params.required();\n    String cname = required.get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest wrappedReq = null;\n    if (core != null) {\n      try {\n        doPersist = coreContainer.isPersistent();\n\n        String[] dirNames = required.getParams(CoreAdminParams.INDEX_DIR);\n\n        DirectoryFactory dirFactory = core.getDirectoryFactory();\n        Directory[] dirs = new Directory[dirNames.length];\n        for (int i = 0; i < dirNames.length; i++) {\n          dirs[i] = dirFactory.open(dirNames[i]);\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_CHAIN));\n        wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(dirs, req));\n      } finally {\n        core.close();\n        wrappedReq.close();\n      }\n    }\n    return doPersist;\n  }\n\n","sourceOld":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    boolean doPersist = false;\n    SolrParams params = req.getParams();\n    SolrParams required = params.required();\n    String cname = required.get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest wrappedReq = null;\n    if (core != null) {\n      try {\n        doPersist = coreContainer.isPersistent();\n\n        String[] dirNames = required.getParams(CoreAdminParams.INDEX_DIR);\n\n        DirectoryFactory dirFactory = core.getDirectoryFactory();\n        Directory[] dirs = new Directory[dirNames.length];\n        for (int i = 0; i < dirNames.length; i++) {\n          dirs[i] = dirFactory.open(dirNames[i]);\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_PROCESSOR));\n        wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(dirs, req));\n      } finally {\n        core.close();\n        wrappedReq.close();\n      }\n    }\n    return doPersist;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    boolean doPersist = false;\n    SolrParams params = req.getParams();\n    SolrParams required = params.required();\n    String cname = required.get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest wrappedReq = null;\n    if (core != null) {\n      try {\n        doPersist = coreContainer.isPersistent();\n\n        String[] dirNames = required.getParams(CoreAdminParams.INDEX_DIR);\n\n        DirectoryFactory dirFactory = core.getDirectoryFactory();\n        Directory[] dirs = new Directory[dirNames.length];\n        for (int i = 0; i < dirNames.length; i++) {\n          dirs[i] = dirFactory.open(dirNames[i]);\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_CHAIN));\n        wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(dirs, req));\n      } finally {\n        core.close();\n        wrappedReq.close();\n      }\n    }\n    return doPersist;\n  }\n\n","sourceOld":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    boolean doPersist = false;\n    SolrParams params = req.getParams();\n    SolrParams required = params.required();\n    String cname = required.get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest wrappedReq = null;\n    if (core != null) {\n      try {\n        doPersist = coreContainer.isPersistent();\n\n        String[] dirNames = required.getParams(CoreAdminParams.INDEX_DIR);\n\n        DirectoryFactory dirFactory = core.getDirectoryFactory();\n        Directory[] dirs = new Directory[dirNames.length];\n        for (int i = 0; i < dirNames.length; i++) {\n          dirs[i] = dirFactory.open(dirNames[i]);\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_PROCESSOR));\n        wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(dirs, req));\n      } finally {\n        core.close();\n        wrappedReq.close();\n      }\n    }\n    return doPersist;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0a3f35d651410616f5a600589b0096c31f88f9a6","date":1308555132,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = req.getParams();\n    String cname = params.required().get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest wrappedReq = null;\n\n    SolrCore[] sourceCores = null;\n    RefCounted<SolrIndexSearcher>[] searchers = null;\n    // stores readers created from indexDir param values\n    IndexReader[] readersToBeClosed = null;\n    if (core != null) {\n      try {\n        String[] dirNames = params.getParams(CoreAdminParams.INDEX_DIR);\n        if (dirNames == null || dirNames.length == 0) {\n          String[] sources = params.getParams(\"srcCore\");\n          if (sources == null || sources.length == 0)\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n                \"At least one indexDir or srcCore must be specified\");\n\n          sourceCores = new SolrCore[sources.length];\n          for (int i = 0; i < sources.length; i++) {\n            String source = sources[i];\n            SolrCore srcCore = coreContainer.getCore(source);\n            if (srcCore == null)\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                  \"Core: \" + source + \" does not exist\");\n            sourceCores[i] = srcCore;\n          }\n        } else  {\n          readersToBeClosed = new IndexReader[dirNames.length];\n          DirectoryFactory dirFactory = core.getDirectoryFactory();\n          for (int i = 0; i < dirNames.length; i++) {\n            readersToBeClosed[i] = IndexReader.open(dirFactory.open(dirNames[i]), true);\n          }\n        }\n\n        IndexReader[] readers = null;\n        if (readersToBeClosed != null)  {\n          readers = readersToBeClosed;\n        } else {\n          readers = new IndexReader[sourceCores.length];\n          searchers = new RefCounted[sourceCores.length];\n          for (int i = 0; i < sourceCores.length; i++) {\n            SolrCore solrCore = sourceCores[i];\n            // record the searchers so that we can decref\n            searchers[i] = solrCore.getSearcher();\n            readers[i] = searchers[i].get().getIndexReader();\n          }\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_CHAIN));\n        wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(readers, req));\n      } finally {\n        if (searchers != null) {\n          for (RefCounted<SolrIndexSearcher> searcher : searchers) {\n            if (searcher != null) searcher.decref();\n          }\n        }\n        if (sourceCores != null) {\n          for (SolrCore solrCore : sourceCores) {\n            if (solrCore != null) solrCore.close();\n          }\n        }\n        if (readersToBeClosed != null) IOUtils.closeSafely(true, readersToBeClosed);\n        if (wrappedReq != null) wrappedReq.close();\n        core.close();\n      }\n    }\n    return coreContainer.isPersistent();\n  }\n\n","sourceOld":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    boolean doPersist = false;\n    SolrParams params = req.getParams();\n    SolrParams required = params.required();\n    String cname = required.get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest wrappedReq = null;\n    if (core != null) {\n      try {\n        doPersist = coreContainer.isPersistent();\n\n        String[] dirNames = required.getParams(CoreAdminParams.INDEX_DIR);\n\n        DirectoryFactory dirFactory = core.getDirectoryFactory();\n        Directory[] dirs = new Directory[dirNames.length];\n        for (int i = 0; i < dirNames.length; i++) {\n          dirs[i] = dirFactory.open(dirNames[i]);\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_CHAIN));\n        wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(dirs, req));\n      } finally {\n        core.close();\n        wrappedReq.close();\n      }\n    }\n    return doPersist;\n  }\n\n","bugFix":null,"bugIntro":["cf4e1373c1497f3587ee815b1bddda10850a0f37","cf4e1373c1497f3587ee815b1bddda10850a0f37","cf4e1373c1497f3587ee815b1bddda10850a0f37","e22ffe8cc51a892ae103df018822d7873e901c2a","e22ffe8cc51a892ae103df018822d7873e901c2a","e22ffe8cc51a892ae103df018822d7873e901c2a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"718f8730b97959cb87aaeadc9fafb9513f3c1bfe","date":1308670382,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = req.getParams();\n    String cname = params.required().get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest wrappedReq = null;\n\n    SolrCore[] sourceCores = null;\n    RefCounted<SolrIndexSearcher>[] searchers = null;\n    // stores readers created from indexDir param values\n    IndexReader[] readersToBeClosed = null;\n    if (core != null) {\n      try {\n        String[] dirNames = params.getParams(CoreAdminParams.INDEX_DIR);\n        if (dirNames == null || dirNames.length == 0) {\n          String[] sources = params.getParams(\"srcCore\");\n          if (sources == null || sources.length == 0)\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n                \"At least one indexDir or srcCore must be specified\");\n\n          sourceCores = new SolrCore[sources.length];\n          for (int i = 0; i < sources.length; i++) {\n            String source = sources[i];\n            SolrCore srcCore = coreContainer.getCore(source);\n            if (srcCore == null)\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                  \"Core: \" + source + \" does not exist\");\n            sourceCores[i] = srcCore;\n          }\n        } else  {\n          readersToBeClosed = new IndexReader[dirNames.length];\n          DirectoryFactory dirFactory = core.getDirectoryFactory();\n          for (int i = 0; i < dirNames.length; i++) {\n            readersToBeClosed[i] = IndexReader.open(dirFactory.open(dirNames[i]), true);\n          }\n        }\n\n        IndexReader[] readers = null;\n        if (readersToBeClosed != null)  {\n          readers = readersToBeClosed;\n        } else {\n          readers = new IndexReader[sourceCores.length];\n          searchers = new RefCounted[sourceCores.length];\n          for (int i = 0; i < sourceCores.length; i++) {\n            SolrCore solrCore = sourceCores[i];\n            // record the searchers so that we can decref\n            searchers[i] = solrCore.getSearcher();\n            readers[i] = searchers[i].get().getIndexReader();\n          }\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_CHAIN));\n        wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(readers, req));\n      } finally {\n        if (searchers != null) {\n          for (RefCounted<SolrIndexSearcher> searcher : searchers) {\n            if (searcher != null) searcher.decref();\n          }\n        }\n        if (sourceCores != null) {\n          for (SolrCore solrCore : sourceCores) {\n            if (solrCore != null) solrCore.close();\n          }\n        }\n        if (readersToBeClosed != null) IOUtils.closeSafely(true, readersToBeClosed);\n        if (wrappedReq != null) wrappedReq.close();\n        core.close();\n      }\n    }\n    return coreContainer.isPersistent();\n  }\n\n","sourceOld":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    boolean doPersist = false;\n    SolrParams params = req.getParams();\n    SolrParams required = params.required();\n    String cname = required.get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest wrappedReq = null;\n    if (core != null) {\n      try {\n        doPersist = coreContainer.isPersistent();\n\n        String[] dirNames = required.getParams(CoreAdminParams.INDEX_DIR);\n\n        DirectoryFactory dirFactory = core.getDirectoryFactory();\n        Directory[] dirs = new Directory[dirNames.length];\n        for (int i = 0; i < dirNames.length; i++) {\n          dirs[i] = dirFactory.open(dirNames[i]);\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_CHAIN));\n        wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(dirs, req));\n      } finally {\n        core.close();\n        wrappedReq.close();\n      }\n    }\n    return doPersist;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = req.getParams();\n    String cname = params.required().get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest wrappedReq = null;\n\n    SolrCore[] sourceCores = null;\n    RefCounted<SolrIndexSearcher>[] searchers = null;\n    // stores readers created from indexDir param values\n    IndexReader[] readersToBeClosed = null;\n    if (core != null) {\n      try {\n        String[] dirNames = params.getParams(CoreAdminParams.INDEX_DIR);\n        if (dirNames == null || dirNames.length == 0) {\n          String[] sources = params.getParams(\"srcCore\");\n          if (sources == null || sources.length == 0)\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n                \"At least one indexDir or srcCore must be specified\");\n\n          sourceCores = new SolrCore[sources.length];\n          for (int i = 0; i < sources.length; i++) {\n            String source = sources[i];\n            SolrCore srcCore = coreContainer.getCore(source);\n            if (srcCore == null)\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                  \"Core: \" + source + \" does not exist\");\n            sourceCores[i] = srcCore;\n          }\n        } else  {\n          readersToBeClosed = new IndexReader[dirNames.length];\n          DirectoryFactory dirFactory = core.getDirectoryFactory();\n          for (int i = 0; i < dirNames.length; i++) {\n            readersToBeClosed[i] = IndexReader.open(dirFactory.open(dirNames[i]), true);\n          }\n        }\n\n        IndexReader[] readers = null;\n        if (readersToBeClosed != null)  {\n          readers = readersToBeClosed;\n        } else {\n          readers = new IndexReader[sourceCores.length];\n          searchers = new RefCounted[sourceCores.length];\n          for (int i = 0; i < sourceCores.length; i++) {\n            SolrCore solrCore = sourceCores[i];\n            // record the searchers so that we can decref\n            searchers[i] = solrCore.getSearcher();\n            readers[i] = searchers[i].get().getIndexReader();\n          }\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_CHAIN));\n        wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(readers, req));\n      } finally {\n        if (searchers != null) {\n          for (RefCounted<SolrIndexSearcher> searcher : searchers) {\n            if (searcher != null) searcher.decref();\n          }\n        }\n        if (sourceCores != null) {\n          for (SolrCore solrCore : sourceCores) {\n            if (solrCore != null) solrCore.close();\n          }\n        }\n        if (readersToBeClosed != null) IOUtils.closeSafely(true, readersToBeClosed);\n        if (wrappedReq != null) wrappedReq.close();\n        core.close();\n      }\n    }\n    return coreContainer.isPersistent();\n  }\n\n","sourceOld":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = req.getParams();\n    String cname = params.required().get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest wrappedReq = null;\n\n    SolrCore[] sourceCores = null;\n    RefCounted<SolrIndexSearcher>[] searchers = null;\n    // stores readers created from indexDir param values\n    IndexReader[] readersToBeClosed = null;\n    if (core != null) {\n      try {\n        String[] dirNames = params.getParams(CoreAdminParams.INDEX_DIR);\n        if (dirNames == null || dirNames.length == 0) {\n          String[] sources = params.getParams(\"srcCore\");\n          if (sources == null || sources.length == 0)\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n                \"At least one indexDir or srcCore must be specified\");\n\n          sourceCores = new SolrCore[sources.length];\n          for (int i = 0; i < sources.length; i++) {\n            String source = sources[i];\n            SolrCore srcCore = coreContainer.getCore(source);\n            if (srcCore == null)\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                  \"Core: \" + source + \" does not exist\");\n            sourceCores[i] = srcCore;\n          }\n        } else  {\n          readersToBeClosed = new IndexReader[dirNames.length];\n          DirectoryFactory dirFactory = core.getDirectoryFactory();\n          for (int i = 0; i < dirNames.length; i++) {\n            readersToBeClosed[i] = IndexReader.open(dirFactory.open(dirNames[i]), true);\n          }\n        }\n\n        IndexReader[] readers = null;\n        if (readersToBeClosed != null)  {\n          readers = readersToBeClosed;\n        } else {\n          readers = new IndexReader[sourceCores.length];\n          searchers = new RefCounted[sourceCores.length];\n          for (int i = 0; i < sourceCores.length; i++) {\n            SolrCore solrCore = sourceCores[i];\n            // record the searchers so that we can decref\n            searchers[i] = solrCore.getSearcher();\n            readers[i] = searchers[i].get().getIndexReader();\n          }\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_CHAIN));\n        wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(readers, req));\n      } finally {\n        if (searchers != null) {\n          for (RefCounted<SolrIndexSearcher> searcher : searchers) {\n            if (searcher != null) searcher.decref();\n          }\n        }\n        if (sourceCores != null) {\n          for (SolrCore solrCore : sourceCores) {\n            if (solrCore != null) solrCore.close();\n          }\n        }\n        if (readersToBeClosed != null) IOUtils.closeSafely(true, readersToBeClosed);\n        if (wrappedReq != null) wrappedReq.close();\n        core.close();\n      }\n    }\n    return coreContainer.isPersistent();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = req.getParams();\n    String cname = params.required().get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest wrappedReq = null;\n\n    SolrCore[] sourceCores = null;\n    RefCounted<SolrIndexSearcher>[] searchers = null;\n    // stores readers created from indexDir param values\n    IndexReader[] readersToBeClosed = null;\n    if (core != null) {\n      try {\n        String[] dirNames = params.getParams(CoreAdminParams.INDEX_DIR);\n        if (dirNames == null || dirNames.length == 0) {\n          String[] sources = params.getParams(\"srcCore\");\n          if (sources == null || sources.length == 0)\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n                \"At least one indexDir or srcCore must be specified\");\n\n          sourceCores = new SolrCore[sources.length];\n          for (int i = 0; i < sources.length; i++) {\n            String source = sources[i];\n            SolrCore srcCore = coreContainer.getCore(source);\n            if (srcCore == null)\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                  \"Core: \" + source + \" does not exist\");\n            sourceCores[i] = srcCore;\n          }\n        } else  {\n          readersToBeClosed = new IndexReader[dirNames.length];\n          DirectoryFactory dirFactory = core.getDirectoryFactory();\n          for (int i = 0; i < dirNames.length; i++) {\n            readersToBeClosed[i] = IndexReader.open(dirFactory.open(dirNames[i]), true);\n          }\n        }\n\n        IndexReader[] readers = null;\n        if (readersToBeClosed != null)  {\n          readers = readersToBeClosed;\n        } else {\n          readers = new IndexReader[sourceCores.length];\n          searchers = new RefCounted[sourceCores.length];\n          for (int i = 0; i < sourceCores.length; i++) {\n            SolrCore solrCore = sourceCores[i];\n            // record the searchers so that we can decref\n            searchers[i] = solrCore.getSearcher();\n            readers[i] = searchers[i].get().getIndexReader();\n          }\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_CHAIN));\n        wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(readers, req));\n      } finally {\n        if (searchers != null) {\n          for (RefCounted<SolrIndexSearcher> searcher : searchers) {\n            if (searcher != null) searcher.decref();\n          }\n        }\n        if (sourceCores != null) {\n          for (SolrCore solrCore : sourceCores) {\n            if (solrCore != null) solrCore.close();\n          }\n        }\n        if (readersToBeClosed != null) IOUtils.closeSafely(true, readersToBeClosed);\n        if (wrappedReq != null) wrappedReq.close();\n        core.close();\n      }\n    }\n    return coreContainer.isPersistent();\n  }\n\n","sourceOld":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = req.getParams();\n    String cname = params.required().get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest wrappedReq = null;\n\n    SolrCore[] sourceCores = null;\n    RefCounted<SolrIndexSearcher>[] searchers = null;\n    // stores readers created from indexDir param values\n    IndexReader[] readersToBeClosed = null;\n    if (core != null) {\n      try {\n        String[] dirNames = params.getParams(CoreAdminParams.INDEX_DIR);\n        if (dirNames == null || dirNames.length == 0) {\n          String[] sources = params.getParams(\"srcCore\");\n          if (sources == null || sources.length == 0)\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n                \"At least one indexDir or srcCore must be specified\");\n\n          sourceCores = new SolrCore[sources.length];\n          for (int i = 0; i < sources.length; i++) {\n            String source = sources[i];\n            SolrCore srcCore = coreContainer.getCore(source);\n            if (srcCore == null)\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                  \"Core: \" + source + \" does not exist\");\n            sourceCores[i] = srcCore;\n          }\n        } else  {\n          readersToBeClosed = new IndexReader[dirNames.length];\n          DirectoryFactory dirFactory = core.getDirectoryFactory();\n          for (int i = 0; i < dirNames.length; i++) {\n            readersToBeClosed[i] = IndexReader.open(dirFactory.open(dirNames[i]), true);\n          }\n        }\n\n        IndexReader[] readers = null;\n        if (readersToBeClosed != null)  {\n          readers = readersToBeClosed;\n        } else {\n          readers = new IndexReader[sourceCores.length];\n          searchers = new RefCounted[sourceCores.length];\n          for (int i = 0; i < sourceCores.length; i++) {\n            SolrCore solrCore = sourceCores[i];\n            // record the searchers so that we can decref\n            searchers[i] = solrCore.getSearcher();\n            readers[i] = searchers[i].get().getIndexReader();\n          }\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_CHAIN));\n        wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(readers, req));\n      } finally {\n        if (searchers != null) {\n          for (RefCounted<SolrIndexSearcher> searcher : searchers) {\n            if (searcher != null) searcher.decref();\n          }\n        }\n        if (sourceCores != null) {\n          for (SolrCore solrCore : sourceCores) {\n            if (solrCore != null) solrCore.close();\n          }\n        }\n        if (readersToBeClosed != null) IOUtils.closeSafely(true, readersToBeClosed);\n        if (wrappedReq != null) wrappedReq.close();\n        core.close();\n      }\n    }\n    return coreContainer.isPersistent();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleMergeAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = req.getParams();\n    String cname = params.required().get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest wrappedReq = null;\n\n    SolrCore[] sourceCores = null;\n    RefCounted<SolrIndexSearcher>[] searchers = null;\n    // stores readers created from indexDir param values\n    IndexReader[] readersToBeClosed = null;\n    if (core != null) {\n      try {\n        String[] dirNames = params.getParams(CoreAdminParams.INDEX_DIR);\n        if (dirNames == null || dirNames.length == 0) {\n          String[] sources = params.getParams(\"srcCore\");\n          if (sources == null || sources.length == 0)\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n                \"At least one indexDir or srcCore must be specified\");\n\n          sourceCores = new SolrCore[sources.length];\n          for (int i = 0; i < sources.length; i++) {\n            String source = sources[i];\n            SolrCore srcCore = coreContainer.getCore(source);\n            if (srcCore == null)\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                  \"Core: \" + source + \" does not exist\");\n            sourceCores[i] = srcCore;\n          }\n        } else  {\n          readersToBeClosed = new IndexReader[dirNames.length];\n          DirectoryFactory dirFactory = core.getDirectoryFactory();\n          for (int i = 0; i < dirNames.length; i++) {\n            readersToBeClosed[i] = IndexReader.open(dirFactory.open(dirNames[i]), true);\n          }\n        }\n\n        IndexReader[] readers = null;\n        if (readersToBeClosed != null)  {\n          readers = readersToBeClosed;\n        } else {\n          readers = new IndexReader[sourceCores.length];\n          searchers = new RefCounted[sourceCores.length];\n          for (int i = 0; i < sourceCores.length; i++) {\n            SolrCore solrCore = sourceCores[i];\n            // record the searchers so that we can decref\n            searchers[i] = solrCore.getSearcher();\n            readers[i] = searchers[i].get().getIndexReader();\n          }\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_CHAIN));\n        wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(readers, req));\n      } finally {\n        if (searchers != null) {\n          for (RefCounted<SolrIndexSearcher> searcher : searchers) {\n            if (searcher != null) searcher.decref();\n          }\n        }\n        if (sourceCores != null) {\n          for (SolrCore solrCore : sourceCores) {\n            if (solrCore != null) solrCore.close();\n          }\n        }\n        if (readersToBeClosed != null) IOUtils.closeSafely(true, readersToBeClosed);\n        if (wrappedReq != null) wrappedReq.close();\n        core.close();\n      }\n    }\n    return coreContainer.isPersistent();\n  }\n\n","sourceOld":"  protected boolean handleMergeAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = req.getParams();\n    String cname = params.required().get(CoreAdminParams.CORE);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest wrappedReq = null;\n\n    SolrCore[] sourceCores = null;\n    RefCounted<SolrIndexSearcher>[] searchers = null;\n    // stores readers created from indexDir param values\n    IndexReader[] readersToBeClosed = null;\n    if (core != null) {\n      try {\n        String[] dirNames = params.getParams(CoreAdminParams.INDEX_DIR);\n        if (dirNames == null || dirNames.length == 0) {\n          String[] sources = params.getParams(\"srcCore\");\n          if (sources == null || sources.length == 0)\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n                \"At least one indexDir or srcCore must be specified\");\n\n          sourceCores = new SolrCore[sources.length];\n          for (int i = 0; i < sources.length; i++) {\n            String source = sources[i];\n            SolrCore srcCore = coreContainer.getCore(source);\n            if (srcCore == null)\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                  \"Core: \" + source + \" does not exist\");\n            sourceCores[i] = srcCore;\n          }\n        } else  {\n          readersToBeClosed = new IndexReader[dirNames.length];\n          DirectoryFactory dirFactory = core.getDirectoryFactory();\n          for (int i = 0; i < dirNames.length; i++) {\n            readersToBeClosed[i] = IndexReader.open(dirFactory.open(dirNames[i]), true);\n          }\n        }\n\n        IndexReader[] readers = null;\n        if (readersToBeClosed != null)  {\n          readers = readersToBeClosed;\n        } else {\n          readers = new IndexReader[sourceCores.length];\n          searchers = new RefCounted[sourceCores.length];\n          for (int i = 0; i < sourceCores.length; i++) {\n            SolrCore solrCore = sourceCores[i];\n            // record the searchers so that we can decref\n            searchers[i] = solrCore.getSearcher();\n            readers[i] = searchers[i].get().getIndexReader();\n          }\n        }\n\n        UpdateRequestProcessorChain processorChain =\n                core.getUpdateProcessingChain(params.get(UpdateParams.UPDATE_CHAIN));\n        wrappedReq = new LocalSolrQueryRequest(core, req.getParams());\n        UpdateRequestProcessor processor =\n                processorChain.createProcessor(wrappedReq, rsp);\n        processor.processMergeIndexes(new MergeIndexesCommand(readers, req));\n      } finally {\n        if (searchers != null) {\n          for (RefCounted<SolrIndexSearcher> searcher : searchers) {\n            if (searcher != null) searcher.decref();\n          }\n        }\n        if (sourceCores != null) {\n          for (SolrCore solrCore : sourceCores) {\n            if (solrCore != null) solrCore.close();\n          }\n        }\n        if (readersToBeClosed != null) IOUtils.closeSafely(true, readersToBeClosed);\n        if (wrappedReq != null) wrappedReq.close();\n        core.close();\n      }\n    }\n    return coreContainer.isPersistent();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"70ad682703b8585f5d0a637efec044d57ec05efb":["4ecea1664e8617d82eca3b8055a3c37cb4da8511","5ae62bcdfd4a0689a745ab1d38c6bd1c7c390cfa"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"c26f00b574427b55127e869b935845554afde1fa":["0a3f35d651410616f5a600589b0096c31f88f9a6","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["70ad682703b8585f5d0a637efec044d57ec05efb","64cae353de680169c133e0a9f4debee071ad3241"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["1da8d55113b689b06716246649de6f62430f15c0","00318b5ccee52f434e86d8e89ec9a065985b62df"],"d493718201f0d0c54c773fb323d87bbd2fbffe41":["ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c","64cae353de680169c133e0a9f4debee071ad3241"],"64cae353de680169c133e0a9f4debee071ad3241":["5ae62bcdfd4a0689a745ab1d38c6bd1c7c390cfa"],"1da8d55113b689b06716246649de6f62430f15c0":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","ad94625fb8d088209f46650c8097196fec67f00c"],"ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","5ae62bcdfd4a0689a745ab1d38c6bd1c7c390cfa"],"0a3f35d651410616f5a600589b0096c31f88f9a6":["64cae353de680169c133e0a9f4debee071ad3241"],"00318b5ccee52f434e86d8e89ec9a065985b62df":["1da8d55113b689b06716246649de6f62430f15c0"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["718f8730b97959cb87aaeadc9fafb9513f3c1bfe"],"a3776dccca01c11e7046323cfad46a3b4a471233":["5ae62bcdfd4a0689a745ab1d38c6bd1c7c390cfa","64cae353de680169c133e0a9f4debee071ad3241"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"718f8730b97959cb87aaeadc9fafb9513f3c1bfe":["a3776dccca01c11e7046323cfad46a3b4a471233","0a3f35d651410616f5a600589b0096c31f88f9a6"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["0a3f35d651410616f5a600589b0096c31f88f9a6"],"ad94625fb8d088209f46650c8097196fec67f00c":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"5ae62bcdfd4a0689a745ab1d38c6bd1c7c390cfa":["00318b5ccee52f434e86d8e89ec9a065985b62df"],"4ecea1664e8617d82eca3b8055a3c37cb4da8511":["1da8d55113b689b06716246649de6f62430f15c0","00318b5ccee52f434e86d8e89ec9a065985b62df"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"]},"commit2Childs":{"70ad682703b8585f5d0a637efec044d57ec05efb":["135621f3a0670a9394eb563224a3b76cc4dddc0f"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["1da8d55113b689b06716246649de6f62430f15c0"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["ad94625fb8d088209f46650c8097196fec67f00c"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":[],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c"],"d493718201f0d0c54c773fb323d87bbd2fbffe41":[],"64cae353de680169c133e0a9f4debee071ad3241":["135621f3a0670a9394eb563224a3b76cc4dddc0f","d493718201f0d0c54c773fb323d87bbd2fbffe41","0a3f35d651410616f5a600589b0096c31f88f9a6","a3776dccca01c11e7046323cfad46a3b4a471233"],"1da8d55113b689b06716246649de6f62430f15c0":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","00318b5ccee52f434e86d8e89ec9a065985b62df","4ecea1664e8617d82eca3b8055a3c37cb4da8511"],"ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c":["d493718201f0d0c54c773fb323d87bbd2fbffe41"],"0a3f35d651410616f5a600589b0096c31f88f9a6":["c26f00b574427b55127e869b935845554afde1fa","718f8730b97959cb87aaeadc9fafb9513f3c1bfe","a258fbb26824fd104ed795e5d9033d2d040049ee"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"00318b5ccee52f434e86d8e89ec9a065985b62df":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","5ae62bcdfd4a0689a745ab1d38c6bd1c7c390cfa","4ecea1664e8617d82eca3b8055a3c37cb4da8511"],"a3776dccca01c11e7046323cfad46a3b4a471233":["718f8730b97959cb87aaeadc9fafb9513f3c1bfe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"718f8730b97959cb87aaeadc9fafb9513f3c1bfe":["c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"ad94625fb8d088209f46650c8097196fec67f00c":["1da8d55113b689b06716246649de6f62430f15c0"],"4ecea1664e8617d82eca3b8055a3c37cb4da8511":["70ad682703b8585f5d0a637efec044d57ec05efb"],"5ae62bcdfd4a0689a745ab1d38c6bd1c7c390cfa":["70ad682703b8585f5d0a637efec044d57ec05efb","64cae353de680169c133e0a9f4debee071ad3241","ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c","a3776dccca01c11e7046323cfad46a3b4a471233"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["135621f3a0670a9394eb563224a3b76cc4dddc0f","d493718201f0d0c54c773fb323d87bbd2fbffe41","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}