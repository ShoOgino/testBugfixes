{"path":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(ServletRequest,ServletResponse,AtomicReference[ServletRequest]).mjava","commits":[{"id":"58b7eb80017f1c5b32035176b965fa0cc0287d04","date":1432069816,"type":0,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(ServletRequest,ServletResponse,AtomicReference[ServletRequest]).mjava","pathOld":"/dev/null","sourceNew":"  private boolean authenticateRequest(ServletRequest request, ServletResponse response, final AtomicReference<ServletRequest> wrappedRequest) throws IOException {\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      try {\n        log.debug(\"Request to authenticate: \"+request+\", domain: \"+request.getLocalName()+\", port: \"+request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        authenticationPlugin.doAuthenticate(request, response, new FilterChain() {\n          public void doFilter(ServletRequest req, ServletResponse rsp) throws IOException, ServletException {\n            isAuthenticated.set(true);\n            wrappedRequest.set(req);\n          }\n        });\n      } catch (Exception e) {\n        e.printStackTrace();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \"+e);\n      }\n    }\n    // failed authentication?\n    if (!isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"108c77096b1abf4c8c26991421f63f87d4c6b13c","date":1432228904,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(ServletRequest,ServletResponse,AtomicReference[ServletRequest]).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(ServletRequest,ServletResponse,AtomicReference[ServletRequest]).mjava","sourceNew":"  private boolean authenticateRequest(ServletRequest request, ServletResponse response, final AtomicReference<ServletRequest> wrappedRequest) throws IOException {\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      try {\n        log.debug(\"Request to authenticate: \"+request+\", domain: \"+request.getLocalName()+\", port: \"+request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        authenticationPlugin.doAuthenticate(request, response, new FilterChain() {\n          public void doFilter(ServletRequest req, ServletResponse rsp) throws IOException, ServletException {\n            isAuthenticated.set(true);\n            wrappedRequest.set(req);\n          }\n        });\n      } catch (Exception e) {\n        e.printStackTrace();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // failed authentication?\n    if (!isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean authenticateRequest(ServletRequest request, ServletResponse response, final AtomicReference<ServletRequest> wrappedRequest) throws IOException {\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      try {\n        log.debug(\"Request to authenticate: \"+request+\", domain: \"+request.getLocalName()+\", port: \"+request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        authenticationPlugin.doAuthenticate(request, response, new FilterChain() {\n          public void doFilter(ServletRequest req, ServletResponse rsp) throws IOException, ServletException {\n            isAuthenticated.set(true);\n            wrappedRequest.set(req);\n          }\n        });\n      } catch (Exception e) {\n        e.printStackTrace();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \"+e);\n      }\n    }\n    // failed authentication?\n    if (!isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"896e12033d56085efdb7b88bd289beb2645361dc","date":1434214735,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(ServletRequest,ServletResponse,AtomicReference[ServletRequest]).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(ServletRequest,ServletResponse,AtomicReference[ServletRequest]).mjava","sourceNew":"  private boolean authenticateRequest(ServletRequest request, ServletResponse response, final AtomicReference<ServletRequest> wrappedRequest) throws IOException {\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        authenticationPlugin.doAuthenticate(request, response, new FilterChain() {\n          public void doFilter(ServletRequest req, ServletResponse rsp) throws IOException, ServletException {\n            isAuthenticated.set(true);\n            wrappedRequest.set(req);\n          }\n        });\n      } catch (Exception e) {\n        e.printStackTrace();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // failed authentication?\n    if (!isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean authenticateRequest(ServletRequest request, ServletResponse response, final AtomicReference<ServletRequest> wrappedRequest) throws IOException {\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      try {\n        log.debug(\"Request to authenticate: \"+request+\", domain: \"+request.getLocalName()+\", port: \"+request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        authenticationPlugin.doAuthenticate(request, response, new FilterChain() {\n          public void doFilter(ServletRequest req, ServletResponse rsp) throws IOException, ServletException {\n            isAuthenticated.set(true);\n            wrappedRequest.set(req);\n          }\n        });\n      } catch (Exception e) {\n        e.printStackTrace();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // failed authentication?\n    if (!isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":["50fd776bfdfbf1b644edd777d559f521b4e8319e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b3a34dae868734612eb6329aa0ef754f30bd2036","date":1438783154,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(ServletRequest,ServletResponse,AtomicReference[ServletRequest]).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(ServletRequest,ServletResponse,AtomicReference[ServletRequest]).mjava","sourceNew":"  private boolean authenticateRequest(ServletRequest request, ServletResponse response, final AtomicReference<ServletRequest> wrappedRequest) throws IOException {\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      //special case when solr is securing inter-node requests\n      String header = ((HttpServletRequest) request).getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        authenticationPlugin.doAuthenticate(request, response, new FilterChain() {\n          public void doFilter(ServletRequest req, ServletResponse rsp) throws IOException, ServletException {\n            isAuthenticated.set(true);\n            wrappedRequest.set(req);\n          }\n        });\n      } catch (Exception e) {\n        e.printStackTrace();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // failed authentication?\n    if (!isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean authenticateRequest(ServletRequest request, ServletResponse response, final AtomicReference<ServletRequest> wrappedRequest) throws IOException {\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        authenticationPlugin.doAuthenticate(request, response, new FilterChain() {\n          public void doFilter(ServletRequest req, ServletResponse rsp) throws IOException, ServletException {\n            isAuthenticated.set(true);\n            wrappedRequest.set(req);\n          }\n        });\n      } catch (Exception e) {\n        e.printStackTrace();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // failed authentication?\n    if (!isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"20be168d828ac40d262f85364d02f15b491dd88b","date":1469725145,"type":3,"author":"Gregory Chanan","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(ServletRequest,ServletResponse,AtomicReference[ServletRequest]).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(ServletRequest,ServletResponse,AtomicReference[ServletRequest]).mjava","sourceNew":"  private boolean authenticateRequest(ServletRequest request, ServletResponse response, final AtomicReference<ServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      //special case when solr is securing inter-node requests\n      String header = ((HttpServletRequest) request).getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.doAuthenticate(request, response, new FilterChain() {\n          public void doFilter(ServletRequest req, ServletResponse rsp) throws IOException, ServletException {\n            isAuthenticated.set(true);\n            wrappedRequest.set(req);\n          }\n        });\n      } catch (Exception e) {\n        e.printStackTrace();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean authenticateRequest(ServletRequest request, ServletResponse response, final AtomicReference<ServletRequest> wrappedRequest) throws IOException {\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      //special case when solr is securing inter-node requests\n      String header = ((HttpServletRequest) request).getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        authenticationPlugin.doAuthenticate(request, response, new FilterChain() {\n          public void doFilter(ServletRequest req, ServletResponse rsp) throws IOException, ServletException {\n            isAuthenticated.set(true);\n            wrappedRequest.set(req);\n          }\n        });\n      } catch (Exception e) {\n        e.printStackTrace();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // failed authentication?\n    if (!isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(ServletRequest,ServletResponse,AtomicReference[ServletRequest]).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(ServletRequest,ServletResponse,AtomicReference[ServletRequest]).mjava","sourceNew":"  private boolean authenticateRequest(ServletRequest request, ServletResponse response, final AtomicReference<ServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      //special case when solr is securing inter-node requests\n      String header = ((HttpServletRequest) request).getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.doAuthenticate(request, response, new FilterChain() {\n          public void doFilter(ServletRequest req, ServletResponse rsp) throws IOException, ServletException {\n            isAuthenticated.set(true);\n            wrappedRequest.set(req);\n          }\n        });\n      } catch (Exception e) {\n        e.printStackTrace();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean authenticateRequest(ServletRequest request, ServletResponse response, final AtomicReference<ServletRequest> wrappedRequest) throws IOException {\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      //special case when solr is securing inter-node requests\n      String header = ((HttpServletRequest) request).getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        authenticationPlugin.doAuthenticate(request, response, new FilterChain() {\n          public void doFilter(ServletRequest req, ServletResponse rsp) throws IOException, ServletException {\n            isAuthenticated.set(true);\n            wrappedRequest.set(req);\n          }\n        });\n      } catch (Exception e) {\n        e.printStackTrace();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // failed authentication?\n    if (!isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b6b27adfd0ae23a874c905f6003b09606641f5f","date":1472324778,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(ServletRequest,ServletResponse,AtomicReference[ServletRequest]).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(ServletRequest,ServletResponse,AtomicReference[ServletRequest]).mjava","sourceNew":"  private boolean authenticateRequest(ServletRequest request, ServletResponse response, final AtomicReference<ServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null ||\n        PKIAuthenticationPlugin.PATH.equals(((HttpServletRequest)request).getPathInfo())) {\n      return true;\n    } else {\n      //special case when solr is securing inter-node requests\n      String header = ((HttpServletRequest) request).getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.doAuthenticate(request, response, new FilterChain() {\n          public void doFilter(ServletRequest req, ServletResponse rsp) throws IOException, ServletException {\n            isAuthenticated.set(true);\n            wrappedRequest.set(req);\n          }\n        });\n      } catch (Exception e) {\n        e.printStackTrace();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean authenticateRequest(ServletRequest request, ServletResponse response, final AtomicReference<ServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      //special case when solr is securing inter-node requests\n      String header = ((HttpServletRequest) request).getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.doAuthenticate(request, response, new FilterChain() {\n          public void doFilter(ServletRequest req, ServletResponse rsp) throws IOException, ServletException {\n            isAuthenticated.set(true);\n            wrappedRequest.set(req);\n          }\n        });\n      } catch (Exception e) {\n        e.printStackTrace();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":["179fb5ae04b4ee17fe6e657ef7283f535f111de3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"179fb5ae04b4ee17fe6e657ef7283f535f111de3","date":1472456223,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(ServletRequest,ServletResponse,AtomicReference[ServletRequest]).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(ServletRequest,ServletResponse,AtomicReference[ServletRequest]).mjava","sourceNew":"  private boolean authenticateRequest(ServletRequest request, ServletResponse response, final AtomicReference<ServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      try {\n        if (PKIAuthenticationPlugin.PATH.equals(((HttpServletRequest) request).getPathInfo())) return true;\n      } catch (Exception e) {\n        log.error(\"Unexpected error \", e);\n      }\n\n      //special case when solr is securing inter-node requests\n      String header = ((HttpServletRequest) request).getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.doAuthenticate(request, response, new FilterChain() {\n          public void doFilter(ServletRequest req, ServletResponse rsp) throws IOException, ServletException {\n            isAuthenticated.set(true);\n            wrappedRequest.set(req);\n          }\n        });\n      } catch (Exception e) {\n        e.printStackTrace();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean authenticateRequest(ServletRequest request, ServletResponse response, final AtomicReference<ServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null ||\n        PKIAuthenticationPlugin.PATH.equals(((HttpServletRequest)request).getPathInfo())) {\n      return true;\n    } else {\n      //special case when solr is securing inter-node requests\n      String header = ((HttpServletRequest) request).getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.doAuthenticate(request, response, new FilterChain() {\n          public void doFilter(ServletRequest req, ServletResponse rsp) throws IOException, ServletException {\n            isAuthenticated.set(true);\n            wrappedRequest.set(req);\n          }\n        });\n      } catch (Exception e) {\n        e.printStackTrace();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":["7b6b27adfd0ae23a874c905f6003b09606641f5f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(ServletRequest,ServletResponse,AtomicReference[ServletRequest]).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(ServletRequest,ServletResponse,AtomicReference[ServletRequest]).mjava","sourceNew":"  private boolean authenticateRequest(ServletRequest request, ServletResponse response, final AtomicReference<ServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      try {\n        if (PKIAuthenticationPlugin.PATH.equals(((HttpServletRequest) request).getPathInfo())) return true;\n      } catch (Exception e) {\n        log.error(\"Unexpected error \", e);\n      }\n\n      //special case when solr is securing inter-node requests\n      String header = ((HttpServletRequest) request).getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.doAuthenticate(request, response, new FilterChain() {\n          public void doFilter(ServletRequest req, ServletResponse rsp) throws IOException, ServletException {\n            isAuthenticated.set(true);\n            wrappedRequest.set(req);\n          }\n        });\n      } catch (Exception e) {\n        e.printStackTrace();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean authenticateRequest(ServletRequest request, ServletResponse response, final AtomicReference<ServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      //special case when solr is securing inter-node requests\n      String header = ((HttpServletRequest) request).getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.doAuthenticate(request, response, new FilterChain() {\n          public void doFilter(ServletRequest req, ServletResponse rsp) throws IOException, ServletException {\n            isAuthenticated.set(true);\n            wrappedRequest.set(req);\n          }\n        });\n      } catch (Exception e) {\n        e.printStackTrace();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(ServletRequest,ServletResponse,AtomicReference[ServletRequest]).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(ServletRequest,ServletResponse,AtomicReference[ServletRequest]).mjava","sourceNew":"  private boolean authenticateRequest(ServletRequest request, ServletResponse response, final AtomicReference<ServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      try {\n        if (PKIAuthenticationPlugin.PATH.equals(((HttpServletRequest) request).getPathInfo())) return true;\n      } catch (Exception e) {\n        log.error(\"Unexpected error \", e);\n      }\n\n      //special case when solr is securing inter-node requests\n      String header = ((HttpServletRequest) request).getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.doAuthenticate(request, response, new FilterChain() {\n          public void doFilter(ServletRequest req, ServletResponse rsp) throws IOException, ServletException {\n            isAuthenticated.set(true);\n            wrappedRequest.set(req);\n          }\n        });\n      } catch (Exception e) {\n        e.printStackTrace();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean authenticateRequest(ServletRequest request, ServletResponse response, final AtomicReference<ServletRequest> wrappedRequest) throws IOException {\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      //special case when solr is securing inter-node requests\n      String header = ((HttpServletRequest) request).getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        authenticationPlugin.doAuthenticate(request, response, new FilterChain() {\n          public void doFilter(ServletRequest req, ServletResponse rsp) throws IOException, ServletException {\n            isAuthenticated.set(true);\n            wrappedRequest.set(req);\n          }\n        });\n      } catch (Exception e) {\n        e.printStackTrace();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // failed authentication?\n    if (!isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"88bc4985c282c4086425237f691ed9fb95021bbc","date":1477469197,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(ServletRequest,ServletResponse,AtomicReference[ServletRequest]).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(ServletRequest,ServletResponse,AtomicReference[ServletRequest]).mjava","sourceNew":"  private boolean authenticateRequest(ServletRequest request, ServletResponse response, final AtomicReference<ServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      // /admin/info/key must be always open. see SOLR-9188\n      // tests work only w/ getPathInfo\n      //otherwise it's just enough to have getServletPath()\n      if (PKIAuthenticationPlugin.PATH.equals(((HttpServletRequest) request).getServletPath()) ||\n          PKIAuthenticationPlugin.PATH.equals(((HttpServletRequest) request).getPathInfo())) return true;\n      String header = ((HttpServletRequest) request).getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.doAuthenticate(request, response, (req, rsp) -> {\n          isAuthenticated.set(true);\n          wrappedRequest.set(req);\n        });\n      } catch (Exception e) {\n        log.info(\"Error authenticating\", e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean authenticateRequest(ServletRequest request, ServletResponse response, final AtomicReference<ServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      try {\n        if (PKIAuthenticationPlugin.PATH.equals(((HttpServletRequest) request).getPathInfo())) return true;\n      } catch (Exception e) {\n        log.error(\"Unexpected error \", e);\n      }\n\n      //special case when solr is securing inter-node requests\n      String header = ((HttpServletRequest) request).getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.doAuthenticate(request, response, new FilterChain() {\n          public void doFilter(ServletRequest req, ServletResponse rsp) throws IOException, ServletException {\n            isAuthenticated.set(true);\n            wrappedRequest.set(req);\n          }\n        });\n      } catch (Exception e) {\n        e.printStackTrace();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"80d0e6d59ae23f4a6f30eaf40bfb40742300287f","date":1477598926,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(ServletRequest,ServletResponse,AtomicReference[ServletRequest]).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(ServletRequest,ServletResponse,AtomicReference[ServletRequest]).mjava","sourceNew":"  private boolean authenticateRequest(ServletRequest request, ServletResponse response, final AtomicReference<ServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      // /admin/info/key must be always open. see SOLR-9188\n      // tests work only w/ getPathInfo\n      //otherwise it's just enough to have getServletPath()\n      if (PKIAuthenticationPlugin.PATH.equals(((HttpServletRequest) request).getServletPath()) ||\n          PKIAuthenticationPlugin.PATH.equals(((HttpServletRequest) request).getPathInfo())) return true;\n      String header = ((HttpServletRequest) request).getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.doAuthenticate(request, response, (req, rsp) -> {\n          isAuthenticated.set(true);\n          wrappedRequest.set(req);\n        });\n      } catch (Exception e) {\n        log.info(\"Error authenticating\", e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean authenticateRequest(ServletRequest request, ServletResponse response, final AtomicReference<ServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      try {\n        if (PKIAuthenticationPlugin.PATH.equals(((HttpServletRequest) request).getPathInfo())) return true;\n      } catch (Exception e) {\n        log.error(\"Unexpected error \", e);\n      }\n\n      //special case when solr is securing inter-node requests\n      String header = ((HttpServletRequest) request).getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.doAuthenticate(request, response, new FilterChain() {\n          public void doFilter(ServletRequest req, ServletResponse rsp) throws IOException, ServletException {\n            isAuthenticated.set(true);\n            wrappedRequest.set(req);\n          }\n        });\n      } catch (Exception e) {\n        e.printStackTrace();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1214bb624eb41181e5c8e260e0050c7e973ba0f4","date":1487943042,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(ServletRequest,ServletResponse,AtomicReference[ServletRequest]).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(ServletRequest,ServletResponse,AtomicReference[ServletRequest]).mjava","sourceNew":"  private boolean authenticateRequest(ServletRequest request, ServletResponse response, final AtomicReference<ServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      String requestUri = ((HttpServletRequest) request).getRequestURI();\n      if (requestUri != null && requestUri.endsWith(PKIAuthenticationPlugin.PATH)) {\n        log.debug(\"Passthrough of pki URL \" + requestUri);\n        return true;\n      }\n      String header = ((HttpServletRequest) request).getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.doAuthenticate(request, response, (req, rsp) -> {\n          isAuthenticated.set(true);\n          wrappedRequest.set(req);\n        });\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean authenticateRequest(ServletRequest request, ServletResponse response, final AtomicReference<ServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      // /admin/info/key must be always open. see SOLR-9188\n      // tests work only w/ getPathInfo\n      //otherwise it's just enough to have getServletPath()\n      if (PKIAuthenticationPlugin.PATH.equals(((HttpServletRequest) request).getServletPath()) ||\n          PKIAuthenticationPlugin.PATH.equals(((HttpServletRequest) request).getPathInfo())) return true;\n      String header = ((HttpServletRequest) request).getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.doAuthenticate(request, response, (req, rsp) -> {\n          isAuthenticated.set(true);\n          wrappedRequest.set(req);\n        });\n      } catch (Exception e) {\n        log.info(\"Error authenticating\", e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b61ef53ee9899b83a89bf97542c28a4cfd0a64bf","date":1487979822,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(ServletRequest,ServletResponse,AtomicReference[ServletRequest]).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(ServletRequest,ServletResponse,AtomicReference[ServletRequest]).mjava","sourceNew":"  private boolean authenticateRequest(ServletRequest request, ServletResponse response, final AtomicReference<ServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      // /admin/info/key must be always open. see SOLR-9188\n      // tests work only w/ getPathInfo\n      //otherwise it's just enough to have getServletPath()\n      if (PKIAuthenticationPlugin.PATH.equals(((HttpServletRequest) request).getServletPath()) ||\n          PKIAuthenticationPlugin.PATH.equals(((HttpServletRequest) request).getPathInfo())) return true;\n      String header = ((HttpServletRequest) request).getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.doAuthenticate(request, response, (req, rsp) -> {\n          isAuthenticated.set(true);\n          wrappedRequest.set(req);\n        });\n      } catch (Exception e) {\n        log.info(\"Error authenticating\", e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean authenticateRequest(ServletRequest request, ServletResponse response, final AtomicReference<ServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      String requestUri = ((HttpServletRequest) request).getRequestURI();\n      if (requestUri != null && requestUri.endsWith(PKIAuthenticationPlugin.PATH)) {\n        log.debug(\"Passthrough of pki URL \" + requestUri);\n        return true;\n      }\n      String header = ((HttpServletRequest) request).getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.doAuthenticate(request, response, (req, rsp) -> {\n          isAuthenticated.set(true);\n          wrappedRequest.set(req);\n        });\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"61d55d0cc95bfc03461b5c355153ca28c49076eb","date":1515469157,"type":5,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(HttpServletRequest,HttpServletResponse,AtomicReference[HttpServletRequest]).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(ServletRequest,ServletResponse,AtomicReference[ServletRequest]).mjava","sourceNew":"  private boolean authenticateRequest(HttpServletRequest request, HttpServletResponse response, final AtomicReference<HttpServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      // /admin/info/key must be always open. see SOLR-9188\n      // tests work only w/ getPathInfo\n      //otherwise it's just enough to have getServletPath()\n      if (PKIAuthenticationPlugin.PATH.equals(request.getServletPath()) ||\n          PKIAuthenticationPlugin.PATH.equals(request.getPathInfo())) return true;\n      String header = request.getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.doAuthenticate(request, response, (req, rsp) -> {\n          isAuthenticated.set(true);\n          wrappedRequest.set((HttpServletRequest) req);\n        });\n      } catch (Exception e) {\n        log.info(\"Error authenticating\", e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean authenticateRequest(ServletRequest request, ServletResponse response, final AtomicReference<ServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      // /admin/info/key must be always open. see SOLR-9188\n      // tests work only w/ getPathInfo\n      //otherwise it's just enough to have getServletPath()\n      if (PKIAuthenticationPlugin.PATH.equals(((HttpServletRequest) request).getServletPath()) ||\n          PKIAuthenticationPlugin.PATH.equals(((HttpServletRequest) request).getPathInfo())) return true;\n      String header = ((HttpServletRequest) request).getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.doAuthenticate(request, response, (req, rsp) -> {\n          isAuthenticated.set(true);\n          wrappedRequest.set(req);\n        });\n      } catch (Exception e) {\n        log.info(\"Error authenticating\", e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":["946009ad0fba506337041a368b0a74d2edd59e2c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":4,"author":"Karl Wright","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#authenticateRequest(ServletRequest,ServletResponse,AtomicReference[ServletRequest]).mjava","sourceNew":null,"sourceOld":"  private boolean authenticateRequest(ServletRequest request, ServletResponse response, final AtomicReference<ServletRequest> wrappedRequest) throws IOException {\n    boolean requestContinues = false;\n    final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n    AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n    if (authenticationPlugin == null) {\n      return true;\n    } else {\n      // /admin/info/key must be always open. see SOLR-9188\n      // tests work only w/ getPathInfo\n      //otherwise it's just enough to have getServletPath()\n      if (PKIAuthenticationPlugin.PATH.equals(((HttpServletRequest) request).getServletPath()) ||\n          PKIAuthenticationPlugin.PATH.equals(((HttpServletRequest) request).getPathInfo())) return true;\n      String header = ((HttpServletRequest) request).getHeader(PKIAuthenticationPlugin.HEADER);\n      if (header != null && cores.getPkiAuthenticationPlugin() != null)\n        authenticationPlugin = cores.getPkiAuthenticationPlugin();\n      try {\n        log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n        // upon successful authentication, this should call the chain's next filter.\n        requestContinues = authenticationPlugin.doAuthenticate(request, response, (req, rsp) -> {\n          isAuthenticated.set(true);\n          wrappedRequest.set(req);\n        });\n      } catch (Exception e) {\n        log.info(\"Error authenticating\", e);\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n      }\n    }\n    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n    // multiple code paths.\n    if (!requestContinues || !isAuthenticated.get()) {\n      response.flushBuffer();\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["b61ef53ee9899b83a89bf97542c28a4cfd0a64bf","61d55d0cc95bfc03461b5c355153ca28c49076eb"],"58b7eb80017f1c5b32035176b965fa0cc0287d04":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"179fb5ae04b4ee17fe6e657ef7283f535f111de3":["7b6b27adfd0ae23a874c905f6003b09606641f5f"],"b61ef53ee9899b83a89bf97542c28a4cfd0a64bf":["1214bb624eb41181e5c8e260e0050c7e973ba0f4"],"b3a34dae868734612eb6329aa0ef754f30bd2036":["896e12033d56085efdb7b88bd289beb2645361dc"],"7b6b27adfd0ae23a874c905f6003b09606641f5f":["20be168d828ac40d262f85364d02f15b491dd88b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["b3a34dae868734612eb6329aa0ef754f30bd2036","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"1214bb624eb41181e5c8e260e0050c7e973ba0f4":["88bc4985c282c4086425237f691ed9fb95021bbc"],"61d55d0cc95bfc03461b5c355153ca28c49076eb":["b61ef53ee9899b83a89bf97542c28a4cfd0a64bf"],"88bc4985c282c4086425237f691ed9fb95021bbc":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["20be168d828ac40d262f85364d02f15b491dd88b","179fb5ae04b4ee17fe6e657ef7283f535f111de3"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","88bc4985c282c4086425237f691ed9fb95021bbc"],"20be168d828ac40d262f85364d02f15b491dd88b":["b3a34dae868734612eb6329aa0ef754f30bd2036"],"896e12033d56085efdb7b88bd289beb2645361dc":["108c77096b1abf4c8c26991421f63f87d4c6b13c"],"108c77096b1abf4c8c26991421f63f87d4c6b13c":["58b7eb80017f1c5b32035176b965fa0cc0287d04"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["b3a34dae868734612eb6329aa0ef754f30bd2036","20be168d828ac40d262f85364d02f15b491dd88b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b94236357aaa22b76c10629851fe4e376e0cea82"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"58b7eb80017f1c5b32035176b965fa0cc0287d04":["108c77096b1abf4c8c26991421f63f87d4c6b13c"],"179fb5ae04b4ee17fe6e657ef7283f535f111de3":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"b61ef53ee9899b83a89bf97542c28a4cfd0a64bf":["b94236357aaa22b76c10629851fe4e376e0cea82","61d55d0cc95bfc03461b5c355153ca28c49076eb"],"7b6b27adfd0ae23a874c905f6003b09606641f5f":["179fb5ae04b4ee17fe6e657ef7283f535f111de3"],"b3a34dae868734612eb6329aa0ef754f30bd2036":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","20be168d828ac40d262f85364d02f15b491dd88b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"1214bb624eb41181e5c8e260e0050c7e973ba0f4":["b61ef53ee9899b83a89bf97542c28a4cfd0a64bf"],"61d55d0cc95bfc03461b5c355153ca28c49076eb":["b94236357aaa22b76c10629851fe4e376e0cea82"],"88bc4985c282c4086425237f691ed9fb95021bbc":["1214bb624eb41181e5c8e260e0050c7e973ba0f4","80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["58b7eb80017f1c5b32035176b965fa0cc0287d04"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","88bc4985c282c4086425237f691ed9fb95021bbc"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":[],"896e12033d56085efdb7b88bd289beb2645361dc":["b3a34dae868734612eb6329aa0ef754f30bd2036"],"20be168d828ac40d262f85364d02f15b491dd88b":["7b6b27adfd0ae23a874c905f6003b09606641f5f","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"108c77096b1abf4c8c26991421f63f87d4c6b13c":["896e12033d56085efdb7b88bd289beb2645361dc"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f","3b013574eedcdbac35dc7e35b0ee616ffc38895d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}