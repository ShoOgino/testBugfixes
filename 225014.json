{"path":"lucene/highlighter/src/java/org/apache/lucene/search/matchhighlight/MatchRegionRetriever#MatchRegionRetriever(IndexSearcher,Query,Analyzer,OffsetsRetrievalStrategySupplier).mjava","commits":[{"id":"2fb36690ce41edd0bebf4e4babc0fa8c9b0f2e5c","date":1597407672,"type":0,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/matchhighlight/MatchRegionRetriever#MatchRegionRetriever(IndexSearcher,Query,Analyzer,OffsetsRetrievalStrategySupplier).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * @param searcher Index searcher to be used for retrieving matches.\n   * @param query The query for which matches should be retrieved. The query should be rewritten\n   *              against the provided searcher.\n   * @param analyzer An analyzer that may be used to reprocess (retokenize) document fields\n   *                 in the absence of position offsets in the index. Note that the analyzer must return\n   *                 tokens (positions and offsets) identical to the ones stored in the index.\n   * @param fieldOffsetStrategySupplier A custom supplier of per-field {@link OffsetsRetrievalStrategy}\n   *                                    instances.\n   */\n  public MatchRegionRetriever(IndexSearcher searcher, Query query, Analyzer analyzer,\n                              OffsetsRetrievalStrategySupplier fieldOffsetStrategySupplier)\n      throws IOException {\n    leaves = searcher.getIndexReader().leaves();\n    assert checkOrderConsistency(leaves);\n\n    // We need full scoring mode so that we can receive matches from all sub-clauses\n    // (no optimizations in Boolean queries take place).\n    weight = searcher.createWeight(query, ScoreMode.COMPLETE, 0);\n\n    // Compute the subset of fields affected by this query so that we don't load or scan\n    // fields that are irrelevant.\n    affectedFields = new TreeSet<>();\n    query.visit(\n        new QueryVisitor() {\n          @Override\n          public boolean acceptField(String field) {\n            affectedFields.add(field);\n            return false;\n          }\n        });\n\n    // Compute value offset retrieval strategy for all affected fields.\n    offsetStrategies = new HashMap<>();\n    for (String field : affectedFields) {\n      offsetStrategies.put(field, fieldOffsetStrategySupplier.apply(field));\n    }\n\n    // Ask offset strategies if they'll need field values.\n    preloadFields = new HashSet<>();\n    offsetStrategies.forEach(\n        (field, strategy) -> {\n          if (strategy.requiresDocument()) {\n            preloadFields.add(field);\n          }\n        });\n\n    // Only preload those field values that can be affected by the query and are required\n    // by strategies.\n    preloadFields.retainAll(affectedFields);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"930e5c340e08514a7f57a54cf65e2f8f1f90c8f0","date":1599736633,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/matchhighlight/MatchRegionRetriever#MatchRegionRetriever(IndexSearcher,Query,OffsetsRetrievalStrategySupplier).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/matchhighlight/MatchRegionRetriever#MatchRegionRetriever(IndexSearcher,Query,Analyzer,OffsetsRetrievalStrategySupplier).mjava","sourceNew":"  /**\n   * @param searcher Index searcher to be used for retrieving matches.\n   * @param query The query for which matches should be retrieved. The query should be rewritten\n   *              against the provided searcher.\n   * @param fieldOffsetStrategySupplier A custom supplier of per-field {@link OffsetsRetrievalStrategy}\n   *                                    instances.\n   */\n  public MatchRegionRetriever(IndexSearcher searcher, Query query,\n                              OffsetsRetrievalStrategySupplier fieldOffsetStrategySupplier)\n      throws IOException {\n    leaves = searcher.getIndexReader().leaves();\n    assert checkOrderConsistency(leaves);\n\n    // We need full scoring mode so that we can receive matches from all sub-clauses\n    // (no optimizations in Boolean queries take place).\n    weight = searcher.createWeight(query, ScoreMode.COMPLETE, 0);\n\n    // Compute the subset of fields affected by this query so that we don't load or scan\n    // fields that are irrelevant.\n    affectedFields = new TreeSet<>();\n    query.visit(\n        new QueryVisitor() {\n          @Override\n          public boolean acceptField(String field) {\n            affectedFields.add(field);\n            return false;\n          }\n        });\n\n    // Compute value offset retrieval strategy for all affected fields.\n    offsetStrategies = new HashMap<>();\n    for (String field : affectedFields) {\n      offsetStrategies.put(field, fieldOffsetStrategySupplier.apply(field));\n    }\n\n    // Ask offset strategies if they'll need field values.\n    preloadFields = new HashSet<>();\n    offsetStrategies.forEach(\n        (field, strategy) -> {\n          if (strategy.requiresDocument()) {\n            preloadFields.add(field);\n          }\n        });\n\n    // Only preload those field values that can be affected by the query and are required\n    // by strategies.\n    preloadFields.retainAll(affectedFields);\n  }\n\n","sourceOld":"  /**\n   * @param searcher Index searcher to be used for retrieving matches.\n   * @param query The query for which matches should be retrieved. The query should be rewritten\n   *              against the provided searcher.\n   * @param analyzer An analyzer that may be used to reprocess (retokenize) document fields\n   *                 in the absence of position offsets in the index. Note that the analyzer must return\n   *                 tokens (positions and offsets) identical to the ones stored in the index.\n   * @param fieldOffsetStrategySupplier A custom supplier of per-field {@link OffsetsRetrievalStrategy}\n   *                                    instances.\n   */\n  public MatchRegionRetriever(IndexSearcher searcher, Query query, Analyzer analyzer,\n                              OffsetsRetrievalStrategySupplier fieldOffsetStrategySupplier)\n      throws IOException {\n    leaves = searcher.getIndexReader().leaves();\n    assert checkOrderConsistency(leaves);\n\n    // We need full scoring mode so that we can receive matches from all sub-clauses\n    // (no optimizations in Boolean queries take place).\n    weight = searcher.createWeight(query, ScoreMode.COMPLETE, 0);\n\n    // Compute the subset of fields affected by this query so that we don't load or scan\n    // fields that are irrelevant.\n    affectedFields = new TreeSet<>();\n    query.visit(\n        new QueryVisitor() {\n          @Override\n          public boolean acceptField(String field) {\n            affectedFields.add(field);\n            return false;\n          }\n        });\n\n    // Compute value offset retrieval strategy for all affected fields.\n    offsetStrategies = new HashMap<>();\n    for (String field : affectedFields) {\n      offsetStrategies.put(field, fieldOffsetStrategySupplier.apply(field));\n    }\n\n    // Ask offset strategies if they'll need field values.\n    preloadFields = new HashSet<>();\n    offsetStrategies.forEach(\n        (field, strategy) -> {\n          if (strategy.requiresDocument()) {\n            preloadFields.add(field);\n          }\n        });\n\n    // Only preload those field values that can be affected by the query and are required\n    // by strategies.\n    preloadFields.retainAll(affectedFields);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2fb36690ce41edd0bebf4e4babc0fa8c9b0f2e5c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"930e5c340e08514a7f57a54cf65e2f8f1f90c8f0":["2fb36690ce41edd0bebf4e4babc0fa8c9b0f2e5c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["930e5c340e08514a7f57a54cf65e2f8f1f90c8f0"]},"commit2Childs":{"2fb36690ce41edd0bebf4e4babc0fa8c9b0f2e5c":["930e5c340e08514a7f57a54cf65e2f8f1f90c8f0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2fb36690ce41edd0bebf4e4babc0fa8c9b0f2e5c"],"930e5c340e08514a7f57a54cf65e2f8f1f90c8f0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}