{"path":"sandbox/contributions/ant/src/main/org/apache/lucene/ant/IndexTask#indexDocs().mjava","commits":[{"id":"6cae9303ec860d8a88b807570b29e841a3d1fbd3","date":1026349951,"type":1,"author":"Erik Hatcher","isMerge":false,"pathNew":"sandbox/contributions/ant/src/main/org/apache/lucene/ant/IndexTask#indexDocs().mjava","pathOld":"sandbox/projects/ant/src/main/org/apache/lucene/ant/IndexTask#indexDocs().mjava","sourceNew":"    /**\n     *  index the fileset\n     *\n     * @exception  IOException  Description of Exception\n     * @todo refactor - definitely lots of room for improvement here\n     */\n    private void indexDocs() throws IOException {\n        Date start = new Date();\n\n        boolean create = overwrite;\n        // If the index directory doesn't exist,\n        // create it and force create mode\n        if (indexPath.mkdirs() && !overwrite) {\n            create = true;\n        }\n\n        Searcher searcher = null;\n        Analyzer analyzer = new StopAnalyzer();\n        boolean checkLastModified = false;\n        if (!create) {\n            try {\n                searcher = new IndexSearcher(indexPath.getAbsolutePath());\n                checkLastModified = true;\n            }\n            catch (IOException ioe) {\n                log(\"IOException: \" + ioe.getMessage());\n                // Empty - ignore, which indicates to index all\n                // documents\n            }\n        }\n\n        log(\"checkLastModified = \" + checkLastModified);\n\n        IndexWriter writer =\n                       new IndexWriter(indexPath, analyzer, create);\n        int totalFiles = 0;\n        int totalIndexed = 0;\n        int totalIgnored = 0;\n        try {\n            writer.mergeFactor = mergeFactor;\n\n            for (int i = 0; i < filesets.size(); i++) {\n                FileSet fs = (FileSet) filesets.elementAt(i);\n                if (fs != null) {\n                    DirectoryScanner ds =\n                                   fs.getDirectoryScanner(project);\n                    String[] dsfiles = ds.getIncludedFiles();\n                    File baseDir = ds.getBasedir();\n\n                    for (int j = 0; j < dsfiles.length; j++) {\n                        File file = new File(baseDir, dsfiles[j]);\n                        totalFiles++;\n\n                        if (!file.exists() || !file.canRead()) {\n                            throw new BuildException(\"File \\\"\" +\n                        file.getAbsolutePath()\n                        + \"\\\" does not exist or is not readable.\");\n                        }\n\n                        boolean indexIt = true;\n\n                        if (checkLastModified) {\n                            Hits hits = null;\n                            Term pathTerm = \n                                  new Term(\"path\", file.getPath());\n                            TermQuery query =\n                                           new TermQuery(pathTerm);\n                            hits = searcher.search(query);\n\n                            // if document is found, compare the\n                            // indexed last modified time with the\n                            // current file\n                            // - don't index if up to date\n                            if (hits.length() > 0) {\n                                Document doc = hits.doc(0);\n                                String indexModified =\n                                               doc.get(\"modified\");\n                                if (indexModified != null) {\n                                    if (DateField.stringToTime(indexModified)\n                                             == file.lastModified()) {\n                                        indexIt = false;\n                                    }\n                                }\n                            }\n                        }\n\n                        if (indexIt) {\n                            try {\n                                log(\"Indexing \" + file.getPath(),\n                                    Project.MSG_VERBOSE);\n                                Document doc =\n                                         handler.getDocument(file);\n\n                                if (doc == null) {\n                                    totalIgnored++;\n                                }\n                                else {\n                                    // Add the path of the file as a field named \"path\".  Use a Text field, so\n                                    // that the index stores the path, and so that the path is searchable\n                                    doc.add(Field.Keyword(\"path\", file.getPath()));\n\n                                    // Add the last modified date of the file a field named \"modified\".  Use a\n                                    // Keyword field, so that it's searchable, but so that no attempt is made\n                                    // to tokenize the field into words.\n                                    doc.add(Field.Keyword(\"modified\",\n                                            DateField.timeToString(file.lastModified())));\n\n                                    writer.addDocument(doc);\n                                    totalIndexed++;\n                                }\n                            }\n                            catch (DocumentHandlerException e) {\n                                throw new BuildException(e);\n                            }\n                        }\n                    }\n                    // for j\n                }\n                // if (fs != null)\n            }\n            // for i\n\n            writer.optimize();\n        }\n        //try\n        finally {\n            // always make sure everything gets closed,\n            // no matter how we exit.\n            writer.close();\n            if (searcher != null) {\n                searcher.close();\n            }\n        }\n\n        Date end = new Date();\n\n        log(totalIndexed + \" out of \" + totalFiles + \" indexed (\" +\n                totalIgnored + \" ignored) in \" + (end.getTime() - start.getTime()) +\n                \" milliseconds\");\n    }\n\n","sourceOld":"    /**\n     *  index the fileset\n     *\n     * @exception  IOException  Description of Exception\n     * @todo refactor - definitely lots of room for improvement here\n     */\n    private void indexDocs() throws IOException {\n        Date start = new Date();\n\n        boolean create = overwrite;\n        // If the index directory doesn't exist,\n        // create it and force create mode\n        if (indexPath.mkdirs() && !overwrite) {\n            create = true;\n        }\n\n        Searcher searcher = null;\n        Analyzer analyzer = new StopAnalyzer();\n        boolean checkLastModified = false;\n        if (!create) {\n            try {\n                searcher = new IndexSearcher(indexPath.getAbsolutePath());\n                checkLastModified = true;\n            }\n            catch (IOException ioe) {\n                log(\"IOException: \" + ioe.getMessage());\n                // Empty - ignore, which indicates to index all\n                // documents\n            }\n        }\n\n        log(\"checkLastModified = \" + checkLastModified);\n\n        IndexWriter writer =\n                       new IndexWriter(indexPath, analyzer, create);\n        int totalFiles = 0;\n        int totalIndexed = 0;\n        int totalIgnored = 0;\n        try {\n            writer.mergeFactor = mergeFactor;\n\n            for (int i = 0; i < filesets.size(); i++) {\n                FileSet fs = (FileSet) filesets.elementAt(i);\n                if (fs != null) {\n                    DirectoryScanner ds =\n                                   fs.getDirectoryScanner(project);\n                    String[] dsfiles = ds.getIncludedFiles();\n                    File baseDir = ds.getBasedir();\n\n                    for (int j = 0; j < dsfiles.length; j++) {\n                        File file = new File(baseDir, dsfiles[j]);\n                        totalFiles++;\n\n                        if (!file.exists() || !file.canRead()) {\n                            throw new BuildException(\"File \\\"\" +\n                        file.getAbsolutePath()\n                        + \"\\\" does not exist or is not readable.\");\n                        }\n\n                        boolean indexIt = true;\n\n                        if (checkLastModified) {\n                            Hits hits = null;\n                            Term pathTerm = \n                                  new Term(\"path\", file.getPath());\n                            TermQuery query =\n                                           new TermQuery(pathTerm);\n                            hits = searcher.search(query);\n\n                            // if document is found, compare the\n                            // indexed last modified time with the\n                            // current file\n                            // - don't index if up to date\n                            if (hits.length() > 0) {\n                                Document doc = hits.doc(0);\n                                String indexModified =\n                                               doc.get(\"modified\");\n                                if (indexModified != null) {\n                                    if (DateField.stringToTime(indexModified)\n                                             == file.lastModified()) {\n                                        indexIt = false;\n                                    }\n                                }\n                            }\n                        }\n\n                        if (indexIt) {\n                            try {\n                                log(\"Indexing \" + file.getPath(),\n                                    Project.MSG_VERBOSE);\n                                Document doc =\n                                         handler.getDocument(file);\n\n                                if (doc == null) {\n                                    totalIgnored++;\n                                }\n                                else {\n                                    // Add the path of the file as a field named \"path\".  Use a Text field, so\n                                    // that the index stores the path, and so that the path is searchable\n                                    doc.add(Field.Keyword(\"path\", file.getPath()));\n\n                                    // Add the last modified date of the file a field named \"modified\".  Use a\n                                    // Keyword field, so that it's searchable, but so that no attempt is made\n                                    // to tokenize the field into words.\n                                    doc.add(Field.Keyword(\"modified\",\n                                            DateField.timeToString(file.lastModified())));\n\n                                    writer.addDocument(doc);\n                                    totalIndexed++;\n                                }\n                            }\n                            catch (DocumentHandlerException e) {\n                                throw new BuildException(e);\n                            }\n                        }\n                    }\n                    // for j\n                }\n                // if (fs != null)\n            }\n            // for i\n\n            writer.optimize();\n        }\n        //try\n        finally {\n            // always make sure everything gets closed,\n            // no matter how we exit.\n            writer.close();\n            if (searcher != null) {\n                searcher.close();\n            }\n        }\n\n        Date end = new Date();\n\n        log(totalIndexed + \" out of \" + totalFiles + \" indexed (\" +\n                totalIgnored + \" ignored) in \" + (end.getTime() - start.getTime()) +\n                \" milliseconds\");\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"febb159f33ae1f7cccd813bde934e23fff2e5877","date":1073317555,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"sandbox/contributions/ant/src/main/org/apache/lucene/ant/IndexTask#indexDocs().mjava","pathOld":"sandbox/contributions/ant/src/main/org/apache/lucene/ant/IndexTask#indexDocs().mjava","sourceNew":"    /**\n     *  index the fileset\n     *\n     * @exception  IOException  Description of Exception\n     * @todo refactor - definitely lots of room for improvement here\n     */\n    private void indexDocs() throws IOException {\n        Date start = new Date();\n\n        boolean create = overwrite;\n        // If the index directory doesn't exist,\n        // create it and force create mode\n        if (indexPath.mkdirs() && !overwrite) {\n            create = true;\n        }\n\n        Searcher searcher = null;\n        Analyzer analyzer = new StopAnalyzer();\n        boolean checkLastModified = false;\n        if (!create) {\n            try {\n                searcher = new IndexSearcher(indexPath.getAbsolutePath());\n                checkLastModified = true;\n            }\n            catch (IOException ioe) {\n                log(\"IOException: \" + ioe.getMessage());\n                // Empty - ignore, which indicates to index all\n                // documents\n            }\n        }\n\n        log(\"checkLastModified = \" + checkLastModified);\n\n        IndexWriter writer =\n                       new IndexWriter(indexPath, analyzer, create);\n        int totalFiles = 0;\n        int totalIndexed = 0;\n        int totalIgnored = 0;\n        try {\n            writer.mergeFactor = mergeFactor;\n\n            for (int i = 0; i < filesets.size(); i++) {\n                FileSet fs = (FileSet) filesets.elementAt(i);\n                if (fs != null) {\n                    DirectoryScanner ds =\n                                   fs.getDirectoryScanner(getProject());\n                    String[] dsfiles = ds.getIncludedFiles();\n                    File baseDir = ds.getBasedir();\n\n                    for (int j = 0; j < dsfiles.length; j++) {\n                        File file = new File(baseDir, dsfiles[j]);\n                        totalFiles++;\n\n                        if (!file.exists() || !file.canRead()) {\n                            throw new BuildException(\"File \\\"\" +\n                        file.getAbsolutePath()\n                        + \"\\\" does not exist or is not readable.\");\n                        }\n\n                        boolean indexIt = true;\n\n                        if (checkLastModified) {\n                            Hits hits = null;\n                            Term pathTerm =\n                                  new Term(\"path\", file.getPath());\n                            TermQuery query =\n                                           new TermQuery(pathTerm);\n                            hits = searcher.search(query);\n\n                            // if document is found, compare the\n                            // indexed last modified time with the\n                            // current file\n                            // - don't index if up to date\n                            if (hits.length() > 0) {\n                                Document doc = hits.doc(0);\n                                String indexModified =\n                                               doc.get(\"modified\");\n                                if (indexModified != null) {\n                                    if (DateField.stringToTime(indexModified)\n                                             == file.lastModified()) {\n                                        indexIt = false;\n                                    }\n                                }\n                            }\n                        }\n\n                        if (indexIt) {\n                            try {\n                                log(\"Indexing \" + file.getPath(),\n                                    Project.MSG_VERBOSE);\n                                Document doc =\n                                         handler.getDocument(file);\n\n                                if (doc == null) {\n                                    totalIgnored++;\n                                }\n                                else {\n                                    // Add the path of the file as a field named \"path\".  Use a Text field, so\n                                    // that the index stores the path, and so that the path is searchable\n                                    doc.add(Field.Keyword(\"path\", file.getPath()));\n\n                                    // Add the last modified date of the file a field named \"modified\".  Use a\n                                    // Keyword field, so that it's searchable, but so that no attempt is made\n                                    // to tokenize the field into words.\n                                    doc.add(Field.Keyword(\"modified\",\n                                            DateField.timeToString(file.lastModified())));\n\n                                    writer.addDocument(doc);\n                                    totalIndexed++;\n                                }\n                            }\n                            catch (DocumentHandlerException e) {\n                                throw new BuildException(e);\n                            }\n                        }\n                    }\n                    // for j\n                }\n                // if (fs != null)\n            }\n            // for i\n\n            writer.optimize();\n        }\n        //try\n        finally {\n            // always make sure everything gets closed,\n            // no matter how we exit.\n            writer.close();\n            if (searcher != null) {\n                searcher.close();\n            }\n        }\n\n        Date end = new Date();\n\n        log(totalIndexed + \" out of \" + totalFiles + \" indexed (\" +\n                totalIgnored + \" ignored) in \" + (end.getTime() - start.getTime()) +\n                \" milliseconds\");\n    }\n\n","sourceOld":"    /**\n     *  index the fileset\n     *\n     * @exception  IOException  Description of Exception\n     * @todo refactor - definitely lots of room for improvement here\n     */\n    private void indexDocs() throws IOException {\n        Date start = new Date();\n\n        boolean create = overwrite;\n        // If the index directory doesn't exist,\n        // create it and force create mode\n        if (indexPath.mkdirs() && !overwrite) {\n            create = true;\n        }\n\n        Searcher searcher = null;\n        Analyzer analyzer = new StopAnalyzer();\n        boolean checkLastModified = false;\n        if (!create) {\n            try {\n                searcher = new IndexSearcher(indexPath.getAbsolutePath());\n                checkLastModified = true;\n            }\n            catch (IOException ioe) {\n                log(\"IOException: \" + ioe.getMessage());\n                // Empty - ignore, which indicates to index all\n                // documents\n            }\n        }\n\n        log(\"checkLastModified = \" + checkLastModified);\n\n        IndexWriter writer =\n                       new IndexWriter(indexPath, analyzer, create);\n        int totalFiles = 0;\n        int totalIndexed = 0;\n        int totalIgnored = 0;\n        try {\n            writer.mergeFactor = mergeFactor;\n\n            for (int i = 0; i < filesets.size(); i++) {\n                FileSet fs = (FileSet) filesets.elementAt(i);\n                if (fs != null) {\n                    DirectoryScanner ds =\n                                   fs.getDirectoryScanner(project);\n                    String[] dsfiles = ds.getIncludedFiles();\n                    File baseDir = ds.getBasedir();\n\n                    for (int j = 0; j < dsfiles.length; j++) {\n                        File file = new File(baseDir, dsfiles[j]);\n                        totalFiles++;\n\n                        if (!file.exists() || !file.canRead()) {\n                            throw new BuildException(\"File \\\"\" +\n                        file.getAbsolutePath()\n                        + \"\\\" does not exist or is not readable.\");\n                        }\n\n                        boolean indexIt = true;\n\n                        if (checkLastModified) {\n                            Hits hits = null;\n                            Term pathTerm = \n                                  new Term(\"path\", file.getPath());\n                            TermQuery query =\n                                           new TermQuery(pathTerm);\n                            hits = searcher.search(query);\n\n                            // if document is found, compare the\n                            // indexed last modified time with the\n                            // current file\n                            // - don't index if up to date\n                            if (hits.length() > 0) {\n                                Document doc = hits.doc(0);\n                                String indexModified =\n                                               doc.get(\"modified\");\n                                if (indexModified != null) {\n                                    if (DateField.stringToTime(indexModified)\n                                             == file.lastModified()) {\n                                        indexIt = false;\n                                    }\n                                }\n                            }\n                        }\n\n                        if (indexIt) {\n                            try {\n                                log(\"Indexing \" + file.getPath(),\n                                    Project.MSG_VERBOSE);\n                                Document doc =\n                                         handler.getDocument(file);\n\n                                if (doc == null) {\n                                    totalIgnored++;\n                                }\n                                else {\n                                    // Add the path of the file as a field named \"path\".  Use a Text field, so\n                                    // that the index stores the path, and so that the path is searchable\n                                    doc.add(Field.Keyword(\"path\", file.getPath()));\n\n                                    // Add the last modified date of the file a field named \"modified\".  Use a\n                                    // Keyword field, so that it's searchable, but so that no attempt is made\n                                    // to tokenize the field into words.\n                                    doc.add(Field.Keyword(\"modified\",\n                                            DateField.timeToString(file.lastModified())));\n\n                                    writer.addDocument(doc);\n                                    totalIndexed++;\n                                }\n                            }\n                            catch (DocumentHandlerException e) {\n                                throw new BuildException(e);\n                            }\n                        }\n                    }\n                    // for j\n                }\n                // if (fs != null)\n            }\n            // for i\n\n            writer.optimize();\n        }\n        //try\n        finally {\n            // always make sure everything gets closed,\n            // no matter how we exit.\n            writer.close();\n            if (searcher != null) {\n                searcher.close();\n            }\n        }\n\n        Date end = new Date();\n\n        log(totalIndexed + \" out of \" + totalFiles + \" indexed (\" +\n                totalIgnored + \" ignored) in \" + (end.getTime() - start.getTime()) +\n                \" milliseconds\");\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1231e7cbcc1a7bb7e8e177fba43db8d12e03b6db","date":1074524313,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"sandbox/contributions/ant/src/main/org/apache/lucene/ant/IndexTask#indexDocs().mjava","pathOld":"sandbox/contributions/ant/src/main/org/apache/lucene/ant/IndexTask#indexDocs().mjava","sourceNew":"  /**\n   * Index the fileset.\n   *\n   *@exception  IOException if Lucene I/O exception\n   *@todo refactor!!!!!\n   */\n  private void indexDocs() throws IOException {\n    Date start = new Date();\n\n    boolean create = overwrite;\n    // If the index directory doesn't exist,\n    // create it and force create mode\n    if (indexDir.mkdirs() && !overwrite) {\n      create = true;\n    }\n\n    Searcher searcher = null;\n    boolean checkLastModified = false;\n    if (!create) {\n      try {\n        searcher = new IndexSearcher(indexDir.getAbsolutePath());\n        checkLastModified = true;\n      } catch (IOException ioe) {\n        log(\"IOException: \" + ioe.getMessage());\n        // Empty - ignore, which indicates to index all\n        // documents\n      }\n    }\n\n    log(\"checkLastModified = \" + checkLastModified, Project.MSG_VERBOSE);\n\n    IndexWriter writer =\n      new IndexWriter(indexDir, analyzer, create);\n    int totalFiles = 0;\n    int totalIndexed = 0;\n    int totalIgnored = 0;\n    try {\n      writer.mergeFactor = mergeFactor;\n\n      for (int i = 0; i < filesets.size(); i++) {\n        FileSet fs = (FileSet) filesets.get(i);\n        if (fs != null) {\n          DirectoryScanner ds =\n            fs.getDirectoryScanner(getProject());\n          String[] dsfiles = ds.getIncludedFiles();\n          File baseDir = ds.getBasedir();\n\n          for (int j = 0; j < dsfiles.length; j++) {\n            File file = new File(baseDir, dsfiles[j]);\n            totalFiles++;\n\n            if (!file.exists() || !file.canRead()) {\n              throw new BuildException(\"File \\\"\" +\n                                       file.getAbsolutePath()\n                                       + \"\\\" does not exist or is not readable.\");\n            }\n\n            boolean indexIt = true;\n\n            if (checkLastModified) {\n              Hits hits = null;\n              Term pathTerm =\n                new Term(\"path\", file.getPath());\n              TermQuery query =\n                new TermQuery(pathTerm);\n              hits = searcher.search(query);\n\n              // if document is found, compare the\n              // indexed last modified time with the\n              // current file\n              // - don't index if up to date\n              if (hits.length() > 0) {\n                Document doc = hits.doc(0);\n                String indexModified =\n                  doc.get(\"modified\").trim();\n                if (indexModified != null) {\n                  if (DateField.stringToTime(indexModified)\n                    == file.lastModified()) {\n                    indexIt = false;\n                  }\n                }\n              }\n            }\n\n            if (indexIt) {\n              try {\n                log(\"Indexing \" + file.getPath(),\n                    Project.MSG_VERBOSE);\n                Document doc =\n                  handler.getDocument(file);\n\n                if (doc == null) {\n                  totalIgnored++;\n                } else {\n                  // Add the path of the file as a field named \"path\".  Use a Text field, so\n                  // that the index stores the path, and so that the path is searchable\n                  doc.add(Field.Keyword(\"path\", file.getPath()));\n\n                  // Add the last modified date of the file a field named \"modified\".  Use a\n                  // Keyword field, so that it's searchable, but so that no attempt is made\n                  // to tokenize the field into words.\n                  doc.add(Field.Keyword(\"modified\",\n                                        DateField.timeToString(file.lastModified())));\n\n                  writer.addDocument(doc);\n                  totalIndexed++;\n                }\n              } catch (DocumentHandlerException e) {\n                throw new BuildException(e);\n              }\n            }\n          }\n          // for j\n        }\n        // if (fs != null)\n      }\n      // for i\n\n      writer.optimize();\n    }\n      //try\n    finally {\n      // always make sure everything gets closed,\n      // no matter how we exit.\n      writer.close();\n      if (searcher != null) {\n        searcher.close();\n      }\n    }\n\n    Date end = new Date();\n\n    log(totalIndexed + \" out of \" + totalFiles + \" indexed (\" +\n        totalIgnored + \" ignored) in \" + (end.getTime() - start.getTime()) +\n        \" milliseconds\");\n  }\n\n","sourceOld":"    /**\n     *  index the fileset\n     *\n     * @exception  IOException  Description of Exception\n     * @todo refactor - definitely lots of room for improvement here\n     */\n    private void indexDocs() throws IOException {\n        Date start = new Date();\n\n        boolean create = overwrite;\n        // If the index directory doesn't exist,\n        // create it and force create mode\n        if (indexPath.mkdirs() && !overwrite) {\n            create = true;\n        }\n\n        Searcher searcher = null;\n        Analyzer analyzer = new StopAnalyzer();\n        boolean checkLastModified = false;\n        if (!create) {\n            try {\n                searcher = new IndexSearcher(indexPath.getAbsolutePath());\n                checkLastModified = true;\n            }\n            catch (IOException ioe) {\n                log(\"IOException: \" + ioe.getMessage());\n                // Empty - ignore, which indicates to index all\n                // documents\n            }\n        }\n\n        log(\"checkLastModified = \" + checkLastModified);\n\n        IndexWriter writer =\n                       new IndexWriter(indexPath, analyzer, create);\n        int totalFiles = 0;\n        int totalIndexed = 0;\n        int totalIgnored = 0;\n        try {\n            writer.mergeFactor = mergeFactor;\n\n            for (int i = 0; i < filesets.size(); i++) {\n                FileSet fs = (FileSet) filesets.elementAt(i);\n                if (fs != null) {\n                    DirectoryScanner ds =\n                                   fs.getDirectoryScanner(getProject());\n                    String[] dsfiles = ds.getIncludedFiles();\n                    File baseDir = ds.getBasedir();\n\n                    for (int j = 0; j < dsfiles.length; j++) {\n                        File file = new File(baseDir, dsfiles[j]);\n                        totalFiles++;\n\n                        if (!file.exists() || !file.canRead()) {\n                            throw new BuildException(\"File \\\"\" +\n                        file.getAbsolutePath()\n                        + \"\\\" does not exist or is not readable.\");\n                        }\n\n                        boolean indexIt = true;\n\n                        if (checkLastModified) {\n                            Hits hits = null;\n                            Term pathTerm =\n                                  new Term(\"path\", file.getPath());\n                            TermQuery query =\n                                           new TermQuery(pathTerm);\n                            hits = searcher.search(query);\n\n                            // if document is found, compare the\n                            // indexed last modified time with the\n                            // current file\n                            // - don't index if up to date\n                            if (hits.length() > 0) {\n                                Document doc = hits.doc(0);\n                                String indexModified =\n                                               doc.get(\"modified\");\n                                if (indexModified != null) {\n                                    if (DateField.stringToTime(indexModified)\n                                             == file.lastModified()) {\n                                        indexIt = false;\n                                    }\n                                }\n                            }\n                        }\n\n                        if (indexIt) {\n                            try {\n                                log(\"Indexing \" + file.getPath(),\n                                    Project.MSG_VERBOSE);\n                                Document doc =\n                                         handler.getDocument(file);\n\n                                if (doc == null) {\n                                    totalIgnored++;\n                                }\n                                else {\n                                    // Add the path of the file as a field named \"path\".  Use a Text field, so\n                                    // that the index stores the path, and so that the path is searchable\n                                    doc.add(Field.Keyword(\"path\", file.getPath()));\n\n                                    // Add the last modified date of the file a field named \"modified\".  Use a\n                                    // Keyword field, so that it's searchable, but so that no attempt is made\n                                    // to tokenize the field into words.\n                                    doc.add(Field.Keyword(\"modified\",\n                                            DateField.timeToString(file.lastModified())));\n\n                                    writer.addDocument(doc);\n                                    totalIndexed++;\n                                }\n                            }\n                            catch (DocumentHandlerException e) {\n                                throw new BuildException(e);\n                            }\n                        }\n                    }\n                    // for j\n                }\n                // if (fs != null)\n            }\n            // for i\n\n            writer.optimize();\n        }\n        //try\n        finally {\n            // always make sure everything gets closed,\n            // no matter how we exit.\n            writer.close();\n            if (searcher != null) {\n                searcher.close();\n            }\n        }\n\n        Date end = new Date();\n\n        log(totalIndexed + \" out of \" + totalFiles + \" indexed (\" +\n                totalIgnored + \" ignored) in \" + (end.getTime() - start.getTime()) +\n                \" milliseconds\");\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e569ce7afe50440c144f72c841b3469a54519875","date":1074879613,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"sandbox/contributions/ant/src/main/org/apache/lucene/ant/IndexTask#indexDocs().mjava","pathOld":"sandbox/contributions/ant/src/main/org/apache/lucene/ant/IndexTask#indexDocs().mjava","sourceNew":"  /**\n   * Index the fileset.\n   *\n   *@exception  IOException if Lucene I/O exception\n   *@todo refactor!!!!!\n   */\n  private void indexDocs() throws IOException {\n    Date start = new Date();\n\n    boolean create = overwrite;\n    // If the index directory doesn't exist,\n    // create it and force create mode\n    if (indexDir.mkdirs() && !overwrite) {\n      create = true;\n    }\n\n    Searcher searcher = null;\n    boolean checkLastModified = false;\n    if (!create) {\n      try {\n        searcher = new IndexSearcher(indexDir.getAbsolutePath());\n        checkLastModified = true;\n      } catch (IOException ioe) {\n        log(\"IOException: \" + ioe.getMessage());\n        // Empty - ignore, which indicates to index all\n        // documents\n      }\n    }\n\n    log(\"checkLastModified = \" + checkLastModified, Project.MSG_VERBOSE);\n\n    IndexWriter writer =\n      new IndexWriter(indexDir, analyzer, create);\n    int totalFiles = 0;\n    int totalIndexed = 0;\n    int totalIgnored = 0;\n    try {\n      writer.mergeFactor = mergeFactor;\n\n      for (int i = 0; i < filesets.size(); i++) {\n        FileSet fs = (FileSet) filesets.get(i);\n        if (fs != null) {\n          DirectoryScanner ds =\n            fs.getDirectoryScanner(getProject());\n          String[] dsfiles = ds.getIncludedFiles();\n          File baseDir = ds.getBasedir();\n\n          for (int j = 0; j < dsfiles.length; j++) {\n            File file = new File(baseDir, dsfiles[j]);\n            totalFiles++;\n\n            if (!file.exists() || !file.canRead()) {\n              throw new BuildException(\"File \\\"\" +\n                                       file.getAbsolutePath()\n                                       + \"\\\" does not exist or is not readable.\");\n            }\n\n            boolean indexIt = true;\n\n            if (checkLastModified) {\n              Hits hits = null;\n              Term pathTerm =\n                new Term(\"path\", file.getPath());\n              TermQuery query =\n                new TermQuery(pathTerm);\n              hits = searcher.search(query);\n\n              // if document is found, compare the\n              // indexed last modified time with the\n              // current file\n              // - don't index if up to date\n              if (hits.length() > 0) {\n                Document doc = hits.doc(0);\n                String indexModified =\n                  doc.get(\"modified\").trim();\n                if (indexModified != null) {\n                  if (DateField.stringToTime(indexModified)\n                    == file.lastModified()) {\n                    indexIt = false;\n                  }\n                }\n              }\n            }\n\n            if (indexIt) {\n              try {\n                log(\"Indexing \" + file.getPath(),\n                    Project.MSG_VERBOSE);\n                Document doc =\n                  handler.getDocument(file);\n\n                if (doc == null) {\n                  totalIgnored++;\n                } else {\n                  // Add the path of the file as a field named \"path\".  Use a Keyword field, so\n                  // that the index stores the path, and so that the path is searchable\n                  doc.add(Field.Keyword(\"path\", file.getPath()));\n\n                  // Add the last modified date of the file a field named \"modified\".  Use a\n                  // Keyword field, so that it's searchable, but so that no attempt is made\n                  // to tokenize the field into words.\n                  doc.add(Field.Keyword(\"modified\",\n                                        DateField.timeToString(file.lastModified())));\n\n                  writer.addDocument(doc);\n                  totalIndexed++;\n                }\n              } catch (DocumentHandlerException e) {\n                throw new BuildException(e);\n              }\n            }\n          }\n          // for j\n        }\n        // if (fs != null)\n      }\n      // for i\n\n      writer.optimize();\n    }\n      //try\n    finally {\n      // always make sure everything gets closed,\n      // no matter how we exit.\n      writer.close();\n      if (searcher != null) {\n        searcher.close();\n      }\n    }\n\n    Date end = new Date();\n\n    log(totalIndexed + \" out of \" + totalFiles + \" indexed (\" +\n        totalIgnored + \" ignored) in \" + (end.getTime() - start.getTime()) +\n        \" milliseconds\");\n  }\n\n","sourceOld":"  /**\n   * Index the fileset.\n   *\n   *@exception  IOException if Lucene I/O exception\n   *@todo refactor!!!!!\n   */\n  private void indexDocs() throws IOException {\n    Date start = new Date();\n\n    boolean create = overwrite;\n    // If the index directory doesn't exist,\n    // create it and force create mode\n    if (indexDir.mkdirs() && !overwrite) {\n      create = true;\n    }\n\n    Searcher searcher = null;\n    boolean checkLastModified = false;\n    if (!create) {\n      try {\n        searcher = new IndexSearcher(indexDir.getAbsolutePath());\n        checkLastModified = true;\n      } catch (IOException ioe) {\n        log(\"IOException: \" + ioe.getMessage());\n        // Empty - ignore, which indicates to index all\n        // documents\n      }\n    }\n\n    log(\"checkLastModified = \" + checkLastModified, Project.MSG_VERBOSE);\n\n    IndexWriter writer =\n      new IndexWriter(indexDir, analyzer, create);\n    int totalFiles = 0;\n    int totalIndexed = 0;\n    int totalIgnored = 0;\n    try {\n      writer.mergeFactor = mergeFactor;\n\n      for (int i = 0; i < filesets.size(); i++) {\n        FileSet fs = (FileSet) filesets.get(i);\n        if (fs != null) {\n          DirectoryScanner ds =\n            fs.getDirectoryScanner(getProject());\n          String[] dsfiles = ds.getIncludedFiles();\n          File baseDir = ds.getBasedir();\n\n          for (int j = 0; j < dsfiles.length; j++) {\n            File file = new File(baseDir, dsfiles[j]);\n            totalFiles++;\n\n            if (!file.exists() || !file.canRead()) {\n              throw new BuildException(\"File \\\"\" +\n                                       file.getAbsolutePath()\n                                       + \"\\\" does not exist or is not readable.\");\n            }\n\n            boolean indexIt = true;\n\n            if (checkLastModified) {\n              Hits hits = null;\n              Term pathTerm =\n                new Term(\"path\", file.getPath());\n              TermQuery query =\n                new TermQuery(pathTerm);\n              hits = searcher.search(query);\n\n              // if document is found, compare the\n              // indexed last modified time with the\n              // current file\n              // - don't index if up to date\n              if (hits.length() > 0) {\n                Document doc = hits.doc(0);\n                String indexModified =\n                  doc.get(\"modified\").trim();\n                if (indexModified != null) {\n                  if (DateField.stringToTime(indexModified)\n                    == file.lastModified()) {\n                    indexIt = false;\n                  }\n                }\n              }\n            }\n\n            if (indexIt) {\n              try {\n                log(\"Indexing \" + file.getPath(),\n                    Project.MSG_VERBOSE);\n                Document doc =\n                  handler.getDocument(file);\n\n                if (doc == null) {\n                  totalIgnored++;\n                } else {\n                  // Add the path of the file as a field named \"path\".  Use a Text field, so\n                  // that the index stores the path, and so that the path is searchable\n                  doc.add(Field.Keyword(\"path\", file.getPath()));\n\n                  // Add the last modified date of the file a field named \"modified\".  Use a\n                  // Keyword field, so that it's searchable, but so that no attempt is made\n                  // to tokenize the field into words.\n                  doc.add(Field.Keyword(\"modified\",\n                                        DateField.timeToString(file.lastModified())));\n\n                  writer.addDocument(doc);\n                  totalIndexed++;\n                }\n              } catch (DocumentHandlerException e) {\n                throw new BuildException(e);\n              }\n            }\n          }\n          // for j\n        }\n        // if (fs != null)\n      }\n      // for i\n\n      writer.optimize();\n    }\n      //try\n    finally {\n      // always make sure everything gets closed,\n      // no matter how we exit.\n      writer.close();\n      if (searcher != null) {\n        searcher.close();\n      }\n    }\n\n    Date end = new Date();\n\n    log(totalIndexed + \" out of \" + totalFiles + \" indexed (\" +\n        totalIgnored + \" ignored) in \" + (end.getTime() - start.getTime()) +\n        \" milliseconds\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b6ac42777974b5a102c942a62dff20c24fa5eca","date":1077446018,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"sandbox/contributions/ant/src/main/org/apache/lucene/ant/IndexTask#indexDocs().mjava","pathOld":"sandbox/contributions/ant/src/main/org/apache/lucene/ant/IndexTask#indexDocs().mjava","sourceNew":"  /**\n   * Index the fileset.\n   *\n   *@exception  IOException if Lucene I/O exception\n   *@todo refactor!!!!!\n   */\n  private void indexDocs() throws IOException {\n    Date start = new Date();\n\n    boolean create = overwrite;\n    // If the index directory doesn't exist,\n    // create it and force create mode\n    if (indexDir.mkdirs() && !overwrite) {\n      create = true;\n    }\n\n    Searcher searcher = null;\n    boolean checkLastModified = false;\n    if (!create) {\n      try {\n        searcher = new IndexSearcher(indexDir.getAbsolutePath());\n        checkLastModified = true;\n      } catch (IOException ioe) {\n        log(\"IOException: \" + ioe.getMessage());\n        // Empty - ignore, which indicates to index all\n        // documents\n      }\n    }\n\n    log(\"checkLastModified = \" + checkLastModified, Project.MSG_VERBOSE);\n\n    IndexWriter writer =\n      new IndexWriter(indexDir, analyzer, create);\n    int totalFiles = 0;\n    int totalIndexed = 0;\n    int totalIgnored = 0;\n    try {\n      writer.mergeFactor = mergeFactor;\n\n      for (int i = 0; i < filesets.size(); i++) {\n        FileSet fs = (FileSet) filesets.get(i);\n        if (fs != null) {\n          DirectoryScanner ds =\n            fs.getDirectoryScanner(getProject());\n          String[] dsfiles = ds.getIncludedFiles();\n          File baseDir = ds.getBasedir();\n\n          for (int j = 0; j < dsfiles.length; j++) {\n            File file = new File(baseDir, dsfiles[j]);\n            totalFiles++;\n\n            if (!file.exists() || !file.canRead()) {\n              throw new BuildException(\"File \\\"\" +\n                                       file.getAbsolutePath()\n                                       + \"\\\" does not exist or is not readable.\");\n            }\n\n            boolean indexIt = true;\n\n            if (checkLastModified) {\n              Term pathTerm =\n                new Term(\"path\", file.getPath());\n              TermQuery query =\n                new TermQuery(pathTerm);\n              Hits hits = searcher.search(query);\n\n              // if document is found, compare the\n              // indexed last modified time with the\n              // current file\n              // - don't index if up to date\n              if (hits.length() > 0) {\n                Document doc = hits.doc(0);\n                String indexModified =\n                  doc.get(\"modified\").trim();\n                if (indexModified != null) {\n                  if (DateField.stringToTime(indexModified)\n                    == file.lastModified()) {\n                    indexIt = false;\n                  }\n                }\n              }\n            }\n\n            if (indexIt) {\n              try {\n                log(\"Indexing \" + file.getPath(),\n                    Project.MSG_VERBOSE);\n                Document doc =\n                  handler.getDocument(file);\n\n                if (doc == null) {\n                  totalIgnored++;\n                } else {\n                  // Add the path of the file as a field named \"path\".  Use a Keyword field, so\n                  // that the index stores the path, and so that the path is searchable\n                  doc.add(Field.Keyword(\"path\", file.getPath()));\n\n                  // Add the last modified date of the file a field named \"modified\".  Use a\n                  // Keyword field, so that it's searchable, but so that no attempt is made\n                  // to tokenize the field into words.\n                  doc.add(Field.Keyword(\"modified\",\n                                        DateField.timeToString(file.lastModified())));\n\n                  writer.addDocument(doc);\n                  totalIndexed++;\n                }\n              } catch (DocumentHandlerException e) {\n                throw new BuildException(e);\n              }\n            }\n          }\n          // for j\n        }\n        // if (fs != null)\n      }\n      // for i\n\n      writer.optimize();\n    }\n      //try\n    finally {\n      // always make sure everything gets closed,\n      // no matter how we exit.\n      writer.close();\n      if (searcher != null) {\n        searcher.close();\n      }\n    }\n\n    Date end = new Date();\n\n    log(totalIndexed + \" out of \" + totalFiles + \" indexed (\" +\n        totalIgnored + \" ignored) in \" + (end.getTime() - start.getTime()) +\n        \" milliseconds\");\n  }\n\n","sourceOld":"  /**\n   * Index the fileset.\n   *\n   *@exception  IOException if Lucene I/O exception\n   *@todo refactor!!!!!\n   */\n  private void indexDocs() throws IOException {\n    Date start = new Date();\n\n    boolean create = overwrite;\n    // If the index directory doesn't exist,\n    // create it and force create mode\n    if (indexDir.mkdirs() && !overwrite) {\n      create = true;\n    }\n\n    Searcher searcher = null;\n    boolean checkLastModified = false;\n    if (!create) {\n      try {\n        searcher = new IndexSearcher(indexDir.getAbsolutePath());\n        checkLastModified = true;\n      } catch (IOException ioe) {\n        log(\"IOException: \" + ioe.getMessage());\n        // Empty - ignore, which indicates to index all\n        // documents\n      }\n    }\n\n    log(\"checkLastModified = \" + checkLastModified, Project.MSG_VERBOSE);\n\n    IndexWriter writer =\n      new IndexWriter(indexDir, analyzer, create);\n    int totalFiles = 0;\n    int totalIndexed = 0;\n    int totalIgnored = 0;\n    try {\n      writer.mergeFactor = mergeFactor;\n\n      for (int i = 0; i < filesets.size(); i++) {\n        FileSet fs = (FileSet) filesets.get(i);\n        if (fs != null) {\n          DirectoryScanner ds =\n            fs.getDirectoryScanner(getProject());\n          String[] dsfiles = ds.getIncludedFiles();\n          File baseDir = ds.getBasedir();\n\n          for (int j = 0; j < dsfiles.length; j++) {\n            File file = new File(baseDir, dsfiles[j]);\n            totalFiles++;\n\n            if (!file.exists() || !file.canRead()) {\n              throw new BuildException(\"File \\\"\" +\n                                       file.getAbsolutePath()\n                                       + \"\\\" does not exist or is not readable.\");\n            }\n\n            boolean indexIt = true;\n\n            if (checkLastModified) {\n              Hits hits = null;\n              Term pathTerm =\n                new Term(\"path\", file.getPath());\n              TermQuery query =\n                new TermQuery(pathTerm);\n              hits = searcher.search(query);\n\n              // if document is found, compare the\n              // indexed last modified time with the\n              // current file\n              // - don't index if up to date\n              if (hits.length() > 0) {\n                Document doc = hits.doc(0);\n                String indexModified =\n                  doc.get(\"modified\").trim();\n                if (indexModified != null) {\n                  if (DateField.stringToTime(indexModified)\n                    == file.lastModified()) {\n                    indexIt = false;\n                  }\n                }\n              }\n            }\n\n            if (indexIt) {\n              try {\n                log(\"Indexing \" + file.getPath(),\n                    Project.MSG_VERBOSE);\n                Document doc =\n                  handler.getDocument(file);\n\n                if (doc == null) {\n                  totalIgnored++;\n                } else {\n                  // Add the path of the file as a field named \"path\".  Use a Keyword field, so\n                  // that the index stores the path, and so that the path is searchable\n                  doc.add(Field.Keyword(\"path\", file.getPath()));\n\n                  // Add the last modified date of the file a field named \"modified\".  Use a\n                  // Keyword field, so that it's searchable, but so that no attempt is made\n                  // to tokenize the field into words.\n                  doc.add(Field.Keyword(\"modified\",\n                                        DateField.timeToString(file.lastModified())));\n\n                  writer.addDocument(doc);\n                  totalIndexed++;\n                }\n              } catch (DocumentHandlerException e) {\n                throw new BuildException(e);\n              }\n            }\n          }\n          // for j\n        }\n        // if (fs != null)\n      }\n      // for i\n\n      writer.optimize();\n    }\n      //try\n    finally {\n      // always make sure everything gets closed,\n      // no matter how we exit.\n      writer.close();\n      if (searcher != null) {\n        searcher.close();\n      }\n    }\n\n    Date end = new Date();\n\n    log(totalIndexed + \" out of \" + totalFiles + \" indexed (\" +\n        totalIgnored + \" ignored) in \" + (end.getTime() - start.getTime()) +\n        \" milliseconds\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c333557085915d436787767528f4137d928ec79","date":1077461404,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"sandbox/contributions/ant/src/main/org/apache/lucene/ant/IndexTask#indexDocs().mjava","pathOld":"sandbox/contributions/ant/src/main/org/apache/lucene/ant/IndexTask#indexDocs().mjava","sourceNew":"  /**\n   * Index the fileset.\n   *\n   *@exception  IOException if Lucene I/O exception\n   *@todo refactor!!!!!\n   */\n  private void indexDocs() throws IOException {\n    Date start = new Date();\n\n    boolean create = overwrite;\n    // If the index directory doesn't exist,\n    // create it and force create mode\n    if (indexDir.mkdirs() && !overwrite) {\n      create = true;\n    }\n\n    Searcher searcher = null;\n    boolean checkLastModified = false;\n    if (!create) {\n      try {\n        searcher = new IndexSearcher(indexDir.getAbsolutePath());\n        checkLastModified = true;\n      } catch (IOException ioe) {\n        log(\"IOException: \" + ioe.getMessage());\n        // Empty - ignore, which indicates to index all\n        // documents\n      }\n    }\n\n    log(\"checkLastModified = \" + checkLastModified, Project.MSG_VERBOSE);\n\n    IndexWriter writer =\n      new IndexWriter(indexDir, analyzer, create);\n\n    if (create && useCompoundIndex) {\n      writer.setUseCompoundFile(useCompoundIndex);\n    }\n    int totalFiles = 0;\n    int totalIndexed = 0;\n    int totalIgnored = 0;\n    try {\n      writer.mergeFactor = mergeFactor;\n\n      for (int i = 0; i < filesets.size(); i++) {\n        FileSet fs = (FileSet) filesets.get(i);\n        if (fs != null) {\n          DirectoryScanner ds =\n            fs.getDirectoryScanner(getProject());\n          String[] dsfiles = ds.getIncludedFiles();\n          File baseDir = ds.getBasedir();\n\n          for (int j = 0; j < dsfiles.length; j++) {\n            File file = new File(baseDir, dsfiles[j]);\n            totalFiles++;\n\n            if (!file.exists() || !file.canRead()) {\n              throw new BuildException(\"File \\\"\" +\n                                       file.getAbsolutePath()\n                                       + \"\\\" does not exist or is not readable.\");\n            }\n\n            boolean indexIt = true;\n\n            if (checkLastModified) {\n              Term pathTerm =\n                new Term(\"path\", file.getPath());\n              TermQuery query =\n                new TermQuery(pathTerm);\n              Hits hits = searcher.search(query);\n\n              // if document is found, compare the\n              // indexed last modified time with the\n              // current file\n              // - don't index if up to date\n              if (hits.length() > 0) {\n                Document doc = hits.doc(0);\n                String indexModified =\n                  doc.get(\"modified\").trim();\n                if (indexModified != null) {\n                  if (DateField.stringToTime(indexModified)\n                    == file.lastModified()) {\n                    indexIt = false;\n                  }\n                }\n              }\n            }\n\n            if (indexIt) {\n              try {\n                log(\"Indexing \" + file.getPath(),\n                    Project.MSG_VERBOSE);\n                Document doc =\n                  handler.getDocument(file);\n\n                if (doc == null) {\n                  totalIgnored++;\n                } else {\n                  // Add the path of the file as a field named \"path\".  Use a Keyword field, so\n                  // that the index stores the path, and so that the path is searchable\n                  doc.add(Field.Keyword(\"path\", file.getPath()));\n\n                  // Add the last modified date of the file a field named \"modified\".  Use a\n                  // Keyword field, so that it's searchable, but so that no attempt is made\n                  // to tokenize the field into words.\n                  doc.add(Field.Keyword(\"modified\",\n                                        DateField.timeToString(file.lastModified())));\n\n                  writer.addDocument(doc);\n                  totalIndexed++;\n                }\n              } catch (DocumentHandlerException e) {\n                throw new BuildException(e);\n              }\n            }\n          }\n          // for j\n        }\n        // if (fs != null)\n      }\n      // for i\n\n      writer.optimize();\n    }\n      //try\n    finally {\n      // always make sure everything gets closed,\n      // no matter how we exit.\n      writer.close();\n      if (searcher != null) {\n        searcher.close();\n      }\n    }\n\n    Date end = new Date();\n\n    log(totalIndexed + \" out of \" + totalFiles + \" indexed (\" +\n        totalIgnored + \" ignored) in \" + (end.getTime() - start.getTime()) +\n        \" milliseconds\");\n  }\n\n","sourceOld":"  /**\n   * Index the fileset.\n   *\n   *@exception  IOException if Lucene I/O exception\n   *@todo refactor!!!!!\n   */\n  private void indexDocs() throws IOException {\n    Date start = new Date();\n\n    boolean create = overwrite;\n    // If the index directory doesn't exist,\n    // create it and force create mode\n    if (indexDir.mkdirs() && !overwrite) {\n      create = true;\n    }\n\n    Searcher searcher = null;\n    boolean checkLastModified = false;\n    if (!create) {\n      try {\n        searcher = new IndexSearcher(indexDir.getAbsolutePath());\n        checkLastModified = true;\n      } catch (IOException ioe) {\n        log(\"IOException: \" + ioe.getMessage());\n        // Empty - ignore, which indicates to index all\n        // documents\n      }\n    }\n\n    log(\"checkLastModified = \" + checkLastModified, Project.MSG_VERBOSE);\n\n    IndexWriter writer =\n      new IndexWriter(indexDir, analyzer, create);\n    int totalFiles = 0;\n    int totalIndexed = 0;\n    int totalIgnored = 0;\n    try {\n      writer.mergeFactor = mergeFactor;\n\n      for (int i = 0; i < filesets.size(); i++) {\n        FileSet fs = (FileSet) filesets.get(i);\n        if (fs != null) {\n          DirectoryScanner ds =\n            fs.getDirectoryScanner(getProject());\n          String[] dsfiles = ds.getIncludedFiles();\n          File baseDir = ds.getBasedir();\n\n          for (int j = 0; j < dsfiles.length; j++) {\n            File file = new File(baseDir, dsfiles[j]);\n            totalFiles++;\n\n            if (!file.exists() || !file.canRead()) {\n              throw new BuildException(\"File \\\"\" +\n                                       file.getAbsolutePath()\n                                       + \"\\\" does not exist or is not readable.\");\n            }\n\n            boolean indexIt = true;\n\n            if (checkLastModified) {\n              Term pathTerm =\n                new Term(\"path\", file.getPath());\n              TermQuery query =\n                new TermQuery(pathTerm);\n              Hits hits = searcher.search(query);\n\n              // if document is found, compare the\n              // indexed last modified time with the\n              // current file\n              // - don't index if up to date\n              if (hits.length() > 0) {\n                Document doc = hits.doc(0);\n                String indexModified =\n                  doc.get(\"modified\").trim();\n                if (indexModified != null) {\n                  if (DateField.stringToTime(indexModified)\n                    == file.lastModified()) {\n                    indexIt = false;\n                  }\n                }\n              }\n            }\n\n            if (indexIt) {\n              try {\n                log(\"Indexing \" + file.getPath(),\n                    Project.MSG_VERBOSE);\n                Document doc =\n                  handler.getDocument(file);\n\n                if (doc == null) {\n                  totalIgnored++;\n                } else {\n                  // Add the path of the file as a field named \"path\".  Use a Keyword field, so\n                  // that the index stores the path, and so that the path is searchable\n                  doc.add(Field.Keyword(\"path\", file.getPath()));\n\n                  // Add the last modified date of the file a field named \"modified\".  Use a\n                  // Keyword field, so that it's searchable, but so that no attempt is made\n                  // to tokenize the field into words.\n                  doc.add(Field.Keyword(\"modified\",\n                                        DateField.timeToString(file.lastModified())));\n\n                  writer.addDocument(doc);\n                  totalIndexed++;\n                }\n              } catch (DocumentHandlerException e) {\n                throw new BuildException(e);\n              }\n            }\n          }\n          // for j\n        }\n        // if (fs != null)\n      }\n      // for i\n\n      writer.optimize();\n    }\n      //try\n    finally {\n      // always make sure everything gets closed,\n      // no matter how we exit.\n      writer.close();\n      if (searcher != null) {\n        searcher.close();\n      }\n    }\n\n    Date end = new Date();\n\n    log(totalIndexed + \" out of \" + totalFiles + \" indexed (\" +\n        totalIgnored + \" ignored) in \" + (end.getTime() - start.getTime()) +\n        \" milliseconds\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf7669a0fd28faf55d56f58018d3b074ff29108a","date":1091716348,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"sandbox/contributions/ant/src/main/org/apache/lucene/ant/IndexTask#indexDocs().mjava","pathOld":"sandbox/contributions/ant/src/main/org/apache/lucene/ant/IndexTask#indexDocs().mjava","sourceNew":"  /**\n   * Index the fileset.\n   *\n   *@exception  IOException if Lucene I/O exception\n   *@todo refactor!!!!!\n   */\n  private void indexDocs() throws IOException {\n    Date start = new Date();\n\n    boolean create = overwrite;\n    // If the index directory doesn't exist,\n    // create it and force create mode\n    if (indexDir.mkdirs() && !overwrite) {\n      create = true;\n    }\n\n    Searcher searcher = null;\n    boolean checkLastModified = false;\n    if (!create) {\n      try {\n        searcher = new IndexSearcher(indexDir.getAbsolutePath());\n        checkLastModified = true;\n      } catch (IOException ioe) {\n        log(\"IOException: \" + ioe.getMessage());\n        // Empty - ignore, which indicates to index all\n        // documents\n      }\n    }\n\n    log(\"checkLastModified = \" + checkLastModified, Project.MSG_VERBOSE);\n\n    IndexWriter writer =\n      new IndexWriter(indexDir, analyzer, create);\n\n    writer.setUseCompoundFile(useCompoundIndex);\n    int totalFiles = 0;\n    int totalIndexed = 0;\n    int totalIgnored = 0;\n    try {\n      writer.mergeFactor = mergeFactor;\n\n      for (int i = 0; i < filesets.size(); i++) {\n        FileSet fs = (FileSet) filesets.get(i);\n        if (fs != null) {\n          DirectoryScanner ds =\n            fs.getDirectoryScanner(getProject());\n          String[] dsfiles = ds.getIncludedFiles();\n          File baseDir = ds.getBasedir();\n\n          for (int j = 0; j < dsfiles.length; j++) {\n            File file = new File(baseDir, dsfiles[j]);\n            totalFiles++;\n\n            if (!file.exists() || !file.canRead()) {\n              throw new BuildException(\"File \\\"\" +\n                                       file.getAbsolutePath()\n                                       + \"\\\" does not exist or is not readable.\");\n            }\n\n            boolean indexIt = true;\n\n            if (checkLastModified) {\n              Term pathTerm =\n                new Term(\"path\", file.getPath());\n              TermQuery query =\n                new TermQuery(pathTerm);\n              Hits hits = searcher.search(query);\n\n              // if document is found, compare the\n              // indexed last modified time with the\n              // current file\n              // - don't index if up to date\n              if (hits.length() > 0) {\n                Document doc = hits.doc(0);\n                String indexModified =\n                  doc.get(\"modified\").trim();\n                if (indexModified != null) {\n                  if (DateField.stringToTime(indexModified)\n                    == file.lastModified()) {\n                    // TODO: remove existing document\n                    indexIt = false;\n                  }\n                }\n              }\n            }\n\n            if (indexIt) {\n              try {\n                log(\"Indexing \" + file.getPath(),\n                    Project.MSG_VERBOSE);\n                Document doc =\n                  handler.getDocument(file);\n\n                if (doc == null) {\n                  totalIgnored++;\n                } else {\n                  // Add the path of the file as a field named \"path\".  Use a Keyword field, so\n                  // that the index stores the path, and so that the path is searchable\n                  doc.add(Field.Keyword(\"path\", file.getPath()));\n\n                  // Add the last modified date of the file a field named \"modified\".  Use a\n                  // Keyword field, so that it's searchable, but so that no attempt is made\n                  // to tokenize the field into words.\n                  doc.add(Field.Keyword(\"modified\",\n                                        DateField.timeToString(file.lastModified())));\n\n                  writer.addDocument(doc);\n                  totalIndexed++;\n                }\n              } catch (DocumentHandlerException e) {\n                throw new BuildException(e);\n              }\n            }\n          }\n          // for j\n        }\n        // if (fs != null)\n      }\n      // for i\n\n      writer.optimize();\n    }\n      //try\n    finally {\n      // always make sure everything gets closed,\n      // no matter how we exit.\n      writer.close();\n      if (searcher != null) {\n        searcher.close();\n      }\n    }\n\n    Date end = new Date();\n\n    log(totalIndexed + \" out of \" + totalFiles + \" indexed (\" +\n        totalIgnored + \" ignored) in \" + (end.getTime() - start.getTime()) +\n        \" milliseconds\");\n  }\n\n","sourceOld":"  /**\n   * Index the fileset.\n   *\n   *@exception  IOException if Lucene I/O exception\n   *@todo refactor!!!!!\n   */\n  private void indexDocs() throws IOException {\n    Date start = new Date();\n\n    boolean create = overwrite;\n    // If the index directory doesn't exist,\n    // create it and force create mode\n    if (indexDir.mkdirs() && !overwrite) {\n      create = true;\n    }\n\n    Searcher searcher = null;\n    boolean checkLastModified = false;\n    if (!create) {\n      try {\n        searcher = new IndexSearcher(indexDir.getAbsolutePath());\n        checkLastModified = true;\n      } catch (IOException ioe) {\n        log(\"IOException: \" + ioe.getMessage());\n        // Empty - ignore, which indicates to index all\n        // documents\n      }\n    }\n\n    log(\"checkLastModified = \" + checkLastModified, Project.MSG_VERBOSE);\n\n    IndexWriter writer =\n      new IndexWriter(indexDir, analyzer, create);\n\n    if (create && useCompoundIndex) {\n      writer.setUseCompoundFile(useCompoundIndex);\n    }\n    int totalFiles = 0;\n    int totalIndexed = 0;\n    int totalIgnored = 0;\n    try {\n      writer.mergeFactor = mergeFactor;\n\n      for (int i = 0; i < filesets.size(); i++) {\n        FileSet fs = (FileSet) filesets.get(i);\n        if (fs != null) {\n          DirectoryScanner ds =\n            fs.getDirectoryScanner(getProject());\n          String[] dsfiles = ds.getIncludedFiles();\n          File baseDir = ds.getBasedir();\n\n          for (int j = 0; j < dsfiles.length; j++) {\n            File file = new File(baseDir, dsfiles[j]);\n            totalFiles++;\n\n            if (!file.exists() || !file.canRead()) {\n              throw new BuildException(\"File \\\"\" +\n                                       file.getAbsolutePath()\n                                       + \"\\\" does not exist or is not readable.\");\n            }\n\n            boolean indexIt = true;\n\n            if (checkLastModified) {\n              Term pathTerm =\n                new Term(\"path\", file.getPath());\n              TermQuery query =\n                new TermQuery(pathTerm);\n              Hits hits = searcher.search(query);\n\n              // if document is found, compare the\n              // indexed last modified time with the\n              // current file\n              // - don't index if up to date\n              if (hits.length() > 0) {\n                Document doc = hits.doc(0);\n                String indexModified =\n                  doc.get(\"modified\").trim();\n                if (indexModified != null) {\n                  if (DateField.stringToTime(indexModified)\n                    == file.lastModified()) {\n                    indexIt = false;\n                  }\n                }\n              }\n            }\n\n            if (indexIt) {\n              try {\n                log(\"Indexing \" + file.getPath(),\n                    Project.MSG_VERBOSE);\n                Document doc =\n                  handler.getDocument(file);\n\n                if (doc == null) {\n                  totalIgnored++;\n                } else {\n                  // Add the path of the file as a field named \"path\".  Use a Keyword field, so\n                  // that the index stores the path, and so that the path is searchable\n                  doc.add(Field.Keyword(\"path\", file.getPath()));\n\n                  // Add the last modified date of the file a field named \"modified\".  Use a\n                  // Keyword field, so that it's searchable, but so that no attempt is made\n                  // to tokenize the field into words.\n                  doc.add(Field.Keyword(\"modified\",\n                                        DateField.timeToString(file.lastModified())));\n\n                  writer.addDocument(doc);\n                  totalIndexed++;\n                }\n              } catch (DocumentHandlerException e) {\n                throw new BuildException(e);\n              }\n            }\n          }\n          // for j\n        }\n        // if (fs != null)\n      }\n      // for i\n\n      writer.optimize();\n    }\n      //try\n    finally {\n      // always make sure everything gets closed,\n      // no matter how we exit.\n      writer.close();\n      if (searcher != null) {\n        searcher.close();\n      }\n    }\n\n    Date end = new Date();\n\n    log(totalIndexed + \" out of \" + totalFiles + \" indexed (\" +\n        totalIgnored + \" ignored) in \" + (end.getTime() - start.getTime()) +\n        \" milliseconds\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"043c298cb215f13ba7b9b81d20760704e8f93d66","date":1107566743,"type":5,"author":"Erik Hatcher","isMerge":false,"pathNew":"contrib/ant/src/main/org/apache/lucene/ant/IndexTask#indexDocs().mjava","pathOld":"sandbox/contributions/ant/src/main/org/apache/lucene/ant/IndexTask#indexDocs().mjava","sourceNew":"  /**\n   * Index the fileset.\n   *\n   *@exception  IOException if Lucene I/O exception\n   *@todo refactor!!!!!\n   */\n  private void indexDocs() throws IOException {\n    Date start = new Date();\n\n    boolean create = overwrite;\n    // If the index directory doesn't exist,\n    // create it and force create mode\n    if (indexDir.mkdirs() && !overwrite) {\n      create = true;\n    }\n\n    Searcher searcher = null;\n    boolean checkLastModified = false;\n    if (!create) {\n      try {\n        searcher = new IndexSearcher(indexDir.getAbsolutePath());\n        checkLastModified = true;\n      } catch (IOException ioe) {\n        log(\"IOException: \" + ioe.getMessage());\n        // Empty - ignore, which indicates to index all\n        // documents\n      }\n    }\n\n    log(\"checkLastModified = \" + checkLastModified, Project.MSG_VERBOSE);\n\n    IndexWriter writer =\n      new IndexWriter(indexDir, analyzer, create);\n\n    writer.setUseCompoundFile(useCompoundIndex);\n    int totalFiles = 0;\n    int totalIndexed = 0;\n    int totalIgnored = 0;\n    try {\n      writer.mergeFactor = mergeFactor;\n\n      for (int i = 0; i < filesets.size(); i++) {\n        FileSet fs = (FileSet) filesets.get(i);\n        if (fs != null) {\n          DirectoryScanner ds =\n            fs.getDirectoryScanner(getProject());\n          String[] dsfiles = ds.getIncludedFiles();\n          File baseDir = ds.getBasedir();\n\n          for (int j = 0; j < dsfiles.length; j++) {\n            File file = new File(baseDir, dsfiles[j]);\n            totalFiles++;\n\n            if (!file.exists() || !file.canRead()) {\n              throw new BuildException(\"File \\\"\" +\n                                       file.getAbsolutePath()\n                                       + \"\\\" does not exist or is not readable.\");\n            }\n\n            boolean indexIt = true;\n\n            if (checkLastModified) {\n              Term pathTerm =\n                new Term(\"path\", file.getPath());\n              TermQuery query =\n                new TermQuery(pathTerm);\n              Hits hits = searcher.search(query);\n\n              // if document is found, compare the\n              // indexed last modified time with the\n              // current file\n              // - don't index if up to date\n              if (hits.length() > 0) {\n                Document doc = hits.doc(0);\n                String indexModified =\n                  doc.get(\"modified\").trim();\n                if (indexModified != null) {\n                  if (DateField.stringToTime(indexModified)\n                    == file.lastModified()) {\n                    // TODO: remove existing document\n                    indexIt = false;\n                  }\n                }\n              }\n            }\n\n            if (indexIt) {\n              try {\n                log(\"Indexing \" + file.getPath(),\n                    Project.MSG_VERBOSE);\n                Document doc =\n                  handler.getDocument(file);\n\n                if (doc == null) {\n                  totalIgnored++;\n                } else {\n                  // Add the path of the file as a field named \"path\".  Use a Keyword field, so\n                  // that the index stores the path, and so that the path is searchable\n                  doc.add(Field.Keyword(\"path\", file.getPath()));\n\n                  // Add the last modified date of the file a field named \"modified\".  Use a\n                  // Keyword field, so that it's searchable, but so that no attempt is made\n                  // to tokenize the field into words.\n                  doc.add(Field.Keyword(\"modified\",\n                                        DateField.timeToString(file.lastModified())));\n\n                  writer.addDocument(doc);\n                  totalIndexed++;\n                }\n              } catch (DocumentHandlerException e) {\n                throw new BuildException(e);\n              }\n            }\n          }\n          // for j\n        }\n        // if (fs != null)\n      }\n      // for i\n\n      writer.optimize();\n    }\n      //try\n    finally {\n      // always make sure everything gets closed,\n      // no matter how we exit.\n      writer.close();\n      if (searcher != null) {\n        searcher.close();\n      }\n    }\n\n    Date end = new Date();\n\n    log(totalIndexed + \" out of \" + totalFiles + \" indexed (\" +\n        totalIgnored + \" ignored) in \" + (end.getTime() - start.getTime()) +\n        \" milliseconds\");\n  }\n\n","sourceOld":"  /**\n   * Index the fileset.\n   *\n   *@exception  IOException if Lucene I/O exception\n   *@todo refactor!!!!!\n   */\n  private void indexDocs() throws IOException {\n    Date start = new Date();\n\n    boolean create = overwrite;\n    // If the index directory doesn't exist,\n    // create it and force create mode\n    if (indexDir.mkdirs() && !overwrite) {\n      create = true;\n    }\n\n    Searcher searcher = null;\n    boolean checkLastModified = false;\n    if (!create) {\n      try {\n        searcher = new IndexSearcher(indexDir.getAbsolutePath());\n        checkLastModified = true;\n      } catch (IOException ioe) {\n        log(\"IOException: \" + ioe.getMessage());\n        // Empty - ignore, which indicates to index all\n        // documents\n      }\n    }\n\n    log(\"checkLastModified = \" + checkLastModified, Project.MSG_VERBOSE);\n\n    IndexWriter writer =\n      new IndexWriter(indexDir, analyzer, create);\n\n    writer.setUseCompoundFile(useCompoundIndex);\n    int totalFiles = 0;\n    int totalIndexed = 0;\n    int totalIgnored = 0;\n    try {\n      writer.mergeFactor = mergeFactor;\n\n      for (int i = 0; i < filesets.size(); i++) {\n        FileSet fs = (FileSet) filesets.get(i);\n        if (fs != null) {\n          DirectoryScanner ds =\n            fs.getDirectoryScanner(getProject());\n          String[] dsfiles = ds.getIncludedFiles();\n          File baseDir = ds.getBasedir();\n\n          for (int j = 0; j < dsfiles.length; j++) {\n            File file = new File(baseDir, dsfiles[j]);\n            totalFiles++;\n\n            if (!file.exists() || !file.canRead()) {\n              throw new BuildException(\"File \\\"\" +\n                                       file.getAbsolutePath()\n                                       + \"\\\" does not exist or is not readable.\");\n            }\n\n            boolean indexIt = true;\n\n            if (checkLastModified) {\n              Term pathTerm =\n                new Term(\"path\", file.getPath());\n              TermQuery query =\n                new TermQuery(pathTerm);\n              Hits hits = searcher.search(query);\n\n              // if document is found, compare the\n              // indexed last modified time with the\n              // current file\n              // - don't index if up to date\n              if (hits.length() > 0) {\n                Document doc = hits.doc(0);\n                String indexModified =\n                  doc.get(\"modified\").trim();\n                if (indexModified != null) {\n                  if (DateField.stringToTime(indexModified)\n                    == file.lastModified()) {\n                    // TODO: remove existing document\n                    indexIt = false;\n                  }\n                }\n              }\n            }\n\n            if (indexIt) {\n              try {\n                log(\"Indexing \" + file.getPath(),\n                    Project.MSG_VERBOSE);\n                Document doc =\n                  handler.getDocument(file);\n\n                if (doc == null) {\n                  totalIgnored++;\n                } else {\n                  // Add the path of the file as a field named \"path\".  Use a Keyword field, so\n                  // that the index stores the path, and so that the path is searchable\n                  doc.add(Field.Keyword(\"path\", file.getPath()));\n\n                  // Add the last modified date of the file a field named \"modified\".  Use a\n                  // Keyword field, so that it's searchable, but so that no attempt is made\n                  // to tokenize the field into words.\n                  doc.add(Field.Keyword(\"modified\",\n                                        DateField.timeToString(file.lastModified())));\n\n                  writer.addDocument(doc);\n                  totalIndexed++;\n                }\n              } catch (DocumentHandlerException e) {\n                throw new BuildException(e);\n              }\n            }\n          }\n          // for j\n        }\n        // if (fs != null)\n      }\n      // for i\n\n      writer.optimize();\n    }\n      //try\n    finally {\n      // always make sure everything gets closed,\n      // no matter how we exit.\n      writer.close();\n      if (searcher != null) {\n        searcher.close();\n      }\n    }\n\n    Date end = new Date();\n\n    log(totalIndexed + \" out of \" + totalFiles + \" indexed (\" +\n        totalIgnored + \" ignored) in \" + (end.getTime() - start.getTime()) +\n        \" milliseconds\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e569ce7afe50440c144f72c841b3469a54519875":["1231e7cbcc1a7bb7e8e177fba43db8d12e03b6db"],"043c298cb215f13ba7b9b81d20760704e8f93d66":["cf7669a0fd28faf55d56f58018d3b074ff29108a"],"febb159f33ae1f7cccd813bde934e23fff2e5877":["6cae9303ec860d8a88b807570b29e841a3d1fbd3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6cae9303ec860d8a88b807570b29e841a3d1fbd3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5b6ac42777974b5a102c942a62dff20c24fa5eca":["e569ce7afe50440c144f72c841b3469a54519875"],"1231e7cbcc1a7bb7e8e177fba43db8d12e03b6db":["febb159f33ae1f7cccd813bde934e23fff2e5877"],"cf7669a0fd28faf55d56f58018d3b074ff29108a":["4c333557085915d436787767528f4137d928ec79"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["043c298cb215f13ba7b9b81d20760704e8f93d66"],"4c333557085915d436787767528f4137d928ec79":["5b6ac42777974b5a102c942a62dff20c24fa5eca"]},"commit2Childs":{"e569ce7afe50440c144f72c841b3469a54519875":["5b6ac42777974b5a102c942a62dff20c24fa5eca"],"043c298cb215f13ba7b9b81d20760704e8f93d66":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"febb159f33ae1f7cccd813bde934e23fff2e5877":["1231e7cbcc1a7bb7e8e177fba43db8d12e03b6db"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6cae9303ec860d8a88b807570b29e841a3d1fbd3"],"6cae9303ec860d8a88b807570b29e841a3d1fbd3":["febb159f33ae1f7cccd813bde934e23fff2e5877"],"1231e7cbcc1a7bb7e8e177fba43db8d12e03b6db":["e569ce7afe50440c144f72c841b3469a54519875"],"5b6ac42777974b5a102c942a62dff20c24fa5eca":["4c333557085915d436787767528f4137d928ec79"],"cf7669a0fd28faf55d56f58018d3b074ff29108a":["043c298cb215f13ba7b9b81d20760704e8f93d66"],"4c333557085915d436787767528f4137d928ec79":["cf7669a0fd28faf55d56f58018d3b074ff29108a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}