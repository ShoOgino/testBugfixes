{"path":"solr/core/src/test/org/apache/solr/util/OrderedExecutorTest#testRunInParallel().mjava","commits":[{"id":"defa11d88d50ec356d5e7428f1ebc89623e840ac","date":1527653148,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/util/OrderedExecutorTest#testRunInParallel().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testRunInParallel() {\n    OrderedExecutor orderedExecutor = new OrderedExecutor(10, ExecutorUtil.newMDCAwareCachedThreadPool(\"testLockWhenQueueIsFull\"));\n    AtomicInteger atomicInteger = new AtomicInteger(0);\n    orderedExecutor.execute(1, () -> {\n      try {\n        Thread.sleep(500L);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n      if (atomicInteger.get() == 1) atomicInteger.incrementAndGet();\n    });\n\n    orderedExecutor.execute(2, atomicInteger::incrementAndGet);\n    orderedExecutor.shutdownAndAwaitTermination();\n    assertEquals(atomicInteger.get(), 2);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"75ed8f3680408b9cf2575d925b99ff3ac45254e8","date":1549488732,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/util/OrderedExecutorTest#testRunInParallel().mjava","pathOld":"solr/core/src/test/org/apache/solr/util/OrderedExecutorTest#testRunInParallel().mjava","sourceNew":"  @Test\n  public void testRunInParallel() {\n    final int parallelism = atLeast(3);\n    \n    final ExecutorService controlExecutor = ExecutorUtil.newMDCAwareCachedThreadPool(\"testRunInParallel_control\");\n    final OrderedExecutor orderedExecutor = new OrderedExecutor\n      (parallelism, ExecutorUtil.newMDCAwareCachedThreadPool(\"testRunInParallel_test\"));\n\n    try {\n      // distinct lockIds should be able to be used in parallel, up to the size of the executor,\n      // w/o any execute calls blocking... until the test Runables being executed are all\n      // waiting on the same cyclic barrier...\n      final CyclicBarrier barrier = new CyclicBarrier(parallelism + 1);\n      final CountDownLatch preBarrierLatch = new CountDownLatch(parallelism);\n      final CountDownLatch postBarrierLatch = new CountDownLatch(parallelism);\n      \n      for (int i = 0; i < parallelism; i++) {\n        final int lockId = i;\n        controlExecutor.execute(() -> {\n            orderedExecutor.execute(lockId, () -> {\n                try {\n                  log.info(\"Worker #{} starting\", lockId);\n                  preBarrierLatch.countDown();\n                  barrier.await(120, TimeUnit.SECONDS);\n                  postBarrierLatch.countDown();\n                } catch (TimeoutException t) {\n                  log.error(\"Timeout in worker#\" + lockId + \"awaiting barrier\", t);\n                } catch (BrokenBarrierException b) {\n                  log.error(\"Broken Barrier in worker#\" + lockId, b);\n                } catch (InterruptedException e) {\n                  log.error(\"Interrupt in worker#\" + lockId + \"awaiting barrier\", e);\n                  Thread.currentThread().interrupt();\n                }\n              });\n          });\n      }\n\n      log.info(\"main thread: about to wait on pre-barrier latch, barrier={}, post-barrier latch={}\",\n               barrier.getNumberWaiting(), postBarrierLatch.getCount());\n      \n      try {\n        // this latch should have fully counted down by now\n        // (or with a small await for thread scheduling but no other external action)\n        assertTrue(\"Timeout awaiting pre barrier latch\",\n                   preBarrierLatch.await(120, TimeUnit.SECONDS));\n      } catch (InterruptedException e) {\n        log.error(\"Interrupt awwaiting pre barrier latch\", e);\n        Thread.currentThread().interrupt();\n        fail(\"interupt while trying to await the preBarrierLatch\");\n      }\n      \n      log.info(\"main thread: pre-barrier latch done, barrier={}, post-barrier latch={}\",\n               barrier.getNumberWaiting(), postBarrierLatch.getCount());\n      \n      // nothing should have counted down yet on the postBarrierLatch\n      assertEquals(parallelism, postBarrierLatch.getCount());\n\n      try {\n        // if we now await on the the barrier, it should release\n        // (once all other threads get to the barrier as well, but no external action needed)\n        barrier.await(120, TimeUnit.SECONDS);\n        \n        log.info(\"main thread: barrier has released, post-barrier latch={}\",\n                 postBarrierLatch.getCount());\n        \n        // and now the post-barrier latch should release immediately\n        // (or with a small await for thread scheduling but no other external action)\n        assertTrue(\"Timeout awaiting post barrier latch\",\n                   postBarrierLatch.await(120, TimeUnit.SECONDS));\n      } catch (TimeoutException t) {\n        log.error(\"Timeout awaiting barrier\", t);\n        fail(\"barrier timed out\");\n      } catch (BrokenBarrierException b) {\n        log.error(\"Broken Barrier in main test thread\", b);\n        fail(\"broken barrier while trying to release the barrier\");\n      } catch (InterruptedException e) {\n        log.error(\"Interrupt awwaiting barrier / post barrier latch\", e);\n        Thread.currentThread().interrupt();\n        fail(\"interupt while trying to release the barrier and await the postBarrierLatch\");\n      }\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(controlExecutor);\n      orderedExecutor.shutdownAndAwaitTermination();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testRunInParallel() {\n    OrderedExecutor orderedExecutor = new OrderedExecutor(10, ExecutorUtil.newMDCAwareCachedThreadPool(\"testLockWhenQueueIsFull\"));\n    AtomicInteger atomicInteger = new AtomicInteger(0);\n    orderedExecutor.execute(1, () -> {\n      try {\n        Thread.sleep(500L);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n      if (atomicInteger.get() == 1) atomicInteger.incrementAndGet();\n    });\n\n    orderedExecutor.execute(2, atomicInteger::incrementAndGet);\n    orderedExecutor.shutdownAndAwaitTermination();\n    assertEquals(atomicInteger.get(), 2);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/util/OrderedExecutorTest#testRunInParallel().mjava","pathOld":"solr/core/src/test/org/apache/solr/util/OrderedExecutorTest#testRunInParallel().mjava","sourceNew":"  @Test\n  public void testRunInParallel() {\n    final int parallelism = atLeast(3);\n    \n    final ExecutorService controlExecutor = ExecutorUtil.newMDCAwareCachedThreadPool(\"testRunInParallel_control\");\n    final OrderedExecutor orderedExecutor = new OrderedExecutor\n      (parallelism, ExecutorUtil.newMDCAwareCachedThreadPool(\"testRunInParallel_test\"));\n\n    try {\n      // distinct lockIds should be able to be used in parallel, up to the size of the executor,\n      // w/o any execute calls blocking... until the test Runables being executed are all\n      // waiting on the same cyclic barrier...\n      final CyclicBarrier barrier = new CyclicBarrier(parallelism + 1);\n      final CountDownLatch preBarrierLatch = new CountDownLatch(parallelism);\n      final CountDownLatch postBarrierLatch = new CountDownLatch(parallelism);\n      \n      for (int i = 0; i < parallelism; i++) {\n        final int lockId = i;\n        controlExecutor.execute(() -> {\n            orderedExecutor.execute(lockId, () -> {\n                try {\n                  log.info(\"Worker #{} starting\", lockId);\n                  preBarrierLatch.countDown();\n                  barrier.await(120, TimeUnit.SECONDS);\n                  postBarrierLatch.countDown();\n                } catch (TimeoutException t) {\n                  log.error(\"Timeout in worker# {} awaiting barrier\", lockId, t);\n                } catch (BrokenBarrierException b) {\n                  log.error(\"Broken Barrier in worker#{}\", lockId, b);\n                } catch (InterruptedException e) {\n                  log.error(\"Interrupt in worker#{} awaiting barrier\", lockId, e);\n                  Thread.currentThread().interrupt();\n                }\n              });\n          });\n      }\n\n      if (log.isInfoEnabled()) {\n        log.info(\"main thread: about to wait on pre-barrier latch, barrier={}, post-barrier latch={}\",\n            barrier.getNumberWaiting(), postBarrierLatch.getCount());\n      }\n      \n      try {\n        // this latch should have fully counted down by now\n        // (or with a small await for thread scheduling but no other external action)\n        assertTrue(\"Timeout awaiting pre barrier latch\",\n                   preBarrierLatch.await(120, TimeUnit.SECONDS));\n      } catch (InterruptedException e) {\n        log.error(\"Interrupt awwaiting pre barrier latch\", e);\n        Thread.currentThread().interrupt();\n        fail(\"interupt while trying to await the preBarrierLatch\");\n      }\n\n      if (log.isInfoEnabled()) {\n        log.info(\"main thread: pre-barrier latch done, barrier={}, post-barrier latch={}\",\n            barrier.getNumberWaiting(), postBarrierLatch.getCount());\n      }\n      \n      // nothing should have counted down yet on the postBarrierLatch\n      assertEquals(parallelism, postBarrierLatch.getCount());\n\n      try {\n        // if we now await on the the barrier, it should release\n        // (once all other threads get to the barrier as well, but no external action needed)\n        barrier.await(120, TimeUnit.SECONDS);\n\n        if (log.isInfoEnabled()) {\n          log.info(\"main thread: barrier has released, post-barrier latch={}\",\n              postBarrierLatch.getCount());\n        }\n        \n        // and now the post-barrier latch should release immediately\n        // (or with a small await for thread scheduling but no other external action)\n        assertTrue(\"Timeout awaiting post barrier latch\",\n                   postBarrierLatch.await(120, TimeUnit.SECONDS));\n      } catch (TimeoutException t) {\n        log.error(\"Timeout awaiting barrier\", t);\n        fail(\"barrier timed out\");\n      } catch (BrokenBarrierException b) {\n        log.error(\"Broken Barrier in main test thread\", b);\n        fail(\"broken barrier while trying to release the barrier\");\n      } catch (InterruptedException e) {\n        log.error(\"Interrupt awwaiting barrier / post barrier latch\", e);\n        Thread.currentThread().interrupt();\n        fail(\"interupt while trying to release the barrier and await the postBarrierLatch\");\n      }\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(controlExecutor);\n      orderedExecutor.shutdownAndAwaitTermination();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testRunInParallel() {\n    final int parallelism = atLeast(3);\n    \n    final ExecutorService controlExecutor = ExecutorUtil.newMDCAwareCachedThreadPool(\"testRunInParallel_control\");\n    final OrderedExecutor orderedExecutor = new OrderedExecutor\n      (parallelism, ExecutorUtil.newMDCAwareCachedThreadPool(\"testRunInParallel_test\"));\n\n    try {\n      // distinct lockIds should be able to be used in parallel, up to the size of the executor,\n      // w/o any execute calls blocking... until the test Runables being executed are all\n      // waiting on the same cyclic barrier...\n      final CyclicBarrier barrier = new CyclicBarrier(parallelism + 1);\n      final CountDownLatch preBarrierLatch = new CountDownLatch(parallelism);\n      final CountDownLatch postBarrierLatch = new CountDownLatch(parallelism);\n      \n      for (int i = 0; i < parallelism; i++) {\n        final int lockId = i;\n        controlExecutor.execute(() -> {\n            orderedExecutor.execute(lockId, () -> {\n                try {\n                  log.info(\"Worker #{} starting\", lockId);\n                  preBarrierLatch.countDown();\n                  barrier.await(120, TimeUnit.SECONDS);\n                  postBarrierLatch.countDown();\n                } catch (TimeoutException t) {\n                  log.error(\"Timeout in worker#\" + lockId + \"awaiting barrier\", t);\n                } catch (BrokenBarrierException b) {\n                  log.error(\"Broken Barrier in worker#\" + lockId, b);\n                } catch (InterruptedException e) {\n                  log.error(\"Interrupt in worker#\" + lockId + \"awaiting barrier\", e);\n                  Thread.currentThread().interrupt();\n                }\n              });\n          });\n      }\n\n      log.info(\"main thread: about to wait on pre-barrier latch, barrier={}, post-barrier latch={}\",\n               barrier.getNumberWaiting(), postBarrierLatch.getCount());\n      \n      try {\n        // this latch should have fully counted down by now\n        // (or with a small await for thread scheduling but no other external action)\n        assertTrue(\"Timeout awaiting pre barrier latch\",\n                   preBarrierLatch.await(120, TimeUnit.SECONDS));\n      } catch (InterruptedException e) {\n        log.error(\"Interrupt awwaiting pre barrier latch\", e);\n        Thread.currentThread().interrupt();\n        fail(\"interupt while trying to await the preBarrierLatch\");\n      }\n      \n      log.info(\"main thread: pre-barrier latch done, barrier={}, post-barrier latch={}\",\n               barrier.getNumberWaiting(), postBarrierLatch.getCount());\n      \n      // nothing should have counted down yet on the postBarrierLatch\n      assertEquals(parallelism, postBarrierLatch.getCount());\n\n      try {\n        // if we now await on the the barrier, it should release\n        // (once all other threads get to the barrier as well, but no external action needed)\n        barrier.await(120, TimeUnit.SECONDS);\n        \n        log.info(\"main thread: barrier has released, post-barrier latch={}\",\n                 postBarrierLatch.getCount());\n        \n        // and now the post-barrier latch should release immediately\n        // (or with a small await for thread scheduling but no other external action)\n        assertTrue(\"Timeout awaiting post barrier latch\",\n                   postBarrierLatch.await(120, TimeUnit.SECONDS));\n      } catch (TimeoutException t) {\n        log.error(\"Timeout awaiting barrier\", t);\n        fail(\"barrier timed out\");\n      } catch (BrokenBarrierException b) {\n        log.error(\"Broken Barrier in main test thread\", b);\n        fail(\"broken barrier while trying to release the barrier\");\n      } catch (InterruptedException e) {\n        log.error(\"Interrupt awwaiting barrier / post barrier latch\", e);\n        Thread.currentThread().interrupt();\n        fail(\"interupt while trying to release the barrier and await the postBarrierLatch\");\n      }\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(controlExecutor);\n      orderedExecutor.shutdownAndAwaitTermination();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"defa11d88d50ec356d5e7428f1ebc89623e840ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"75ed8f3680408b9cf2575d925b99ff3ac45254e8":["defa11d88d50ec356d5e7428f1ebc89623e840ac"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["75ed8f3680408b9cf2575d925b99ff3ac45254e8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a966532d92cf9ba2856f15a8140151bb6b518e4b"]},"commit2Childs":{"defa11d88d50ec356d5e7428f1ebc89623e840ac":["75ed8f3680408b9cf2575d925b99ff3ac45254e8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["defa11d88d50ec356d5e7428f1ebc89623e840ac"],"75ed8f3680408b9cf2575d925b99ff3ac45254e8":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}