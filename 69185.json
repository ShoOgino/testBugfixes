{"path":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(IndexOutput).mjava","commits":[{"id":"14654be3f7a82c9a3c52169e365baa55bfe64f66","date":1587212697,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(IndexOutput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,IndexOutput).mjava","sourceNew":"  /** Write ourselves to the provided {@link IndexOutput} */\n  public void write(IndexOutput out) throws IOException {\n    CodecUtil.writeIndexHeader(out, \"segments\", VERSION_CURRENT, \n                               StringHelper.randomId(), Long.toString(generation, Character.MAX_RADIX));\n    out.writeVInt(Version.LATEST.major);\n    out.writeVInt(Version.LATEST.minor);\n    out.writeVInt(Version.LATEST.bugfix);\n    //System.out.println(Thread.currentThread().getName() + \": now write \" + out.getName() + \" with version=\" + version);\n\n    out.writeVInt(indexCreatedVersionMajor);\n\n    out.writeLong(version);\n    out.writeVLong(counter); // write counter\n    out.writeInt(size());\n\n    if (size() > 0) {\n\n      Version minSegmentVersion = null;\n\n      // We do a separate loop up front so we can write the minSegmentVersion before\n      // any SegmentInfo; this makes it cleaner to throw IndexFormatTooOldExc at read time:\n      for (SegmentCommitInfo siPerCommit : this) {\n        Version segmentVersion = siPerCommit.info.getVersion();\n        if (minSegmentVersion == null || segmentVersion.onOrAfter(minSegmentVersion) == false) {\n          minSegmentVersion = segmentVersion;\n        }\n      }\n\n      out.writeVInt(minSegmentVersion.major);\n      out.writeVInt(minSegmentVersion.minor);\n      out.writeVInt(minSegmentVersion.bugfix);\n    }\n\n    // write infos\n    for (SegmentCommitInfo siPerCommit : this) {\n      SegmentInfo si = siPerCommit.info;\n      if (indexCreatedVersionMajor >= 7 && si.minVersion == null) {\n        throw new IllegalStateException(\"Segments must record minVersion if they have been created on or after Lucene 7: \" + si);\n      }\n      out.writeString(si.name);\n      byte segmentID[] = si.getId();\n      if (segmentID.length != StringHelper.ID_LENGTH) {\n        throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n      }\n      out.writeBytes(segmentID, segmentID.length);\n      out.writeString(si.getCodec().getName());\n      out.writeLong(siPerCommit.getDelGen());\n      int delCount = siPerCommit.getDelCount();\n      if (delCount < 0 || delCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n      }\n      out.writeInt(delCount);\n      out.writeLong(siPerCommit.getFieldInfosGen());\n      out.writeLong(siPerCommit.getDocValuesGen());\n      int softDelCount = siPerCommit.getSoftDelCount();\n      if (softDelCount < 0 || softDelCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" softDelCount=\" + softDelCount);\n      }\n      out.writeInt(softDelCount);\n      // we ensure that there is a valid ID for this SCI just in case\n      // this is manually upgraded outside of IW\n      byte[] sciId = siPerCommit.getId();\n      if (sciId != null) {\n        out.writeByte((byte)1);\n        assert sciId.length == StringHelper.ID_LENGTH : \"invalid SegmentCommitInfo#id: \" + Arrays.toString(sciId);\n        out.writeBytes(sciId, 0, sciId.length);\n      } else {\n        out.writeByte((byte)0);\n      }\n\n      out.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n      final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n      out.writeInt(dvUpdatesFiles.size());\n      for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n        out.writeInt(e.getKey());\n        out.writeSetOfStrings(e.getValue());\n      }\n    }\n    out.writeMapOfStrings(userData);\n    CodecUtil.writeFooter(out);\n  }\n\n","sourceOld":"  /** Write ourselves to the provided {@link IndexOutput} */\n  public void write(Directory directory, IndexOutput out) throws IOException {\n    CodecUtil.writeIndexHeader(out, \"segments\", VERSION_CURRENT, \n                               StringHelper.randomId(), Long.toString(generation, Character.MAX_RADIX));\n    out.writeVInt(Version.LATEST.major);\n    out.writeVInt(Version.LATEST.minor);\n    out.writeVInt(Version.LATEST.bugfix);\n    //System.out.println(Thread.currentThread().getName() + \": now write \" + out.getName() + \" with version=\" + version);\n\n    out.writeVInt(indexCreatedVersionMajor);\n\n    out.writeLong(version);\n    out.writeVLong(counter); // write counter\n    out.writeInt(size());\n\n    if (size() > 0) {\n\n      Version minSegmentVersion = null;\n\n      // We do a separate loop up front so we can write the minSegmentVersion before\n      // any SegmentInfo; this makes it cleaner to throw IndexFormatTooOldExc at read time:\n      for (SegmentCommitInfo siPerCommit : this) {\n        Version segmentVersion = siPerCommit.info.getVersion();\n        if (minSegmentVersion == null || segmentVersion.onOrAfter(minSegmentVersion) == false) {\n          minSegmentVersion = segmentVersion;\n        }\n      }\n\n      out.writeVInt(minSegmentVersion.major);\n      out.writeVInt(minSegmentVersion.minor);\n      out.writeVInt(minSegmentVersion.bugfix);\n    }\n\n    // write infos\n    for (SegmentCommitInfo siPerCommit : this) {\n      SegmentInfo si = siPerCommit.info;\n      if (indexCreatedVersionMajor >= 7 && si.minVersion == null) {\n        throw new IllegalStateException(\"Segments must record minVersion if they have been created on or after Lucene 7: \" + si);\n      }\n      out.writeString(si.name);\n      byte segmentID[] = si.getId();\n      if (segmentID.length != StringHelper.ID_LENGTH) {\n        throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n      }\n      out.writeBytes(segmentID, segmentID.length);\n      out.writeString(si.getCodec().getName());\n      out.writeLong(siPerCommit.getDelGen());\n      int delCount = siPerCommit.getDelCount();\n      if (delCount < 0 || delCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n      }\n      out.writeInt(delCount);\n      out.writeLong(siPerCommit.getFieldInfosGen());\n      out.writeLong(siPerCommit.getDocValuesGen());\n      int softDelCount = siPerCommit.getSoftDelCount();\n      if (softDelCount < 0 || softDelCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" softDelCount=\" + softDelCount);\n      }\n      out.writeInt(softDelCount);\n      out.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n      final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n      out.writeInt(dvUpdatesFiles.size());\n      for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n        out.writeInt(e.getKey());\n        out.writeSetOfStrings(e.getValue());\n      }\n    }\n    out.writeMapOfStrings(userData);\n    CodecUtil.writeFooter(out);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"14654be3f7a82c9a3c52169e365baa55bfe64f66":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["14654be3f7a82c9a3c52169e365baa55bfe64f66"]},"commit2Childs":{"14654be3f7a82c9a3c52169e365baa55bfe64f66":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["14654be3f7a82c9a3c52169e365baa55bfe64f66"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}