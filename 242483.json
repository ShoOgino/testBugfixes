{"path":"lucene/suggest/src/java/org/apache/lucene/search/suggest/SortedInputIterator#sort().mjava","commits":[{"id":"41aee74b5f91a096e3fd950f4a336bc763f0e7a7","date":1381772070,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/SortedInputIterator#sort().mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/SortedTermFreqPayloadIteratorWrapper#sort().mjava","sourceNew":"  private Sort.ByteSequencesReader sort() throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    tempInput = File.createTempFile(prefix, \".input\", directory);\n    tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n    \n    final Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    boolean success = false;\n    try {\n      BytesRef spare;\n      byte[] buffer = new byte[0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      while ((spare = source.next()) != null) {\n        encode(writer, output, buffer, spare, source.payload(), source.weight());\n      }\n      writer.close();\n      new Sort(tieBreakByCostComparator).sort(tempInput, tempSorted);\n      ByteSequencesReader reader = new Sort.ByteSequencesReader(tempSorted);\n      success = true;\n      return reader;\n      \n    } finally {\n      if (success) {\n        IOUtils.close(writer);\n      } else {\n        try {\n          IOUtils.closeWhileHandlingException(writer);\n        } finally {\n          close();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private Sort.ByteSequencesReader sort() throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    tempInput = File.createTempFile(prefix, \".input\", directory);\n    tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n    \n    final Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    boolean success = false;\n    try {\n      BytesRef spare;\n      byte[] buffer = new byte[0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      while ((spare = source.next()) != null) {\n        encode(writer, output, buffer, spare, source.payload(), source.weight());\n      }\n      writer.close();\n      new Sort(tieBreakByCostComparator).sort(tempInput, tempSorted);\n      ByteSequencesReader reader = new Sort.ByteSequencesReader(tempSorted);\n      success = true;\n      return reader;\n      \n    } finally {\n      if (success) {\n        IOUtils.close(writer);\n      } else {\n        try {\n          IOUtils.closeWhileHandlingException(writer);\n        } finally {\n          close();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"36f5a8c57e16c0f801006a52f87c75378427852e","date":1393256707,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/SortedInputIterator#sort().mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/SortedInputIterator#sort().mjava","sourceNew":"  private ByteSequencesReader sort() throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = OfflineSorter.defaultTempDir();\n    tempInput = File.createTempFile(prefix, \".input\", directory);\n    tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n    \n    final OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    boolean success = false;\n    try {\n      BytesRef spare;\n      byte[] buffer = new byte[0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      while ((spare = source.next()) != null) {\n        encode(writer, output, buffer, spare, source.payload(), source.weight());\n      }\n      writer.close();\n      new OfflineSorter(tieBreakByCostComparator).sort(tempInput, tempSorted);\n      ByteSequencesReader reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n      success = true;\n      return reader;\n      \n    } finally {\n      if (success) {\n        IOUtils.close(writer);\n      } else {\n        try {\n          IOUtils.closeWhileHandlingException(writer);\n        } finally {\n          close();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private Sort.ByteSequencesReader sort() throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    tempInput = File.createTempFile(prefix, \".input\", directory);\n    tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n    \n    final Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    boolean success = false;\n    try {\n      BytesRef spare;\n      byte[] buffer = new byte[0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      while ((spare = source.next()) != null) {\n        encode(writer, output, buffer, spare, source.payload(), source.weight());\n      }\n      writer.close();\n      new Sort(tieBreakByCostComparator).sort(tempInput, tempSorted);\n      ByteSequencesReader reader = new Sort.ByteSequencesReader(tempSorted);\n      success = true;\n      return reader;\n      \n    } finally {\n      if (success) {\n        IOUtils.close(writer);\n      } else {\n        try {\n          IOUtils.closeWhileHandlingException(writer);\n        } finally {\n          close();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba791bce8103c79e38f957e9c5a53a75871bd918","date":1393539206,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/SortedInputIterator#sort().mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/SortedInputIterator#sort().mjava","sourceNew":"  private ByteSequencesReader sort() throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = OfflineSorter.defaultTempDir();\n    tempInput = File.createTempFile(prefix, \".input\", directory);\n    tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n    \n    final OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    boolean success = false;\n    try {\n      BytesRef spare;\n      byte[] buffer = new byte[0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      while ((spare = source.next()) != null) {\n        encode(writer, output, buffer, spare, source.payload(), source.weight());\n      }\n      writer.close();\n      new OfflineSorter(tieBreakByCostComparator).sort(tempInput, tempSorted);\n      ByteSequencesReader reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n      success = true;\n      return reader;\n      \n    } finally {\n      if (success) {\n        IOUtils.close(writer);\n      } else {\n        try {\n          IOUtils.closeWhileHandlingException(writer);\n        } finally {\n          close();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private Sort.ByteSequencesReader sort() throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    tempInput = File.createTempFile(prefix, \".input\", directory);\n    tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n    \n    final Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    boolean success = false;\n    try {\n      BytesRef spare;\n      byte[] buffer = new byte[0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      while ((spare = source.next()) != null) {\n        encode(writer, output, buffer, spare, source.payload(), source.weight());\n      }\n      writer.close();\n      new Sort(tieBreakByCostComparator).sort(tempInput, tempSorted);\n      ByteSequencesReader reader = new Sort.ByteSequencesReader(tempSorted);\n      success = true;\n      return reader;\n      \n    } finally {\n      if (success) {\n        IOUtils.close(writer);\n      } else {\n        try {\n          IOUtils.closeWhileHandlingException(writer);\n        } finally {\n          close();\n        }\n      }\n    }\n  }\n\n","bugFix":["c784b25e28b81ddedff2b97738c8286773f00f15","dc3c850c5222a1ce7d619563f67bf047a11b32b6"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"58d0345a28bb6b4be59c38e6a77e2cc0e615ee4b","date":1395588343,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/SortedInputIterator#sort().mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/SortedInputIterator#sort().mjava","sourceNew":"  private ByteSequencesReader sort() throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = OfflineSorter.defaultTempDir();\n    tempInput = File.createTempFile(prefix, \".input\", directory);\n    tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n    \n    final OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    boolean success = false;\n    try {\n      BytesRef spare;\n      byte[] buffer = new byte[0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      while ((spare = source.next()) != null) {\n        encode(writer, output, buffer, spare, source.payload(), source.contexts(), source.weight());\n      }\n      writer.close();\n      new OfflineSorter(tieBreakByCostComparator).sort(tempInput, tempSorted);\n      ByteSequencesReader reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n      success = true;\n      return reader;\n      \n    } finally {\n      if (success) {\n        IOUtils.close(writer);\n      } else {\n        try {\n          IOUtils.closeWhileHandlingException(writer);\n        } finally {\n          close();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private ByteSequencesReader sort() throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = OfflineSorter.defaultTempDir();\n    tempInput = File.createTempFile(prefix, \".input\", directory);\n    tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n    \n    final OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    boolean success = false;\n    try {\n      BytesRef spare;\n      byte[] buffer = new byte[0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      while ((spare = source.next()) != null) {\n        encode(writer, output, buffer, spare, source.payload(), source.weight());\n      }\n      writer.close();\n      new OfflineSorter(tieBreakByCostComparator).sort(tempInput, tempSorted);\n      ByteSequencesReader reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n      success = true;\n      return reader;\n      \n    } finally {\n      if (success) {\n        IOUtils.close(writer);\n      } else {\n        try {\n          IOUtils.closeWhileHandlingException(writer);\n        } finally {\n          close();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4abec28b874149a7223e32cc7a01704c27790de","date":1410644789,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/SortedInputIterator#sort().mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/SortedInputIterator#sort().mjava","sourceNew":"  private ByteSequencesReader sort() throws IOException {\n    String prefix = getClass().getSimpleName();\n    Path directory = OfflineSorter.defaultTempDir();\n    tempInput = Files.createTempFile(directory, prefix, \".input\");\n    tempSorted = Files.createTempFile(directory, prefix, \".sorted\");\n    \n    final OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    boolean success = false;\n    try {\n      BytesRef spare;\n      byte[] buffer = new byte[0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      while ((spare = source.next()) != null) {\n        encode(writer, output, buffer, spare, source.payload(), source.contexts(), source.weight());\n      }\n      writer.close();\n      new OfflineSorter(tieBreakByCostComparator).sort(tempInput, tempSorted);\n      ByteSequencesReader reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n      success = true;\n      return reader;\n      \n    } finally {\n      if (success) {\n        IOUtils.close(writer);\n      } else {\n        try {\n          IOUtils.closeWhileHandlingException(writer);\n        } finally {\n          close();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private ByteSequencesReader sort() throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = OfflineSorter.defaultTempDir();\n    tempInput = File.createTempFile(prefix, \".input\", directory);\n    tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n    \n    final OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    boolean success = false;\n    try {\n      BytesRef spare;\n      byte[] buffer = new byte[0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      while ((spare = source.next()) != null) {\n        encode(writer, output, buffer, spare, source.payload(), source.contexts(), source.weight());\n      }\n      writer.close();\n      new OfflineSorter(tieBreakByCostComparator).sort(tempInput, tempSorted);\n      ByteSequencesReader reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n      success = true;\n      return reader;\n      \n    } finally {\n      if (success) {\n        IOUtils.close(writer);\n      } else {\n        try {\n          IOUtils.closeWhileHandlingException(writer);\n        } finally {\n          close();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8ccfbb043f2ebf23df8782dd32a68ff1b399c3d2","date":1443129829,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/SortedInputIterator#sort().mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/SortedInputIterator#sort().mjava","sourceNew":"  private ByteSequencesReader sort() throws IOException {\n    String prefix = getClass().getSimpleName();\n    Path directory = OfflineSorter.getDefaultTempDir();\n    tempInput = Files.createTempFile(directory, prefix, \".input\");\n    tempSorted = Files.createTempFile(directory, prefix, \".sorted\");\n    \n    final OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    boolean success = false;\n    try {\n      BytesRef spare;\n      byte[] buffer = new byte[0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      while ((spare = source.next()) != null) {\n        encode(writer, output, buffer, spare, source.payload(), source.contexts(), source.weight());\n      }\n      writer.close();\n      new OfflineSorter(tieBreakByCostComparator).sort(tempInput, tempSorted);\n      ByteSequencesReader reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n      success = true;\n      return reader;\n      \n    } finally {\n      if (success) {\n        IOUtils.close(writer);\n      } else {\n        try {\n          IOUtils.closeWhileHandlingException(writer);\n        } finally {\n          close();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private ByteSequencesReader sort() throws IOException {\n    String prefix = getClass().getSimpleName();\n    Path directory = OfflineSorter.defaultTempDir();\n    tempInput = Files.createTempFile(directory, prefix, \".input\");\n    tempSorted = Files.createTempFile(directory, prefix, \".sorted\");\n    \n    final OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    boolean success = false;\n    try {\n      BytesRef spare;\n      byte[] buffer = new byte[0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      while ((spare = source.next()) != null) {\n        encode(writer, output, buffer, spare, source.payload(), source.contexts(), source.weight());\n      }\n      writer.close();\n      new OfflineSorter(tieBreakByCostComparator).sort(tempInput, tempSorted);\n      ByteSequencesReader reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n      success = true;\n      return reader;\n      \n    } finally {\n      if (success) {\n        IOUtils.close(writer);\n      } else {\n        try {\n          IOUtils.closeWhileHandlingException(writer);\n        } finally {\n          close();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"867e3d9153fb761456b54a9dcce566e1545c5ef6","date":1444903098,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/SortedInputIterator#sort().mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/SortedInputIterator#sort().mjava","sourceNew":"  private ByteSequencesReader sort() throws IOException {\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, tieBreakByCostComparator);\n    tempInput = tempDir.createTempOutput(tempFileNamePrefix, \"input\", IOContext.DEFAULT);\n    \n    final OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    boolean success = false;\n    try {\n      BytesRef spare;\n      byte[] buffer = new byte[0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      while ((spare = source.next()) != null) {\n        encode(writer, output, buffer, spare, source.payload(), source.contexts(), source.weight());\n      }\n      writer.close();\n      tempSortedFileName = sorter.sort(tempInput.getName());\n      ByteSequencesReader reader = new OfflineSorter.ByteSequencesReader(tempDir.openInput(tempSortedFileName, IOContext.READONCE));\n      success = true;\n      return reader;\n      \n    } finally {\n      if (success) {\n        IOUtils.close(writer);\n      } else {\n        try {\n          IOUtils.closeWhileHandlingException(writer);\n        } finally {\n          close();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private ByteSequencesReader sort() throws IOException {\n    String prefix = getClass().getSimpleName();\n    Path directory = OfflineSorter.getDefaultTempDir();\n    tempInput = Files.createTempFile(directory, prefix, \".input\");\n    tempSorted = Files.createTempFile(directory, prefix, \".sorted\");\n    \n    final OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    boolean success = false;\n    try {\n      BytesRef spare;\n      byte[] buffer = new byte[0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      while ((spare = source.next()) != null) {\n        encode(writer, output, buffer, spare, source.payload(), source.contexts(), source.weight());\n      }\n      writer.close();\n      new OfflineSorter(tieBreakByCostComparator).sort(tempInput, tempSorted);\n      ByteSequencesReader reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n      success = true;\n      return reader;\n      \n    } finally {\n      if (success) {\n        IOUtils.close(writer);\n      } else {\n        try {\n          IOUtils.closeWhileHandlingException(writer);\n        } finally {\n          close();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"950b7a6881d14da782b60444c11295e3ec50d41a","date":1458379095,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/SortedInputIterator#sort().mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/SortedInputIterator#sort().mjava","sourceNew":"  private ByteSequencesReader sort() throws IOException {\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, tieBreakByCostComparator);\n    tempInput = tempDir.createTempOutput(tempFileNamePrefix, \"input\", IOContext.DEFAULT);\n    \n    try (OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput)) {\n      BytesRef spare;\n      byte[] buffer = new byte[0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      while ((spare = source.next()) != null) {\n        encode(writer, output, buffer, spare, source.payload(), source.contexts(), source.weight());\n      }\n      CodecUtil.writeFooter(tempInput);\n    }\n\n    tempSortedFileName = sorter.sort(tempInput.getName());\n    return new OfflineSorter.ByteSequencesReader(tempDir.openChecksumInput(tempSortedFileName, IOContext.READONCE), tempSortedFileName);\n  }\n\n","sourceOld":"  private ByteSequencesReader sort() throws IOException {\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, tieBreakByCostComparator);\n    tempInput = tempDir.createTempOutput(tempFileNamePrefix, \"input\", IOContext.DEFAULT);\n    \n    final OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    boolean success = false;\n    try {\n      BytesRef spare;\n      byte[] buffer = new byte[0];\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      while ((spare = source.next()) != null) {\n        encode(writer, output, buffer, spare, source.payload(), source.contexts(), source.weight());\n      }\n      writer.close();\n      tempSortedFileName = sorter.sort(tempInput.getName());\n      ByteSequencesReader reader = new OfflineSorter.ByteSequencesReader(tempDir.openInput(tempSortedFileName, IOContext.READONCE));\n      success = true;\n      return reader;\n      \n    } finally {\n      if (success) {\n        IOUtils.close(writer);\n      } else {\n        try {\n          IOUtils.closeWhileHandlingException(writer);\n        } finally {\n          close();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8ccfbb043f2ebf23df8782dd32a68ff1b399c3d2":["f4abec28b874149a7223e32cc7a01704c27790de"],"58d0345a28bb6b4be59c38e6a77e2cc0e615ee4b":["ba791bce8103c79e38f957e9c5a53a75871bd918"],"41aee74b5f91a096e3fd950f4a336bc763f0e7a7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ba791bce8103c79e38f957e9c5a53a75871bd918":["41aee74b5f91a096e3fd950f4a336bc763f0e7a7","36f5a8c57e16c0f801006a52f87c75378427852e"],"36f5a8c57e16c0f801006a52f87c75378427852e":["41aee74b5f91a096e3fd950f4a336bc763f0e7a7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"950b7a6881d14da782b60444c11295e3ec50d41a":["867e3d9153fb761456b54a9dcce566e1545c5ef6"],"f4abec28b874149a7223e32cc7a01704c27790de":["58d0345a28bb6b4be59c38e6a77e2cc0e615ee4b"],"867e3d9153fb761456b54a9dcce566e1545c5ef6":["8ccfbb043f2ebf23df8782dd32a68ff1b399c3d2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["950b7a6881d14da782b60444c11295e3ec50d41a"]},"commit2Childs":{"8ccfbb043f2ebf23df8782dd32a68ff1b399c3d2":["867e3d9153fb761456b54a9dcce566e1545c5ef6"],"58d0345a28bb6b4be59c38e6a77e2cc0e615ee4b":["f4abec28b874149a7223e32cc7a01704c27790de"],"ba791bce8103c79e38f957e9c5a53a75871bd918":["58d0345a28bb6b4be59c38e6a77e2cc0e615ee4b"],"41aee74b5f91a096e3fd950f4a336bc763f0e7a7":["ba791bce8103c79e38f957e9c5a53a75871bd918","36f5a8c57e16c0f801006a52f87c75378427852e"],"36f5a8c57e16c0f801006a52f87c75378427852e":["ba791bce8103c79e38f957e9c5a53a75871bd918"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["41aee74b5f91a096e3fd950f4a336bc763f0e7a7"],"950b7a6881d14da782b60444c11295e3ec50d41a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f4abec28b874149a7223e32cc7a01704c27790de":["8ccfbb043f2ebf23df8782dd32a68ff1b399c3d2"],"867e3d9153fb761456b54a9dcce566e1545c5ef6":["950b7a6881d14da782b60444c11295e3ec50d41a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}