{"path":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean,boolean).mjava","commits":[{"id":"fb17639909a369c1e64866842e5c213440acc17e","date":1423238093,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores, boolean doMaxScore) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    numHits = Math.min(numHits, limit);\n\n    final boolean fillFields = true;\n    if (executor == null) {\n      final TopFieldCollector collector = TopFieldCollector.create(sort, numHits, after, fillFields, doDocScores, doMaxScore);\n      search(query, collector);\n      return collector.topDocs();\n    } else {\n      final TopFieldCollector[] collectors = new TopFieldCollector[leafSlices.length];\n      boolean needsScores = false;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        collectors[i] = TopFieldCollector.create(sort, numHits, after, fillFields, doDocScores, doMaxScore);\n        needsScores |= collectors[i].needsScores();\n      }\n\n      final Weight weight = createNormalizedWeight(query, needsScores);\n      final List<Future<TopFieldDocs>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final TopFieldCollector collector = collectors[i];\n        topDocsFutures.add(executor.submit(new Callable<TopFieldDocs>() {\n          @Override\n          public TopFieldDocs call() throws Exception {\n            search(Arrays.asList(leaves), weight, collector);\n            return collector.topDocs();\n          }\n        }));\n      }\n\n      final TopFieldDocs[] topDocs = new TopFieldDocs[leafSlices.length];\n      for (int i = 0; i < topDocs.length; ++i) {\n        try {\n          topDocs[i] = topDocsFutures.get(i).get();\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      return TopDocs.merge(sort, numHits, topDocs);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"954e59be3da8dc1b046646ad7af4b466852009d3","date":1423482367,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean,boolean).mjava","sourceNew":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores, boolean doMaxScore) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    numHits = Math.min(numHits, limit);\n\n    final boolean fillFields = true;\n    if (executor == null) {\n      final TopFieldCollector collector = TopFieldCollector.create(sort, numHits, after, fillFields, doDocScores, doMaxScore);\n      search(query, collector);\n      return collector.topDocs();\n    } else {\n      final TopFieldCollector[] collectors = new TopFieldCollector[leafSlices.length];\n      int postingsFlags = PostingsEnum.FLAG_NONE;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        collectors[i] = TopFieldCollector.create(sort, numHits, after, fillFields, doDocScores, doMaxScore);\n        if (collectors[i].needsScores())\n          postingsFlags |= PostingsEnum.FLAG_FREQS;\n      }\n\n      final Weight weight = createNormalizedWeight(query, postingsFlags);\n      final List<Future<TopFieldDocs>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final TopFieldCollector collector = collectors[i];\n        topDocsFutures.add(executor.submit(new Callable<TopFieldDocs>() {\n          @Override\n          public TopFieldDocs call() throws Exception {\n            search(Arrays.asList(leaves), weight, collector);\n            return collector.topDocs();\n          }\n        }));\n      }\n\n      final TopFieldDocs[] topDocs = new TopFieldDocs[leafSlices.length];\n      for (int i = 0; i < topDocs.length; ++i) {\n        try {\n          topDocs[i] = topDocsFutures.get(i).get();\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      return TopDocs.merge(sort, numHits, topDocs);\n    }\n  }\n\n","sourceOld":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores, boolean doMaxScore) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    numHits = Math.min(numHits, limit);\n\n    final boolean fillFields = true;\n    if (executor == null) {\n      final TopFieldCollector collector = TopFieldCollector.create(sort, numHits, after, fillFields, doDocScores, doMaxScore);\n      search(query, collector);\n      return collector.topDocs();\n    } else {\n      final TopFieldCollector[] collectors = new TopFieldCollector[leafSlices.length];\n      boolean needsScores = false;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        collectors[i] = TopFieldCollector.create(sort, numHits, after, fillFields, doDocScores, doMaxScore);\n        needsScores |= collectors[i].needsScores();\n      }\n\n      final Weight weight = createNormalizedWeight(query, needsScores);\n      final List<Future<TopFieldDocs>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final TopFieldCollector collector = collectors[i];\n        topDocsFutures.add(executor.submit(new Callable<TopFieldDocs>() {\n          @Override\n          public TopFieldDocs call() throws Exception {\n            search(Arrays.asList(leaves), weight, collector);\n            return collector.topDocs();\n          }\n        }));\n      }\n\n      final TopFieldDocs[] topDocs = new TopFieldDocs[leafSlices.length];\n      for (int i = 0; i < topDocs.length; ++i) {\n        try {\n          topDocs[i] = topDocsFutures.get(i).get();\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      return TopDocs.merge(sort, numHits, topDocs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6a47d642ab24da1a811adce4bda9cc52c520ca13","date":1423483323,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean,boolean).mjava","sourceNew":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores, boolean doMaxScore) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    numHits = Math.min(numHits, limit);\n\n    final boolean fillFields = true;\n    if (executor == null) {\n      final TopFieldCollector collector = TopFieldCollector.create(sort, numHits, after, fillFields, doDocScores, doMaxScore);\n      search(query, collector);\n      return collector.topDocs();\n    } else {\n      final TopFieldCollector[] collectors = new TopFieldCollector[leafSlices.length];\n      boolean needsScores = false;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        collectors[i] = TopFieldCollector.create(sort, numHits, after, fillFields, doDocScores, doMaxScore);\n        needsScores |= collectors[i].needsScores();\n      }\n\n      final Weight weight = createNormalizedWeight(query, needsScores);\n      final List<Future<TopFieldDocs>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final TopFieldCollector collector = collectors[i];\n        topDocsFutures.add(executor.submit(new Callable<TopFieldDocs>() {\n          @Override\n          public TopFieldDocs call() throws Exception {\n            search(Arrays.asList(leaves), weight, collector);\n            return collector.topDocs();\n          }\n        }));\n      }\n\n      final TopFieldDocs[] topDocs = new TopFieldDocs[leafSlices.length];\n      for (int i = 0; i < topDocs.length; ++i) {\n        try {\n          topDocs[i] = topDocsFutures.get(i).get();\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      return TopDocs.merge(sort, numHits, topDocs);\n    }\n  }\n\n","sourceOld":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores, boolean doMaxScore) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    numHits = Math.min(numHits, limit);\n\n    final boolean fillFields = true;\n    if (executor == null) {\n      final TopFieldCollector collector = TopFieldCollector.create(sort, numHits, after, fillFields, doDocScores, doMaxScore);\n      search(query, collector);\n      return collector.topDocs();\n    } else {\n      final TopFieldCollector[] collectors = new TopFieldCollector[leafSlices.length];\n      int postingsFlags = PostingsEnum.FLAG_NONE;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        collectors[i] = TopFieldCollector.create(sort, numHits, after, fillFields, doDocScores, doMaxScore);\n        if (collectors[i].needsScores())\n          postingsFlags |= PostingsEnum.FLAG_FREQS;\n      }\n\n      final Weight weight = createNormalizedWeight(query, postingsFlags);\n      final List<Future<TopFieldDocs>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final TopFieldCollector collector = collectors[i];\n        topDocsFutures.add(executor.submit(new Callable<TopFieldDocs>() {\n          @Override\n          public TopFieldDocs call() throws Exception {\n            search(Arrays.asList(leaves), weight, collector);\n            return collector.topDocs();\n          }\n        }));\n      }\n\n      final TopFieldDocs[] topDocs = new TopFieldDocs[leafSlices.length];\n      for (int i = 0; i < topDocs.length; ++i) {\n        try {\n          topDocs[i] = topDocsFutures.get(i).get();\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      return TopDocs.merge(sort, numHits, topDocs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"308eabc0d18aa58a75b0a130d08524e98661807b","date":1425056617,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean,boolean).mjava","sourceNew":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores, boolean doMaxScore) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        final boolean fillFields = true;\n        return TopFieldCollector.create(sort, cappedNumHits, after, fillFields, doDocScores, doMaxScore);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(sort, cappedNumHits, topDocs);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","sourceOld":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores, boolean doMaxScore) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    numHits = Math.min(numHits, limit);\n\n    final boolean fillFields = true;\n    if (executor == null) {\n      final TopFieldCollector collector = TopFieldCollector.create(sort, numHits, after, fillFields, doDocScores, doMaxScore);\n      search(query, collector);\n      return collector.topDocs();\n    } else {\n      final TopFieldCollector[] collectors = new TopFieldCollector[leafSlices.length];\n      boolean needsScores = false;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        collectors[i] = TopFieldCollector.create(sort, numHits, after, fillFields, doDocScores, doMaxScore);\n        needsScores |= collectors[i].needsScores();\n      }\n\n      final Weight weight = createNormalizedWeight(query, needsScores);\n      final List<Future<TopFieldDocs>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final TopFieldCollector collector = collectors[i];\n        topDocsFutures.add(executor.submit(new Callable<TopFieldDocs>() {\n          @Override\n          public TopFieldDocs call() throws Exception {\n            search(Arrays.asList(leaves), weight, collector);\n            return collector.topDocs();\n          }\n        }));\n      }\n\n      final TopFieldDocs[] topDocs = new TopFieldDocs[leafSlices.length];\n      for (int i = 0; i < topDocs.length; ++i) {\n        try {\n          topDocs[i] = topDocsFutures.get(i).get();\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      return TopDocs.merge(sort, numHits, topDocs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean,boolean).mjava","sourceNew":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores, boolean doMaxScore) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        final boolean fillFields = true;\n        return TopFieldCollector.create(sort, cappedNumHits, after, fillFields, doDocScores, doMaxScore);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(sort, cappedNumHits, topDocs);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","sourceOld":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores, boolean doMaxScore) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    numHits = Math.min(numHits, limit);\n\n    final boolean fillFields = true;\n    if (executor == null) {\n      final TopFieldCollector collector = TopFieldCollector.create(sort, numHits, after, fillFields, doDocScores, doMaxScore);\n      search(query, collector);\n      return collector.topDocs();\n    } else {\n      final TopFieldCollector[] collectors = new TopFieldCollector[leafSlices.length];\n      boolean needsScores = false;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        collectors[i] = TopFieldCollector.create(sort, numHits, after, fillFields, doDocScores, doMaxScore);\n        needsScores |= collectors[i].needsScores();\n      }\n\n      final Weight weight = createNormalizedWeight(query, needsScores);\n      final List<Future<TopFieldDocs>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final TopFieldCollector collector = collectors[i];\n        topDocsFutures.add(executor.submit(new Callable<TopFieldDocs>() {\n          @Override\n          public TopFieldDocs call() throws Exception {\n            search(Arrays.asList(leaves), weight, collector);\n            return collector.topDocs();\n          }\n        }));\n      }\n\n      final TopFieldDocs[] topDocs = new TopFieldDocs[leafSlices.length];\n      for (int i = 0; i < topDocs.length; ++i) {\n        try {\n          topDocs[i] = topDocsFutures.get(i).get();\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      return TopDocs.merge(sort, numHits, topDocs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9a5b816df64f2b489d1e711be80f9416f9862c1b","date":1487973679,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean,boolean).mjava","sourceNew":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores, boolean doMaxScore) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        final boolean fillFields = true;\n        return TopFieldCollector.create(sort, cappedNumHits, after, fillFields, doDocScores, doMaxScore);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(sort, 0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","sourceOld":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores, boolean doMaxScore) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        final boolean fillFields = true;\n        return TopFieldCollector.create(sort, cappedNumHits, after, fillFields, doDocScores, doMaxScore);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(sort, cappedNumHits, topDocs);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a38488a55cc52553c9792da5044dd31b15128cd8","date":1510755769,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean,boolean).mjava","sourceNew":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores, boolean doMaxScore) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        final boolean fillFields = true;\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, fillFields, doDocScores, doMaxScore);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","sourceOld":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores, boolean doMaxScore) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        final boolean fillFields = true;\n        return TopFieldCollector.create(sort, cappedNumHits, after, fillFields, doDocScores, doMaxScore);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(sort, 0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"404d1ab7f6f396235047017c88d545fec15dafb7","date":1511975378,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean,boolean).mjava","sourceNew":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores, boolean doMaxScore) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        final boolean fillFields = true;\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, fillFields, doDocScores, doMaxScore, true);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","sourceOld":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores, boolean doMaxScore) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        final boolean fillFields = true;\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, fillFields, doDocScores, doMaxScore);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1aad05eeff7818b0833c02ac6b743aa72054963b","date":1512093122,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean,boolean).mjava","sourceNew":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores, boolean doMaxScore) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        final boolean fillFields = true;\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, fillFields, doDocScores, doMaxScore, true);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","sourceOld":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores, boolean doMaxScore) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        final boolean fillFields = true;\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, fillFields, doDocScores, doMaxScore);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81fff83bdb893c1471efd78f6a9a3ce4f98120b9","date":1531895937,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean,boolean).mjava","sourceNew":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        final boolean fillFields = true;\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, fillFields, doDocScores, true);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","sourceOld":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores, boolean doMaxScore) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        final boolean fillFields = true;\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, fillFields, doDocScores, doMaxScore, true);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":4,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(FieldDoc,Query,int,Sort,boolean,boolean).mjava","sourceNew":null,"sourceOld":"  private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,\n      boolean doDocScores, boolean doMaxScore) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    final int cappedNumHits = Math.min(numHits, limit);\n    final Sort rewrittenSort = sort.rewrite(this);\n\n    final CollectorManager<TopFieldCollector, TopFieldDocs> manager = new CollectorManager<TopFieldCollector, TopFieldDocs>() {\n\n      @Override\n      public TopFieldCollector newCollector() throws IOException {\n        final boolean fillFields = true;\n        // TODO: don't pay the price for accurate hit counts by default\n        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, fillFields, doDocScores, doMaxScore, true);\n      }\n\n      @Override\n      public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {\n        final TopFieldDocs[] topDocs = new TopFieldDocs[collectors.size()];\n        int i = 0;\n        for (TopFieldCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(rewrittenSort, 0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6a47d642ab24da1a811adce4bda9cc52c520ca13":["954e59be3da8dc1b046646ad7af4b466852009d3"],"fb17639909a369c1e64866842e5c213440acc17e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"404d1ab7f6f396235047017c88d545fec15dafb7":["a38488a55cc52553c9792da5044dd31b15128cd8"],"308eabc0d18aa58a75b0a130d08524e98661807b":["6a47d642ab24da1a811adce4bda9cc52c520ca13"],"a38488a55cc52553c9792da5044dd31b15128cd8":["9a5b816df64f2b489d1e711be80f9416f9862c1b"],"954e59be3da8dc1b046646ad7af4b466852009d3":["fb17639909a369c1e64866842e5c213440acc17e"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["a38488a55cc52553c9792da5044dd31b15128cd8","404d1ab7f6f396235047017c88d545fec15dafb7"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["6a47d642ab24da1a811adce4bda9cc52c520ca13","308eabc0d18aa58a75b0a130d08524e98661807b"],"9a5b816df64f2b489d1e711be80f9416f9862c1b":["308eabc0d18aa58a75b0a130d08524e98661807b"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["1aad05eeff7818b0833c02ac6b743aa72054963b","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["81fff83bdb893c1471efd78f6a9a3ce4f98120b9"]},"commit2Childs":{"6a47d642ab24da1a811adce4bda9cc52c520ca13":["308eabc0d18aa58a75b0a130d08524e98661807b","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"fb17639909a369c1e64866842e5c213440acc17e":["954e59be3da8dc1b046646ad7af4b466852009d3"],"404d1ab7f6f396235047017c88d545fec15dafb7":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"308eabc0d18aa58a75b0a130d08524e98661807b":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","9a5b816df64f2b489d1e711be80f9416f9862c1b"],"954e59be3da8dc1b046646ad7af4b466852009d3":["6a47d642ab24da1a811adce4bda9cc52c520ca13"],"a38488a55cc52553c9792da5044dd31b15128cd8":["404d1ab7f6f396235047017c88d545fec15dafb7","1aad05eeff7818b0833c02ac6b743aa72054963b"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"9a5b816df64f2b489d1e711be80f9416f9862c1b":["a38488a55cc52553c9792da5044dd31b15128cd8"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fb17639909a369c1e64866842e5c213440acc17e"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}