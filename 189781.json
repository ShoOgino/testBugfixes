{"path":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","commits":[{"id":"ebd6f706eb59fe367493c820daeccd76587ec6bf","date":1340868972,"type":0,"author":"Ryan McKinley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Returns the DocValues used by the function query.\n   *\n   * @param reader the index reader\n   * @return the values\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n    final double[] minX = FieldCache.DEFAULT.getDoubles(reader, field.minX, true);\n    final double[] minY = FieldCache.DEFAULT.getDoubles(reader, field.minY, true);\n    final double[] maxX = FieldCache.DEFAULT.getDoubles(reader, field.maxX, true);\n    final double[] maxY = FieldCache.DEFAULT.getDoubles(reader, field.maxY, true);\n\n    final Bits validMinX = FieldCache.DEFAULT.getDocsWithField(reader, field.minX);\n    final Bits validMaxX = FieldCache.DEFAULT.getDocsWithField(reader, field.maxX);\n\n    return new FunctionValues() {\n      @Override\n      public float floatVal(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          Rectangle rect = new RectangleImpl(\n              minX[doc], maxX[doc],\n              minY[doc], maxY[doc]);\n          return (float) similarity.score(rect, null);\n        }\n        return 0;\n      }\n\n      public Explanation explain(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          Rectangle rect = new RectangleImpl(\n              minX[doc], maxX[doc],\n              minY[doc], maxY[doc]);\n          Explanation exp = new Explanation();\n          similarity.score(rect, exp);\n          return exp;\n        }\n        return new Explanation(0, \"No BBox\");\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"71f05adabc003001d1164371fa63caae32828ffc","date":1340873778,"type":3,"author":"Jan HÃ¸ydahl","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  /**\n   * Returns the DocValues used by the function query.\n   *\n   * @param readerContext the AtomicReaderContext which holds an AtomicReader\n   * @return the values\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n    final double[] minX = FieldCache.DEFAULT.getDoubles(reader, field.minX, true);\n    final double[] minY = FieldCache.DEFAULT.getDoubles(reader, field.minY, true);\n    final double[] maxX = FieldCache.DEFAULT.getDoubles(reader, field.maxX, true);\n    final double[] maxY = FieldCache.DEFAULT.getDoubles(reader, field.maxY, true);\n\n    final Bits validMinX = FieldCache.DEFAULT.getDocsWithField(reader, field.minX);\n    final Bits validMaxX = FieldCache.DEFAULT.getDocsWithField(reader, field.maxX);\n\n    return new FunctionValues() {\n      @Override\n      public float floatVal(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          Rectangle rect = new RectangleImpl(\n              minX[doc], maxX[doc],\n              minY[doc], maxY[doc]);\n          return (float) similarity.score(rect, null);\n        }\n        return 0;\n      }\n\n      public Explanation explain(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          Rectangle rect = new RectangleImpl(\n              minX[doc], maxX[doc],\n              minY[doc], maxY[doc]);\n          Explanation exp = new Explanation();\n          similarity.score(rect, exp);\n          return exp;\n        }\n        return new Explanation(0, \"No BBox\");\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns the DocValues used by the function query.\n   *\n   * @param reader the index reader\n   * @return the values\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n    final double[] minX = FieldCache.DEFAULT.getDoubles(reader, field.minX, true);\n    final double[] minY = FieldCache.DEFAULT.getDoubles(reader, field.minY, true);\n    final double[] maxX = FieldCache.DEFAULT.getDoubles(reader, field.maxX, true);\n    final double[] maxY = FieldCache.DEFAULT.getDoubles(reader, field.maxY, true);\n\n    final Bits validMinX = FieldCache.DEFAULT.getDocsWithField(reader, field.minX);\n    final Bits validMaxX = FieldCache.DEFAULT.getDocsWithField(reader, field.maxX);\n\n    return new FunctionValues() {\n      @Override\n      public float floatVal(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          Rectangle rect = new RectangleImpl(\n              minX[doc], maxX[doc],\n              minY[doc], maxY[doc]);\n          return (float) similarity.score(rect, null);\n        }\n        return 0;\n      }\n\n      public Explanation explain(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          Rectangle rect = new RectangleImpl(\n              minX[doc], maxX[doc],\n              minY[doc], maxY[doc]);\n          Explanation exp = new Explanation();\n          similarity.score(rect, exp);\n          return exp;\n        }\n        return new Explanation(0, \"No BBox\");\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0415a016b37e58a017fed0a91234f733ab359971","date":1341458183,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  /**\n   * Returns the DocValues used by the function query.\n   *\n   * @param readerContext the AtomicReaderContext which holds an AtomicReader\n   * @return the values\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n    final double[] minX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minX, true);\n    final double[] minY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minY, true);\n    final double[] maxX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxX, true);\n    final double[] maxY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxY, true);\n\n    final Bits validMinX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_minX);\n    final Bits validMaxX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_maxX);\n\n    return new FunctionValues() {\n      @Override\n      public float floatVal(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          Rectangle rect = new RectangleImpl(\n              minX[doc], maxX[doc],\n              minY[doc], maxY[doc]);\n          return (float) similarity.score(rect, null);\n        }\n        return 0;\n      }\n\n      public Explanation explain(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          Rectangle rect = new RectangleImpl(\n              minX[doc], maxX[doc],\n              minY[doc], maxY[doc]);\n          Explanation exp = new Explanation();\n          similarity.score(rect, exp);\n          return exp;\n        }\n        return new Explanation(0, \"No BBox\");\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns the DocValues used by the function query.\n   *\n   * @param readerContext the AtomicReaderContext which holds an AtomicReader\n   * @return the values\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n    final double[] minX = FieldCache.DEFAULT.getDoubles(reader, field.minX, true);\n    final double[] minY = FieldCache.DEFAULT.getDoubles(reader, field.minY, true);\n    final double[] maxX = FieldCache.DEFAULT.getDoubles(reader, field.maxX, true);\n    final double[] maxY = FieldCache.DEFAULT.getDoubles(reader, field.maxY, true);\n\n    final Bits validMinX = FieldCache.DEFAULT.getDocsWithField(reader, field.minX);\n    final Bits validMaxX = FieldCache.DEFAULT.getDocsWithField(reader, field.maxX);\n\n    return new FunctionValues() {\n      @Override\n      public float floatVal(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          Rectangle rect = new RectangleImpl(\n              minX[doc], maxX[doc],\n              minY[doc], maxY[doc]);\n          return (float) similarity.score(rect, null);\n        }\n        return 0;\n      }\n\n      public Explanation explain(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          Rectangle rect = new RectangleImpl(\n              minX[doc], maxX[doc],\n              minY[doc], maxY[doc]);\n          Explanation exp = new Explanation();\n          similarity.score(rect, exp);\n          return exp;\n        }\n        return new Explanation(0, \"No BBox\");\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Returns the DocValues used by the function query.\n   *\n   * @param readerContext the AtomicReaderContext which holds an AtomicReader\n   * @return the values\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n    final double[] minX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minX, true);\n    final double[] minY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minY, true);\n    final double[] maxX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxX, true);\n    final double[] maxY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxY, true);\n\n    final Bits validMinX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_minX);\n    final Bits validMaxX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_maxX);\n\n    return new FunctionValues() {\n      @Override\n      public float floatVal(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          Rectangle rect = new RectangleImpl(\n              minX[doc], maxX[doc],\n              minY[doc], maxY[doc]);\n          return (float) similarity.score(rect, null);\n        }\n        return 0;\n      }\n\n      public Explanation explain(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          Rectangle rect = new RectangleImpl(\n              minX[doc], maxX[doc],\n              minY[doc], maxY[doc]);\n          Explanation exp = new Explanation();\n          similarity.score(rect, exp);\n          return exp;\n        }\n        return new Explanation(0, \"No BBox\");\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"da956410d7a790f567af4e7e94584fb0930212f2","date":1346859431,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  /**\n   * Returns the DocValues used by the function query.\n   *\n   * @param readerContext the AtomicReaderContext which holds an AtomicReader\n   * @return the values\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n    final double[] minX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minX, true);\n    final double[] minY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minY, true);\n    final double[] maxX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxX, true);\n    final double[] maxY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxY, true);\n\n    final Bits validMinX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_minX);\n    final Bits validMaxX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_maxX);\n\n    return new FunctionValues() {\n      //reused\n      Rectangle rect = strategy.getSpatialContext().makeRectangle(0,0,0,0);\n\n      @Override\n      public float floatVal(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX[doc], maxX[doc],\n              minY[doc], maxY[doc]);\n          return (float) similarity.score(rect, null);\n        }\n        return 0;\n      }\n\n      public Explanation explain(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX[doc], maxX[doc],\n              minY[doc], maxY[doc]);\n          Explanation exp = new Explanation();\n          similarity.score(rect, exp);\n          return exp;\n        }\n        return new Explanation(0, \"No BBox\");\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns the DocValues used by the function query.\n   *\n   * @param readerContext the AtomicReaderContext which holds an AtomicReader\n   * @return the values\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n    final double[] minX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minX, true);\n    final double[] minY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minY, true);\n    final double[] maxX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxX, true);\n    final double[] maxY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxY, true);\n\n    final Bits validMinX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_minX);\n    final Bits validMaxX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_maxX);\n\n    return new FunctionValues() {\n      @Override\n      public float floatVal(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          Rectangle rect = new RectangleImpl(\n              minX[doc], maxX[doc],\n              minY[doc], maxY[doc]);\n          return (float) similarity.score(rect, null);\n        }\n        return 0;\n      }\n\n      public Explanation explain(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          Rectangle rect = new RectangleImpl(\n              minX[doc], maxX[doc],\n              minY[doc], maxY[doc]);\n          Explanation exp = new Explanation();\n          similarity.score(rect, exp);\n          return exp;\n        }\n        return new Explanation(0, \"No BBox\");\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"28bce66b0b769a7827b1f4df30b3f50a2ed6c355","date":1347720564,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  /**\n   * Returns the DocValues used by the function query.\n   *\n   * @param readerContext the AtomicReaderContext which holds an AtomicReader\n   * @return the values\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n    final double[] minX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minX, true);\n    final double[] minY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minY, true);\n    final double[] maxX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxX, true);\n    final double[] maxY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxY, true);\n\n    final Bits validMinX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_minX);\n    final Bits validMaxX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_maxX);\n\n    return new FunctionValues() {\n      //reused\n      Rectangle rect = strategy.getSpatialContext().makeRectangle(0,0,0,0);\n\n      @Override\n      public float floatVal(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX[doc], maxX[doc],\n              minY[doc], maxY[doc]);\n          return (float) similarity.score(rect, null);\n        } else {\n          return (float) similarity.score(null, null);\n        }\n      }\n\n      public Explanation explain(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX[doc], maxX[doc],\n              minY[doc], maxY[doc]);\n          Explanation exp = new Explanation();\n          similarity.score(rect, exp);\n          return exp;\n        }\n        return new Explanation(0, \"No BBox\");\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns the DocValues used by the function query.\n   *\n   * @param readerContext the AtomicReaderContext which holds an AtomicReader\n   * @return the values\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n    final double[] minX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minX, true);\n    final double[] minY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minY, true);\n    final double[] maxX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxX, true);\n    final double[] maxY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxY, true);\n\n    final Bits validMinX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_minX);\n    final Bits validMaxX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_maxX);\n\n    return new FunctionValues() {\n      //reused\n      Rectangle rect = strategy.getSpatialContext().makeRectangle(0,0,0,0);\n\n      @Override\n      public float floatVal(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX[doc], maxX[doc],\n              minY[doc], maxY[doc]);\n          return (float) similarity.score(rect, null);\n        }\n        return 0;\n      }\n\n      public Explanation explain(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX[doc], maxX[doc],\n              minY[doc], maxY[doc]);\n          Explanation exp = new Explanation();\n          similarity.score(rect, exp);\n          return exp;\n        }\n        return new Explanation(0, \"No BBox\");\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"34a3cb4eb36d5e20abde21f4d8fe5442588e7e03","date":1353235561,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  /**\n   * Returns the DocValues used by the function query.\n   *\n   * @param readerContext the AtomicReaderContext which holds an AtomicReader\n   * @return the values\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n    final FieldCache.Doubles minX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minX, true);\n    final FieldCache.Doubles minY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minY, true);\n    final FieldCache.Doubles maxX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxX, true);\n    final FieldCache.Doubles maxY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxY, true);\n\n    final Bits validMinX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_minX);\n    final Bits validMaxX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_maxX);\n\n    return new FunctionValues() {\n      //reused\n      Rectangle rect = strategy.getSpatialContext().makeRectangle(0,0,0,0);\n\n      @Override\n      public float floatVal(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX.get(doc), maxX.get(doc),\n              minY.get(doc), maxY.get(doc));\n          return (float) similarity.score(rect, null);\n        } else {\n          return (float) similarity.score(null, null);\n        }\n      }\n\n      public Explanation explain(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX.get(doc), maxX.get(doc),\n              minY.get(doc), maxY.get(doc));\n          Explanation exp = new Explanation();\n          similarity.score(rect, exp);\n          return exp;\n        }\n        return new Explanation(0, \"No BBox\");\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns the DocValues used by the function query.\n   *\n   * @param readerContext the AtomicReaderContext which holds an AtomicReader\n   * @return the values\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n    final double[] minX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minX, true);\n    final double[] minY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minY, true);\n    final double[] maxX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxX, true);\n    final double[] maxY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxY, true);\n\n    final Bits validMinX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_minX);\n    final Bits validMaxX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_maxX);\n\n    return new FunctionValues() {\n      //reused\n      Rectangle rect = strategy.getSpatialContext().makeRectangle(0,0,0,0);\n\n      @Override\n      public float floatVal(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX[doc], maxX[doc],\n              minY[doc], maxY[doc]);\n          return (float) similarity.score(rect, null);\n        } else {\n          return (float) similarity.score(null, null);\n        }\n      }\n\n      public Explanation explain(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX[doc], maxX[doc],\n              minY[doc], maxY[doc]);\n          Explanation exp = new Explanation();\n          similarity.score(rect, exp);\n          return exp;\n        }\n        return new Explanation(0, \"No BBox\");\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  /**\n   * Returns the DocValues used by the function query.\n   *\n   * @param readerContext the AtomicReaderContext which holds an AtomicReader\n   * @return the values\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n    final double[] minX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minX, true);\n    final double[] minY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minY, true);\n    final double[] maxX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxX, true);\n    final double[] maxY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxY, true);\n\n    final Bits validMinX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_minX);\n    final Bits validMaxX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_maxX);\n\n    return new FunctionValues() {\n      //reused\n      Rectangle rect = strategy.getSpatialContext().makeRectangle(0,0,0,0);\n\n      @Override\n      public float floatVal(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX[doc], maxX[doc],\n              minY[doc], maxY[doc]);\n          return (float) similarity.score(rect, null);\n        } else {\n          return (float) similarity.score(null, null);\n        }\n      }\n\n      @Override\n      public Explanation explain(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX[doc], maxX[doc],\n              minY[doc], maxY[doc]);\n          Explanation exp = new Explanation();\n          similarity.score(rect, exp);\n          return exp;\n        }\n        return new Explanation(0, \"No BBox\");\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns the DocValues used by the function query.\n   *\n   * @param readerContext the AtomicReaderContext which holds an AtomicReader\n   * @return the values\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n    final double[] minX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minX, true);\n    final double[] minY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minY, true);\n    final double[] maxX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxX, true);\n    final double[] maxY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxY, true);\n\n    final Bits validMinX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_minX);\n    final Bits validMaxX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_maxX);\n\n    return new FunctionValues() {\n      //reused\n      Rectangle rect = strategy.getSpatialContext().makeRectangle(0,0,0,0);\n\n      @Override\n      public float floatVal(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX[doc], maxX[doc],\n              minY[doc], maxY[doc]);\n          return (float) similarity.score(rect, null);\n        } else {\n          return (float) similarity.score(null, null);\n        }\n      }\n\n      public Explanation explain(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX[doc], maxX[doc],\n              minY[doc], maxY[doc]);\n          Explanation exp = new Explanation();\n          similarity.score(rect, exp);\n          return exp;\n        }\n        return new Explanation(0, \"No BBox\");\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  /**\n   * Returns the DocValues used by the function query.\n   *\n   * @param readerContext the AtomicReaderContext which holds an AtomicReader\n   * @return the values\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n    final FieldCache.Doubles minX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minX, true);\n    final FieldCache.Doubles minY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minY, true);\n    final FieldCache.Doubles maxX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxX, true);\n    final FieldCache.Doubles maxY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxY, true);\n\n    final Bits validMinX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_minX);\n    final Bits validMaxX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_maxX);\n\n    return new FunctionValues() {\n      //reused\n      Rectangle rect = strategy.getSpatialContext().makeRectangle(0,0,0,0);\n\n      @Override\n      public float floatVal(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX.get(doc), maxX.get(doc),\n              minY.get(doc), maxY.get(doc));\n          return (float) similarity.score(rect, null);\n        } else {\n          return (float) similarity.score(null, null);\n        }\n      }\n\n      @Override\n      public Explanation explain(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX.get(doc), maxX.get(doc),\n              minY.get(doc), maxY.get(doc));\n          Explanation exp = new Explanation();\n          similarity.score(rect, exp);\n          return exp;\n        }\n        return new Explanation(0, \"No BBox\");\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns the DocValues used by the function query.\n   *\n   * @param readerContext the AtomicReaderContext which holds an AtomicReader\n   * @return the values\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n    final FieldCache.Doubles minX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minX, true);\n    final FieldCache.Doubles minY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minY, true);\n    final FieldCache.Doubles maxX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxX, true);\n    final FieldCache.Doubles maxY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxY, true);\n\n    final Bits validMinX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_minX);\n    final Bits validMaxX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_maxX);\n\n    return new FunctionValues() {\n      //reused\n      Rectangle rect = strategy.getSpatialContext().makeRectangle(0,0,0,0);\n\n      @Override\n      public float floatVal(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX.get(doc), maxX.get(doc),\n              minY.get(doc), maxY.get(doc));\n          return (float) similarity.score(rect, null);\n        } else {\n          return (float) similarity.score(null, null);\n        }\n      }\n\n      public Explanation explain(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX.get(doc), maxX.get(doc),\n              minY.get(doc), maxY.get(doc));\n          Explanation exp = new Explanation();\n          similarity.score(rect, exp);\n          return exp;\n        }\n        return new Explanation(0, \"No BBox\");\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  /**\n   * Returns the DocValues used by the function query.\n   *\n   * @param readerContext the AtomicReaderContext which holds an AtomicReader\n   * @return the values\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n    final FieldCache.Doubles minX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minX, true);\n    final FieldCache.Doubles minY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minY, true);\n    final FieldCache.Doubles maxX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxX, true);\n    final FieldCache.Doubles maxY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxY, true);\n\n    final Bits validMinX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_minX);\n    final Bits validMaxX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_maxX);\n\n    return new FunctionValues() {\n      //reused\n      Rectangle rect = strategy.getSpatialContext().makeRectangle(0,0,0,0);\n\n      @Override\n      public float floatVal(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX.get(doc), maxX.get(doc),\n              minY.get(doc), maxY.get(doc));\n          return (float) similarity.score(rect, null);\n        } else {\n          return (float) similarity.score(null, null);\n        }\n      }\n\n      @Override\n      public Explanation explain(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX.get(doc), maxX.get(doc),\n              minY.get(doc), maxY.get(doc));\n          Explanation exp = new Explanation();\n          similarity.score(rect, exp);\n          return exp;\n        }\n        return new Explanation(0, \"No BBox\");\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns the DocValues used by the function query.\n   *\n   * @param readerContext the AtomicReaderContext which holds an AtomicReader\n   * @return the values\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n    final double[] minX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minX, true);\n    final double[] minY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minY, true);\n    final double[] maxX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxX, true);\n    final double[] maxY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxY, true);\n\n    final Bits validMinX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_minX);\n    final Bits validMaxX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_maxX);\n\n    return new FunctionValues() {\n      //reused\n      Rectangle rect = strategy.getSpatialContext().makeRectangle(0,0,0,0);\n\n      @Override\n      public float floatVal(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX[doc], maxX[doc],\n              minY[doc], maxY[doc]);\n          return (float) similarity.score(rect, null);\n        } else {\n          return (float) similarity.score(null, null);\n        }\n      }\n\n      @Override\n      public Explanation explain(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX[doc], maxX[doc],\n              minY[doc], maxY[doc]);\n          Explanation exp = new Explanation();\n          similarity.score(rect, exp);\n          return exp;\n        }\n        return new Explanation(0, \"No BBox\");\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","bugFix":["0415a016b37e58a017fed0a91234f733ab359971","ebd6f706eb59fe367493c820daeccd76587ec6bf"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"11a746437bc5c0a0b3df0337ed249c387c812871","date":1376687959,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  /**\n   * Returns the DocValues used by the function query.\n   *\n   * @param readerContext the AtomicReaderContext which holds an AtomicReader\n   * @return the values\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n    final FieldCache.Doubles minX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minX, true);\n    final FieldCache.Doubles minY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minY, true);\n    final FieldCache.Doubles maxX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxX, true);\n    final FieldCache.Doubles maxY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxY, true);\n\n    final Bits validMinX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_minX);\n    final Bits validMaxX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_maxX);\n\n    return new FunctionValues() {\n      //reused\n      Rectangle rect = strategy.getSpatialContext().makeRectangle(0,0,0,0);\n\n      @Override\n      public float floatVal(int doc) {\n        double minXVal = minX.get(doc);\n        double maxXVal = maxX.get(doc);\n        // make sure it has minX and area\n        if ((minXVal != 0 || validMinX.get(doc)) && (maxXVal != 0 || validMaxX.get(doc))) {\n          rect.reset(\n              minXVal, maxXVal,\n              minY.get(doc), maxY.get(doc));\n          return (float) similarity.score(rect, null);\n        } else {\n          return (float) similarity.score(null, null);\n        }\n      }\n\n      @Override\n      public Explanation explain(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX.get(doc), maxX.get(doc),\n              minY.get(doc), maxY.get(doc));\n          Explanation exp = new Explanation();\n          similarity.score(rect, exp);\n          return exp;\n        }\n        return new Explanation(0, \"No BBox\");\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns the DocValues used by the function query.\n   *\n   * @param readerContext the AtomicReaderContext which holds an AtomicReader\n   * @return the values\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n    final FieldCache.Doubles minX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minX, true);\n    final FieldCache.Doubles minY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minY, true);\n    final FieldCache.Doubles maxX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxX, true);\n    final FieldCache.Doubles maxY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxY, true);\n\n    final Bits validMinX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_minX);\n    final Bits validMaxX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_maxX);\n\n    return new FunctionValues() {\n      //reused\n      Rectangle rect = strategy.getSpatialContext().makeRectangle(0,0,0,0);\n\n      @Override\n      public float floatVal(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX.get(doc), maxX.get(doc),\n              minY.get(doc), maxY.get(doc));\n          return (float) similarity.score(rect, null);\n        } else {\n          return (float) similarity.score(null, null);\n        }\n      }\n\n      @Override\n      public Explanation explain(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX.get(doc), maxX.get(doc),\n              minY.get(doc), maxY.get(doc));\n          Explanation exp = new Explanation();\n          similarity.score(rect, exp);\n          return exp;\n        }\n        return new Explanation(0, \"No BBox\");\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff","date":1377034255,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  /**\n   * Returns the DocValues used by the function query.\n   *\n   * @param readerContext the AtomicReaderContext which holds an AtomicReader\n   * @return the values\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n    final FieldCache.Doubles minX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minX, true);\n    final FieldCache.Doubles minY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minY, true);\n    final FieldCache.Doubles maxX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxX, true);\n    final FieldCache.Doubles maxY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxY, true);\n\n    final Bits validMinX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_minX);\n    final Bits validMaxX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_maxX);\n\n    return new FunctionValues() {\n      //reused\n      Rectangle rect = strategy.getSpatialContext().makeRectangle(0,0,0,0);\n\n      @Override\n      public float floatVal(int doc) {\n        double minXVal = minX.get(doc);\n        double maxXVal = maxX.get(doc);\n        // make sure it has minX and area\n        if ((minXVal != 0 || validMinX.get(doc)) && (maxXVal != 0 || validMaxX.get(doc))) {\n          rect.reset(\n              minXVal, maxXVal,\n              minY.get(doc), maxY.get(doc));\n          return (float) similarity.score(rect, null);\n        } else {\n          return (float) similarity.score(null, null);\n        }\n      }\n\n      @Override\n      public Explanation explain(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX.get(doc), maxX.get(doc),\n              minY.get(doc), maxY.get(doc));\n          Explanation exp = new Explanation();\n          similarity.score(rect, exp);\n          return exp;\n        }\n        return new Explanation(0, \"No BBox\");\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns the DocValues used by the function query.\n   *\n   * @param readerContext the AtomicReaderContext which holds an AtomicReader\n   * @return the values\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n    final FieldCache.Doubles minX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minX, true);\n    final FieldCache.Doubles minY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minY, true);\n    final FieldCache.Doubles maxX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxX, true);\n    final FieldCache.Doubles maxY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxY, true);\n\n    final Bits validMinX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_minX);\n    final Bits validMaxX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_maxX);\n\n    return new FunctionValues() {\n      //reused\n      Rectangle rect = strategy.getSpatialContext().makeRectangle(0,0,0,0);\n\n      @Override\n      public float floatVal(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX.get(doc), maxX.get(doc),\n              minY.get(doc), maxY.get(doc));\n          return (float) similarity.score(rect, null);\n        } else {\n          return (float) similarity.score(null, null);\n        }\n      }\n\n      @Override\n      public Explanation explain(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX.get(doc), maxX.get(doc),\n              minY.get(doc), maxY.get(doc));\n          Explanation exp = new Explanation();\n          similarity.score(rect, exp);\n          return exp;\n        }\n        return new Explanation(0, \"No BBox\");\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  /**\n   * Returns the DocValues used by the function query.\n   *\n   * @param readerContext the AtomicReaderContext which holds an AtomicReader\n   * @return the values\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n    final FieldCache.Doubles minX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minX, true);\n    final FieldCache.Doubles minY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minY, true);\n    final FieldCache.Doubles maxX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxX, true);\n    final FieldCache.Doubles maxY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxY, true);\n\n    final Bits validMinX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_minX);\n    final Bits validMaxX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_maxX);\n\n    return new FunctionValues() {\n      //reused\n      Rectangle rect = strategy.getSpatialContext().makeRectangle(0,0,0,0);\n\n      @Override\n      public float floatVal(int doc) {\n        double minXVal = minX.get(doc);\n        double maxXVal = maxX.get(doc);\n        // make sure it has minX and area\n        if ((minXVal != 0 || validMinX.get(doc)) && (maxXVal != 0 || validMaxX.get(doc))) {\n          rect.reset(\n              minXVal, maxXVal,\n              minY.get(doc), maxY.get(doc));\n          return (float) similarity.score(rect, null);\n        } else {\n          return (float) similarity.score(null, null);\n        }\n      }\n\n      @Override\n      public Explanation explain(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX.get(doc), maxX.get(doc),\n              minY.get(doc), maxY.get(doc));\n          Explanation exp = new Explanation();\n          similarity.score(rect, exp);\n          return exp;\n        }\n        return new Explanation(0, \"No BBox\");\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns the DocValues used by the function query.\n   *\n   * @param readerContext the AtomicReaderContext which holds an AtomicReader\n   * @return the values\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n    final FieldCache.Doubles minX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minX, true);\n    final FieldCache.Doubles minY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minY, true);\n    final FieldCache.Doubles maxX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxX, true);\n    final FieldCache.Doubles maxY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxY, true);\n\n    final Bits validMinX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_minX);\n    final Bits validMaxX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_maxX);\n\n    return new FunctionValues() {\n      //reused\n      Rectangle rect = strategy.getSpatialContext().makeRectangle(0,0,0,0);\n\n      @Override\n      public float floatVal(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX.get(doc), maxX.get(doc),\n              minY.get(doc), maxY.get(doc));\n          return (float) similarity.score(rect, null);\n        } else {\n          return (float) similarity.score(null, null);\n        }\n      }\n\n      @Override\n      public Explanation explain(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX.get(doc), maxX.get(doc),\n              minY.get(doc), maxY.get(doc));\n          Explanation exp = new Explanation();\n          similarity.score(rect, exp);\n          return exp;\n        }\n        return new Explanation(0, \"No BBox\");\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c","date":1399816179,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  /**\n   * Returns the DocValues used by the function query.\n   *\n   * @param readerContext the AtomicReaderContext which holds an AtomicReader\n   * @return the values\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n    final NumericDocValues minX = DocValues.getNumeric(reader, strategy.field_minX);\n    final NumericDocValues minY = DocValues.getNumeric(reader, strategy.field_minY);\n    final NumericDocValues maxX = DocValues.getNumeric(reader, strategy.field_maxX);\n    final NumericDocValues maxY = DocValues.getNumeric(reader, strategy.field_maxY);\n\n    final Bits validMinX = DocValues.getDocsWithField(reader, strategy.field_minX);\n    final Bits validMaxX = DocValues.getDocsWithField(reader, strategy.field_maxX);\n\n    return new FunctionValues() {\n      //reused\n      Rectangle rect = strategy.getSpatialContext().makeRectangle(0,0,0,0);\n\n      @Override\n      public float floatVal(int doc) {\n        double minXVal = Double.longBitsToDouble(minX.get(doc));\n        double maxXVal = Double.longBitsToDouble(maxX.get(doc));\n        // make sure it has minX and area\n        if ((minXVal != 0 || validMinX.get(doc)) && (maxXVal != 0 || validMaxX.get(doc))) {\n          rect.reset(\n              minXVal, maxXVal,\n              Double.longBitsToDouble(minY.get(doc)), Double.longBitsToDouble(maxY.get(doc)));\n          return (float) similarity.score(rect, null);\n        } else {\n          return (float) similarity.score(null, null);\n        }\n      }\n\n      @Override\n      public Explanation explain(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              Double.longBitsToDouble(minX.get(doc)), Double.longBitsToDouble(maxX.get(doc)),\n              Double.longBitsToDouble(minY.get(doc)), Double.longBitsToDouble(maxY.get(doc)));\n          Explanation exp = new Explanation();\n          similarity.score(rect, exp);\n          return exp;\n        }\n        return new Explanation(0, \"No BBox\");\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns the DocValues used by the function query.\n   *\n   * @param readerContext the AtomicReaderContext which holds an AtomicReader\n   * @return the values\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n    final FieldCache.Doubles minX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minX, true);\n    final FieldCache.Doubles minY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minY, true);\n    final FieldCache.Doubles maxX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxX, true);\n    final FieldCache.Doubles maxY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxY, true);\n\n    final Bits validMinX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_minX);\n    final Bits validMaxX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_maxX);\n\n    return new FunctionValues() {\n      //reused\n      Rectangle rect = strategy.getSpatialContext().makeRectangle(0,0,0,0);\n\n      @Override\n      public float floatVal(int doc) {\n        double minXVal = minX.get(doc);\n        double maxXVal = maxX.get(doc);\n        // make sure it has minX and area\n        if ((minXVal != 0 || validMinX.get(doc)) && (maxXVal != 0 || validMaxX.get(doc))) {\n          rect.reset(\n              minXVal, maxXVal,\n              minY.get(doc), maxY.get(doc));\n          return (float) similarity.score(rect, null);\n        } else {\n          return (float) similarity.score(null, null);\n        }\n      }\n\n      @Override\n      public Explanation explain(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX.get(doc), maxX.get(doc),\n              minY.get(doc), maxY.get(doc));\n          Explanation exp = new Explanation();\n          similarity.score(rect, exp);\n          return exp;\n        }\n        return new Explanation(0, \"No BBox\");\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93dd449115a9247533e44bab47e8429e5dccbc6d","date":1400258396,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  /**\n   * Returns the DocValues used by the function query.\n   *\n   * @param readerContext the AtomicReaderContext which holds an AtomicReader\n   * @return the values\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n    final NumericDocValues minX = DocValues.getNumeric(reader, strategy.field_minX);\n    final NumericDocValues minY = DocValues.getNumeric(reader, strategy.field_minY);\n    final NumericDocValues maxX = DocValues.getNumeric(reader, strategy.field_maxX);\n    final NumericDocValues maxY = DocValues.getNumeric(reader, strategy.field_maxY);\n\n    final Bits validMinX = DocValues.getDocsWithField(reader, strategy.field_minX);\n    final Bits validMaxX = DocValues.getDocsWithField(reader, strategy.field_maxX);\n\n    return new FunctionValues() {\n      //reused\n      Rectangle rect = strategy.getSpatialContext().makeRectangle(0,0,0,0);\n\n      @Override\n      public float floatVal(int doc) {\n        double minXVal = Double.longBitsToDouble(minX.get(doc));\n        double maxXVal = Double.longBitsToDouble(maxX.get(doc));\n        // make sure it has minX and area\n        if ((minXVal != 0 || validMinX.get(doc)) && (maxXVal != 0 || validMaxX.get(doc))) {\n          rect.reset(\n              minXVal, maxXVal,\n              Double.longBitsToDouble(minY.get(doc)), Double.longBitsToDouble(maxY.get(doc)));\n          return (float) similarity.score(rect, null);\n        } else {\n          return (float) similarity.score(null, null);\n        }\n      }\n\n      @Override\n      public Explanation explain(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              Double.longBitsToDouble(minX.get(doc)), Double.longBitsToDouble(maxX.get(doc)),\n              Double.longBitsToDouble(minY.get(doc)), Double.longBitsToDouble(maxY.get(doc)));\n          Explanation exp = new Explanation();\n          similarity.score(rect, exp);\n          return exp;\n        }\n        return new Explanation(0, \"No BBox\");\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns the DocValues used by the function query.\n   *\n   * @param readerContext the AtomicReaderContext which holds an AtomicReader\n   * @return the values\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n    final FieldCache.Doubles minX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minX, true);\n    final FieldCache.Doubles minY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minY, true);\n    final FieldCache.Doubles maxX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxX, true);\n    final FieldCache.Doubles maxY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxY, true);\n\n    final Bits validMinX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_minX);\n    final Bits validMaxX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_maxX);\n\n    return new FunctionValues() {\n      //reused\n      Rectangle rect = strategy.getSpatialContext().makeRectangle(0,0,0,0);\n\n      @Override\n      public float floatVal(int doc) {\n        double minXVal = minX.get(doc);\n        double maxXVal = maxX.get(doc);\n        // make sure it has minX and area\n        if ((minXVal != 0 || validMinX.get(doc)) && (maxXVal != 0 || validMaxX.get(doc))) {\n          rect.reset(\n              minXVal, maxXVal,\n              minY.get(doc), maxY.get(doc));\n          return (float) similarity.score(rect, null);\n        } else {\n          return (float) similarity.score(null, null);\n        }\n      }\n\n      @Override\n      public Explanation explain(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX.get(doc), maxX.get(doc),\n              minY.get(doc), maxY.get(doc));\n          Explanation exp = new Explanation();\n          similarity.score(rect, exp);\n          return exp;\n        }\n        return new Explanation(0, \"No BBox\");\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  /**\n   * Returns the DocValues used by the function query.\n   *\n   * @param readerContext the AtomicReaderContext which holds an AtomicReader\n   * @return the values\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n    final NumericDocValues minX = DocValues.getNumeric(reader, strategy.field_minX);\n    final NumericDocValues minY = DocValues.getNumeric(reader, strategy.field_minY);\n    final NumericDocValues maxX = DocValues.getNumeric(reader, strategy.field_maxX);\n    final NumericDocValues maxY = DocValues.getNumeric(reader, strategy.field_maxY);\n\n    final Bits validMinX = DocValues.getDocsWithField(reader, strategy.field_minX);\n    final Bits validMaxX = DocValues.getDocsWithField(reader, strategy.field_maxX);\n\n    return new FunctionValues() {\n      //reused\n      Rectangle rect = strategy.getSpatialContext().makeRectangle(0,0,0,0);\n\n      @Override\n      public float floatVal(int doc) {\n        double minXVal = Double.longBitsToDouble(minX.get(doc));\n        double maxXVal = Double.longBitsToDouble(maxX.get(doc));\n        // make sure it has minX and area\n        if ((minXVal != 0 || validMinX.get(doc)) && (maxXVal != 0 || validMaxX.get(doc))) {\n          rect.reset(\n              minXVal, maxXVal,\n              Double.longBitsToDouble(minY.get(doc)), Double.longBitsToDouble(maxY.get(doc)));\n          return (float) similarity.score(rect, null);\n        } else {\n          return (float) similarity.score(null, null);\n        }\n      }\n\n      @Override\n      public Explanation explain(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              Double.longBitsToDouble(minX.get(doc)), Double.longBitsToDouble(maxX.get(doc)),\n              Double.longBitsToDouble(minY.get(doc)), Double.longBitsToDouble(maxY.get(doc)));\n          Explanation exp = new Explanation();\n          similarity.score(rect, exp);\n          return exp;\n        }\n        return new Explanation(0, \"No BBox\");\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns the DocValues used by the function query.\n   *\n   * @param readerContext the AtomicReaderContext which holds an AtomicReader\n   * @return the values\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n    final FieldCache.Doubles minX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minX, true);\n    final FieldCache.Doubles minY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_minY, true);\n    final FieldCache.Doubles maxX = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxX, true);\n    final FieldCache.Doubles maxY = FieldCache.DEFAULT.getDoubles(reader, strategy.field_maxY, true);\n\n    final Bits validMinX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_minX);\n    final Bits validMaxX = FieldCache.DEFAULT.getDocsWithField(reader, strategy.field_maxX);\n\n    return new FunctionValues() {\n      //reused\n      Rectangle rect = strategy.getSpatialContext().makeRectangle(0,0,0,0);\n\n      @Override\n      public float floatVal(int doc) {\n        double minXVal = minX.get(doc);\n        double maxXVal = maxX.get(doc);\n        // make sure it has minX and area\n        if ((minXVal != 0 || validMinX.get(doc)) && (maxXVal != 0 || validMaxX.get(doc))) {\n          rect.reset(\n              minXVal, maxXVal,\n              minY.get(doc), maxY.get(doc));\n          return (float) similarity.score(rect, null);\n        } else {\n          return (float) similarity.score(null, null);\n        }\n      }\n\n      @Override\n      public Explanation explain(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              minX.get(doc), maxX.get(doc),\n              minY.get(doc), maxY.get(doc));\n          Explanation exp = new Explanation();\n          similarity.score(rect, exp);\n          return exp;\n        }\n        return new Explanation(0, \"No BBox\");\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1eb9cd4e9d9dc2a301efb4dc420fcb069a9dd018","date":1404828935,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n\n    final FunctionValues shapeValues = bboxValueSource.getValues(context, readerContext);\n\n    return new DoubleDocValues(this) {\n      @Override\n      public double doubleVal(int doc) {\n        //? limit to Rect or call getBoundingBox()? latter would encourage bad practice\n        final Rectangle rect = (Rectangle) shapeValues.objectVal(doc);\n        return rect==null ? 0 : score(rect, null);\n      }\n\n      @Override\n      public boolean exists(int doc) {\n        return shapeValues.exists(doc);\n      }\n\n      @Override\n      public Explanation explain(int doc) {\n        final Rectangle rect = (Rectangle) shapeValues.objectVal(doc);\n        if (rect == null)\n          return new Explanation(0, \"no rect\");\n        Explanation exp = new Explanation();\n        score(rect, exp);\n        return exp;\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns the DocValues used by the function query.\n   *\n   * @param readerContext the AtomicReaderContext which holds an AtomicReader\n   * @return the values\n   */\n  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    AtomicReader reader = readerContext.reader();\n    final NumericDocValues minX = DocValues.getNumeric(reader, strategy.field_minX);\n    final NumericDocValues minY = DocValues.getNumeric(reader, strategy.field_minY);\n    final NumericDocValues maxX = DocValues.getNumeric(reader, strategy.field_maxX);\n    final NumericDocValues maxY = DocValues.getNumeric(reader, strategy.field_maxY);\n\n    final Bits validMinX = DocValues.getDocsWithField(reader, strategy.field_minX);\n    final Bits validMaxX = DocValues.getDocsWithField(reader, strategy.field_maxX);\n\n    return new FunctionValues() {\n      //reused\n      Rectangle rect = strategy.getSpatialContext().makeRectangle(0,0,0,0);\n\n      @Override\n      public float floatVal(int doc) {\n        double minXVal = Double.longBitsToDouble(minX.get(doc));\n        double maxXVal = Double.longBitsToDouble(maxX.get(doc));\n        // make sure it has minX and area\n        if ((minXVal != 0 || validMinX.get(doc)) && (maxXVal != 0 || validMaxX.get(doc))) {\n          rect.reset(\n              minXVal, maxXVal,\n              Double.longBitsToDouble(minY.get(doc)), Double.longBitsToDouble(maxY.get(doc)));\n          return (float) similarity.score(rect, null);\n        } else {\n          return (float) similarity.score(null, null);\n        }\n      }\n\n      @Override\n      public Explanation explain(int doc) {\n        // make sure it has minX and area\n        if (validMinX.get(doc) && validMaxX.get(doc)) {\n          rect.reset(\n              Double.longBitsToDouble(minX.get(doc)), Double.longBitsToDouble(maxX.get(doc)),\n              Double.longBitsToDouble(minY.get(doc)), Double.longBitsToDouble(maxY.get(doc)));\n          Explanation exp = new Explanation();\n          similarity.score(rect, exp);\n          return exp;\n        }\n        return new Explanation(0, \"No BBox\");\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + \"=\" + floatVal(doc);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":4,"author":"Ryan Ernst","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":null,"sourceOld":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n\n    final FunctionValues shapeValues = bboxValueSource.getValues(context, readerContext);\n\n    return new DoubleDocValues(this) {\n      @Override\n      public double doubleVal(int doc) {\n        //? limit to Rect or call getBoundingBox()? latter would encourage bad practice\n        final Rectangle rect = (Rectangle) shapeValues.objectVal(doc);\n        return rect==null ? 0 : score(rect, null);\n      }\n\n      @Override\n      public boolean exists(int doc) {\n        return shapeValues.exists(doc);\n      }\n\n      @Override\n      public Explanation explain(int doc) {\n        final Rectangle rect = (Rectangle) shapeValues.objectVal(doc);\n        if (rect == null)\n          return new Explanation(0, \"no rect\");\n        Explanation exp = new Explanation();\n        score(rect, exp);\n        return exp;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0415a016b37e58a017fed0a91234f733ab359971":["71f05adabc003001d1164371fa63caae32828ffc"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["34a3cb4eb36d5e20abde21f4d8fe5442588e7e03","7530de27b87b961b51f01bd1299b7004d46e8823"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["d4d69c535930b5cce125cff868d40f6373dc27d4","e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"da956410d7a790f567af4e7e94584fb0930212f2":["0415a016b37e58a017fed0a91234f733ab359971"],"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c":["e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff":["d4d69c535930b5cce125cff868d40f6373dc27d4","11a746437bc5c0a0b3df0337ed249c387c812871"],"56572ec06f1407c066d6b7399413178b33176cd8":["e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff","93dd449115a9247533e44bab47e8429e5dccbc6d"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["1eb9cd4e9d9dc2a301efb4dc420fcb069a9dd018"],"1eb9cd4e9d9dc2a301efb4dc420fcb069a9dd018":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"ebd6f706eb59fe367493c820daeccd76587ec6bf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"11a746437bc5c0a0b3df0337ed249c387c812871":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"71f05adabc003001d1164371fa63caae32828ffc":["ebd6f706eb59fe367493c820daeccd76587ec6bf"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["7530de27b87b961b51f01bd1299b7004d46e8823","d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"34a3cb4eb36d5e20abde21f4d8fe5442588e7e03":["28bce66b0b769a7827b1f4df30b3f50a2ed6c355"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff","b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0415a016b37e58a017fed0a91234f733ab359971"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"28bce66b0b769a7827b1f4df30b3f50a2ed6c355":["da956410d7a790f567af4e7e94584fb0930212f2"],"7530de27b87b961b51f01bd1299b7004d46e8823":["28bce66b0b769a7827b1f4df30b3f50a2ed6c355"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c9fb5f46e264daf5ba3860defe623a89d202dd87"]},"commit2Childs":{"0415a016b37e58a017fed0a91234f733ab359971":["da956410d7a790f567af4e7e94584fb0930212f2","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"da956410d7a790f567af4e7e94584fb0930212f2":["28bce66b0b769a7827b1f4df30b3f50a2ed6c355"],"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c","56572ec06f1407c066d6b7399413178b33176cd8","93dd449115a9247533e44bab47e8429e5dccbc6d"],"56572ec06f1407c066d6b7399413178b33176cd8":[],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1eb9cd4e9d9dc2a301efb4dc420fcb069a9dd018":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"ebd6f706eb59fe367493c820daeccd76587ec6bf":["71f05adabc003001d1164371fa63caae32828ffc"],"11a746437bc5c0a0b3df0337ed249c387c812871":["e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"71f05adabc003001d1164371fa63caae32828ffc":["0415a016b37e58a017fed0a91234f733ab359971"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff","11a746437bc5c0a0b3df0337ed249c387c812871"],"34a3cb4eb36d5e20abde21f4d8fe5442588e7e03":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["56572ec06f1407c066d6b7399413178b33176cd8","1eb9cd4e9d9dc2a301efb4dc420fcb069a9dd018"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ebd6f706eb59fe367493c820daeccd76587ec6bf","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"28bce66b0b769a7827b1f4df30b3f50a2ed6c355":["34a3cb4eb36d5e20abde21f4d8fe5442588e7e03","7530de27b87b961b51f01bd1299b7004d46e8823"],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","d4d69c535930b5cce125cff868d40f6373dc27d4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","56572ec06f1407c066d6b7399413178b33176cd8","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}