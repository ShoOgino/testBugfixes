{"path":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#nextDoc().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#nextDoc().mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/util/LineFileDocs#nextDoc().mjava","sourceNew":"  /** Note: Document instance is re-used per-thread */\n  public Document nextDoc() throws IOException {\n    String line;\n    synchronized(this) {\n      line = reader.readLine();\n      if (line == null) {\n        // Always rewind at end:\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: now rewind file...\");\n        }\n        close();\n        open(null);\n        line = reader.readLine();\n      }\n    }\n\n    DocState docState = threadDocs.get();\n    if (docState == null) {\n      docState = new DocState();\n      threadDocs.set(docState);\n    }\n\n    int spot = line.indexOf(SEP);\n    if (spot == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n    int spot2 = line.indexOf(SEP, 1 + spot);\n    if (spot2 == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n\n    docState.body.setValue(line.substring(1+spot2, line.length()));\n    final String title = line.substring(0, spot);\n    docState.title.setValue(title);\n    docState.titleTokenized.setValue(title);\n    docState.date.setValue(line.substring(1+spot, spot2));\n    docState.id.setValue(Integer.toString(id.getAndIncrement()));\n    return docState.doc;\n  }\n\n","sourceOld":"  /** Note: Document instance is re-used per-thread */\n  public Document nextDoc() throws IOException {\n    String line;\n    synchronized(this) {\n      line = reader.readLine();\n      if (line == null) {\n        // Always rewind at end:\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: now rewind file...\");\n        }\n        close();\n        open(null);\n        line = reader.readLine();\n      }\n    }\n\n    DocState docState = threadDocs.get();\n    if (docState == null) {\n      docState = new DocState();\n      threadDocs.set(docState);\n    }\n\n    int spot = line.indexOf(SEP);\n    if (spot == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n    int spot2 = line.indexOf(SEP, 1 + spot);\n    if (spot2 == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n\n    docState.body.setValue(line.substring(1+spot2, line.length()));\n    final String title = line.substring(0, spot);\n    docState.title.setValue(title);\n    docState.titleTokenized.setValue(title);\n    docState.date.setValue(line.substring(1+spot, spot2));\n    docState.id.setValue(Integer.toString(id.getAndIncrement()));\n    return docState.doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a78a90fc9701e511308346ea29f4f5e548bb39fe","date":1329489995,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#nextDoc().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#nextDoc().mjava","sourceNew":"  /** Note: Document instance is re-used per-thread */\n  public Document nextDoc() throws IOException {\n    String line;\n    synchronized(this) {\n      line = reader.readLine();\n      if (line == null) {\n        // Always rewind at end:\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: now rewind file...\");\n        }\n        close();\n        open(null);\n        line = reader.readLine();\n      }\n    }\n\n    DocState docState = threadDocs.get();\n    if (docState == null) {\n      docState = new DocState();\n      threadDocs.set(docState);\n    }\n\n    int spot = line.indexOf(SEP);\n    if (spot == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n    int spot2 = line.indexOf(SEP, 1 + spot);\n    if (spot2 == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n\n    docState.body.setStringValue(line.substring(1+spot2, line.length()));\n    final String title = line.substring(0, spot);\n    docState.title.setStringValue(title);\n    docState.titleTokenized.setStringValue(title);\n    docState.date.setStringValue(line.substring(1+spot, spot2));\n    docState.id.setStringValue(Integer.toString(id.getAndIncrement()));\n    return docState.doc;\n  }\n\n","sourceOld":"  /** Note: Document instance is re-used per-thread */\n  public Document nextDoc() throws IOException {\n    String line;\n    synchronized(this) {\n      line = reader.readLine();\n      if (line == null) {\n        // Always rewind at end:\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: now rewind file...\");\n        }\n        close();\n        open(null);\n        line = reader.readLine();\n      }\n    }\n\n    DocState docState = threadDocs.get();\n    if (docState == null) {\n      docState = new DocState();\n      threadDocs.set(docState);\n    }\n\n    int spot = line.indexOf(SEP);\n    if (spot == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n    int spot2 = line.indexOf(SEP, 1 + spot);\n    if (spot2 == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n\n    docState.body.setValue(line.substring(1+spot2, line.length()));\n    final String title = line.substring(0, spot);\n    docState.title.setValue(title);\n    docState.titleTokenized.setValue(title);\n    docState.date.setValue(line.substring(1+spot, spot2));\n    docState.id.setValue(Integer.toString(id.getAndIncrement()));\n    return docState.doc;\n  }\n\n","bugFix":["01b5702c02a50fec5cd548d8a459434379a5908f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86365ce8db75e42ebe10805e99e92c463fef63b6","date":1330370408,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#nextDoc().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#nextDoc().mjava","sourceNew":"  /** Note: Document instance is re-used per-thread */\n  public Document nextDoc() throws IOException {\n    String line;\n    synchronized(this) {\n      line = reader.readLine();\n      if (line == null) {\n        // Always rewind at end:\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: now rewind file...\");\n        }\n        close();\n        open(null);\n        line = reader.readLine();\n      }\n    }\n\n    DocState docState = threadDocs.get();\n    if (docState == null) {\n      docState = new DocState(useDocValues);\n      threadDocs.set(docState);\n    }\n\n    int spot = line.indexOf(SEP);\n    if (spot == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n    int spot2 = line.indexOf(SEP, 1 + spot);\n    if (spot2 == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n\n    docState.body.setStringValue(line.substring(1+spot2, line.length()));\n    final String title = line.substring(0, spot);\n    docState.title.setStringValue(title);\n    if (docState.titleDV != null) {\n      docState.titleDV.setBytesValue(new BytesRef(title));\n    }\n    docState.titleTokenized.setStringValue(title);\n    docState.date.setStringValue(line.substring(1+spot, spot2));\n    docState.id.setStringValue(Integer.toString(id.getAndIncrement()));\n    return docState.doc;\n  }\n\n","sourceOld":"  /** Note: Document instance is re-used per-thread */\n  public Document nextDoc() throws IOException {\n    String line;\n    synchronized(this) {\n      line = reader.readLine();\n      if (line == null) {\n        // Always rewind at end:\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: now rewind file...\");\n        }\n        close();\n        open(null);\n        line = reader.readLine();\n      }\n    }\n\n    DocState docState = threadDocs.get();\n    if (docState == null) {\n      docState = new DocState();\n      threadDocs.set(docState);\n    }\n\n    int spot = line.indexOf(SEP);\n    if (spot == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n    int spot2 = line.indexOf(SEP, 1 + spot);\n    if (spot2 == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n\n    docState.body.setStringValue(line.substring(1+spot2, line.length()));\n    final String title = line.substring(0, spot);\n    docState.title.setStringValue(title);\n    docState.titleTokenized.setStringValue(title);\n    docState.date.setStringValue(line.substring(1+spot, spot2));\n    docState.id.setStringValue(Integer.toString(id.getAndIncrement()));\n    return docState.doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#nextDoc().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#nextDoc().mjava","sourceNew":"  /** Note: Document instance is re-used per-thread */\n  public Document nextDoc() throws IOException {\n    String line;\n    synchronized(this) {\n      line = reader.readLine();\n      if (line == null) {\n        // Always rewind at end:\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: now rewind file...\");\n        }\n        close();\n        open(null);\n        line = reader.readLine();\n      }\n    }\n\n    DocState docState = threadDocs.get();\n    if (docState == null) {\n      docState = new DocState(useDocValues);\n      threadDocs.set(docState);\n    }\n\n    int spot = line.indexOf(SEP);\n    if (spot == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n    int spot2 = line.indexOf(SEP, 1 + spot);\n    if (spot2 == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n\n    docState.body.setStringValue(line.substring(1+spot2, line.length()));\n    final String title = line.substring(0, spot);\n    docState.title.setStringValue(title);\n    if (docState.titleDV != null) {\n      docState.titleDV.setBytesValue(new BytesRef(title));\n    }\n    docState.titleTokenized.setStringValue(title);\n    docState.date.setStringValue(line.substring(1+spot, spot2));\n    docState.id.setStringValue(Integer.toString(id.getAndIncrement()));\n    return docState.doc;\n  }\n\n","sourceOld":"  /** Note: Document instance is re-used per-thread */\n  public Document nextDoc() throws IOException {\n    String line;\n    synchronized(this) {\n      line = reader.readLine();\n      if (line == null) {\n        // Always rewind at end:\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: now rewind file...\");\n        }\n        close();\n        open(null);\n        line = reader.readLine();\n      }\n    }\n\n    DocState docState = threadDocs.get();\n    if (docState == null) {\n      docState = new DocState();\n      threadDocs.set(docState);\n    }\n\n    int spot = line.indexOf(SEP);\n    if (spot == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n    int spot2 = line.indexOf(SEP, 1 + spot);\n    if (spot2 == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n\n    docState.body.setStringValue(line.substring(1+spot2, line.length()));\n    final String title = line.substring(0, spot);\n    docState.title.setStringValue(title);\n    docState.titleTokenized.setStringValue(title);\n    docState.date.setStringValue(line.substring(1+spot, spot2));\n    docState.id.setStringValue(Integer.toString(id.getAndIncrement()));\n    return docState.doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59a0020b413d44dd79d85d7a66ed5004265fb453","date":1371758877,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#nextDoc().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#nextDoc().mjava","sourceNew":"  /** Note: Document instance is re-used per-thread */\n  public Document nextDoc() throws IOException {\n    String line;\n    synchronized(this) {\n      line = reader.readLine();\n      if (line == null) {\n        // Always rewind at end:\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: now rewind file...\");\n        }\n        close();\n        open(null);\n        line = reader.readLine();\n      }\n    }\n\n    DocState docState = threadDocs.get();\n    if (docState == null) {\n      docState = new DocState(useDocValues);\n      threadDocs.set(docState);\n    }\n\n    int spot = line.indexOf(SEP);\n    if (spot == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n    int spot2 = line.indexOf(SEP, 1 + spot);\n    if (spot2 == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n\n    docState.body.setStringValue(line.substring(1+spot2, line.length()));\n    final String title = line.substring(0, spot);\n    docState.title.setStringValue(title);\n    if (docState.titleDV != null) {\n      docState.titleDV.setBytesValue(new BytesRef(title));\n    }\n    docState.titleTokenized.setStringValue(title);\n    docState.date.setStringValue(line.substring(1+spot, spot2));\n    final int i = id.getAndIncrement();\n    docState.id.setStringValue(Integer.toString(i));\n    docState.idNum.setIntValue(i);\n    return docState.doc;\n  }\n\n","sourceOld":"  /** Note: Document instance is re-used per-thread */\n  public Document nextDoc() throws IOException {\n    String line;\n    synchronized(this) {\n      line = reader.readLine();\n      if (line == null) {\n        // Always rewind at end:\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: now rewind file...\");\n        }\n        close();\n        open(null);\n        line = reader.readLine();\n      }\n    }\n\n    DocState docState = threadDocs.get();\n    if (docState == null) {\n      docState = new DocState(useDocValues);\n      threadDocs.set(docState);\n    }\n\n    int spot = line.indexOf(SEP);\n    if (spot == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n    int spot2 = line.indexOf(SEP, 1 + spot);\n    if (spot2 == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n\n    docState.body.setStringValue(line.substring(1+spot2, line.length()));\n    final String title = line.substring(0, spot);\n    docState.title.setStringValue(title);\n    if (docState.titleDV != null) {\n      docState.titleDV.setBytesValue(new BytesRef(title));\n    }\n    docState.titleTokenized.setStringValue(title);\n    docState.date.setStringValue(line.substring(1+spot, spot2));\n    docState.id.setStringValue(Integer.toString(id.getAndIncrement()));\n    return docState.doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#nextDoc().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#nextDoc().mjava","sourceNew":"  /** Note: Document instance is re-used per-thread */\n  public Document nextDoc() throws IOException {\n    String line;\n    synchronized(this) {\n      line = reader.readLine();\n      if (line == null) {\n        // Always rewind at end:\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: now rewind file...\");\n        }\n        close();\n        open(null);\n        line = reader.readLine();\n      }\n    }\n\n    DocState docState = threadDocs.get();\n    if (docState == null) {\n      docState = new DocState(useDocValues);\n      threadDocs.set(docState);\n    }\n\n    int spot = line.indexOf(SEP);\n    if (spot == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n    int spot2 = line.indexOf(SEP, 1 + spot);\n    if (spot2 == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n\n    docState.body.setStringValue(line.substring(1+spot2, line.length()));\n    final String title = line.substring(0, spot);\n    docState.title.setStringValue(title);\n    if (docState.titleDV != null) {\n      docState.titleDV.setBytesValue(new BytesRef(title));\n    }\n    docState.titleTokenized.setStringValue(title);\n    docState.date.setStringValue(line.substring(1+spot, spot2));\n    final int i = id.getAndIncrement();\n    docState.id.setStringValue(Integer.toString(i));\n    docState.idNum.setIntValue(i);\n    return docState.doc;\n  }\n\n","sourceOld":"  /** Note: Document instance is re-used per-thread */\n  public Document nextDoc() throws IOException {\n    String line;\n    synchronized(this) {\n      line = reader.readLine();\n      if (line == null) {\n        // Always rewind at end:\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: now rewind file...\");\n        }\n        close();\n        open(null);\n        line = reader.readLine();\n      }\n    }\n\n    DocState docState = threadDocs.get();\n    if (docState == null) {\n      docState = new DocState(useDocValues);\n      threadDocs.set(docState);\n    }\n\n    int spot = line.indexOf(SEP);\n    if (spot == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n    int spot2 = line.indexOf(SEP, 1 + spot);\n    if (spot2 == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n\n    docState.body.setStringValue(line.substring(1+spot2, line.length()));\n    final String title = line.substring(0, spot);\n    docState.title.setStringValue(title);\n    if (docState.titleDV != null) {\n      docState.titleDV.setBytesValue(new BytesRef(title));\n    }\n    docState.titleTokenized.setStringValue(title);\n    docState.date.setStringValue(line.substring(1+spot, spot2));\n    docState.id.setStringValue(Integer.toString(id.getAndIncrement()));\n    return docState.doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ed6b1234af94a2693d3e6550e7b3ee41fd3f51c","date":1416362965,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#nextDoc().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#nextDoc().mjava","sourceNew":"  /** Note: Document instance is re-used per-thread */\n  public Document nextDoc() throws IOException {\n    String line;\n    synchronized(this) {\n      line = reader.readLine();\n      if (line == null) {\n        // Always rewind at end:\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: now rewind file...\");\n        }\n        close();\n        open(null);\n        line = reader.readLine();\n      }\n    }\n\n    DocState docState = threadDocs.get();\n    if (docState == null) {\n      docState = new DocState(useDocValues);\n      threadDocs.set(docState);\n    }\n\n    int spot = line.indexOf(SEP);\n    if (spot == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n    int spot2 = line.indexOf(SEP, 1 + spot);\n    if (spot2 == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n\n    docState.body.setStringValue(line.substring(1+spot2, line.length()));\n    final String title = line.substring(0, spot);\n    docState.title.setStringValue(title);\n    if (docState.titleDV != null) {\n      docState.titleDV.setBytesValue(new BytesRef(title));\n    }\n    docState.titleTokenized.setStringValue(title);\n    docState.date.setStringValue(line.substring(1+spot, spot2));\n    final int i = id.getAndIncrement();\n    docState.id.setStringValue(Integer.toString(i));\n    docState.idNum.setIntValue(i);\n    if (docState.idNumDV != null) {\n      docState.idNumDV.setLongValue(i);\n    }\n    return docState.doc;\n  }\n\n","sourceOld":"  /** Note: Document instance is re-used per-thread */\n  public Document nextDoc() throws IOException {\n    String line;\n    synchronized(this) {\n      line = reader.readLine();\n      if (line == null) {\n        // Always rewind at end:\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: now rewind file...\");\n        }\n        close();\n        open(null);\n        line = reader.readLine();\n      }\n    }\n\n    DocState docState = threadDocs.get();\n    if (docState == null) {\n      docState = new DocState(useDocValues);\n      threadDocs.set(docState);\n    }\n\n    int spot = line.indexOf(SEP);\n    if (spot == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n    int spot2 = line.indexOf(SEP, 1 + spot);\n    if (spot2 == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n\n    docState.body.setStringValue(line.substring(1+spot2, line.length()));\n    final String title = line.substring(0, spot);\n    docState.title.setStringValue(title);\n    if (docState.titleDV != null) {\n      docState.titleDV.setBytesValue(new BytesRef(title));\n    }\n    docState.titleTokenized.setStringValue(title);\n    docState.date.setStringValue(line.substring(1+spot, spot2));\n    final int i = id.getAndIncrement();\n    docState.id.setStringValue(Integer.toString(i));\n    docState.idNum.setIntValue(i);\n    return docState.doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"edf3884ae1f2a71b2e1c12fb514407dfc9bf81b2","date":1427842554,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#nextDoc().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#nextDoc().mjava","sourceNew":"  /** Note: Document instance is re-used per-thread */\n  public Document nextDoc() throws IOException {\n    String line;\n    synchronized(this) {\n      line = reader.readLine();\n      if (line == null) {\n        // Always rewind at end:\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: now rewind file...\");\n        }\n        reader.close();\n        reader = null;\n        open(null);\n        line = reader.readLine();\n      }\n    }\n\n    DocState docState = threadDocs.get();\n    if (docState == null) {\n      docState = new DocState(useDocValues);\n      threadDocs.set(docState);\n    }\n\n    int spot = line.indexOf(SEP);\n    if (spot == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n    int spot2 = line.indexOf(SEP, 1 + spot);\n    if (spot2 == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n\n    docState.body.setStringValue(line.substring(1+spot2, line.length()));\n    final String title = line.substring(0, spot);\n    docState.title.setStringValue(title);\n    if (docState.titleDV != null) {\n      docState.titleDV.setBytesValue(new BytesRef(title));\n    }\n    docState.titleTokenized.setStringValue(title);\n    docState.date.setStringValue(line.substring(1+spot, spot2));\n    final int i = id.getAndIncrement();\n    docState.id.setStringValue(Integer.toString(i));\n    docState.idNum.setIntValue(i);\n    if (docState.idNumDV != null) {\n      docState.idNumDV.setLongValue(i);\n    }\n    return docState.doc;\n  }\n\n","sourceOld":"  /** Note: Document instance is re-used per-thread */\n  public Document nextDoc() throws IOException {\n    String line;\n    synchronized(this) {\n      line = reader.readLine();\n      if (line == null) {\n        // Always rewind at end:\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: now rewind file...\");\n        }\n        close();\n        open(null);\n        line = reader.readLine();\n      }\n    }\n\n    DocState docState = threadDocs.get();\n    if (docState == null) {\n      docState = new DocState(useDocValues);\n      threadDocs.set(docState);\n    }\n\n    int spot = line.indexOf(SEP);\n    if (spot == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n    int spot2 = line.indexOf(SEP, 1 + spot);\n    if (spot2 == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n\n    docState.body.setStringValue(line.substring(1+spot2, line.length()));\n    final String title = line.substring(0, spot);\n    docState.title.setStringValue(title);\n    if (docState.titleDV != null) {\n      docState.titleDV.setBytesValue(new BytesRef(title));\n    }\n    docState.titleTokenized.setStringValue(title);\n    docState.date.setStringValue(line.substring(1+spot, spot2));\n    final int i = id.getAndIncrement();\n    docState.id.setStringValue(Integer.toString(i));\n    docState.idNum.setIntValue(i);\n    if (docState.idNumDV != null) {\n      docState.idNumDV.setLongValue(i);\n    }\n    return docState.doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c576bf71df117a2003cac1787df5a9a5de44eb6","date":1427849700,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#nextDoc().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#nextDoc().mjava","sourceNew":"  /** Note: Document instance is re-used per-thread */\n  public Document nextDoc() throws IOException {\n    String line;\n    synchronized(this) {\n      line = reader.readLine();\n      if (line == null) {\n        // Always rewind at end:\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: now rewind file...\");\n        }\n        reader.close();\n        reader = null;\n        open(null);\n        line = reader.readLine();\n      }\n    }\n\n    DocState docState = threadDocs.get();\n    if (docState == null) {\n      docState = new DocState(useDocValues);\n      threadDocs.set(docState);\n    }\n\n    int spot = line.indexOf(SEP);\n    if (spot == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n    int spot2 = line.indexOf(SEP, 1 + spot);\n    if (spot2 == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n\n    docState.body.setStringValue(line.substring(1+spot2, line.length()));\n    final String title = line.substring(0, spot);\n    docState.title.setStringValue(title);\n    if (docState.titleDV != null) {\n      docState.titleDV.setBytesValue(new BytesRef(title));\n    }\n    docState.titleTokenized.setStringValue(title);\n    docState.date.setStringValue(line.substring(1+spot, spot2));\n    final int i = id.getAndIncrement();\n    docState.id.setStringValue(Integer.toString(i));\n    docState.idNum.setIntValue(i);\n    if (docState.idNumDV != null) {\n      docState.idNumDV.setLongValue(i);\n    }\n    return docState.doc;\n  }\n\n","sourceOld":"  /** Note: Document instance is re-used per-thread */\n  public Document nextDoc() throws IOException {\n    String line;\n    synchronized(this) {\n      line = reader.readLine();\n      if (line == null) {\n        // Always rewind at end:\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: now rewind file...\");\n        }\n        close();\n        open(null);\n        line = reader.readLine();\n      }\n    }\n\n    DocState docState = threadDocs.get();\n    if (docState == null) {\n      docState = new DocState(useDocValues);\n      threadDocs.set(docState);\n    }\n\n    int spot = line.indexOf(SEP);\n    if (spot == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n    int spot2 = line.indexOf(SEP, 1 + spot);\n    if (spot2 == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n\n    docState.body.setStringValue(line.substring(1+spot2, line.length()));\n    final String title = line.substring(0, spot);\n    docState.title.setStringValue(title);\n    if (docState.titleDV != null) {\n      docState.titleDV.setBytesValue(new BytesRef(title));\n    }\n    docState.titleTokenized.setStringValue(title);\n    docState.date.setStringValue(line.substring(1+spot, spot2));\n    final int i = id.getAndIncrement();\n    docState.id.setStringValue(Integer.toString(i));\n    docState.idNum.setIntValue(i);\n    if (docState.idNumDV != null) {\n      docState.idNumDV.setLongValue(i);\n    }\n    return docState.doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"221076a44effb5561a3b799974ba1a35119fbcc0","date":1457468497,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#nextDoc().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#nextDoc().mjava","sourceNew":"  /** Note: Document instance is re-used per-thread */\n  public Document nextDoc() throws IOException {\n    String line;\n    synchronized(this) {\n      line = reader.readLine();\n      if (line == null) {\n        // Always rewind at end:\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: now rewind file...\");\n        }\n        reader.close();\n        reader = null;\n        open(null);\n        line = reader.readLine();\n      }\n    }\n\n    DocState docState = threadDocs.get();\n    if (docState == null) {\n      docState = new DocState();\n      threadDocs.set(docState);\n    }\n\n    int spot = line.indexOf(SEP);\n    if (spot == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n    int spot2 = line.indexOf(SEP, 1 + spot);\n    if (spot2 == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n\n    docState.body.setStringValue(line.substring(1+spot2, line.length()));\n    final String title = line.substring(0, spot);\n    docState.title.setStringValue(title);\n    if (docState.titleDV != null) {\n      docState.titleDV.setBytesValue(new BytesRef(title));\n    }\n    docState.titleTokenized.setStringValue(title);\n    docState.date.setStringValue(line.substring(1+spot, spot2));\n    final int i = id.getAndIncrement();\n    docState.id.setStringValue(Integer.toString(i));\n    docState.idNum.setIntValue(i);\n    if (docState.idNumDV != null) {\n      docState.idNumDV.setLongValue(i);\n    }\n\n    if (random.nextInt(5) == 4) {\n      // Make some sparse fields\n      Document doc = new Document();\n      for(IndexableField field : docState.doc) {\n        doc.add(field);\n      }\n\n      if (random.nextInt(3) == 1) {\n        int x = random.nextInt(4);\n        doc.add(new IntPoint(\"docLength\" + x, line.length()));\n      }\n\n      if (random.nextInt(3) == 1) {\n        int x = random.nextInt(4);\n        doc.add(new IntPoint(\"docTitleLength\" + x, title.length()));\n      }\n\n      if (random.nextInt(3) == 1) {\n        int x = random.nextInt(4);\n        doc.add(new NumericDocValuesField(\"docLength\" + x, line.length()));\n      }\n\n      // TODO: more random sparse fields here too\n    }\n\n    return docState.doc;\n  }\n\n","sourceOld":"  /** Note: Document instance is re-used per-thread */\n  public Document nextDoc() throws IOException {\n    String line;\n    synchronized(this) {\n      line = reader.readLine();\n      if (line == null) {\n        // Always rewind at end:\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: now rewind file...\");\n        }\n        reader.close();\n        reader = null;\n        open(null);\n        line = reader.readLine();\n      }\n    }\n\n    DocState docState = threadDocs.get();\n    if (docState == null) {\n      docState = new DocState(useDocValues);\n      threadDocs.set(docState);\n    }\n\n    int spot = line.indexOf(SEP);\n    if (spot == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n    int spot2 = line.indexOf(SEP, 1 + spot);\n    if (spot2 == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n\n    docState.body.setStringValue(line.substring(1+spot2, line.length()));\n    final String title = line.substring(0, spot);\n    docState.title.setStringValue(title);\n    if (docState.titleDV != null) {\n      docState.titleDV.setBytesValue(new BytesRef(title));\n    }\n    docState.titleTokenized.setStringValue(title);\n    docState.date.setStringValue(line.substring(1+spot, spot2));\n    final int i = id.getAndIncrement();\n    docState.id.setStringValue(Integer.toString(i));\n    docState.idNum.setIntValue(i);\n    if (docState.idNumDV != null) {\n      docState.idNumDV.setLongValue(i);\n    }\n    return docState.doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"261bc548c130304500988d5439455607f5cc79be","date":1587485357,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#nextDoc().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs#nextDoc().mjava","sourceNew":"  /** Note: Document instance is re-used per-thread */\n  public Document nextDoc() throws IOException {\n    String line;\n    synchronized(this) {\n      line = reader.readLine();\n      if (line == null) {\n        // Always rewind at end:\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: now rewind file...\");\n        }\n        reader.close();\n        reader = null;\n        open();\n        line = reader.readLine();\n      }\n    }\n\n    DocState docState = threadDocs.get();\n    if (docState == null) {\n      docState = new DocState();\n      threadDocs.set(docState);\n    }\n\n    int spot = line.indexOf(SEP);\n    if (spot == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n    int spot2 = line.indexOf(SEP, 1 + spot);\n    if (spot2 == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n\n    docState.body.setStringValue(line.substring(1+spot2, line.length()));\n    final String title = line.substring(0, spot);\n    docState.title.setStringValue(title);\n    if (docState.titleDV != null) {\n      docState.titleDV.setBytesValue(new BytesRef(title));\n    }\n    docState.titleTokenized.setStringValue(title);\n    docState.date.setStringValue(line.substring(1+spot, spot2));\n    final int i = id.getAndIncrement();\n    docState.id.setStringValue(Integer.toString(i));\n    docState.idNum.setIntValue(i);\n    if (docState.idNumDV != null) {\n      docState.idNumDV.setLongValue(i);\n    }\n\n    if (random.nextInt(5) == 4) {\n      // Make some sparse fields\n      Document doc = new Document();\n      for(IndexableField field : docState.doc) {\n        doc.add(field);\n      }\n\n      if (random.nextInt(3) == 1) {\n        int x = random.nextInt(4);\n        doc.add(new IntPoint(\"docLength\" + x, line.length()));\n      }\n\n      if (random.nextInt(3) == 1) {\n        int x = random.nextInt(4);\n        doc.add(new IntPoint(\"docTitleLength\" + x, title.length()));\n      }\n\n      if (random.nextInt(3) == 1) {\n        int x = random.nextInt(4);\n        doc.add(new NumericDocValuesField(\"docLength\" + x, line.length()));\n      }\n\n      // TODO: more random sparse fields here too\n    }\n\n    return docState.doc;\n  }\n\n","sourceOld":"  /** Note: Document instance is re-used per-thread */\n  public Document nextDoc() throws IOException {\n    String line;\n    synchronized(this) {\n      line = reader.readLine();\n      if (line == null) {\n        // Always rewind at end:\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: LineFileDocs: now rewind file...\");\n        }\n        reader.close();\n        reader = null;\n        open(null);\n        line = reader.readLine();\n      }\n    }\n\n    DocState docState = threadDocs.get();\n    if (docState == null) {\n      docState = new DocState();\n      threadDocs.set(docState);\n    }\n\n    int spot = line.indexOf(SEP);\n    if (spot == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n    int spot2 = line.indexOf(SEP, 1 + spot);\n    if (spot2 == -1) {\n      throw new RuntimeException(\"line: [\" + line + \"] is in an invalid format !\");\n    }\n\n    docState.body.setStringValue(line.substring(1+spot2, line.length()));\n    final String title = line.substring(0, spot);\n    docState.title.setStringValue(title);\n    if (docState.titleDV != null) {\n      docState.titleDV.setBytesValue(new BytesRef(title));\n    }\n    docState.titleTokenized.setStringValue(title);\n    docState.date.setStringValue(line.substring(1+spot, spot2));\n    final int i = id.getAndIncrement();\n    docState.id.setStringValue(Integer.toString(i));\n    docState.idNum.setIntValue(i);\n    if (docState.idNumDV != null) {\n      docState.idNumDV.setLongValue(i);\n    }\n\n    if (random.nextInt(5) == 4) {\n      // Make some sparse fields\n      Document doc = new Document();\n      for(IndexableField field : docState.doc) {\n        doc.add(field);\n      }\n\n      if (random.nextInt(3) == 1) {\n        int x = random.nextInt(4);\n        doc.add(new IntPoint(\"docLength\" + x, line.length()));\n      }\n\n      if (random.nextInt(3) == 1) {\n        int x = random.nextInt(4);\n        doc.add(new IntPoint(\"docTitleLength\" + x, title.length()));\n      }\n\n      if (random.nextInt(3) == 1) {\n        int x = random.nextInt(4);\n        doc.add(new NumericDocValuesField(\"docLength\" + x, line.length()));\n      }\n\n      // TODO: more random sparse fields here too\n    }\n\n    return docState.doc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"edf3884ae1f2a71b2e1c12fb514407dfc9bf81b2":["0ed6b1234af94a2693d3e6550e7b3ee41fd3f51c"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["86365ce8db75e42ebe10805e99e92c463fef63b6","59a0020b413d44dd79d85d7a66ed5004265fb453"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["a78a90fc9701e511308346ea29f4f5e548bb39fe","86365ce8db75e42ebe10805e99e92c463fef63b6"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"86365ce8db75e42ebe10805e99e92c463fef63b6":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"6c576bf71df117a2003cac1787df5a9a5de44eb6":["0ed6b1234af94a2693d3e6550e7b3ee41fd3f51c"],"221076a44effb5561a3b799974ba1a35119fbcc0":["6c576bf71df117a2003cac1787df5a9a5de44eb6"],"0ed6b1234af94a2693d3e6550e7b3ee41fd3f51c":["59a0020b413d44dd79d85d7a66ed5004265fb453"],"a78a90fc9701e511308346ea29f4f5e548bb39fe":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"261bc548c130304500988d5439455607f5cc79be":["221076a44effb5561a3b799974ba1a35119fbcc0"],"59a0020b413d44dd79d85d7a66ed5004265fb453":["86365ce8db75e42ebe10805e99e92c463fef63b6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["261bc548c130304500988d5439455607f5cc79be"]},"commit2Childs":{"edf3884ae1f2a71b2e1c12fb514407dfc9bf81b2":[],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"86365ce8db75e42ebe10805e99e92c463fef63b6":["37a0f60745e53927c4c876cfe5b5a58170f0646c","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","59a0020b413d44dd79d85d7a66ed5004265fb453"],"6c576bf71df117a2003cac1787df5a9a5de44eb6":["221076a44effb5561a3b799974ba1a35119fbcc0"],"221076a44effb5561a3b799974ba1a35119fbcc0":["261bc548c130304500988d5439455607f5cc79be"],"0ed6b1234af94a2693d3e6550e7b3ee41fd3f51c":["edf3884ae1f2a71b2e1c12fb514407dfc9bf81b2","6c576bf71df117a2003cac1787df5a9a5de44eb6"],"a78a90fc9701e511308346ea29f4f5e548bb39fe":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","86365ce8db75e42ebe10805e99e92c463fef63b6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"59a0020b413d44dd79d85d7a66ed5004265fb453":["37a0f60745e53927c4c876cfe5b5a58170f0646c","0ed6b1234af94a2693d3e6550e7b3ee41fd3f51c"],"261bc548c130304500988d5439455607f5cc79be":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["edf3884ae1f2a71b2e1c12fb514407dfc9bf81b2","37a0f60745e53927c4c876cfe5b5a58170f0646c","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}