{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String).mjava","commits":[{"id":"3eaeb36333664e8cb92108ef03f68a7b90beb759","date":1480015298,"type":1,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    collection = stateProvider.getCollectionName(collection);\n\n    DocCollection col = getDocCollection(collection, null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col);\n    final Map<String, LBHttpSolrClient.Req> routes = (urlMap == null ? null : updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField));\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n          // we have info (documents with ids and/or ids to delete) with\n          // which to find the leaders but we could not find (all of) them\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> lbClient.request(lbRequest).getResponse()));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col);\n    final Map<String, LBHttpSolrClient.Req> routes = (urlMap == null ? null : updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField));\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n          // we have info (documents with ids and/or ids to delete) with\n          // which to find the leaders but we could not find (all of) them\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> lbClient.request(lbRequest).getResponse()));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"727bb765ff2542275f6d31f67be18d7104bae148","date":1480353976,"type":1,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    collection = stateProvider.getCollectionName(collection);\n\n    DocCollection col = getDocCollection(collection, null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col);\n    final Map<String, LBHttpSolrClient.Req> routes = (urlMap == null ? null : updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField));\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n          // we have info (documents with ids and/or ids to delete) with\n          // which to find the leaders but we could not find (all of) them\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> lbClient.request(lbRequest).getResponse()));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col);\n    final Map<String, LBHttpSolrClient.Req> routes = (urlMap == null ? null : updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField));\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n          // we have info (documents with ids and/or ids to delete) with\n          // which to find the leaders but we could not find (all of) them\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> lbClient.request(lbRequest).getResponse()));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b824daa61db3f30b91a22213d6c04e1fa2e2b06","date":1508385744,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    SolrParams params = request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n    //Check to see if the collection is an alias.\n    List<String> aliasedCollections = stateProvider.resolveAlias(collection);\n    collection = aliasedCollections.get(0); // pick 1st (consistent with HttpSolrCall behavior)\n\n    DocCollection col = getDocCollection(collection, null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col);\n    final Map<String, LBHttpSolrClient.Req> routes = (urlMap == null ? null : updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField));\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n          // we have info (documents with ids and/or ids to delete) with\n          // which to find the leaders but we could not find (all of) them\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> lbClient.request(lbRequest).getResponse()));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    collection = stateProvider.getCollectionName(collection);\n\n    DocCollection col = getDocCollection(collection, null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col);\n    final Map<String, LBHttpSolrClient.Req> routes = (urlMap == null ? null : updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField));\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n          // we have info (documents with ids and/or ids to delete) with\n          // which to find the leaders but we could not find (all of) them\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> lbClient.request(lbRequest).getResponse()));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"39a9e7b7364ba343ceb6ea953b753d977e10e65b","date":1522685822,"type":3,"author":"Erick","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    SolrParams params = request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n    //Check to see if the collection is an alias.\n    List<String> aliasedCollections = stateProvider.resolveAlias(collection);\n    collection = aliasedCollections.get(0); // pick 1st (consistent with HttpSolrCall behavior)\n\n    DocCollection col = getDocCollection(collection, null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col);\n    final Map<String, LBHttpSolrClient.Req> routes = (urlMap == null ? null : updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField));\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n          // we have info (documents with ids and/or ids to delete) with\n          // which to find the leaders but we could not find (all of) them\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> lbClient.request(lbRequest).getResponse()));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      nonRoutableRequest.setBasicAuthCredentials(request.getBasicAuthUser(), request.getBasicAuthPassword());\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    SolrParams params = request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n    //Check to see if the collection is an alias.\n    List<String> aliasedCollections = stateProvider.resolveAlias(collection);\n    collection = aliasedCollections.get(0); // pick 1st (consistent with HttpSolrCall behavior)\n\n    DocCollection col = getDocCollection(collection, null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col);\n    final Map<String, LBHttpSolrClient.Req> routes = (urlMap == null ? null : updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField));\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n          // we have info (documents with ids and/or ids to delete) with\n          // which to find the leaders but we could not find (all of) them\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> lbClient.request(lbRequest).getResponse()));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0544142c22eb88b6d8b3817f2e1190156aa4f9af","date":1551692505,"type":5,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#directUpdate(AbstractUpdateRequest,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    SolrParams params = request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n    //Check to see if the collection is an alias.\n    List<String> aliasedCollections = getClusterStateProvider().resolveAlias(collection);\n    collection = aliasedCollections.get(0); // pick 1st (consistent with HttpSolrCall behavior)\n\n    DocCollection col = getDocCollection(collection, null);\n\n    DocRouter router = col.getRouter();\n\n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col);\n    final Map<String, ? extends LBSolrClient.Req> routes = createRoutes(updateRequest, routableParams, col, router, urlMap, idField);\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n        // we have info (documents with ids and/or ids to delete) with\n        // which to find the leaders but we could not find (all of) them\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n            \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, ? extends LBSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> {\n            return getLbClient().request(lbRequest).getResponse();\n          }));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw getRouteException(SolrException.ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw getRouteException(SolrException.ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, ? extends LBSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = getLbClient().request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n\n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n\n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n\n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      nonRoutableRequest.setBasicAuthCredentials(request.getBasicAuthUser(), request.getBasicAuthPassword());\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBSolrClient.Req req = new LBSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBSolrClient.Rsp rsp = getLbClient().request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    SolrParams params = request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n    //Check to see if the collection is an alias.\n    List<String> aliasedCollections = stateProvider.resolveAlias(collection);\n    collection = aliasedCollections.get(0); // pick 1st (consistent with HttpSolrCall behavior)\n\n    DocCollection col = getDocCollection(collection, null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    final Map<String,List<String>> urlMap = buildUrlMap(col);\n    final Map<String, LBHttpSolrClient.Req> routes = (urlMap == null ? null : updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField));\n    if (routes == null) {\n      if (directUpdatesToLeadersOnly && hasInfoToFindLeaders(updateRequest, idField)) {\n          // we have info (documents with ids and/or ids to delete) with\n          // which to find the leaders but we could not find (all of) them\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"directUpdatesToLeadersOnly==true but could not find leader(s)\");\n      } else {\n        // we could not find a leader or routes yet - use unoptimized general path\n        return null;\n      }\n    }\n\n    final NamedList<Throwable> exceptions = new NamedList<>();\n    final NamedList<NamedList> shardResponses = new NamedList<>(routes.size()+1); // +1 for deleteQuery\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          MDC.put(\"CloudSolrClient.url\", url);\n          responseFutures.put(url, threadPool.submit(() -> lbClient.request(lbRequest).getResponse()));\n        } finally {\n          MDC.remove(\"CloudSolrClient.url\");\n        }\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        Throwable firstException = exceptions.getVal(0);\n        if(firstException instanceof SolrException) {\n          SolrException e = (SolrException) firstException;\n          throw new RouteException(ErrorCode.getErrorCode(e.code()), exceptions, routes);\n        } else {\n          throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n        }\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          if(e instanceof SolrException) {\n            throw (SolrException) e;\n          } else {\n            throw new SolrServerException(e);\n          }\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      nonRoutableRequest.setBasicAuthCredentials(request.getBasicAuthUser(), request.getBasicAuthPassword());\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr = condenseResponse(shardResponses, (int) TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"39a9e7b7364ba343ceb6ea953b753d977e10e65b":["6b824daa61db3f30b91a22213d6c04e1fa2e2b06"],"6b824daa61db3f30b91a22213d6c04e1fa2e2b06":["3eaeb36333664e8cb92108ef03f68a7b90beb759"],"0544142c22eb88b6d8b3817f2e1190156aa4f9af":["39a9e7b7364ba343ceb6ea953b753d977e10e65b"],"727bb765ff2542275f6d31f67be18d7104bae148":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3eaeb36333664e8cb92108ef03f68a7b90beb759"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3eaeb36333664e8cb92108ef03f68a7b90beb759":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0544142c22eb88b6d8b3817f2e1190156aa4f9af"]},"commit2Childs":{"39a9e7b7364ba343ceb6ea953b753d977e10e65b":["0544142c22eb88b6d8b3817f2e1190156aa4f9af"],"6b824daa61db3f30b91a22213d6c04e1fa2e2b06":["39a9e7b7364ba343ceb6ea953b753d977e10e65b"],"0544142c22eb88b6d8b3817f2e1190156aa4f9af":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"727bb765ff2542275f6d31f67be18d7104bae148":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["727bb765ff2542275f6d31f67be18d7104bae148","3eaeb36333664e8cb92108ef03f68a7b90beb759"],"3eaeb36333664e8cb92108ef03f68a7b90beb759":["6b824daa61db3f30b91a22213d6c04e1fa2e2b06","727bb765ff2542275f6d31f67be18d7104bae148"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["727bb765ff2542275f6d31f67be18d7104bae148","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}