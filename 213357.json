{"path":"solr/core/src/java/org/apache/solr/security/Permission#load(Map).mjava","commits":[{"id":"85784a21c6101aadd8d5b3d9dfed51279fbd43d9","date":1458237890,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/security/Permission#load(Map).mjava","pathOld":"/dev/null","sourceNew":"  static Permission load(Map m) {\n    Permission p = new Permission();\n    String name = (String) m.get(NAME);\n    if (!m.containsKey(\"role\")) throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"role not specified\");\n    p.role = readValueAsSet(m, \"role\");\n    if (PermissionNameProvider.Name.get(name)!= null) {\n      p.wellknownName = PermissionNameProvider.Name.get(name);\n      HashSet<String> disAllowed = new HashSet<>(knownKeys);\n      disAllowed.remove(\"role\");//these are the only\n      disAllowed.remove(NAME);//allowed keys for well-known permissions\n      disAllowed.remove(\"collection\");//allowed keys for well-known permissions\n      disAllowed.remove(\"index\");\n      for (String s : disAllowed) {\n        if (m.containsKey(s))\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, s + \" is not a valid key for the permission : \" + name);\n      }\n\n    }\n    p.name = name;\n    p.path = readSetSmart(name, m, \"path\");\n    p.collections = readSetSmart(name, m, \"collection\");\n    p.method = readSetSmart(name, m, \"method\");\n    p.params = (Map<String, Object>) m.get(\"params\");\n    return p;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["ebd6b7b6f5196cb5defe92032d6cc2147690954f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ebd6b7b6f5196cb5defe92032d6cc2147690954f","date":1462271185,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/security/Permission#load(Map).mjava","pathOld":"solr/core/src/java/org/apache/solr/security/Permission#load(Map).mjava","sourceNew":"  static Permission load(Map m) {\n    Permission p = new Permission();\n    String name = (String) m.get(NAME);\n    if (!m.containsKey(\"role\")) throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"role not specified\");\n    p.role = readValueAsSet(m, \"role\");\n    if (PermissionNameProvider.Name.get(name)!= null) {\n      p.wellknownName = PermissionNameProvider.Name.get(name);\n      HashSet<String> disAllowed = new HashSet<>(knownKeys);\n      disAllowed.remove(\"role\");//these are the only\n      disAllowed.remove(NAME);//allowed keys for well-known permissions\n      disAllowed.remove(\"collection\");//allowed keys for well-known permissions\n      disAllowed.remove(\"index\");\n      for (String s : disAllowed) {\n        if (m.containsKey(s))\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, s + \" is not a valid key for the permission : \" + name);\n      }\n\n    }\n    p.name = name;\n    p.path = readSetSmart(name, m, \"path\");\n    p.collections = readSetSmart(name, m, \"collection\");\n    p.method = readSetSmart(name, m, \"method\");\n    Map<String, Object> paramRules = (Map<String, Object>) m.get(\"params\");\n    if (paramRules != null) {\n      p.params = new LinkedHashMap<>();\n      for (Map.Entry<String, Object> e : paramRules.entrySet()) {\n        if (e.getValue() == null) {\n          p.params.put(e.getKey(), (String[] val) -> val == null);\n        } else {\n          List<String> patternStrs = e.getValue() instanceof List ?\n              (List) e.getValue() :\n              singletonList(e.getValue().toString());\n          List patterns = patternStrs.stream()\n              .map(it -> it.startsWith(\"REGEX:\") ?\n                  Pattern.compile(String.valueOf(it.substring(\"REGEX:\".length())))\n                  : it)\n              .collect(Collectors.toList());\n          p.params.put(e.getKey(), val -> {\n            if (val == null) return false;\n            for (Object pattern : patterns) {\n              for (String s : val) {\n                if (pattern instanceof String) {\n                  if (pattern.equals(s)) return true;\n                } else if (pattern instanceof Pattern) {\n                  if (((Pattern) pattern).matcher(s).find()) return true;\n                }\n              }\n            }\n            return false;\n          });\n        }\n      }\n    }\n    return p;\n  }\n\n","sourceOld":"  static Permission load(Map m) {\n    Permission p = new Permission();\n    String name = (String) m.get(NAME);\n    if (!m.containsKey(\"role\")) throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"role not specified\");\n    p.role = readValueAsSet(m, \"role\");\n    if (PermissionNameProvider.Name.get(name)!= null) {\n      p.wellknownName = PermissionNameProvider.Name.get(name);\n      HashSet<String> disAllowed = new HashSet<>(knownKeys);\n      disAllowed.remove(\"role\");//these are the only\n      disAllowed.remove(NAME);//allowed keys for well-known permissions\n      disAllowed.remove(\"collection\");//allowed keys for well-known permissions\n      disAllowed.remove(\"index\");\n      for (String s : disAllowed) {\n        if (m.containsKey(s))\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, s + \" is not a valid key for the permission : \" + name);\n      }\n\n    }\n    p.name = name;\n    p.path = readSetSmart(name, m, \"path\");\n    p.collections = readSetSmart(name, m, \"collection\");\n    p.method = readSetSmart(name, m, \"method\");\n    p.params = (Map<String, Object>) m.get(\"params\");\n    return p;\n  }\n\n","bugFix":["85784a21c6101aadd8d5b3d9dfed51279fbd43d9"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6548a35b9da836a0b749064ee61085bd7cd80ffb","date":1462272361,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/security/Permission#load(Map).mjava","pathOld":"solr/core/src/java/org/apache/solr/security/Permission#load(Map).mjava","sourceNew":"  static Permission load(Map m) {\n    Permission p = new Permission();\n    String name = (String) m.get(NAME);\n    if (!m.containsKey(\"role\")) throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"role not specified\");\n    p.role = readValueAsSet(m, \"role\");\n    if (PermissionNameProvider.Name.get(name)!= null) {\n      p.wellknownName = PermissionNameProvider.Name.get(name);\n      HashSet<String> disAllowed = new HashSet<>(knownKeys);\n      disAllowed.remove(\"role\");//these are the only\n      disAllowed.remove(NAME);//allowed keys for well-known permissions\n      disAllowed.remove(\"collection\");//allowed keys for well-known permissions\n      disAllowed.remove(\"index\");\n      for (String s : disAllowed) {\n        if (m.containsKey(s))\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, s + \" is not a valid key for the permission : \" + name);\n      }\n\n    }\n    p.name = name;\n    p.path = readSetSmart(name, m, \"path\");\n    p.collections = readSetSmart(name, m, \"collection\");\n    p.method = readSetSmart(name, m, \"method\");\n    Map<String, Object> paramRules = (Map<String, Object>) m.get(\"params\");\n    if (paramRules != null) {\n      p.params = new LinkedHashMap<>();\n      for (Map.Entry<String, Object> e : paramRules.entrySet()) {\n        if (e.getValue() == null) {\n          p.params.put(e.getKey(), (String[] val) -> val == null);\n        } else {\n          List<String> patternStrs = e.getValue() instanceof List ?\n              (List) e.getValue() :\n              singletonList(e.getValue().toString());\n          List patterns = patternStrs.stream()\n              .map(it -> it.startsWith(\"REGEX:\") ?\n                  Pattern.compile(String.valueOf(it.substring(\"REGEX:\".length())))\n                  : it)\n              .collect(Collectors.toList());\n          p.params.put(e.getKey(), val -> {\n            if (val == null) return false;\n            for (Object pattern : patterns) {\n              for (String s : val) {\n                if (pattern instanceof String) {\n                  if (pattern.equals(s)) return true;\n                } else if (pattern instanceof Pattern) {\n                  if (((Pattern) pattern).matcher(s).find()) return true;\n                }\n              }\n            }\n            return false;\n          });\n        }\n      }\n    }\n    return p;\n  }\n\n","sourceOld":"  static Permission load(Map m) {\n    Permission p = new Permission();\n    String name = (String) m.get(NAME);\n    if (!m.containsKey(\"role\")) throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"role not specified\");\n    p.role = readValueAsSet(m, \"role\");\n    if (PermissionNameProvider.Name.get(name)!= null) {\n      p.wellknownName = PermissionNameProvider.Name.get(name);\n      HashSet<String> disAllowed = new HashSet<>(knownKeys);\n      disAllowed.remove(\"role\");//these are the only\n      disAllowed.remove(NAME);//allowed keys for well-known permissions\n      disAllowed.remove(\"collection\");//allowed keys for well-known permissions\n      disAllowed.remove(\"index\");\n      for (String s : disAllowed) {\n        if (m.containsKey(s))\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, s + \" is not a valid key for the permission : \" + name);\n      }\n\n    }\n    p.name = name;\n    p.path = readSetSmart(name, m, \"path\");\n    p.collections = readSetSmart(name, m, \"collection\");\n    p.method = readSetSmart(name, m, \"method\");\n    p.params = (Map<String, Object>) m.get(\"params\");\n    return p;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55b50463286869f584cf849d1587a0fcd54d1dfa","date":1462378517,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/security/Permission#load(Map).mjava","pathOld":"solr/core/src/java/org/apache/solr/security/Permission#load(Map).mjava","sourceNew":"  static Permission load(Map m) {\n    Permission p = new Permission();\n    String name = (String) m.get(NAME);\n    if (!m.containsKey(\"role\")) throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"role not specified\");\n    p.role = readValueAsSet(m, \"role\");\n    if (PermissionNameProvider.Name.get(name)!= null) {\n      p.wellknownName = PermissionNameProvider.Name.get(name);\n      HashSet<String> disAllowed = new HashSet<>(knownKeys);\n      disAllowed.remove(\"role\");//these are the only\n      disAllowed.remove(NAME);//allowed keys for well-known permissions\n      disAllowed.remove(\"collection\");//allowed keys for well-known permissions\n      disAllowed.remove(\"index\");\n      for (String s : disAllowed) {\n        if (m.containsKey(s))\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, s + \" is not a valid key for the permission : \" + name);\n      }\n\n    }\n    p.name = name;\n    p.path = readSetSmart(name, m, \"path\");\n    p.collections = readSetSmart(name, m, \"collection\");\n    p.method = readSetSmart(name, m, \"method\");\n    Map<String, Object> paramRules = (Map<String, Object>) m.get(\"params\");\n    if (paramRules != null) {\n      p.params = new LinkedHashMap<>();\n      for (Map.Entry<String, Object> e : paramRules.entrySet()) {\n        if (e.getValue() == null) {\n          p.params.put(e.getKey(), (String[] val) -> val == null);\n        } else {\n          List<String> patternStrs = e.getValue() instanceof List ?\n              (List) e.getValue() :\n              singletonList(e.getValue().toString());\n          List patterns = patternStrs.stream()\n              .map(it -> it.startsWith(\"REGEX:\") ?\n                  Pattern.compile(String.valueOf(it.substring(\"REGEX:\".length())))\n                  : it)\n              .collect(Collectors.toList());\n          p.params.put(e.getKey(), val -> {\n            if (val == null) return false;\n            for (Object pattern : patterns) {\n              for (String s : val) {\n                if (pattern instanceof String) {\n                  if (pattern.equals(s)) return true;\n                } else if (pattern instanceof Pattern) {\n                  if (((Pattern) pattern).matcher(s).find()) return true;\n                }\n              }\n            }\n            return false;\n          });\n        }\n      }\n    }\n    return p;\n  }\n\n","sourceOld":"  static Permission load(Map m) {\n    Permission p = new Permission();\n    String name = (String) m.get(NAME);\n    if (!m.containsKey(\"role\")) throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"role not specified\");\n    p.role = readValueAsSet(m, \"role\");\n    if (PermissionNameProvider.Name.get(name)!= null) {\n      p.wellknownName = PermissionNameProvider.Name.get(name);\n      HashSet<String> disAllowed = new HashSet<>(knownKeys);\n      disAllowed.remove(\"role\");//these are the only\n      disAllowed.remove(NAME);//allowed keys for well-known permissions\n      disAllowed.remove(\"collection\");//allowed keys for well-known permissions\n      disAllowed.remove(\"index\");\n      for (String s : disAllowed) {\n        if (m.containsKey(s))\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, s + \" is not a valid key for the permission : \" + name);\n      }\n\n    }\n    p.name = name;\n    p.path = readSetSmart(name, m, \"path\");\n    p.collections = readSetSmart(name, m, \"collection\");\n    p.method = readSetSmart(name, m, \"method\");\n    p.params = (Map<String, Object>) m.get(\"params\");\n    return p;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a2673025c1f6208a4ab731e12f4e98a5e7f257cd","date":1463985317,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/security/Permission#load(Map).mjava","pathOld":"solr/core/src/java/org/apache/solr/security/Permission#load(Map).mjava","sourceNew":"  static Permission load(Map m) {\n    Permission p = new Permission();\n    p.originalConfig = new LinkedHashMap<>(m);\n    String name = (String) m.get(NAME);\n    if (!m.containsKey(\"role\")) throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"role not specified\");\n    p.role = readValueAsSet(m, \"role\");\n    if (PermissionNameProvider.Name.get(name)!= null) {\n      p.wellknownName = PermissionNameProvider.Name.get(name);\n      HashSet<String> disAllowed = new HashSet<>(knownKeys);\n      disAllowed.remove(\"role\");//these are the only\n      disAllowed.remove(NAME);//allowed keys for well-known permissions\n      disAllowed.remove(\"collection\");//allowed keys for well-known permissions\n      disAllowed.remove(\"index\");\n      for (String s : disAllowed) {\n        if (m.containsKey(s))\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, s + \" is not a valid key for the permission : \" + name);\n      }\n\n    }\n    p.name = name;\n    p.path = readSetSmart(name, m, \"path\");\n    p.collections = readSetSmart(name, m, \"collection\");\n    p.method = readSetSmart(name, m, \"method\");\n    Map<String, Object> paramRules = (Map<String, Object>) m.get(\"params\");\n    if (paramRules != null) {\n      p.params = new LinkedHashMap<>();\n      for (Map.Entry<String, Object> e : paramRules.entrySet()) {\n        if (e.getValue() == null) {\n          p.params.put(e.getKey(), (String[] val) -> val == null);\n        } else {\n          List<String> patternStrs = e.getValue() instanceof List ?\n              (List) e.getValue() :\n              singletonList(e.getValue().toString());\n          List patterns = patternStrs.stream()\n              .map(it -> it.startsWith(\"REGEX:\") ?\n                  Pattern.compile(String.valueOf(it.substring(\"REGEX:\".length())))\n                  : it)\n              .collect(Collectors.toList());\n          p.params.put(e.getKey(), val -> {\n            if (val == null) return false;\n            for (Object pattern : patterns) {\n              for (String s : val) {\n                if (pattern instanceof String) {\n                  if (pattern.equals(s)) return true;\n                } else if (pattern instanceof Pattern) {\n                  if (((Pattern) pattern).matcher(s).find()) return true;\n                }\n              }\n            }\n            return false;\n          });\n        }\n      }\n    }\n    return p;\n  }\n\n","sourceOld":"  static Permission load(Map m) {\n    Permission p = new Permission();\n    String name = (String) m.get(NAME);\n    if (!m.containsKey(\"role\")) throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"role not specified\");\n    p.role = readValueAsSet(m, \"role\");\n    if (PermissionNameProvider.Name.get(name)!= null) {\n      p.wellknownName = PermissionNameProvider.Name.get(name);\n      HashSet<String> disAllowed = new HashSet<>(knownKeys);\n      disAllowed.remove(\"role\");//these are the only\n      disAllowed.remove(NAME);//allowed keys for well-known permissions\n      disAllowed.remove(\"collection\");//allowed keys for well-known permissions\n      disAllowed.remove(\"index\");\n      for (String s : disAllowed) {\n        if (m.containsKey(s))\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, s + \" is not a valid key for the permission : \" + name);\n      }\n\n    }\n    p.name = name;\n    p.path = readSetSmart(name, m, \"path\");\n    p.collections = readSetSmart(name, m, \"collection\");\n    p.method = readSetSmart(name, m, \"method\");\n    Map<String, Object> paramRules = (Map<String, Object>) m.get(\"params\");\n    if (paramRules != null) {\n      p.params = new LinkedHashMap<>();\n      for (Map.Entry<String, Object> e : paramRules.entrySet()) {\n        if (e.getValue() == null) {\n          p.params.put(e.getKey(), (String[] val) -> val == null);\n        } else {\n          List<String> patternStrs = e.getValue() instanceof List ?\n              (List) e.getValue() :\n              singletonList(e.getValue().toString());\n          List patterns = patternStrs.stream()\n              .map(it -> it.startsWith(\"REGEX:\") ?\n                  Pattern.compile(String.valueOf(it.substring(\"REGEX:\".length())))\n                  : it)\n              .collect(Collectors.toList());\n          p.params.put(e.getKey(), val -> {\n            if (val == null) return false;\n            for (Object pattern : patterns) {\n              for (String s : val) {\n                if (pattern instanceof String) {\n                  if (pattern.equals(s)) return true;\n                } else if (pattern instanceof Pattern) {\n                  if (((Pattern) pattern).matcher(s).find()) return true;\n                }\n              }\n            }\n            return false;\n          });\n        }\n      }\n    }\n    return p;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/security/Permission#load(Map).mjava","pathOld":"solr/core/src/java/org/apache/solr/security/Permission#load(Map).mjava","sourceNew":"  static Permission load(Map m) {\n    Permission p = new Permission();\n    p.originalConfig = new LinkedHashMap<>(m);\n    String name = (String) m.get(NAME);\n    if (!m.containsKey(\"role\")) throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"role not specified\");\n    p.role = readValueAsSet(m, \"role\");\n    if (PermissionNameProvider.Name.get(name)!= null) {\n      p.wellknownName = PermissionNameProvider.Name.get(name);\n      HashSet<String> disAllowed = new HashSet<>(knownKeys);\n      disAllowed.remove(\"role\");//these are the only\n      disAllowed.remove(NAME);//allowed keys for well-known permissions\n      disAllowed.remove(\"collection\");//allowed keys for well-known permissions\n      disAllowed.remove(\"index\");\n      for (String s : disAllowed) {\n        if (m.containsKey(s))\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, s + \" is not a valid key for the permission : \" + name);\n      }\n\n    }\n    p.name = name;\n    p.path = readSetSmart(name, m, \"path\");\n    p.collections = readSetSmart(name, m, \"collection\");\n    p.method = readSetSmart(name, m, \"method\");\n    Map<String, Object> paramRules = (Map<String, Object>) m.get(\"params\");\n    if (paramRules != null) {\n      p.params = new LinkedHashMap<>();\n      for (Map.Entry<String, Object> e : paramRules.entrySet()) {\n        if (e.getValue() == null) {\n          p.params.put(e.getKey(), (String[] val) -> val == null);\n        } else {\n          List<String> patternStrs = e.getValue() instanceof List ?\n              (List) e.getValue() :\n              singletonList(e.getValue().toString());\n          List patterns = patternStrs.stream()\n              .map(it -> it.startsWith(\"REGEX:\") ?\n                  Pattern.compile(String.valueOf(it.substring(\"REGEX:\".length())))\n                  : it)\n              .collect(Collectors.toList());\n          p.params.put(e.getKey(), val -> {\n            if (val == null) return false;\n            for (Object pattern : patterns) {\n              for (String s : val) {\n                if (pattern instanceof String) {\n                  if (pattern.equals(s)) return true;\n                } else if (pattern instanceof Pattern) {\n                  if (((Pattern) pattern).matcher(s).find()) return true;\n                }\n              }\n            }\n            return false;\n          });\n        }\n      }\n    }\n    return p;\n  }\n\n","sourceOld":"  static Permission load(Map m) {\n    Permission p = new Permission();\n    String name = (String) m.get(NAME);\n    if (!m.containsKey(\"role\")) throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"role not specified\");\n    p.role = readValueAsSet(m, \"role\");\n    if (PermissionNameProvider.Name.get(name)!= null) {\n      p.wellknownName = PermissionNameProvider.Name.get(name);\n      HashSet<String> disAllowed = new HashSet<>(knownKeys);\n      disAllowed.remove(\"role\");//these are the only\n      disAllowed.remove(NAME);//allowed keys for well-known permissions\n      disAllowed.remove(\"collection\");//allowed keys for well-known permissions\n      disAllowed.remove(\"index\");\n      for (String s : disAllowed) {\n        if (m.containsKey(s))\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, s + \" is not a valid key for the permission : \" + name);\n      }\n\n    }\n    p.name = name;\n    p.path = readSetSmart(name, m, \"path\");\n    p.collections = readSetSmart(name, m, \"collection\");\n    p.method = readSetSmart(name, m, \"method\");\n    Map<String, Object> paramRules = (Map<String, Object>) m.get(\"params\");\n    if (paramRules != null) {\n      p.params = new LinkedHashMap<>();\n      for (Map.Entry<String, Object> e : paramRules.entrySet()) {\n        if (e.getValue() == null) {\n          p.params.put(e.getKey(), (String[] val) -> val == null);\n        } else {\n          List<String> patternStrs = e.getValue() instanceof List ?\n              (List) e.getValue() :\n              singletonList(e.getValue().toString());\n          List patterns = patternStrs.stream()\n              .map(it -> it.startsWith(\"REGEX:\") ?\n                  Pattern.compile(String.valueOf(it.substring(\"REGEX:\".length())))\n                  : it)\n              .collect(Collectors.toList());\n          p.params.put(e.getKey(), val -> {\n            if (val == null) return false;\n            for (Object pattern : patterns) {\n              for (String s : val) {\n                if (pattern instanceof String) {\n                  if (pattern.equals(s)) return true;\n                } else if (pattern instanceof Pattern) {\n                  if (((Pattern) pattern).matcher(s).find()) return true;\n                }\n              }\n            }\n            return false;\n          });\n        }\n      }\n    }\n    return p;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06a8891f085f71282bb3ece1b1732b68f07813a3","date":1591912889,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/security/Permission#load(Map).mjava","pathOld":"solr/core/src/java/org/apache/solr/security/Permission#load(Map).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  static Permission load(@SuppressWarnings({\"rawtypes\"})Map m) {\n    Permission p = new Permission();\n    p.originalConfig = new LinkedHashMap<>(m);\n    String name = (String) m.get(NAME);\n    if (!m.containsKey(\"role\")) throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"role not specified\");\n    p.role = readValueAsSet(m, \"role\");\n    if (PermissionNameProvider.Name.get(name)!= null) {\n      p.wellknownName = PermissionNameProvider.Name.get(name);\n      HashSet<String> disAllowed = new HashSet<>(knownKeys);\n      disAllowed.remove(\"role\");//these are the only\n      disAllowed.remove(NAME);//allowed keys for well-known permissions\n      disAllowed.remove(\"collection\");//allowed keys for well-known permissions\n      disAllowed.remove(\"index\");\n      for (String s : disAllowed) {\n        if (m.containsKey(s))\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, s + \" is not a valid key for the permission : \" + name);\n      }\n\n    }\n    p.name = name;\n    p.path = readSetSmart(name, m, \"path\");\n    p.collections = readSetSmart(name, m, \"collection\");\n    p.method = readSetSmart(name, m, \"method\");\n    Map<String, Object> paramRules = (Map<String, Object>) m.get(\"params\");\n    if (paramRules != null) {\n      p.params = new LinkedHashMap<>();\n      for (Map.Entry<String, Object> e : paramRules.entrySet()) {\n        if (e.getValue() == null) {\n          p.params.put(e.getKey(), (String[] val) -> val == null);\n        } else {\n          List<String> patternStrs = e.getValue() instanceof List ?\n              (List) e.getValue() :\n              singletonList(e.getValue().toString());\n          List patterns = patternStrs.stream()\n              .map(it -> it.startsWith(\"REGEX:\") ?\n                  Pattern.compile(String.valueOf(it.substring(\"REGEX:\".length())))\n                  : it)\n              .collect(Collectors.toList());\n          p.params.put(e.getKey(), val -> {\n            if (val == null) return false;\n            for (Object pattern : patterns) {\n              for (String s : val) {\n                if (pattern instanceof String) {\n                  if (pattern.equals(s)) return true;\n                } else if (pattern instanceof Pattern) {\n                  if (((Pattern) pattern).matcher(s).find()) return true;\n                }\n              }\n            }\n            return false;\n          });\n        }\n      }\n    }\n    return p;\n  }\n\n","sourceOld":"  static Permission load(Map m) {\n    Permission p = new Permission();\n    p.originalConfig = new LinkedHashMap<>(m);\n    String name = (String) m.get(NAME);\n    if (!m.containsKey(\"role\")) throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"role not specified\");\n    p.role = readValueAsSet(m, \"role\");\n    if (PermissionNameProvider.Name.get(name)!= null) {\n      p.wellknownName = PermissionNameProvider.Name.get(name);\n      HashSet<String> disAllowed = new HashSet<>(knownKeys);\n      disAllowed.remove(\"role\");//these are the only\n      disAllowed.remove(NAME);//allowed keys for well-known permissions\n      disAllowed.remove(\"collection\");//allowed keys for well-known permissions\n      disAllowed.remove(\"index\");\n      for (String s : disAllowed) {\n        if (m.containsKey(s))\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, s + \" is not a valid key for the permission : \" + name);\n      }\n\n    }\n    p.name = name;\n    p.path = readSetSmart(name, m, \"path\");\n    p.collections = readSetSmart(name, m, \"collection\");\n    p.method = readSetSmart(name, m, \"method\");\n    Map<String, Object> paramRules = (Map<String, Object>) m.get(\"params\");\n    if (paramRules != null) {\n      p.params = new LinkedHashMap<>();\n      for (Map.Entry<String, Object> e : paramRules.entrySet()) {\n        if (e.getValue() == null) {\n          p.params.put(e.getKey(), (String[] val) -> val == null);\n        } else {\n          List<String> patternStrs = e.getValue() instanceof List ?\n              (List) e.getValue() :\n              singletonList(e.getValue().toString());\n          List patterns = patternStrs.stream()\n              .map(it -> it.startsWith(\"REGEX:\") ?\n                  Pattern.compile(String.valueOf(it.substring(\"REGEX:\".length())))\n                  : it)\n              .collect(Collectors.toList());\n          p.params.put(e.getKey(), val -> {\n            if (val == null) return false;\n            for (Object pattern : patterns) {\n              for (String s : val) {\n                if (pattern instanceof String) {\n                  if (pattern.equals(s)) return true;\n                } else if (pattern instanceof Pattern) {\n                  if (((Pattern) pattern).matcher(s).find()) return true;\n                }\n              }\n            }\n            return false;\n          });\n        }\n      }\n    }\n    return p;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"85784a21c6101aadd8d5b3d9dfed51279fbd43d9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"06a8891f085f71282bb3ece1b1732b68f07813a3":["a2673025c1f6208a4ab731e12f4e98a5e7f257cd"],"6548a35b9da836a0b749064ee61085bd7cd80ffb":["85784a21c6101aadd8d5b3d9dfed51279fbd43d9","ebd6b7b6f5196cb5defe92032d6cc2147690954f"],"ebd6b7b6f5196cb5defe92032d6cc2147690954f":["85784a21c6101aadd8d5b3d9dfed51279fbd43d9"],"a2673025c1f6208a4ab731e12f4e98a5e7f257cd":["6548a35b9da836a0b749064ee61085bd7cd80ffb"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["55b50463286869f584cf849d1587a0fcd54d1dfa","a2673025c1f6208a4ab731e12f4e98a5e7f257cd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["06a8891f085f71282bb3ece1b1732b68f07813a3"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["85784a21c6101aadd8d5b3d9dfed51279fbd43d9","6548a35b9da836a0b749064ee61085bd7cd80ffb"]},"commit2Childs":{"85784a21c6101aadd8d5b3d9dfed51279fbd43d9":["6548a35b9da836a0b749064ee61085bd7cd80ffb","ebd6b7b6f5196cb5defe92032d6cc2147690954f","55b50463286869f584cf849d1587a0fcd54d1dfa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["85784a21c6101aadd8d5b3d9dfed51279fbd43d9"],"06a8891f085f71282bb3ece1b1732b68f07813a3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6548a35b9da836a0b749064ee61085bd7cd80ffb":["a2673025c1f6208a4ab731e12f4e98a5e7f257cd","55b50463286869f584cf849d1587a0fcd54d1dfa"],"ebd6b7b6f5196cb5defe92032d6cc2147690954f":["6548a35b9da836a0b749064ee61085bd7cd80ffb"],"a2673025c1f6208a4ab731e12f4e98a5e7f257cd":["06a8891f085f71282bb3ece1b1732b68f07813a3","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"55b50463286869f584cf849d1587a0fcd54d1dfa":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}