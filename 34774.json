{"path":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteAlias(Aliases,ZkNodeProps).mjava","commits":[{"id":"1cfa38e36fa296bb93d77df7d5556257dffa4535","date":1362635543,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteAlias(Aliases,ZkNodeProps).mjava","pathOld":"/dev/null","sourceNew":"  private void deleteAlias(Aliases aliases, ZkNodeProps message) {\n    String aliasName = message.getStr(\"name\");\n\n    Map<String,Map<String,String>> newAliasesMap = new HashMap<String,Map<String,String>>();\n    Map<String,String> newCollectionAliasesMap = new HashMap<String,String>();\n    newCollectionAliasesMap.putAll(aliases.getCollectionAliasMap());\n    newCollectionAliasesMap.remove(aliasName);\n    newAliasesMap.put(\"collection\", newCollectionAliasesMap);\n    Aliases newAliases = new Aliases(newAliasesMap);\n    byte[] jsonBytes = null;\n    if (newAliases.collectionAliasSize() > 0) { // only sub map right now\n      jsonBytes  = ZkStateReader.toJSON(newAliases.getAliasMap());\n    }\n    try {\n      zkStateReader.getZkClient().setData(ZkStateReader.ALIASES,\n          jsonBytes, true);\n      checkForAliasAbsence(aliasName);\n      // some fudge for other nodes\n      Thread.sleep(100);\n    } catch (KeeperException e) {\n      log.error(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } catch (InterruptedException e) {\n      log.warn(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    }\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteAlias(Aliases,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteAlias(Aliases,ZkNodeProps).mjava","sourceNew":"  private void deleteAlias(Aliases aliases, ZkNodeProps message) {\n    String aliasName = message.getStr(\"name\");\n\n    Map<String,Map<String,String>> newAliasesMap = new HashMap<>();\n    Map<String,String> newCollectionAliasesMap = new HashMap<>();\n    newCollectionAliasesMap.putAll(aliases.getCollectionAliasMap());\n    newCollectionAliasesMap.remove(aliasName);\n    newAliasesMap.put(\"collection\", newCollectionAliasesMap);\n    Aliases newAliases = new Aliases(newAliasesMap);\n    byte[] jsonBytes = null;\n    if (newAliases.collectionAliasSize() > 0) { // only sub map right now\n      jsonBytes  = ZkStateReader.toJSON(newAliases.getAliasMap());\n    }\n    try {\n      zkStateReader.getZkClient().setData(ZkStateReader.ALIASES,\n          jsonBytes, true);\n      checkForAliasAbsence(aliasName);\n      // some fudge for other nodes\n      Thread.sleep(100);\n    } catch (KeeperException e) {\n      log.error(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } catch (InterruptedException e) {\n      log.warn(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    }\n    \n  }\n\n","sourceOld":"  private void deleteAlias(Aliases aliases, ZkNodeProps message) {\n    String aliasName = message.getStr(\"name\");\n\n    Map<String,Map<String,String>> newAliasesMap = new HashMap<String,Map<String,String>>();\n    Map<String,String> newCollectionAliasesMap = new HashMap<String,String>();\n    newCollectionAliasesMap.putAll(aliases.getCollectionAliasMap());\n    newCollectionAliasesMap.remove(aliasName);\n    newAliasesMap.put(\"collection\", newCollectionAliasesMap);\n    Aliases newAliases = new Aliases(newAliasesMap);\n    byte[] jsonBytes = null;\n    if (newAliases.collectionAliasSize() > 0) { // only sub map right now\n      jsonBytes  = ZkStateReader.toJSON(newAliases.getAliasMap());\n    }\n    try {\n      zkStateReader.getZkClient().setData(ZkStateReader.ALIASES,\n          jsonBytes, true);\n      checkForAliasAbsence(aliasName);\n      // some fudge for other nodes\n      Thread.sleep(100);\n    } catch (KeeperException e) {\n      log.error(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } catch (InterruptedException e) {\n      log.warn(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dbf528c0e702c5cbd1339b2da1cdc823fd44a925","date":1427230904,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteAlias(Aliases,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteAlias(Aliases,ZkNodeProps).mjava","sourceNew":"  private void deleteAlias(Aliases aliases, ZkNodeProps message) {\n    String aliasName = message.getStr(\"name\");\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    MDCUtils.setCollection(aliasName);\n\n    Map<String,Map<String,String>> newAliasesMap = new HashMap<>();\n    Map<String,String> newCollectionAliasesMap = new HashMap<>();\n    newCollectionAliasesMap.putAll(aliases.getCollectionAliasMap());\n    newCollectionAliasesMap.remove(aliasName);\n    newAliasesMap.put(\"collection\", newCollectionAliasesMap);\n    Aliases newAliases = new Aliases(newAliasesMap);\n    byte[] jsonBytes = null;\n    if (newAliases.collectionAliasSize() > 0) { // only sub map right now\n      jsonBytes  = ZkStateReader.toJSON(newAliases.getAliasMap());\n    }\n    try {\n      zkStateReader.getZkClient().setData(ZkStateReader.ALIASES,\n          jsonBytes, true);\n      checkForAliasAbsence(aliasName);\n      // some fudge for other nodes\n      Thread.sleep(100);\n    } catch (KeeperException e) {\n      log.error(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } catch (InterruptedException e) {\n      log.warn(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n    \n  }\n\n","sourceOld":"  private void deleteAlias(Aliases aliases, ZkNodeProps message) {\n    String aliasName = message.getStr(\"name\");\n\n    Map<String,Map<String,String>> newAliasesMap = new HashMap<>();\n    Map<String,String> newCollectionAliasesMap = new HashMap<>();\n    newCollectionAliasesMap.putAll(aliases.getCollectionAliasMap());\n    newCollectionAliasesMap.remove(aliasName);\n    newAliasesMap.put(\"collection\", newCollectionAliasesMap);\n    Aliases newAliases = new Aliases(newAliasesMap);\n    byte[] jsonBytes = null;\n    if (newAliases.collectionAliasSize() > 0) { // only sub map right now\n      jsonBytes  = ZkStateReader.toJSON(newAliases.getAliasMap());\n    }\n    try {\n      zkStateReader.getZkClient().setData(ZkStateReader.ALIASES,\n          jsonBytes, true);\n      checkForAliasAbsence(aliasName);\n      // some fudge for other nodes\n      Thread.sleep(100);\n    } catch (KeeperException e) {\n      log.error(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } catch (InterruptedException e) {\n      log.warn(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteAlias(Aliases,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteAlias(Aliases,ZkNodeProps).mjava","sourceNew":"  private void deleteAlias(Aliases aliases, ZkNodeProps message) {\n    String aliasName = message.getStr(\"name\");\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    MDCUtils.setCollection(aliasName);\n\n    Map<String,Map<String,String>> newAliasesMap = new HashMap<>();\n    Map<String,String> newCollectionAliasesMap = new HashMap<>();\n    newCollectionAliasesMap.putAll(aliases.getCollectionAliasMap());\n    newCollectionAliasesMap.remove(aliasName);\n    newAliasesMap.put(\"collection\", newCollectionAliasesMap);\n    Aliases newAliases = new Aliases(newAliasesMap);\n    byte[] jsonBytes = null;\n    if (newAliases.collectionAliasSize() > 0) { // only sub map right now\n      jsonBytes  = ZkStateReader.toJSON(newAliases.getAliasMap());\n    }\n    try {\n      zkStateReader.getZkClient().setData(ZkStateReader.ALIASES,\n          jsonBytes, true);\n      checkForAliasAbsence(aliasName);\n      // some fudge for other nodes\n      Thread.sleep(100);\n    } catch (KeeperException e) {\n      log.error(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } catch (InterruptedException e) {\n      log.warn(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n    \n  }\n\n","sourceOld":"  private void deleteAlias(Aliases aliases, ZkNodeProps message) {\n    String aliasName = message.getStr(\"name\");\n\n    Map<String,Map<String,String>> newAliasesMap = new HashMap<>();\n    Map<String,String> newCollectionAliasesMap = new HashMap<>();\n    newCollectionAliasesMap.putAll(aliases.getCollectionAliasMap());\n    newCollectionAliasesMap.remove(aliasName);\n    newAliasesMap.put(\"collection\", newCollectionAliasesMap);\n    Aliases newAliases = new Aliases(newAliasesMap);\n    byte[] jsonBytes = null;\n    if (newAliases.collectionAliasSize() > 0) { // only sub map right now\n      jsonBytes  = ZkStateReader.toJSON(newAliases.getAliasMap());\n    }\n    try {\n      zkStateReader.getZkClient().setData(ZkStateReader.ALIASES,\n          jsonBytes, true);\n      checkForAliasAbsence(aliasName);\n      // some fudge for other nodes\n      Thread.sleep(100);\n    } catch (KeeperException e) {\n      log.error(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } catch (InterruptedException e) {\n      log.warn(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1390137e395d2f07f9ba5b8c43d293befe84d563","date":1427947685,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteAlias(Aliases,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteAlias(Aliases,ZkNodeProps).mjava","sourceNew":"  private void deleteAlias(Aliases aliases, ZkNodeProps message) {\n    String aliasName = message.getStr(NAME);\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    MDCUtils.setCollection(aliasName);\n\n    Map<String,Map<String,String>> newAliasesMap = new HashMap<>();\n    Map<String,String> newCollectionAliasesMap = new HashMap<>();\n    newCollectionAliasesMap.putAll(aliases.getCollectionAliasMap());\n    newCollectionAliasesMap.remove(aliasName);\n    newAliasesMap.put(\"collection\", newCollectionAliasesMap);\n    Aliases newAliases = new Aliases(newAliasesMap);\n    byte[] jsonBytes = null;\n    if (newAliases.collectionAliasSize() > 0) { // only sub map right now\n      jsonBytes  = ZkStateReader.toJSON(newAliases.getAliasMap());\n    }\n    try {\n      zkStateReader.getZkClient().setData(ZkStateReader.ALIASES,\n          jsonBytes, true);\n      checkForAliasAbsence(aliasName);\n      // some fudge for other nodes\n      Thread.sleep(100);\n    } catch (KeeperException e) {\n      log.error(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } catch (InterruptedException e) {\n      log.warn(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n    \n  }\n\n","sourceOld":"  private void deleteAlias(Aliases aliases, ZkNodeProps message) {\n    String aliasName = message.getStr(\"name\");\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    MDCUtils.setCollection(aliasName);\n\n    Map<String,Map<String,String>> newAliasesMap = new HashMap<>();\n    Map<String,String> newCollectionAliasesMap = new HashMap<>();\n    newCollectionAliasesMap.putAll(aliases.getCollectionAliasMap());\n    newCollectionAliasesMap.remove(aliasName);\n    newAliasesMap.put(\"collection\", newCollectionAliasesMap);\n    Aliases newAliases = new Aliases(newAliasesMap);\n    byte[] jsonBytes = null;\n    if (newAliases.collectionAliasSize() > 0) { // only sub map right now\n      jsonBytes  = ZkStateReader.toJSON(newAliases.getAliasMap());\n    }\n    try {\n      zkStateReader.getZkClient().setData(ZkStateReader.ALIASES,\n          jsonBytes, true);\n      checkForAliasAbsence(aliasName);\n      // some fudge for other nodes\n      Thread.sleep(100);\n    } catch (KeeperException e) {\n      log.error(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } catch (InterruptedException e) {\n      log.warn(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteAlias(Aliases,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteAlias(Aliases,ZkNodeProps).mjava","sourceNew":"  private void deleteAlias(Aliases aliases, ZkNodeProps message) {\n    String aliasName = message.getStr(NAME);\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    MDCUtils.setCollection(aliasName);\n\n    Map<String,Map<String,String>> newAliasesMap = new HashMap<>();\n    Map<String,String> newCollectionAliasesMap = new HashMap<>();\n    newCollectionAliasesMap.putAll(aliases.getCollectionAliasMap());\n    newCollectionAliasesMap.remove(aliasName);\n    newAliasesMap.put(\"collection\", newCollectionAliasesMap);\n    Aliases newAliases = new Aliases(newAliasesMap);\n    byte[] jsonBytes = null;\n    if (newAliases.collectionAliasSize() > 0) { // only sub map right now\n      jsonBytes  = ZkStateReader.toJSON(newAliases.getAliasMap());\n    }\n    try {\n      zkStateReader.getZkClient().setData(ZkStateReader.ALIASES,\n          jsonBytes, true);\n      checkForAliasAbsence(aliasName);\n      // some fudge for other nodes\n      Thread.sleep(100);\n    } catch (KeeperException e) {\n      log.error(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } catch (InterruptedException e) {\n      log.warn(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n    \n  }\n\n","sourceOld":"  private void deleteAlias(Aliases aliases, ZkNodeProps message) {\n    String aliasName = message.getStr(\"name\");\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    MDCUtils.setCollection(aliasName);\n\n    Map<String,Map<String,String>> newAliasesMap = new HashMap<>();\n    Map<String,String> newCollectionAliasesMap = new HashMap<>();\n    newCollectionAliasesMap.putAll(aliases.getCollectionAliasMap());\n    newCollectionAliasesMap.remove(aliasName);\n    newAliasesMap.put(\"collection\", newCollectionAliasesMap);\n    Aliases newAliases = new Aliases(newAliasesMap);\n    byte[] jsonBytes = null;\n    if (newAliases.collectionAliasSize() > 0) { // only sub map right now\n      jsonBytes  = ZkStateReader.toJSON(newAliases.getAliasMap());\n    }\n    try {\n      zkStateReader.getZkClient().setData(ZkStateReader.ALIASES,\n          jsonBytes, true);\n      checkForAliasAbsence(aliasName);\n      // some fudge for other nodes\n      Thread.sleep(100);\n    } catch (KeeperException e) {\n      log.error(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } catch (InterruptedException e) {\n      log.warn(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe","date":1430750405,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteAlias(Aliases,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteAlias(Aliases,ZkNodeProps).mjava","sourceNew":"  private void deleteAlias(Aliases aliases, ZkNodeProps message) {\n    String aliasName = message.getStr(NAME);\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    MDCUtils.setCollection(aliasName);\n\n    Map<String,Map<String,String>> newAliasesMap = new HashMap<>();\n    Map<String,String> newCollectionAliasesMap = new HashMap<>();\n    newCollectionAliasesMap.putAll(aliases.getCollectionAliasMap());\n    newCollectionAliasesMap.remove(aliasName);\n    newAliasesMap.put(\"collection\", newCollectionAliasesMap);\n    Aliases newAliases = new Aliases(newAliasesMap);\n    byte[] jsonBytes = null;\n    if (newAliases.collectionAliasSize() > 0) { // only sub map right now\n      jsonBytes  = ZkStateReader.toJSON(newAliases.getAliasMap());\n    }\n    try {\n      zkStateReader.getZkClient().setData(ZkStateReader.ALIASES,\n          jsonBytes, true);\n      checkForAliasAbsence(aliasName);\n      // some fudge for other nodes\n      Thread.sleep(100);\n    } catch (KeeperException e) {\n      log.error(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } catch (InterruptedException e) {\n      log.warn(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n\n  }\n\n","sourceOld":"  private void deleteAlias(Aliases aliases, ZkNodeProps message) {\n    String aliasName = message.getStr(NAME);\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    MDCUtils.setCollection(aliasName);\n\n    Map<String,Map<String,String>> newAliasesMap = new HashMap<>();\n    Map<String,String> newCollectionAliasesMap = new HashMap<>();\n    newCollectionAliasesMap.putAll(aliases.getCollectionAliasMap());\n    newCollectionAliasesMap.remove(aliasName);\n    newAliasesMap.put(\"collection\", newCollectionAliasesMap);\n    Aliases newAliases = new Aliases(newAliasesMap);\n    byte[] jsonBytes = null;\n    if (newAliases.collectionAliasSize() > 0) { // only sub map right now\n      jsonBytes  = ZkStateReader.toJSON(newAliases.getAliasMap());\n    }\n    try {\n      zkStateReader.getZkClient().setData(ZkStateReader.ALIASES,\n          jsonBytes, true);\n      checkForAliasAbsence(aliasName);\n      // some fudge for other nodes\n      Thread.sleep(100);\n    } catch (KeeperException e) {\n      log.error(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } catch (InterruptedException e) {\n      log.warn(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"439c63ae5d22132fca810a0029a854e97d2c1a3e","date":1432733612,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteAlias(Aliases,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteAlias(Aliases,ZkNodeProps).mjava","sourceNew":"  private void deleteAlias(Aliases aliases, ZkNodeProps message) {\n    String aliasName = message.getStr(NAME);\n\n    Map<String,Map<String,String>> newAliasesMap = new HashMap<>();\n    Map<String,String> newCollectionAliasesMap = new HashMap<>();\n    newCollectionAliasesMap.putAll(aliases.getCollectionAliasMap());\n    newCollectionAliasesMap.remove(aliasName);\n    newAliasesMap.put(\"collection\", newCollectionAliasesMap);\n    Aliases newAliases = new Aliases(newAliasesMap);\n    byte[] jsonBytes = null;\n    if (newAliases.collectionAliasSize() > 0) { // only sub map right now\n      jsonBytes  = ZkStateReader.toJSON(newAliases.getAliasMap());\n    }\n    try {\n      zkStateReader.getZkClient().setData(ZkStateReader.ALIASES,\n          jsonBytes, true);\n      checkForAliasAbsence(aliasName);\n      // some fudge for other nodes\n      Thread.sleep(100);\n    } catch (KeeperException e) {\n      log.error(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } catch (InterruptedException e) {\n      log.warn(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } \n\n  }\n\n","sourceOld":"  private void deleteAlias(Aliases aliases, ZkNodeProps message) {\n    String aliasName = message.getStr(NAME);\n    Map previousMDCContext = MDC.getCopyOfContextMap();\n    MDCUtils.setCollection(aliasName);\n\n    Map<String,Map<String,String>> newAliasesMap = new HashMap<>();\n    Map<String,String> newCollectionAliasesMap = new HashMap<>();\n    newCollectionAliasesMap.putAll(aliases.getCollectionAliasMap());\n    newCollectionAliasesMap.remove(aliasName);\n    newAliasesMap.put(\"collection\", newCollectionAliasesMap);\n    Aliases newAliases = new Aliases(newAliasesMap);\n    byte[] jsonBytes = null;\n    if (newAliases.collectionAliasSize() > 0) { // only sub map right now\n      jsonBytes  = ZkStateReader.toJSON(newAliases.getAliasMap());\n    }\n    try {\n      zkStateReader.getZkClient().setData(ZkStateReader.ALIASES,\n          jsonBytes, true);\n      checkForAliasAbsence(aliasName);\n      // some fudge for other nodes\n      Thread.sleep(100);\n    } catch (KeeperException e) {\n      log.error(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } catch (InterruptedException e) {\n      log.warn(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } finally {\n      MDCUtils.cleanupMDC(previousMDCContext);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b693a83132c9e45afcd564fd65a25b60ed80388b","date":1436882146,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteAlias(Aliases,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteAlias(Aliases,ZkNodeProps).mjava","sourceNew":"  private void deleteAlias(Aliases aliases, ZkNodeProps message) {\n    String aliasName = message.getStr(NAME);\n\n    Map<String,Map<String,String>> newAliasesMap = new HashMap<>();\n    Map<String,String> newCollectionAliasesMap = new HashMap<>();\n    newCollectionAliasesMap.putAll(aliases.getCollectionAliasMap());\n    newCollectionAliasesMap.remove(aliasName);\n    newAliasesMap.put(\"collection\", newCollectionAliasesMap);\n    Aliases newAliases = new Aliases(newAliasesMap);\n    byte[] jsonBytes = null;\n    if (newAliases.collectionAliasSize() > 0) { // only sub map right now\n      jsonBytes  = Utils.toJSON(newAliases.getAliasMap());\n    }\n    try {\n      zkStateReader.getZkClient().setData(ZkStateReader.ALIASES,\n          jsonBytes, true);\n      checkForAliasAbsence(aliasName);\n      // some fudge for other nodes\n      Thread.sleep(100);\n    } catch (KeeperException e) {\n      log.error(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } catch (InterruptedException e) {\n      log.warn(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } \n\n  }\n\n","sourceOld":"  private void deleteAlias(Aliases aliases, ZkNodeProps message) {\n    String aliasName = message.getStr(NAME);\n\n    Map<String,Map<String,String>> newAliasesMap = new HashMap<>();\n    Map<String,String> newCollectionAliasesMap = new HashMap<>();\n    newCollectionAliasesMap.putAll(aliases.getCollectionAliasMap());\n    newCollectionAliasesMap.remove(aliasName);\n    newAliasesMap.put(\"collection\", newCollectionAliasesMap);\n    Aliases newAliases = new Aliases(newAliasesMap);\n    byte[] jsonBytes = null;\n    if (newAliases.collectionAliasSize() > 0) { // only sub map right now\n      jsonBytes  = ZkStateReader.toJSON(newAliases.getAliasMap());\n    }\n    try {\n      zkStateReader.getZkClient().setData(ZkStateReader.ALIASES,\n          jsonBytes, true);\n      checkForAliasAbsence(aliasName);\n      // some fudge for other nodes\n      Thread.sleep(100);\n    } catch (KeeperException e) {\n      log.error(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } catch (InterruptedException e) {\n      log.warn(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } \n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac","date":1438841252,"type":5,"author":"Gregory Chanan","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionMessageHandler#deleteAlias(Aliases,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#deleteAlias(Aliases,ZkNodeProps).mjava","sourceNew":"  private void deleteAlias(Aliases aliases, ZkNodeProps message) {\n    String aliasName = message.getStr(NAME);\n\n    Map<String,Map<String,String>> newAliasesMap = new HashMap<>();\n    Map<String,String> newCollectionAliasesMap = new HashMap<>();\n    newCollectionAliasesMap.putAll(aliases.getCollectionAliasMap());\n    newCollectionAliasesMap.remove(aliasName);\n    newAliasesMap.put(\"collection\", newCollectionAliasesMap);\n    Aliases newAliases = new Aliases(newAliasesMap);\n    byte[] jsonBytes = null;\n    if (newAliases.collectionAliasSize() > 0) { // only sub map right now\n      jsonBytes  = Utils.toJSON(newAliases.getAliasMap());\n    }\n    try {\n      zkStateReader.getZkClient().setData(ZkStateReader.ALIASES,\n          jsonBytes, true);\n      checkForAliasAbsence(aliasName);\n      // some fudge for other nodes\n      Thread.sleep(100);\n    } catch (KeeperException e) {\n      log.error(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } catch (InterruptedException e) {\n      log.warn(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    }\n\n  }\n\n","sourceOld":"  private void deleteAlias(Aliases aliases, ZkNodeProps message) {\n    String aliasName = message.getStr(NAME);\n\n    Map<String,Map<String,String>> newAliasesMap = new HashMap<>();\n    Map<String,String> newCollectionAliasesMap = new HashMap<>();\n    newCollectionAliasesMap.putAll(aliases.getCollectionAliasMap());\n    newCollectionAliasesMap.remove(aliasName);\n    newAliasesMap.put(\"collection\", newCollectionAliasesMap);\n    Aliases newAliases = new Aliases(newAliasesMap);\n    byte[] jsonBytes = null;\n    if (newAliases.collectionAliasSize() > 0) { // only sub map right now\n      jsonBytes  = Utils.toJSON(newAliases.getAliasMap());\n    }\n    try {\n      zkStateReader.getZkClient().setData(ZkStateReader.ALIASES,\n          jsonBytes, true);\n      checkForAliasAbsence(aliasName);\n      // some fudge for other nodes\n      Thread.sleep(100);\n    } catch (KeeperException e) {\n      log.error(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } catch (InterruptedException e) {\n      log.warn(\"\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } \n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac":["b693a83132c9e45afcd564fd65a25b60ed80388b"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["1cfa38e36fa296bb93d77df7d5556257dffa4535"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","dbf528c0e702c5cbd1339b2da1cdc823fd44a925"],"1cfa38e36fa296bb93d77df7d5556257dffa4535":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1390137e395d2f07f9ba5b8c43d293befe84d563":["dbf528c0e702c5cbd1339b2da1cdc823fd44a925"],"8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe":["1390137e395d2f07f9ba5b8c43d293befe84d563"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","1390137e395d2f07f9ba5b8c43d293befe84d563"],"b693a83132c9e45afcd564fd65a25b60ed80388b":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe"],"dbf528c0e702c5cbd1339b2da1cdc823fd44a925":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"]},"commit2Childs":{"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","dbf528c0e702c5cbd1339b2da1cdc823fd44a925"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["d2638f781be724518ff6c2263d14a48cf6e68017"],"1cfa38e36fa296bb93d77df7d5556257dffa4535":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"1390137e395d2f07f9ba5b8c43d293befe84d563":["8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe","d2638f781be724518ff6c2263d14a48cf6e68017"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1cfa38e36fa296bb93d77df7d5556257dffa4535"],"8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"b693a83132c9e45afcd564fd65a25b60ed80388b":["e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac"],"dbf528c0e702c5cbd1339b2da1cdc823fd44a925":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","1390137e395d2f07f9ba5b8c43d293befe84d563"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["b693a83132c9e45afcd564fd65a25b60ed80388b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d2638f781be724518ff6c2263d14a48cf6e68017","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}