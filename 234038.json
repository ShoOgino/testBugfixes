{"path":"lucene/sandbox/src/test/org/apache/lucene/document/TestFloatPointNearestNeighbor#testNearestNeighborRandom().mjava","commits":[{"id":"1b73cddaec09172a09da82e758d0014ab8810ffa","date":1506898255,"type":0,"author":"Steve Rowe","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/TestFloatPointNearestNeighbor#testNearestNeighborRandom().mjava","pathOld":"/dev/null","sourceNew":"  public void testNearestNeighborRandom() throws Exception {\n    Directory dir;\n    int numPoints = atLeast(5000);\n    if (numPoints > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    IndexWriterConfig iwc = getIndexWriterConfig();\n    iwc.setMergePolicy(newLogMergePolicy());\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int dims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n    float[][] values = new float[numPoints][dims];\n    for (int id = 0 ; id < numPoints ; ++id) {\n      for (int dim = 0 ; dim < dims ; ++dim) {\n        Float f = Float.NaN;\n        while (f.isNaN()) {\n          f = Float.intBitsToFloat(random().nextInt());\n        }\n        values[id][dim] = f;\n      }\n      Document doc = new Document();\n      doc.add(new FloatPoint(\"point\", values[id]));\n      doc.add(new StoredField(\"id\", id));\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n\n    DirectoryReader r = w.getReader();\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    // can't wrap because we require Lucene60PointsFormat directly but e.g. ParallelReader wraps with its own points impl:\n    IndexSearcher s = newSearcher(r, false);\n    int iters = atLeast(100);\n    for (int iter = 0 ; iter < iters ; ++iter) {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter);\n      }\n      float[] origin = new float[dims];\n      for (int dim = 0 ; dim < dims ; ++dim) {\n        Float f = Float.NaN;\n        while (f.isNaN()) {\n          f = Float.intBitsToFloat(random().nextInt());\n        }\n        origin[dim] = f;\n      }\n\n      // dumb brute force search to get the expected result:\n      FloatPointNearestNeighbor.NearestHit[] expectedHits = new FloatPointNearestNeighbor.NearestHit[numPoints];\n      for (int id = 0 ; id < numPoints ; ++id) {\n        FloatPointNearestNeighbor.NearestHit hit = new FloatPointNearestNeighbor.NearestHit();\n        hit.distanceSquared = FloatPointNearestNeighbor.euclideanDistanceSquared(origin, values[id]);\n        hit.docID = id;\n        expectedHits[id] = hit;\n      }\n\n      Arrays.sort(expectedHits, (a, b) -> {\n        int cmp = Double.compare(a.distanceSquared, b.distanceSquared);\n        return cmp != 0 ? cmp : a.docID - b.docID; // tie break by smaller id\n      });\n\n      int topK = TestUtil.nextInt(random(), 1, numPoints);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nhits for origin=\" + Arrays.toString(origin));\n      }\n\n      ScoreDoc[] hits = FloatPointNearestNeighbor.nearest(s, \"point\", topK, origin).scoreDocs;\n      assertEquals(\"fewer than expected hits: \", topK, hits.length);\n\n      if (VERBOSE) {\n        for (int i = 0 ; i < topK ; ++i) {\n          FloatPointNearestNeighbor.NearestHit expected = expectedHits[i];\n          FieldDoc actual = (FieldDoc)hits[i];\n          Document actualDoc = r.document(actual.doc);\n          System.out.println(\"hit \" + i);\n          System.out.println(\"  expected id=\" + expected.docID + \"  \" + Arrays.toString(values[expected.docID])\n              + \"  distance=\" + (float)Math.sqrt(expected.distanceSquared) + \"  distanceSquared=\" + expected.distanceSquared);\n          System.out.println(\"  actual id=\" + actualDoc.getField(\"id\") + \" distance=\" + actual.fields[0]);\n        }\n      }\n\n      for (int i = 0 ; i < topK ; ++i) {\n        FloatPointNearestNeighbor.NearestHit expected = expectedHits[i];\n        FieldDoc actual = (FieldDoc)hits[i];\n        assertEquals(\"hit \" + i + \":\", expected.docID, actual.doc);\n        assertEquals(\"hit \" + i + \":\", (float)Math.sqrt(expected.distanceSquared), (Float)actual.fields[0], 0.000001);\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6240b74b884c5587f2a4062dd27d6c32bf228889","date":1507037235,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/TestFloatPointNearestNeighbor#testNearestNeighborRandom().mjava","pathOld":"/dev/null","sourceNew":"  public void testNearestNeighborRandom() throws Exception {\n    Directory dir;\n    int numPoints = atLeast(5000);\n    if (numPoints > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    IndexWriterConfig iwc = getIndexWriterConfig();\n    iwc.setMergePolicy(newLogMergePolicy());\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int dims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n    float[][] values = new float[numPoints][dims];\n    for (int id = 0 ; id < numPoints ; ++id) {\n      for (int dim = 0 ; dim < dims ; ++dim) {\n        Float f = Float.NaN;\n        while (f.isNaN()) {\n          f = Float.intBitsToFloat(random().nextInt());\n        }\n        values[id][dim] = f;\n      }\n      Document doc = new Document();\n      doc.add(new FloatPoint(\"point\", values[id]));\n      doc.add(new StoredField(\"id\", id));\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n\n    DirectoryReader r = w.getReader();\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    // can't wrap because we require Lucene60PointsFormat directly but e.g. ParallelReader wraps with its own points impl:\n    IndexSearcher s = newSearcher(r, false);\n    int iters = atLeast(100);\n    for (int iter = 0 ; iter < iters ; ++iter) {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter);\n      }\n      float[] origin = new float[dims];\n      for (int dim = 0 ; dim < dims ; ++dim) {\n        Float f = Float.NaN;\n        while (f.isNaN()) {\n          f = Float.intBitsToFloat(random().nextInt());\n        }\n        origin[dim] = f;\n      }\n\n      // dumb brute force search to get the expected result:\n      FloatPointNearestNeighbor.NearestHit[] expectedHits = new FloatPointNearestNeighbor.NearestHit[numPoints];\n      for (int id = 0 ; id < numPoints ; ++id) {\n        FloatPointNearestNeighbor.NearestHit hit = new FloatPointNearestNeighbor.NearestHit();\n        hit.distanceSquared = FloatPointNearestNeighbor.euclideanDistanceSquared(origin, values[id]);\n        hit.docID = id;\n        expectedHits[id] = hit;\n      }\n\n      Arrays.sort(expectedHits, (a, b) -> {\n        int cmp = Double.compare(a.distanceSquared, b.distanceSquared);\n        return cmp != 0 ? cmp : a.docID - b.docID; // tie break by smaller id\n      });\n\n      int topK = TestUtil.nextInt(random(), 1, numPoints);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nhits for origin=\" + Arrays.toString(origin));\n      }\n\n      ScoreDoc[] hits = FloatPointNearestNeighbor.nearest(s, \"point\", topK, origin).scoreDocs;\n      assertEquals(\"fewer than expected hits: \", topK, hits.length);\n\n      if (VERBOSE) {\n        for (int i = 0 ; i < topK ; ++i) {\n          FloatPointNearestNeighbor.NearestHit expected = expectedHits[i];\n          FieldDoc actual = (FieldDoc)hits[i];\n          Document actualDoc = r.document(actual.doc);\n          System.out.println(\"hit \" + i);\n          System.out.println(\"  expected id=\" + expected.docID + \"  \" + Arrays.toString(values[expected.docID])\n              + \"  distance=\" + (float)Math.sqrt(expected.distanceSquared) + \"  distanceSquared=\" + expected.distanceSquared);\n          System.out.println(\"  actual id=\" + actualDoc.getField(\"id\") + \" distance=\" + actual.fields[0]);\n        }\n      }\n\n      for (int i = 0 ; i < topK ; ++i) {\n        FloatPointNearestNeighbor.NearestHit expected = expectedHits[i];\n        FieldDoc actual = (FieldDoc)hits[i];\n        assertEquals(\"hit \" + i + \":\", expected.docID, actual.doc);\n        assertEquals(\"hit \" + i + \":\", (float)Math.sqrt(expected.distanceSquared), (Float)actual.fields[0], 0.000001);\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"097748fa4ff327a26994476115f52d1a899b549f","date":1568267320,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/TestFloatPointNearestNeighbor#testNearestNeighborRandom().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/TestFloatPointNearestNeighbor#testNearestNeighborRandom().mjava","sourceNew":"  public void testNearestNeighborRandom() throws Exception {\n    Directory dir;\n    int numPoints = atLeast(5000);\n    if (numPoints > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    IndexWriterConfig iwc = getIndexWriterConfig();\n    iwc.setMergePolicy(newLogMergePolicy());\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int dims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n    float[][] values = new float[numPoints][dims];\n    for (int id = 0 ; id < numPoints ; ++id) {\n      for (int dim = 0 ; dim < dims ; ++dim) {\n        Float f = Float.NaN;\n        while (f.isNaN()) {\n          f = Float.intBitsToFloat(random().nextInt());\n        }\n        values[id][dim] = f;\n      }\n      Document doc = new Document();\n      doc.add(new FloatPoint(\"point\", values[id]));\n      doc.add(new StoredField(\"id\", id));\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n\n    DirectoryReader r = w.getReader();\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    // can't wrap because we require Lucene60PointsFormat directly but e.g. ParallelReader wraps with its own points impl:\n    IndexSearcher s = newSearcher(r, false);\n    int iters = atLeast(100);\n    for (int iter = 0 ; iter < iters ; ++iter) {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter);\n      }\n      float[] origin = new float[dims];\n      for (int dim = 0 ; dim < dims ; ++dim) {\n        Float f = Float.NaN;\n        while (f.isNaN()) {\n          f = Float.intBitsToFloat(random().nextInt());\n        }\n        origin[dim] = f;\n      }\n\n      // dumb brute force search to get the expected result:\n      FloatPointNearestNeighbor.NearestHit[] expectedHits = new FloatPointNearestNeighbor.NearestHit[numPoints];\n      for (int id = 0 ; id < numPoints ; ++id) {\n        FloatPointNearestNeighbor.NearestHit hit = new FloatPointNearestNeighbor.NearestHit();\n        hit.distanceSquared = euclideanDistanceSquared(origin, values[id]);\n        hit.docID = id;\n        expectedHits[id] = hit;\n      }\n\n      Arrays.sort(expectedHits, (a, b) -> {\n        int cmp = Double.compare(a.distanceSquared, b.distanceSquared);\n        return cmp != 0 ? cmp : a.docID - b.docID; // tie break by smaller id\n      });\n\n      int topK = TestUtil.nextInt(random(), 1, numPoints);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nhits for origin=\" + Arrays.toString(origin));\n      }\n\n      ScoreDoc[] hits = FloatPointNearestNeighbor.nearest(s, \"point\", topK, origin).scoreDocs;\n      assertEquals(\"fewer than expected hits: \", topK, hits.length);\n\n      if (VERBOSE) {\n        for (int i = 0 ; i < topK ; ++i) {\n          FloatPointNearestNeighbor.NearestHit expected = expectedHits[i];\n          FieldDoc actual = (FieldDoc)hits[i];\n          Document actualDoc = r.document(actual.doc);\n          System.out.println(\"hit \" + i);\n          System.out.println(\"  expected id=\" + expected.docID + \"  \" + Arrays.toString(values[expected.docID])\n              + \"  distance=\" + (float)Math.sqrt(expected.distanceSquared) + \"  distanceSquared=\" + expected.distanceSquared);\n          System.out.println(\"  actual id=\" + actualDoc.getField(\"id\") + \" distance=\" + actual.fields[0]);\n        }\n      }\n\n      for (int i = 0 ; i < topK ; ++i) {\n        FloatPointNearestNeighbor.NearestHit expected = expectedHits[i];\n        FieldDoc actual = (FieldDoc)hits[i];\n        assertEquals(\"hit \" + i + \":\", expected.docID, actual.doc);\n        assertEquals(\"hit \" + i + \":\", (float)Math.sqrt(expected.distanceSquared), (Float)actual.fields[0], 0.000001);\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testNearestNeighborRandom() throws Exception {\n    Directory dir;\n    int numPoints = atLeast(5000);\n    if (numPoints > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    IndexWriterConfig iwc = getIndexWriterConfig();\n    iwc.setMergePolicy(newLogMergePolicy());\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int dims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n    float[][] values = new float[numPoints][dims];\n    for (int id = 0 ; id < numPoints ; ++id) {\n      for (int dim = 0 ; dim < dims ; ++dim) {\n        Float f = Float.NaN;\n        while (f.isNaN()) {\n          f = Float.intBitsToFloat(random().nextInt());\n        }\n        values[id][dim] = f;\n      }\n      Document doc = new Document();\n      doc.add(new FloatPoint(\"point\", values[id]));\n      doc.add(new StoredField(\"id\", id));\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n\n    DirectoryReader r = w.getReader();\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    // can't wrap because we require Lucene60PointsFormat directly but e.g. ParallelReader wraps with its own points impl:\n    IndexSearcher s = newSearcher(r, false);\n    int iters = atLeast(100);\n    for (int iter = 0 ; iter < iters ; ++iter) {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter);\n      }\n      float[] origin = new float[dims];\n      for (int dim = 0 ; dim < dims ; ++dim) {\n        Float f = Float.NaN;\n        while (f.isNaN()) {\n          f = Float.intBitsToFloat(random().nextInt());\n        }\n        origin[dim] = f;\n      }\n\n      // dumb brute force search to get the expected result:\n      FloatPointNearestNeighbor.NearestHit[] expectedHits = new FloatPointNearestNeighbor.NearestHit[numPoints];\n      for (int id = 0 ; id < numPoints ; ++id) {\n        FloatPointNearestNeighbor.NearestHit hit = new FloatPointNearestNeighbor.NearestHit();\n        hit.distanceSquared = FloatPointNearestNeighbor.euclideanDistanceSquared(origin, values[id]);\n        hit.docID = id;\n        expectedHits[id] = hit;\n      }\n\n      Arrays.sort(expectedHits, (a, b) -> {\n        int cmp = Double.compare(a.distanceSquared, b.distanceSquared);\n        return cmp != 0 ? cmp : a.docID - b.docID; // tie break by smaller id\n      });\n\n      int topK = TestUtil.nextInt(random(), 1, numPoints);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nhits for origin=\" + Arrays.toString(origin));\n      }\n\n      ScoreDoc[] hits = FloatPointNearestNeighbor.nearest(s, \"point\", topK, origin).scoreDocs;\n      assertEquals(\"fewer than expected hits: \", topK, hits.length);\n\n      if (VERBOSE) {\n        for (int i = 0 ; i < topK ; ++i) {\n          FloatPointNearestNeighbor.NearestHit expected = expectedHits[i];\n          FieldDoc actual = (FieldDoc)hits[i];\n          Document actualDoc = r.document(actual.doc);\n          System.out.println(\"hit \" + i);\n          System.out.println(\"  expected id=\" + expected.docID + \"  \" + Arrays.toString(values[expected.docID])\n              + \"  distance=\" + (float)Math.sqrt(expected.distanceSquared) + \"  distanceSquared=\" + expected.distanceSquared);\n          System.out.println(\"  actual id=\" + actualDoc.getField(\"id\") + \" distance=\" + actual.fields[0]);\n        }\n      }\n\n      for (int i = 0 ; i < topK ; ++i) {\n        FloatPointNearestNeighbor.NearestHit expected = expectedHits[i];\n        FieldDoc actual = (FieldDoc)hits[i];\n        assertEquals(\"hit \" + i + \":\", expected.docID, actual.doc);\n        assertEquals(\"hit \" + i + \":\", (float)Math.sqrt(expected.distanceSquared), (Float)actual.fields[0], 0.000001);\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59ed8c026ba85e3c42fb89605b2032dc6f9cc241","date":1581113294,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/TestFloatPointNearestNeighbor#testNearestNeighborRandom().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/TestFloatPointNearestNeighbor#testNearestNeighborRandom().mjava","sourceNew":"  public void testNearestNeighborRandom() throws Exception {\n    Directory dir;\n    int numPoints = atLeast(5000);\n    if (numPoints > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    IndexWriterConfig iwc = getIndexWriterConfig();\n    iwc.setMergePolicy(newLogMergePolicy());\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int dims = TestUtil.nextInt(random(), 1, PointValues.MAX_INDEX_DIMENSIONS);\n    float[][] values = new float[numPoints][dims];\n    for (int id = 0 ; id < numPoints ; ++id) {\n      for (int dim = 0 ; dim < dims ; ++dim) {\n        Float f = Float.NaN;\n        while (f.isNaN()) {\n          f = Float.intBitsToFloat(random().nextInt());\n        }\n        values[id][dim] = f;\n      }\n      Document doc = new Document();\n      doc.add(new FloatPoint(\"point\", values[id]));\n      doc.add(new StoredField(\"id\", id));\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n\n    DirectoryReader r = w.getReader();\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    // can't wrap because we require Lucene60PointsFormat directly but e.g. ParallelReader wraps with its own points impl:\n    IndexSearcher s = newSearcher(r, false);\n    int iters = atLeast(100);\n    for (int iter = 0 ; iter < iters ; ++iter) {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter);\n      }\n      float[] origin = new float[dims];\n      for (int dim = 0 ; dim < dims ; ++dim) {\n        Float f = Float.NaN;\n        while (f.isNaN()) {\n          f = Float.intBitsToFloat(random().nextInt());\n        }\n        origin[dim] = f;\n      }\n\n      // dumb brute force search to get the expected result:\n      FloatPointNearestNeighbor.NearestHit[] expectedHits = new FloatPointNearestNeighbor.NearestHit[numPoints];\n      for (int id = 0 ; id < numPoints ; ++id) {\n        FloatPointNearestNeighbor.NearestHit hit = new FloatPointNearestNeighbor.NearestHit();\n        hit.distanceSquared = euclideanDistanceSquared(origin, values[id]);\n        hit.docID = id;\n        expectedHits[id] = hit;\n      }\n\n      Arrays.sort(expectedHits, (a, b) -> {\n        int cmp = Double.compare(a.distanceSquared, b.distanceSquared);\n        return cmp != 0 ? cmp : a.docID - b.docID; // tie break by smaller id\n      });\n\n      int topK = TestUtil.nextInt(random(), 1, numPoints);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nhits for origin=\" + Arrays.toString(origin));\n      }\n\n      ScoreDoc[] hits = FloatPointNearestNeighbor.nearest(s, \"point\", topK, origin).scoreDocs;\n      assertEquals(\"fewer than expected hits: \", topK, hits.length);\n\n      if (VERBOSE) {\n        for (int i = 0 ; i < topK ; ++i) {\n          FloatPointNearestNeighbor.NearestHit expected = expectedHits[i];\n          FieldDoc actual = (FieldDoc)hits[i];\n          Document actualDoc = r.document(actual.doc);\n          System.out.println(\"hit \" + i);\n          System.out.println(\"  expected id=\" + expected.docID + \"  \" + Arrays.toString(values[expected.docID])\n              + \"  distance=\" + (float)Math.sqrt(expected.distanceSquared) + \"  distanceSquared=\" + expected.distanceSquared);\n          System.out.println(\"  actual id=\" + actualDoc.getField(\"id\") + \" distance=\" + actual.fields[0]);\n        }\n      }\n\n      for (int i = 0 ; i < topK ; ++i) {\n        FloatPointNearestNeighbor.NearestHit expected = expectedHits[i];\n        FieldDoc actual = (FieldDoc)hits[i];\n        assertEquals(\"hit \" + i + \":\", expected.docID, actual.doc);\n        assertEquals(\"hit \" + i + \":\", (float)Math.sqrt(expected.distanceSquared), (Float)actual.fields[0], 0.000001);\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testNearestNeighborRandom() throws Exception {\n    Directory dir;\n    int numPoints = atLeast(5000);\n    if (numPoints > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    IndexWriterConfig iwc = getIndexWriterConfig();\n    iwc.setMergePolicy(newLogMergePolicy());\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int dims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n    float[][] values = new float[numPoints][dims];\n    for (int id = 0 ; id < numPoints ; ++id) {\n      for (int dim = 0 ; dim < dims ; ++dim) {\n        Float f = Float.NaN;\n        while (f.isNaN()) {\n          f = Float.intBitsToFloat(random().nextInt());\n        }\n        values[id][dim] = f;\n      }\n      Document doc = new Document();\n      doc.add(new FloatPoint(\"point\", values[id]));\n      doc.add(new StoredField(\"id\", id));\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n\n    DirectoryReader r = w.getReader();\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n    }\n    // can't wrap because we require Lucene60PointsFormat directly but e.g. ParallelReader wraps with its own points impl:\n    IndexSearcher s = newSearcher(r, false);\n    int iters = atLeast(100);\n    for (int iter = 0 ; iter < iters ; ++iter) {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter);\n      }\n      float[] origin = new float[dims];\n      for (int dim = 0 ; dim < dims ; ++dim) {\n        Float f = Float.NaN;\n        while (f.isNaN()) {\n          f = Float.intBitsToFloat(random().nextInt());\n        }\n        origin[dim] = f;\n      }\n\n      // dumb brute force search to get the expected result:\n      FloatPointNearestNeighbor.NearestHit[] expectedHits = new FloatPointNearestNeighbor.NearestHit[numPoints];\n      for (int id = 0 ; id < numPoints ; ++id) {\n        FloatPointNearestNeighbor.NearestHit hit = new FloatPointNearestNeighbor.NearestHit();\n        hit.distanceSquared = euclideanDistanceSquared(origin, values[id]);\n        hit.docID = id;\n        expectedHits[id] = hit;\n      }\n\n      Arrays.sort(expectedHits, (a, b) -> {\n        int cmp = Double.compare(a.distanceSquared, b.distanceSquared);\n        return cmp != 0 ? cmp : a.docID - b.docID; // tie break by smaller id\n      });\n\n      int topK = TestUtil.nextInt(random(), 1, numPoints);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nhits for origin=\" + Arrays.toString(origin));\n      }\n\n      ScoreDoc[] hits = FloatPointNearestNeighbor.nearest(s, \"point\", topK, origin).scoreDocs;\n      assertEquals(\"fewer than expected hits: \", topK, hits.length);\n\n      if (VERBOSE) {\n        for (int i = 0 ; i < topK ; ++i) {\n          FloatPointNearestNeighbor.NearestHit expected = expectedHits[i];\n          FieldDoc actual = (FieldDoc)hits[i];\n          Document actualDoc = r.document(actual.doc);\n          System.out.println(\"hit \" + i);\n          System.out.println(\"  expected id=\" + expected.docID + \"  \" + Arrays.toString(values[expected.docID])\n              + \"  distance=\" + (float)Math.sqrt(expected.distanceSquared) + \"  distanceSquared=\" + expected.distanceSquared);\n          System.out.println(\"  actual id=\" + actualDoc.getField(\"id\") + \" distance=\" + actual.fields[0]);\n        }\n      }\n\n      for (int i = 0 ; i < topK ; ++i) {\n        FloatPointNearestNeighbor.NearestHit expected = expectedHits[i];\n        FieldDoc actual = (FieldDoc)hits[i];\n        assertEquals(\"hit \" + i + \":\", expected.docID, actual.doc);\n        assertEquals(\"hit \" + i + \":\", (float)Math.sqrt(expected.distanceSquared), (Float)actual.fields[0], 0.000001);\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1b73cddaec09172a09da82e758d0014ab8810ffa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6240b74b884c5587f2a4062dd27d6c32bf228889":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1b73cddaec09172a09da82e758d0014ab8810ffa"],"59ed8c026ba85e3c42fb89605b2032dc6f9cc241":["097748fa4ff327a26994476115f52d1a899b549f"],"097748fa4ff327a26994476115f52d1a899b549f":["1b73cddaec09172a09da82e758d0014ab8810ffa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["59ed8c026ba85e3c42fb89605b2032dc6f9cc241"]},"commit2Childs":{"1b73cddaec09172a09da82e758d0014ab8810ffa":["6240b74b884c5587f2a4062dd27d6c32bf228889","097748fa4ff327a26994476115f52d1a899b549f"],"6240b74b884c5587f2a4062dd27d6c32bf228889":[],"59ed8c026ba85e3c42fb89605b2032dc6f9cc241":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"097748fa4ff327a26994476115f52d1a899b549f":["59ed8c026ba85e3c42fb89605b2032dc6f9cc241"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1b73cddaec09172a09da82e758d0014ab8810ffa","6240b74b884c5587f2a4062dd27d6c32bf228889"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["6240b74b884c5587f2a4062dd27d6c32bf228889","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}