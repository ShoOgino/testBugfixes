{"path":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledMaintenanceTriggerTest#testInactiveShardCleanup().mjava","commits":[{"id":"9c6c0dad4932399aec99b4818086cb1772773916","date":1520515900,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledMaintenanceTriggerTest#testInactiveShardCleanup().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testInactiveShardCleanup() throws Exception {\n    String collection1 = getClass().getSimpleName() + \"_collection1\";\n    CollectionAdminRequest.Create create1 = CollectionAdminRequest.createCollection(collection1,\n        \"conf\", 1, 1);\n\n    create1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collection1, collection1,\n        CloudTestUtils.clusterShape(1, 1));\n\n    CollectionAdminRequest.SplitShard split1 = CollectionAdminRequest.splitShard(collection1)\n        .setShardName(\"shard1\");\n    split1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to split \" + collection1, collection1,\n        CloudTestUtils.clusterShape(3, 1));\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'foo',\" +\n        \"'trigger' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'stage' : ['STARTED','ABORTED','SUCCEEDED','FAILED'],\" +\n        \"'beforeAction' : 'inactive_shard_plan',\" +\n        \"'afterAction' : 'inactive_shard_plan',\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : 'NOW+3SECONDS',\" +\n        \"'every' : '+2SECONDS',\" +\n        \"'enabled' : true,\" +\n        \"'actions' : [{'name' : 'inactive_shard_plan', 'class' : 'solr.InactiveShardPlanAction', 'ttl' : '10'},\" +\n        \"{'name' : 'execute_plan', 'class' : '\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'test', 'class' : '\" + TestTriggerAction.class.getName() + \"'}]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    boolean await = listenerCreated.await(10, TimeUnit.SECONDS);\n    assertTrue(\"listener not created in time\", await);\n    await = triggerFired.await(60, TimeUnit.SECONDS);\n    assertTrue(\"cleanup action didn't run\", await);\n\n    // cleanup should have occurred\n    assertFalse(\"no events captured!\", listenerEvents.isEmpty());\n    List<CapturedEvent> events = new ArrayList<>(listenerEvents.get(\"foo\"));\n    listenerEvents.clear();\n\n    assertFalse(events.isEmpty());\n    int inactiveEvents = 0;\n    CapturedEvent ce = null;\n    for (CapturedEvent e : events) {\n      if (e.stage != TriggerEventProcessorStage.AFTER_ACTION) {\n        continue;\n      }\n      if (e.context.containsKey(\"properties.inactive_shard_plan\")) {\n        ce = e;\n        break;\n      } else {\n        inactiveEvents++;\n      }\n    }\n    assertTrue(\"should be at least one inactive event\", inactiveEvents > 0);\n    assertNotNull(\"missing cleanup event\", ce);\n    Map<String, Object> map = (Map<String, Object>)ce.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n\n    Map<String, List<String>> inactive = (Map<String, List<String>>)map.get(\"inactive\");\n    assertEquals(1, inactive.size());\n    assertNotNull(inactive.get(collection1));\n    Map<String, List<String>> cleanup = (Map<String, List<String>>)map.get(\"cleanup\");\n    assertEquals(1, cleanup.size());\n    assertNotNull(cleanup.get(collection1));\n\n    ClusterState state = cloudManager.getClusterStateProvider().getClusterState();\n\n    CloudTestUtils.clusterShape(2, 1).matches(state.getLiveNodes(), state.getCollection(collection1));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0bfcbdfe07d46da058707c12412aef939a5f2198","date":1521339918,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledMaintenanceTriggerTest#testInactiveShardCleanup().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledMaintenanceTriggerTest#testInactiveShardCleanup().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 17-Mar-2018\n  public void testInactiveShardCleanup() throws Exception {\n    String collection1 = getClass().getSimpleName() + \"_collection1\";\n    CollectionAdminRequest.Create create1 = CollectionAdminRequest.createCollection(collection1,\n        \"conf\", 1, 1);\n\n    create1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collection1, collection1,\n        CloudTestUtils.clusterShape(1, 1));\n\n    CollectionAdminRequest.SplitShard split1 = CollectionAdminRequest.splitShard(collection1)\n        .setShardName(\"shard1\");\n    split1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to split \" + collection1, collection1,\n        CloudTestUtils.clusterShape(3, 1));\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'foo',\" +\n        \"'trigger' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'stage' : ['STARTED','ABORTED','SUCCEEDED','FAILED'],\" +\n        \"'beforeAction' : 'inactive_shard_plan',\" +\n        \"'afterAction' : 'inactive_shard_plan',\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : 'NOW+3SECONDS',\" +\n        \"'every' : '+2SECONDS',\" +\n        \"'enabled' : true,\" +\n        \"'actions' : [{'name' : 'inactive_shard_plan', 'class' : 'solr.InactiveShardPlanAction', 'ttl' : '10'},\" +\n        \"{'name' : 'execute_plan', 'class' : '\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'test', 'class' : '\" + TestTriggerAction.class.getName() + \"'}]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    boolean await = listenerCreated.await(10, TimeUnit.SECONDS);\n    assertTrue(\"listener not created in time\", await);\n    await = triggerFired.await(60, TimeUnit.SECONDS);\n    assertTrue(\"cleanup action didn't run\", await);\n\n    // cleanup should have occurred\n    assertFalse(\"no events captured!\", listenerEvents.isEmpty());\n    List<CapturedEvent> events = new ArrayList<>(listenerEvents.get(\"foo\"));\n    listenerEvents.clear();\n\n    assertFalse(events.isEmpty());\n    int inactiveEvents = 0;\n    CapturedEvent ce = null;\n    for (CapturedEvent e : events) {\n      if (e.stage != TriggerEventProcessorStage.AFTER_ACTION) {\n        continue;\n      }\n      if (e.context.containsKey(\"properties.inactive_shard_plan\")) {\n        ce = e;\n        break;\n      } else {\n        inactiveEvents++;\n      }\n    }\n    assertTrue(\"should be at least one inactive event\", inactiveEvents > 0);\n    assertNotNull(\"missing cleanup event\", ce);\n    Map<String, Object> map = (Map<String, Object>)ce.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n\n    Map<String, List<String>> inactive = (Map<String, List<String>>)map.get(\"inactive\");\n    assertEquals(1, inactive.size());\n    assertNotNull(inactive.get(collection1));\n    Map<String, List<String>> cleanup = (Map<String, List<String>>)map.get(\"cleanup\");\n    assertEquals(1, cleanup.size());\n    assertNotNull(cleanup.get(collection1));\n\n    ClusterState state = cloudManager.getClusterStateProvider().getClusterState();\n\n    CloudTestUtils.clusterShape(2, 1).matches(state.getLiveNodes(), state.getCollection(collection1));\n  }\n\n","sourceOld":"  @Test\n  public void testInactiveShardCleanup() throws Exception {\n    String collection1 = getClass().getSimpleName() + \"_collection1\";\n    CollectionAdminRequest.Create create1 = CollectionAdminRequest.createCollection(collection1,\n        \"conf\", 1, 1);\n\n    create1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collection1, collection1,\n        CloudTestUtils.clusterShape(1, 1));\n\n    CollectionAdminRequest.SplitShard split1 = CollectionAdminRequest.splitShard(collection1)\n        .setShardName(\"shard1\");\n    split1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to split \" + collection1, collection1,\n        CloudTestUtils.clusterShape(3, 1));\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'foo',\" +\n        \"'trigger' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'stage' : ['STARTED','ABORTED','SUCCEEDED','FAILED'],\" +\n        \"'beforeAction' : 'inactive_shard_plan',\" +\n        \"'afterAction' : 'inactive_shard_plan',\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : 'NOW+3SECONDS',\" +\n        \"'every' : '+2SECONDS',\" +\n        \"'enabled' : true,\" +\n        \"'actions' : [{'name' : 'inactive_shard_plan', 'class' : 'solr.InactiveShardPlanAction', 'ttl' : '10'},\" +\n        \"{'name' : 'execute_plan', 'class' : '\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'test', 'class' : '\" + TestTriggerAction.class.getName() + \"'}]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    boolean await = listenerCreated.await(10, TimeUnit.SECONDS);\n    assertTrue(\"listener not created in time\", await);\n    await = triggerFired.await(60, TimeUnit.SECONDS);\n    assertTrue(\"cleanup action didn't run\", await);\n\n    // cleanup should have occurred\n    assertFalse(\"no events captured!\", listenerEvents.isEmpty());\n    List<CapturedEvent> events = new ArrayList<>(listenerEvents.get(\"foo\"));\n    listenerEvents.clear();\n\n    assertFalse(events.isEmpty());\n    int inactiveEvents = 0;\n    CapturedEvent ce = null;\n    for (CapturedEvent e : events) {\n      if (e.stage != TriggerEventProcessorStage.AFTER_ACTION) {\n        continue;\n      }\n      if (e.context.containsKey(\"properties.inactive_shard_plan\")) {\n        ce = e;\n        break;\n      } else {\n        inactiveEvents++;\n      }\n    }\n    assertTrue(\"should be at least one inactive event\", inactiveEvents > 0);\n    assertNotNull(\"missing cleanup event\", ce);\n    Map<String, Object> map = (Map<String, Object>)ce.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n\n    Map<String, List<String>> inactive = (Map<String, List<String>>)map.get(\"inactive\");\n    assertEquals(1, inactive.size());\n    assertNotNull(inactive.get(collection1));\n    Map<String, List<String>> cleanup = (Map<String, List<String>>)map.get(\"cleanup\");\n    assertEquals(1, cleanup.size());\n    assertNotNull(cleanup.get(collection1));\n\n    ClusterState state = cloudManager.getClusterStateProvider().getClusterState();\n\n    CloudTestUtils.clusterShape(2, 1).matches(state.getLiveNodes(), state.getCollection(collection1));\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"203e3fcf513c02ee2c07015f2ce277e26dc60907","date":1521404157,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledMaintenanceTriggerTest#testInactiveShardCleanup().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledMaintenanceTriggerTest#testInactiveShardCleanup().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 17-Mar-2018\n  public void testInactiveShardCleanup() throws Exception {\n    String collection1 = getClass().getSimpleName() + \"_collection1\";\n    CollectionAdminRequest.Create create1 = CollectionAdminRequest.createCollection(collection1,\n        \"conf\", 1, 1);\n\n    create1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collection1, collection1,\n        CloudTestUtils.clusterShape(1, 1));\n\n    CollectionAdminRequest.SplitShard split1 = CollectionAdminRequest.splitShard(collection1)\n        .setShardName(\"shard1\");\n    split1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to split \" + collection1, collection1,\n        CloudTestUtils.clusterShape(3, 1));\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'foo',\" +\n        \"'trigger' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'stage' : ['STARTED','ABORTED','SUCCEEDED','FAILED'],\" +\n        \"'beforeAction' : 'inactive_shard_plan',\" +\n        \"'afterAction' : 'inactive_shard_plan',\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : 'NOW+3SECONDS',\" +\n        \"'every' : '+2SECONDS',\" +\n        \"'enabled' : true,\" +\n        \"'actions' : [{'name' : 'inactive_shard_plan', 'class' : 'solr.InactiveShardPlanAction', 'ttl' : '10'},\" +\n        \"{'name' : 'execute_plan', 'class' : '\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'test', 'class' : '\" + TestTriggerAction.class.getName() + \"'}]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    boolean await = listenerCreated.await(10, TimeUnit.SECONDS);\n    assertTrue(\"listener not created in time\", await);\n    await = triggerFired.await(60, TimeUnit.SECONDS);\n    assertTrue(\"cleanup action didn't run\", await);\n\n    // cleanup should have occurred\n    assertFalse(\"no events captured!\", listenerEvents.isEmpty());\n    List<CapturedEvent> events = new ArrayList<>(listenerEvents.get(\"foo\"));\n    listenerEvents.clear();\n\n    assertFalse(events.isEmpty());\n    int inactiveEvents = 0;\n    CapturedEvent ce = null;\n    for (CapturedEvent e : events) {\n      if (e.stage != TriggerEventProcessorStage.AFTER_ACTION) {\n        continue;\n      }\n      if (e.context.containsKey(\"properties.inactive_shard_plan\")) {\n        ce = e;\n        break;\n      } else {\n        inactiveEvents++;\n      }\n    }\n    assertTrue(\"should be at least one inactive event\", inactiveEvents > 0);\n    assertNotNull(\"missing cleanup event\", ce);\n    Map<String, Object> map = (Map<String, Object>)ce.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n\n    Map<String, List<String>> inactive = (Map<String, List<String>>)map.get(\"inactive\");\n    assertEquals(1, inactive.size());\n    assertNotNull(inactive.get(collection1));\n    Map<String, List<String>> cleanup = (Map<String, List<String>>)map.get(\"cleanup\");\n    assertEquals(1, cleanup.size());\n    assertNotNull(cleanup.get(collection1));\n\n    ClusterState state = cloudManager.getClusterStateProvider().getClusterState();\n\n    CloudTestUtils.clusterShape(2, 1).matches(state.getLiveNodes(), state.getCollection(collection1));\n  }\n\n","sourceOld":"  @Test\n  public void testInactiveShardCleanup() throws Exception {\n    String collection1 = getClass().getSimpleName() + \"_collection1\";\n    CollectionAdminRequest.Create create1 = CollectionAdminRequest.createCollection(collection1,\n        \"conf\", 1, 1);\n\n    create1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collection1, collection1,\n        CloudTestUtils.clusterShape(1, 1));\n\n    CollectionAdminRequest.SplitShard split1 = CollectionAdminRequest.splitShard(collection1)\n        .setShardName(\"shard1\");\n    split1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to split \" + collection1, collection1,\n        CloudTestUtils.clusterShape(3, 1));\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'foo',\" +\n        \"'trigger' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'stage' : ['STARTED','ABORTED','SUCCEEDED','FAILED'],\" +\n        \"'beforeAction' : 'inactive_shard_plan',\" +\n        \"'afterAction' : 'inactive_shard_plan',\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : 'NOW+3SECONDS',\" +\n        \"'every' : '+2SECONDS',\" +\n        \"'enabled' : true,\" +\n        \"'actions' : [{'name' : 'inactive_shard_plan', 'class' : 'solr.InactiveShardPlanAction', 'ttl' : '10'},\" +\n        \"{'name' : 'execute_plan', 'class' : '\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'test', 'class' : '\" + TestTriggerAction.class.getName() + \"'}]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    boolean await = listenerCreated.await(10, TimeUnit.SECONDS);\n    assertTrue(\"listener not created in time\", await);\n    await = triggerFired.await(60, TimeUnit.SECONDS);\n    assertTrue(\"cleanup action didn't run\", await);\n\n    // cleanup should have occurred\n    assertFalse(\"no events captured!\", listenerEvents.isEmpty());\n    List<CapturedEvent> events = new ArrayList<>(listenerEvents.get(\"foo\"));\n    listenerEvents.clear();\n\n    assertFalse(events.isEmpty());\n    int inactiveEvents = 0;\n    CapturedEvent ce = null;\n    for (CapturedEvent e : events) {\n      if (e.stage != TriggerEventProcessorStage.AFTER_ACTION) {\n        continue;\n      }\n      if (e.context.containsKey(\"properties.inactive_shard_plan\")) {\n        ce = e;\n        break;\n      } else {\n        inactiveEvents++;\n      }\n    }\n    assertTrue(\"should be at least one inactive event\", inactiveEvents > 0);\n    assertNotNull(\"missing cleanup event\", ce);\n    Map<String, Object> map = (Map<String, Object>)ce.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n\n    Map<String, List<String>> inactive = (Map<String, List<String>>)map.get(\"inactive\");\n    assertEquals(1, inactive.size());\n    assertNotNull(inactive.get(collection1));\n    Map<String, List<String>> cleanup = (Map<String, List<String>>)map.get(\"cleanup\");\n    assertEquals(1, cleanup.size());\n    assertNotNull(cleanup.get(collection1));\n\n    ClusterState state = cloudManager.getClusterStateProvider().getClusterState();\n\n    CloudTestUtils.clusterShape(2, 1).matches(state.getLiveNodes(), state.getCollection(collection1));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1","date":1523453934,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledMaintenanceTriggerTest#testInactiveShardCleanup().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledMaintenanceTriggerTest#testInactiveShardCleanup().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 17-Mar-2018\n  public void testInactiveShardCleanup() throws Exception {\n    String collection1 = getClass().getSimpleName() + \"_collection1\";\n    CollectionAdminRequest.Create create1 = CollectionAdminRequest.createCollection(collection1,\n        \"conf\", 1, 1);\n\n    create1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collection1, collection1,\n        CloudTestUtils.clusterShape(1, 1));\n\n    CollectionAdminRequest.SplitShard split1 = CollectionAdminRequest.splitShard(collection1)\n        .setShardName(\"shard1\");\n    split1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to split \" + collection1, collection1,\n        CloudTestUtils.clusterShape(3, 1, true));\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'foo',\" +\n        \"'trigger' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'stage' : ['STARTED','ABORTED','SUCCEEDED','FAILED'],\" +\n        \"'beforeAction' : 'inactive_shard_plan',\" +\n        \"'afterAction' : 'inactive_shard_plan',\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : 'NOW+3SECONDS',\" +\n        \"'every' : '+2SECONDS',\" +\n        \"'enabled' : true,\" +\n        \"'actions' : [{'name' : 'inactive_shard_plan', 'class' : 'solr.InactiveShardPlanAction', 'ttl' : '10'},\" +\n        \"{'name' : 'execute_plan', 'class' : '\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'test', 'class' : '\" + TestTriggerAction.class.getName() + \"'}]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    boolean await = listenerCreated.await(10, TimeUnit.SECONDS);\n    assertTrue(\"listener not created in time\", await);\n    await = triggerFired.await(60, TimeUnit.SECONDS);\n    assertTrue(\"cleanup action didn't run\", await);\n\n    // cleanup should have occurred\n    assertFalse(\"no events captured!\", listenerEvents.isEmpty());\n    List<CapturedEvent> events = new ArrayList<>(listenerEvents.get(\"foo\"));\n    listenerEvents.clear();\n\n    assertFalse(events.isEmpty());\n    int inactiveEvents = 0;\n    CapturedEvent ce = null;\n    for (CapturedEvent e : events) {\n      if (e.stage != TriggerEventProcessorStage.AFTER_ACTION) {\n        continue;\n      }\n      if (e.context.containsKey(\"properties.inactive_shard_plan\")) {\n        ce = e;\n        break;\n      } else {\n        inactiveEvents++;\n      }\n    }\n    assertTrue(\"should be at least one inactive event\", inactiveEvents > 0);\n    assertNotNull(\"missing cleanup event\", ce);\n    Map<String, Object> map = (Map<String, Object>)ce.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n\n    Map<String, List<String>> inactive = (Map<String, List<String>>)map.get(\"inactive\");\n    assertEquals(1, inactive.size());\n    assertNotNull(inactive.get(collection1));\n    Map<String, List<String>> cleanup = (Map<String, List<String>>)map.get(\"cleanup\");\n    assertEquals(1, cleanup.size());\n    assertNotNull(cleanup.get(collection1));\n\n    ClusterState state = cloudManager.getClusterStateProvider().getClusterState();\n\n    CloudTestUtils.clusterShape(2, 1).matches(state.getLiveNodes(), state.getCollection(collection1));\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 17-Mar-2018\n  public void testInactiveShardCleanup() throws Exception {\n    String collection1 = getClass().getSimpleName() + \"_collection1\";\n    CollectionAdminRequest.Create create1 = CollectionAdminRequest.createCollection(collection1,\n        \"conf\", 1, 1);\n\n    create1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collection1, collection1,\n        CloudTestUtils.clusterShape(1, 1));\n\n    CollectionAdminRequest.SplitShard split1 = CollectionAdminRequest.splitShard(collection1)\n        .setShardName(\"shard1\");\n    split1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to split \" + collection1, collection1,\n        CloudTestUtils.clusterShape(3, 1));\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'foo',\" +\n        \"'trigger' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'stage' : ['STARTED','ABORTED','SUCCEEDED','FAILED'],\" +\n        \"'beforeAction' : 'inactive_shard_plan',\" +\n        \"'afterAction' : 'inactive_shard_plan',\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : 'NOW+3SECONDS',\" +\n        \"'every' : '+2SECONDS',\" +\n        \"'enabled' : true,\" +\n        \"'actions' : [{'name' : 'inactive_shard_plan', 'class' : 'solr.InactiveShardPlanAction', 'ttl' : '10'},\" +\n        \"{'name' : 'execute_plan', 'class' : '\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'test', 'class' : '\" + TestTriggerAction.class.getName() + \"'}]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    boolean await = listenerCreated.await(10, TimeUnit.SECONDS);\n    assertTrue(\"listener not created in time\", await);\n    await = triggerFired.await(60, TimeUnit.SECONDS);\n    assertTrue(\"cleanup action didn't run\", await);\n\n    // cleanup should have occurred\n    assertFalse(\"no events captured!\", listenerEvents.isEmpty());\n    List<CapturedEvent> events = new ArrayList<>(listenerEvents.get(\"foo\"));\n    listenerEvents.clear();\n\n    assertFalse(events.isEmpty());\n    int inactiveEvents = 0;\n    CapturedEvent ce = null;\n    for (CapturedEvent e : events) {\n      if (e.stage != TriggerEventProcessorStage.AFTER_ACTION) {\n        continue;\n      }\n      if (e.context.containsKey(\"properties.inactive_shard_plan\")) {\n        ce = e;\n        break;\n      } else {\n        inactiveEvents++;\n      }\n    }\n    assertTrue(\"should be at least one inactive event\", inactiveEvents > 0);\n    assertNotNull(\"missing cleanup event\", ce);\n    Map<String, Object> map = (Map<String, Object>)ce.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n\n    Map<String, List<String>> inactive = (Map<String, List<String>>)map.get(\"inactive\");\n    assertEquals(1, inactive.size());\n    assertNotNull(inactive.get(collection1));\n    Map<String, List<String>> cleanup = (Map<String, List<String>>)map.get(\"cleanup\");\n    assertEquals(1, cleanup.size());\n    assertNotNull(cleanup.get(collection1));\n\n    ClusterState state = cloudManager.getClusterStateProvider().getClusterState();\n\n    CloudTestUtils.clusterShape(2, 1).matches(state.getLiveNodes(), state.getCollection(collection1));\n  }\n\n","bugFix":null,"bugIntro":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"43345f1452f9510f8aaadae6156fe0c834e7d957","date":1523483670,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledMaintenanceTriggerTest#testInactiveShardCleanup().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledMaintenanceTriggerTest#testInactiveShardCleanup().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 17-Mar-2018\n  public void testInactiveShardCleanup() throws Exception {\n    String collection1 = getClass().getSimpleName() + \"_collection1\";\n    CollectionAdminRequest.Create create1 = CollectionAdminRequest.createCollection(collection1,\n        \"conf\", 1, 1);\n\n    create1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collection1, collection1,\n        CloudTestUtils.clusterShape(1, 1));\n\n    CollectionAdminRequest.SplitShard split1 = CollectionAdminRequest.splitShard(collection1)\n        .setShardName(\"shard1\");\n    split1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to split \" + collection1, collection1,\n        CloudTestUtils.clusterShape(3, 1, true));\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'foo',\" +\n        \"'trigger' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'stage' : ['STARTED','ABORTED','SUCCEEDED','FAILED'],\" +\n        \"'beforeAction' : 'inactive_shard_plan',\" +\n        \"'afterAction' : 'inactive_shard_plan',\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : 'NOW+3SECONDS',\" +\n        \"'every' : '+2SECONDS',\" +\n        \"'enabled' : true,\" +\n        \"'actions' : [{'name' : 'inactive_shard_plan', 'class' : 'solr.InactiveShardPlanAction', 'ttl' : '10'},\" +\n        \"{'name' : 'execute_plan', 'class' : '\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'test', 'class' : '\" + TestTriggerAction.class.getName() + \"'}]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    boolean await = listenerCreated.await(10, TimeUnit.SECONDS);\n    assertTrue(\"listener not created in time\", await);\n    await = triggerFired.await(60, TimeUnit.SECONDS);\n    assertTrue(\"cleanup action didn't run\", await);\n\n    // cleanup should have occurred\n    assertFalse(\"no events captured!\", listenerEvents.isEmpty());\n    List<CapturedEvent> events = new ArrayList<>(listenerEvents.get(\"foo\"));\n    listenerEvents.clear();\n\n    assertFalse(events.isEmpty());\n    int inactiveEvents = 0;\n    CapturedEvent ce = null;\n    for (CapturedEvent e : events) {\n      if (e.stage != TriggerEventProcessorStage.AFTER_ACTION) {\n        continue;\n      }\n      if (e.context.containsKey(\"properties.inactive_shard_plan\")) {\n        ce = e;\n        break;\n      } else {\n        inactiveEvents++;\n      }\n    }\n    assertTrue(\"should be at least one inactive event\", inactiveEvents > 0);\n    assertNotNull(\"missing cleanup event\", ce);\n    Map<String, Object> map = (Map<String, Object>)ce.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n\n    Map<String, List<String>> inactive = (Map<String, List<String>>)map.get(\"inactive\");\n    assertEquals(1, inactive.size());\n    assertNotNull(inactive.get(collection1));\n    Map<String, List<String>> cleanup = (Map<String, List<String>>)map.get(\"cleanup\");\n    assertEquals(1, cleanup.size());\n    assertNotNull(cleanup.get(collection1));\n\n    ClusterState state = cloudManager.getClusterStateProvider().getClusterState();\n\n    CloudTestUtils.clusterShape(2, 1).matches(state.getLiveNodes(), state.getCollection(collection1));\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 17-Mar-2018\n  public void testInactiveShardCleanup() throws Exception {\n    String collection1 = getClass().getSimpleName() + \"_collection1\";\n    CollectionAdminRequest.Create create1 = CollectionAdminRequest.createCollection(collection1,\n        \"conf\", 1, 1);\n\n    create1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collection1, collection1,\n        CloudTestUtils.clusterShape(1, 1));\n\n    CollectionAdminRequest.SplitShard split1 = CollectionAdminRequest.splitShard(collection1)\n        .setShardName(\"shard1\");\n    split1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to split \" + collection1, collection1,\n        CloudTestUtils.clusterShape(3, 1));\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'foo',\" +\n        \"'trigger' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'stage' : ['STARTED','ABORTED','SUCCEEDED','FAILED'],\" +\n        \"'beforeAction' : 'inactive_shard_plan',\" +\n        \"'afterAction' : 'inactive_shard_plan',\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : 'NOW+3SECONDS',\" +\n        \"'every' : '+2SECONDS',\" +\n        \"'enabled' : true,\" +\n        \"'actions' : [{'name' : 'inactive_shard_plan', 'class' : 'solr.InactiveShardPlanAction', 'ttl' : '10'},\" +\n        \"{'name' : 'execute_plan', 'class' : '\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'test', 'class' : '\" + TestTriggerAction.class.getName() + \"'}]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    boolean await = listenerCreated.await(10, TimeUnit.SECONDS);\n    assertTrue(\"listener not created in time\", await);\n    await = triggerFired.await(60, TimeUnit.SECONDS);\n    assertTrue(\"cleanup action didn't run\", await);\n\n    // cleanup should have occurred\n    assertFalse(\"no events captured!\", listenerEvents.isEmpty());\n    List<CapturedEvent> events = new ArrayList<>(listenerEvents.get(\"foo\"));\n    listenerEvents.clear();\n\n    assertFalse(events.isEmpty());\n    int inactiveEvents = 0;\n    CapturedEvent ce = null;\n    for (CapturedEvent e : events) {\n      if (e.stage != TriggerEventProcessorStage.AFTER_ACTION) {\n        continue;\n      }\n      if (e.context.containsKey(\"properties.inactive_shard_plan\")) {\n        ce = e;\n        break;\n      } else {\n        inactiveEvents++;\n      }\n    }\n    assertTrue(\"should be at least one inactive event\", inactiveEvents > 0);\n    assertNotNull(\"missing cleanup event\", ce);\n    Map<String, Object> map = (Map<String, Object>)ce.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n\n    Map<String, List<String>> inactive = (Map<String, List<String>>)map.get(\"inactive\");\n    assertEquals(1, inactive.size());\n    assertNotNull(inactive.get(collection1));\n    Map<String, List<String>> cleanup = (Map<String, List<String>>)map.get(\"cleanup\");\n    assertEquals(1, cleanup.size());\n    assertNotNull(cleanup.get(collection1));\n\n    ClusterState state = cloudManager.getClusterStateProvider().getClusterState();\n\n    CloudTestUtils.clusterShape(2, 1).matches(state.getLiveNodes(), state.getCollection(collection1));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"042b92cf48996255bedb0c3c4bf772d7e06e4dea","date":1534272102,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledMaintenanceTriggerTest#testInactiveShardCleanup().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledMaintenanceTriggerTest#testInactiveShardCleanup().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 17-Mar-2018\n  public void testInactiveShardCleanup() throws Exception {\n    String collection1 = getClass().getSimpleName() + \"_collection1\";\n    CollectionAdminRequest.Create create1 = CollectionAdminRequest.createCollection(collection1,\n        \"conf\", 1, 1);\n\n    create1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collection1, collection1,\n        CloudTestUtils.clusterShape(1, 1));\n\n    CollectionAdminRequest.SplitShard split1 = CollectionAdminRequest.splitShard(collection1)\n        .setShardName(\"shard1\");\n    split1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to split \" + collection1, collection1,\n        CloudTestUtils.clusterShape(3, 1, true, true));\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'foo',\" +\n        \"'trigger' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'stage' : ['STARTED','ABORTED','SUCCEEDED','FAILED'],\" +\n        \"'beforeAction' : 'inactive_shard_plan',\" +\n        \"'afterAction' : 'inactive_shard_plan',\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : 'NOW+3SECONDS',\" +\n        \"'every' : '+2SECONDS',\" +\n        \"'enabled' : true,\" +\n        \"'actions' : [{'name' : 'inactive_shard_plan', 'class' : 'solr.InactiveShardPlanAction', 'ttl' : '10'},\" +\n        \"{'name' : 'execute_plan', 'class' : '\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'test', 'class' : '\" + TestTriggerAction.class.getName() + \"'}]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    boolean await = listenerCreated.await(10, TimeUnit.SECONDS);\n    assertTrue(\"listener not created in time\", await);\n    await = triggerFired.await(60, TimeUnit.SECONDS);\n    assertTrue(\"cleanup action didn't run\", await);\n\n    // cleanup should have occurred\n    assertFalse(\"no events captured!\", listenerEvents.isEmpty());\n    List<CapturedEvent> events = new ArrayList<>(listenerEvents.get(\"foo\"));\n    listenerEvents.clear();\n\n    assertFalse(events.isEmpty());\n    int inactiveEvents = 0;\n    CapturedEvent ce = null;\n    for (CapturedEvent e : events) {\n      if (e.stage != TriggerEventProcessorStage.AFTER_ACTION) {\n        continue;\n      }\n      if (e.context.containsKey(\"properties.inactive_shard_plan\")) {\n        ce = e;\n        break;\n      } else {\n        inactiveEvents++;\n      }\n    }\n    assertTrue(\"should be at least one inactive event\", inactiveEvents > 0);\n    assertNotNull(\"missing cleanup event\", ce);\n    Map<String, Object> map = (Map<String, Object>)ce.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n\n    Map<String, List<String>> inactive = (Map<String, List<String>>)map.get(\"inactive\");\n    assertEquals(1, inactive.size());\n    assertNotNull(inactive.get(collection1));\n    Map<String, List<String>> cleanup = (Map<String, List<String>>)map.get(\"cleanup\");\n    assertEquals(1, cleanup.size());\n    assertNotNull(cleanup.get(collection1));\n\n    ClusterState state = cloudManager.getClusterStateProvider().getClusterState();\n\n    CloudTestUtils.clusterShape(2, 1).matches(state.getLiveNodes(), state.getCollection(collection1));\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 17-Mar-2018\n  public void testInactiveShardCleanup() throws Exception {\n    String collection1 = getClass().getSimpleName() + \"_collection1\";\n    CollectionAdminRequest.Create create1 = CollectionAdminRequest.createCollection(collection1,\n        \"conf\", 1, 1);\n\n    create1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collection1, collection1,\n        CloudTestUtils.clusterShape(1, 1));\n\n    CollectionAdminRequest.SplitShard split1 = CollectionAdminRequest.splitShard(collection1)\n        .setShardName(\"shard1\");\n    split1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to split \" + collection1, collection1,\n        CloudTestUtils.clusterShape(3, 1, true));\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'foo',\" +\n        \"'trigger' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'stage' : ['STARTED','ABORTED','SUCCEEDED','FAILED'],\" +\n        \"'beforeAction' : 'inactive_shard_plan',\" +\n        \"'afterAction' : 'inactive_shard_plan',\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : 'NOW+3SECONDS',\" +\n        \"'every' : '+2SECONDS',\" +\n        \"'enabled' : true,\" +\n        \"'actions' : [{'name' : 'inactive_shard_plan', 'class' : 'solr.InactiveShardPlanAction', 'ttl' : '10'},\" +\n        \"{'name' : 'execute_plan', 'class' : '\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'test', 'class' : '\" + TestTriggerAction.class.getName() + \"'}]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    boolean await = listenerCreated.await(10, TimeUnit.SECONDS);\n    assertTrue(\"listener not created in time\", await);\n    await = triggerFired.await(60, TimeUnit.SECONDS);\n    assertTrue(\"cleanup action didn't run\", await);\n\n    // cleanup should have occurred\n    assertFalse(\"no events captured!\", listenerEvents.isEmpty());\n    List<CapturedEvent> events = new ArrayList<>(listenerEvents.get(\"foo\"));\n    listenerEvents.clear();\n\n    assertFalse(events.isEmpty());\n    int inactiveEvents = 0;\n    CapturedEvent ce = null;\n    for (CapturedEvent e : events) {\n      if (e.stage != TriggerEventProcessorStage.AFTER_ACTION) {\n        continue;\n      }\n      if (e.context.containsKey(\"properties.inactive_shard_plan\")) {\n        ce = e;\n        break;\n      } else {\n        inactiveEvents++;\n      }\n    }\n    assertTrue(\"should be at least one inactive event\", inactiveEvents > 0);\n    assertNotNull(\"missing cleanup event\", ce);\n    Map<String, Object> map = (Map<String, Object>)ce.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n\n    Map<String, List<String>> inactive = (Map<String, List<String>>)map.get(\"inactive\");\n    assertEquals(1, inactive.size());\n    assertNotNull(inactive.get(collection1));\n    Map<String, List<String>> cleanup = (Map<String, List<String>>)map.get(\"cleanup\");\n    assertEquals(1, cleanup.size());\n    assertNotNull(cleanup.get(collection1));\n\n    ClusterState state = cloudManager.getClusterStateProvider().getClusterState();\n\n    CloudTestUtils.clusterShape(2, 1).matches(state.getLiveNodes(), state.getCollection(collection1));\n  }\n\n","bugFix":["ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fea75bde50d2c0a79b0a0be05e7c3e1fdfa89894","date":1537432584,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledMaintenanceTriggerTest#testInactiveShardCleanup().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledMaintenanceTriggerTest#testInactiveShardCleanup().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 17-Mar-2018\n  public void testInactiveShardCleanup() throws Exception {\n    String collection1 = getClass().getSimpleName() + \"_collection1\";\n    CollectionAdminRequest.Create create1 = CollectionAdminRequest.createCollection(collection1,\n        \"conf\", 1, 1);\n\n    create1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collection1, collection1,\n        CloudTestUtils.clusterShape(1, 1));\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'foo',\" +\n        \"'trigger' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'stage' : ['STARTED','ABORTED','SUCCEEDED','FAILED'],\" +\n        \"'beforeAction' : 'inactive_shard_plan',\" +\n        \"'afterAction' : 'inactive_shard_plan',\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : 'NOW+3SECONDS',\" +\n        \"'every' : '+2SECONDS',\" +\n        \"'enabled' : true,\" +\n        \"'actions' : [{'name' : 'inactive_shard_plan', 'class' : 'solr.InactiveShardPlanAction', 'ttl' : '10'},\" +\n        \"{'name' : 'execute_plan', 'class' : '\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'test', 'class' : '\" + TestTriggerAction.class.getName() + \"'}]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n\n    boolean await = listenerCreated.await(10, TimeUnit.SECONDS);\n    assertTrue(\"listener not created in time\", await);\n\n    CollectionAdminRequest.SplitShard split1 = CollectionAdminRequest.splitShard(collection1)\n        .setShardName(\"shard1\");\n    split1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to split \" + collection1, collection1,\n        CloudTestUtils.clusterShape(3, 1, true, true));\n\n\n    await = triggerFired.await(60, TimeUnit.SECONDS);\n    assertTrue(\"cleanup action didn't run\", await);\n\n    // cleanup should have occurred\n    assertFalse(\"no events captured!\", listenerEvents.isEmpty());\n    List<CapturedEvent> events = new ArrayList<>(listenerEvents.get(\"foo\"));\n    listenerEvents.clear();\n\n    assertFalse(events.isEmpty());\n    int inactiveEvents = 0;\n    CapturedEvent ce = null;\n    for (CapturedEvent e : events) {\n      if (e.stage != TriggerEventProcessorStage.AFTER_ACTION) {\n        continue;\n      }\n      if (e.context.containsKey(\"properties.inactive_shard_plan\")) {\n        ce = e;\n        break;\n      } else {\n        inactiveEvents++;\n      }\n    }\n    assertTrue(\"should be at least one inactive event\", inactiveEvents > 0);\n    assertNotNull(\"missing cleanup event\", ce);\n    Map<String, Object> map = (Map<String, Object>)ce.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n\n    Map<String, List<String>> inactive = (Map<String, List<String>>)map.get(\"inactive\");\n    assertEquals(1, inactive.size());\n    assertNotNull(inactive.get(collection1));\n    Map<String, List<String>> cleanup = (Map<String, List<String>>)map.get(\"cleanup\");\n    assertEquals(1, cleanup.size());\n    assertNotNull(cleanup.get(collection1));\n\n    ClusterState state = cloudManager.getClusterStateProvider().getClusterState();\n\n    CloudTestUtils.clusterShape(2, 1).matches(state.getLiveNodes(), state.getCollection(collection1));\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 17-Mar-2018\n  public void testInactiveShardCleanup() throws Exception {\n    String collection1 = getClass().getSimpleName() + \"_collection1\";\n    CollectionAdminRequest.Create create1 = CollectionAdminRequest.createCollection(collection1,\n        \"conf\", 1, 1);\n\n    create1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collection1, collection1,\n        CloudTestUtils.clusterShape(1, 1));\n\n    CollectionAdminRequest.SplitShard split1 = CollectionAdminRequest.splitShard(collection1)\n        .setShardName(\"shard1\");\n    split1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to split \" + collection1, collection1,\n        CloudTestUtils.clusterShape(3, 1, true, true));\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'foo',\" +\n        \"'trigger' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'stage' : ['STARTED','ABORTED','SUCCEEDED','FAILED'],\" +\n        \"'beforeAction' : 'inactive_shard_plan',\" +\n        \"'afterAction' : 'inactive_shard_plan',\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : 'NOW+3SECONDS',\" +\n        \"'every' : '+2SECONDS',\" +\n        \"'enabled' : true,\" +\n        \"'actions' : [{'name' : 'inactive_shard_plan', 'class' : 'solr.InactiveShardPlanAction', 'ttl' : '10'},\" +\n        \"{'name' : 'execute_plan', 'class' : '\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'test', 'class' : '\" + TestTriggerAction.class.getName() + \"'}]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    boolean await = listenerCreated.await(10, TimeUnit.SECONDS);\n    assertTrue(\"listener not created in time\", await);\n    await = triggerFired.await(60, TimeUnit.SECONDS);\n    assertTrue(\"cleanup action didn't run\", await);\n\n    // cleanup should have occurred\n    assertFalse(\"no events captured!\", listenerEvents.isEmpty());\n    List<CapturedEvent> events = new ArrayList<>(listenerEvents.get(\"foo\"));\n    listenerEvents.clear();\n\n    assertFalse(events.isEmpty());\n    int inactiveEvents = 0;\n    CapturedEvent ce = null;\n    for (CapturedEvent e : events) {\n      if (e.stage != TriggerEventProcessorStage.AFTER_ACTION) {\n        continue;\n      }\n      if (e.context.containsKey(\"properties.inactive_shard_plan\")) {\n        ce = e;\n        break;\n      } else {\n        inactiveEvents++;\n      }\n    }\n    assertTrue(\"should be at least one inactive event\", inactiveEvents > 0);\n    assertNotNull(\"missing cleanup event\", ce);\n    Map<String, Object> map = (Map<String, Object>)ce.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n\n    Map<String, List<String>> inactive = (Map<String, List<String>>)map.get(\"inactive\");\n    assertEquals(1, inactive.size());\n    assertNotNull(inactive.get(collection1));\n    Map<String, List<String>> cleanup = (Map<String, List<String>>)map.get(\"cleanup\");\n    assertEquals(1, cleanup.size());\n    assertNotNull(cleanup.get(collection1));\n\n    ClusterState state = cloudManager.getClusterStateProvider().getClusterState();\n\n    CloudTestUtils.clusterShape(2, 1).matches(state.getLiveNodes(), state.getCollection(collection1));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae70f2df00762dfce0455c0e39381848762662e5","date":1539113410,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledMaintenanceTriggerTest#testInactiveShardCleanup().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledMaintenanceTriggerTest#testInactiveShardCleanup().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 17-Mar-2018\n  public void testInactiveShardCleanup() throws Exception {\n    String collection1 = getClass().getSimpleName() + \"_collection1\";\n    CollectionAdminRequest.Create create1 = CollectionAdminRequest.createCollection(collection1,\n        \"conf\", 1, 1);\n\n    create1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collection1, collection1,\n        CloudTestUtils.clusterShape(1, 1));\n\n    // also create a very stale lock\n    Map<String, Object> lockData = new HashMap<>();\n    lockData.put(ZkStateReader.STATE_TIMESTAMP_PROP, String.valueOf(cloudManager.getTimeSource().getEpochTimeNs() -\n        TimeUnit.NANOSECONDS.convert(48, TimeUnit.HOURS)));\n    String staleLockName = collection1 + \"/staleShard-splitting\";\n    cloudManager.getDistribStateManager().makePath(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" +\n        staleLockName, Utils.toJSON(lockData), CreateMode.EPHEMERAL, true);\n\n    // expect two events - one for a very stale lock, one for the cleanup\n    triggerFired = new CountDownLatch(2);\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'foo',\" +\n        \"'trigger' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'stage' : ['STARTED','ABORTED','SUCCEEDED','FAILED'],\" +\n        \"'beforeAction' : 'inactive_shard_plan',\" +\n        \"'afterAction' : 'inactive_shard_plan',\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : 'NOW+10SECONDS',\" +\n        \"'every' : '+2SECONDS',\" +\n        \"'enabled' : true,\" +\n        \"'actions' : [{'name' : 'inactive_shard_plan', 'class' : 'solr.InactiveShardPlanAction', 'ttl' : '20'},\" +\n        \"{'name' : 'execute_plan', 'class' : '\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'test', 'class' : '\" + TestTriggerAction.class.getName() + \"'}]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n\n    boolean await = listenerCreated.await(10, TimeUnit.SECONDS);\n    assertTrue(\"listener not created in time\", await);\n\n    CollectionAdminRequest.SplitShard split1 = CollectionAdminRequest.splitShard(collection1)\n        .setShardName(\"shard1\");\n    split1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to split \" + collection1, collection1,\n        CloudTestUtils.clusterShape(3, 1, true, true));\n\n\n    await = triggerFired.await(90, TimeUnit.SECONDS);\n    assertTrue(\"cleanup action didn't run\", await);\n\n    // cleanup should have occurred\n    assertFalse(\"no events captured!\", listenerEvents.isEmpty());\n    List<CapturedEvent> events = new ArrayList<>(listenerEvents.get(\"foo\"));\n    listenerEvents.clear();\n\n    assertFalse(events.isEmpty());\n    CapturedEvent ce = null;\n    CapturedEvent staleLock = null;\n    for (CapturedEvent e : events) {\n      if (e.stage != TriggerEventProcessorStage.AFTER_ACTION) {\n        continue;\n      }\n      Map<String, Object> plan = (Map<String, Object>)e.context.get(\"properties.inactive_shard_plan\");\n      if (plan == null) {\n        continue;\n      }\n      if (plan.containsKey(\"cleanup\")) {\n        ce = e;\n      }\n      // capture only the first\n      if (plan.containsKey(\"staleLocks\") && staleLock == null) {\n        staleLock = e;\n      }\n    }\n    assertNotNull(\"missing cleanup event: \" + events, ce);\n    assertNotNull(\"missing staleLocks event: \" + events, staleLock);\n\n    Map<String, Object> map = (Map<String, Object>)ce.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n\n    Map<String, List<String>> inactive = (Map<String, List<String>>)map.get(\"inactive\");\n    assertEquals(1, inactive.size());\n    assertNotNull(inactive.get(collection1));\n    Map<String, List<String>> cleanup = (Map<String, List<String>>)map.get(\"cleanup\");\n    assertEquals(1, cleanup.size());\n    assertNotNull(cleanup.get(collection1));\n\n    map = (Map<String, Object>)staleLock.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n    Map<String, Map<String, Object>> locks = (Map<String, Map<String, Object>>)map.get(\"staleLocks\");\n    assertNotNull(locks);\n    assertTrue(\"missing stale lock data: \" + locks + \"\\nevents: \" + events, locks.containsKey(staleLockName));\n\n    ClusterState state = cloudManager.getClusterStateProvider().getClusterState();\n\n    CloudTestUtils.clusterShape(2, 1).matches(state.getLiveNodes(), state.getCollection(collection1));\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 17-Mar-2018\n  public void testInactiveShardCleanup() throws Exception {\n    String collection1 = getClass().getSimpleName() + \"_collection1\";\n    CollectionAdminRequest.Create create1 = CollectionAdminRequest.createCollection(collection1,\n        \"conf\", 1, 1);\n\n    create1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collection1, collection1,\n        CloudTestUtils.clusterShape(1, 1));\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'foo',\" +\n        \"'trigger' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'stage' : ['STARTED','ABORTED','SUCCEEDED','FAILED'],\" +\n        \"'beforeAction' : 'inactive_shard_plan',\" +\n        \"'afterAction' : 'inactive_shard_plan',\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : 'NOW+3SECONDS',\" +\n        \"'every' : '+2SECONDS',\" +\n        \"'enabled' : true,\" +\n        \"'actions' : [{'name' : 'inactive_shard_plan', 'class' : 'solr.InactiveShardPlanAction', 'ttl' : '10'},\" +\n        \"{'name' : 'execute_plan', 'class' : '\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'test', 'class' : '\" + TestTriggerAction.class.getName() + \"'}]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n\n    boolean await = listenerCreated.await(10, TimeUnit.SECONDS);\n    assertTrue(\"listener not created in time\", await);\n\n    CollectionAdminRequest.SplitShard split1 = CollectionAdminRequest.splitShard(collection1)\n        .setShardName(\"shard1\");\n    split1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to split \" + collection1, collection1,\n        CloudTestUtils.clusterShape(3, 1, true, true));\n\n\n    await = triggerFired.await(60, TimeUnit.SECONDS);\n    assertTrue(\"cleanup action didn't run\", await);\n\n    // cleanup should have occurred\n    assertFalse(\"no events captured!\", listenerEvents.isEmpty());\n    List<CapturedEvent> events = new ArrayList<>(listenerEvents.get(\"foo\"));\n    listenerEvents.clear();\n\n    assertFalse(events.isEmpty());\n    int inactiveEvents = 0;\n    CapturedEvent ce = null;\n    for (CapturedEvent e : events) {\n      if (e.stage != TriggerEventProcessorStage.AFTER_ACTION) {\n        continue;\n      }\n      if (e.context.containsKey(\"properties.inactive_shard_plan\")) {\n        ce = e;\n        break;\n      } else {\n        inactiveEvents++;\n      }\n    }\n    assertTrue(\"should be at least one inactive event\", inactiveEvents > 0);\n    assertNotNull(\"missing cleanup event\", ce);\n    Map<String, Object> map = (Map<String, Object>)ce.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n\n    Map<String, List<String>> inactive = (Map<String, List<String>>)map.get(\"inactive\");\n    assertEquals(1, inactive.size());\n    assertNotNull(inactive.get(collection1));\n    Map<String, List<String>> cleanup = (Map<String, List<String>>)map.get(\"cleanup\");\n    assertEquals(1, cleanup.size());\n    assertNotNull(cleanup.get(collection1));\n\n    ClusterState state = cloudManager.getClusterStateProvider().getClusterState();\n\n    CloudTestUtils.clusterShape(2, 1).matches(state.getLiveNodes(), state.getCollection(collection1));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledMaintenanceTriggerTest#testInactiveShardCleanup().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledMaintenanceTriggerTest#testInactiveShardCleanup().mjava","sourceNew":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 17-Mar-2018\n  public void testInactiveShardCleanup() throws Exception {\n    String collection1 = getClass().getSimpleName() + \"_collection1\";\n    CollectionAdminRequest.Create create1 = CollectionAdminRequest.createCollection(collection1,\n        \"conf\", 1, 1);\n\n    create1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collection1, collection1,\n        CloudTestUtils.clusterShape(1, 1));\n\n    // also create a very stale lock\n    Map<String, Object> lockData = new HashMap<>();\n    lockData.put(ZkStateReader.STATE_TIMESTAMP_PROP, String.valueOf(cloudManager.getTimeSource().getEpochTimeNs() -\n        TimeUnit.NANOSECONDS.convert(48, TimeUnit.HOURS)));\n    String staleLockName = collection1 + \"/staleShard-splitting\";\n    cloudManager.getDistribStateManager().makePath(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" +\n        staleLockName, Utils.toJSON(lockData), CreateMode.EPHEMERAL, true);\n\n    // expect two events - one for a very stale lock, one for the cleanup\n    triggerFired = new CountDownLatch(2);\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'foo',\" +\n        \"'trigger' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'stage' : ['STARTED','ABORTED','SUCCEEDED','FAILED'],\" +\n        \"'beforeAction' : 'inactive_shard_plan',\" +\n        \"'afterAction' : 'inactive_shard_plan',\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : 'NOW+10SECONDS',\" +\n        \"'every' : '+2SECONDS',\" +\n        \"'enabled' : true,\" +\n        \"'actions' : [{'name' : 'inactive_shard_plan', 'class' : 'solr.InactiveShardPlanAction', 'ttl' : '20'},\" +\n        \"{'name' : 'execute_plan', 'class' : '\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'test', 'class' : '\" + TestTriggerAction.class.getName() + \"'}]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n\n    boolean await = listenerCreated.await(10, TimeUnit.SECONDS);\n    assertTrue(\"listener not created in time\", await);\n\n    CollectionAdminRequest.SplitShard split1 = CollectionAdminRequest.splitShard(collection1)\n        .setShardName(\"shard1\");\n    split1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to split \" + collection1, collection1,\n        CloudTestUtils.clusterShape(3, 1, true, true));\n\n\n    await = triggerFired.await(90, TimeUnit.SECONDS);\n    assertTrue(\"cleanup action didn't run\", await);\n\n    // cleanup should have occurred\n    assertFalse(\"no events captured!\", listenerEvents.isEmpty());\n    List<CapturedEvent> events = new ArrayList<>(listenerEvents.get(\"foo\"));\n    listenerEvents.clear();\n\n    assertFalse(events.isEmpty());\n    CapturedEvent ce = null;\n    CapturedEvent staleLock = null;\n    for (CapturedEvent e : events) {\n      if (e.stage != TriggerEventProcessorStage.AFTER_ACTION) {\n        continue;\n      }\n      Map<String, Object> plan = (Map<String, Object>)e.context.get(\"properties.inactive_shard_plan\");\n      if (plan == null) {\n        continue;\n      }\n      if (plan.containsKey(\"cleanup\")) {\n        ce = e;\n      }\n      // capture only the first\n      if (plan.containsKey(\"staleLocks\") && staleLock == null) {\n        staleLock = e;\n      }\n    }\n    assertNotNull(\"missing cleanup event: \" + events, ce);\n    assertNotNull(\"missing staleLocks event: \" + events, staleLock);\n\n    Map<String, Object> map = (Map<String, Object>)ce.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n\n    Map<String, List<String>> inactive = (Map<String, List<String>>)map.get(\"inactive\");\n    assertEquals(1, inactive.size());\n    assertNotNull(inactive.get(collection1));\n    Map<String, List<String>> cleanup = (Map<String, List<String>>)map.get(\"cleanup\");\n    assertEquals(1, cleanup.size());\n    assertNotNull(cleanup.get(collection1));\n\n    map = (Map<String, Object>)staleLock.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n    Map<String, Map<String, Object>> locks = (Map<String, Map<String, Object>>)map.get(\"staleLocks\");\n    assertNotNull(locks);\n    assertTrue(\"missing stale lock data: \" + locks + \"\\nevents: \" + events, locks.containsKey(staleLockName));\n\n    ClusterState state = cloudManager.getClusterStateProvider().getClusterState();\n\n    CloudTestUtils.clusterShape(2, 1).matches(state.getLiveNodes(), state.getCollection(collection1));\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 17-Mar-2018\n  public void testInactiveShardCleanup() throws Exception {\n    String collection1 = getClass().getSimpleName() + \"_collection1\";\n    CollectionAdminRequest.Create create1 = CollectionAdminRequest.createCollection(collection1,\n        \"conf\", 1, 1);\n\n    create1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collection1, collection1,\n        CloudTestUtils.clusterShape(1, 1));\n\n    // also create a very stale lock\n    Map<String, Object> lockData = new HashMap<>();\n    lockData.put(ZkStateReader.STATE_TIMESTAMP_PROP, String.valueOf(cloudManager.getTimeSource().getEpochTimeNs() -\n        TimeUnit.NANOSECONDS.convert(48, TimeUnit.HOURS)));\n    String staleLockName = collection1 + \"/staleShard-splitting\";\n    cloudManager.getDistribStateManager().makePath(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" +\n        staleLockName, Utils.toJSON(lockData), CreateMode.EPHEMERAL, true);\n\n    // expect two events - one for a very stale lock, one for the cleanup\n    triggerFired = new CountDownLatch(2);\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'foo',\" +\n        \"'trigger' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'stage' : ['STARTED','ABORTED','SUCCEEDED','FAILED'],\" +\n        \"'beforeAction' : 'inactive_shard_plan',\" +\n        \"'afterAction' : 'inactive_shard_plan',\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : 'NOW+10SECONDS',\" +\n        \"'every' : '+2SECONDS',\" +\n        \"'enabled' : true,\" +\n        \"'actions' : [{'name' : 'inactive_shard_plan', 'class' : 'solr.InactiveShardPlanAction', 'ttl' : '20'},\" +\n        \"{'name' : 'execute_plan', 'class' : '\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'test', 'class' : '\" + TestTriggerAction.class.getName() + \"'}]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n\n    boolean await = listenerCreated.await(10, TimeUnit.SECONDS);\n    assertTrue(\"listener not created in time\", await);\n\n    CollectionAdminRequest.SplitShard split1 = CollectionAdminRequest.splitShard(collection1)\n        .setShardName(\"shard1\");\n    split1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to split \" + collection1, collection1,\n        CloudTestUtils.clusterShape(3, 1, true, true));\n\n\n    await = triggerFired.await(90, TimeUnit.SECONDS);\n    assertTrue(\"cleanup action didn't run\", await);\n\n    // cleanup should have occurred\n    assertFalse(\"no events captured!\", listenerEvents.isEmpty());\n    List<CapturedEvent> events = new ArrayList<>(listenerEvents.get(\"foo\"));\n    listenerEvents.clear();\n\n    assertFalse(events.isEmpty());\n    CapturedEvent ce = null;\n    CapturedEvent staleLock = null;\n    for (CapturedEvent e : events) {\n      if (e.stage != TriggerEventProcessorStage.AFTER_ACTION) {\n        continue;\n      }\n      Map<String, Object> plan = (Map<String, Object>)e.context.get(\"properties.inactive_shard_plan\");\n      if (plan == null) {\n        continue;\n      }\n      if (plan.containsKey(\"cleanup\")) {\n        ce = e;\n      }\n      // capture only the first\n      if (plan.containsKey(\"staleLocks\") && staleLock == null) {\n        staleLock = e;\n      }\n    }\n    assertNotNull(\"missing cleanup event: \" + events, ce);\n    assertNotNull(\"missing staleLocks event: \" + events, staleLock);\n\n    Map<String, Object> map = (Map<String, Object>)ce.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n\n    Map<String, List<String>> inactive = (Map<String, List<String>>)map.get(\"inactive\");\n    assertEquals(1, inactive.size());\n    assertNotNull(inactive.get(collection1));\n    Map<String, List<String>> cleanup = (Map<String, List<String>>)map.get(\"cleanup\");\n    assertEquals(1, cleanup.size());\n    assertNotNull(cleanup.get(collection1));\n\n    map = (Map<String, Object>)staleLock.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n    Map<String, Map<String, Object>> locks = (Map<String, Map<String, Object>>)map.get(\"staleLocks\");\n    assertNotNull(locks);\n    assertTrue(\"missing stale lock data: \" + locks + \"\\nevents: \" + events, locks.containsKey(staleLockName));\n\n    ClusterState state = cloudManager.getClusterStateProvider().getClusterState();\n\n    CloudTestUtils.clusterShape(2, 1).matches(state.getLiveNodes(), state.getCollection(collection1));\n  }\n\n","bugFix":["0bfcbdfe07d46da058707c12412aef939a5f2198"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89948af0461fead48f44ba8fb7866f107ce83f22","date":1545157711,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledMaintenanceTriggerTest#testInactiveShardCleanup().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledMaintenanceTriggerTest#testInactiveShardCleanup().mjava","sourceNew":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 17-Mar-2018\n  public void testInactiveShardCleanup() throws Exception {\n    String collection1 = getClass().getSimpleName() + \"_collection1\";\n    CollectionAdminRequest.Create create1 = CollectionAdminRequest.createCollection(collection1,\n        \"conf\", 1, 1);\n\n    create1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collection1, collection1,\n        CloudTestUtils.clusterShape(1, 1));\n\n    // also create a very stale lock\n    Map<String, Object> lockData = new HashMap<>();\n    lockData.put(ZkStateReader.STATE_TIMESTAMP_PROP, String.valueOf(cloudManager.getTimeSource().getEpochTimeNs() -\n        TimeUnit.NANOSECONDS.convert(48, TimeUnit.HOURS)));\n    String staleLockName = collection1 + \"/staleShard-splitting\";\n    cloudManager.getDistribStateManager().makePath(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" +\n        staleLockName, Utils.toJSON(lockData), CreateMode.EPHEMERAL, true);\n\n    // expect two events - one for a very stale lock, one for the cleanup\n    triggerFired = new CountDownLatch(2);\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'foo',\" +\n        \"'trigger' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'stage' : ['STARTED','ABORTED','SUCCEEDED','FAILED'],\" +\n        \"'beforeAction' : 'inactive_shard_plan',\" +\n        \"'afterAction' : 'inactive_shard_plan',\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setListenerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : 'NOW+10SECONDS',\" +\n        \"'every' : '+2SECONDS',\" +\n        \"'enabled' : true,\" +\n        \"'actions' : [{'name' : 'inactive_shard_plan', 'class' : 'solr.InactiveShardPlanAction', 'ttl' : '20'},\" +\n        \"{'name' : 'execute_plan', 'class' : '\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'test', 'class' : '\" + TestTriggerAction.class.getName() + \"'}]\" +\n        \"}}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n\n    boolean await = listenerCreated.await(10, TimeUnit.SECONDS);\n    assertTrue(\"listener not created in time\", await);\n\n    CollectionAdminRequest.SplitShard split1 = CollectionAdminRequest.splitShard(collection1)\n        .setShardName(\"shard1\");\n    split1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to split \" + collection1, collection1,\n        CloudTestUtils.clusterShape(3, 1, true, true));\n\n\n    await = triggerFired.await(90, TimeUnit.SECONDS);\n    assertTrue(\"cleanup action didn't run\", await);\n\n    // cleanup should have occurred\n    assertFalse(\"no events captured!\", listenerEvents.isEmpty());\n    List<CapturedEvent> events = new ArrayList<>(listenerEvents.get(\"foo\"));\n    listenerEvents.clear();\n\n    assertFalse(events.isEmpty());\n    CapturedEvent ce = null;\n    CapturedEvent staleLock = null;\n    for (CapturedEvent e : events) {\n      if (e.stage != TriggerEventProcessorStage.AFTER_ACTION) {\n        continue;\n      }\n      Map<String, Object> plan = (Map<String, Object>)e.context.get(\"properties.inactive_shard_plan\");\n      if (plan == null) {\n        continue;\n      }\n      if (plan.containsKey(\"cleanup\")) {\n        ce = e;\n      }\n      // capture only the first\n      if (plan.containsKey(\"staleLocks\") && staleLock == null) {\n        staleLock = e;\n      }\n    }\n    assertNotNull(\"missing cleanup event: \" + events, ce);\n    assertNotNull(\"missing staleLocks event: \" + events, staleLock);\n\n    Map<String, Object> map = (Map<String, Object>)ce.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n\n    Map<String, List<String>> inactive = (Map<String, List<String>>)map.get(\"inactive\");\n    assertEquals(1, inactive.size());\n    assertNotNull(inactive.get(collection1));\n    Map<String, List<String>> cleanup = (Map<String, List<String>>)map.get(\"cleanup\");\n    assertEquals(1, cleanup.size());\n    assertNotNull(cleanup.get(collection1));\n\n    map = (Map<String, Object>)staleLock.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n    Map<String, Map<String, Object>> locks = (Map<String, Map<String, Object>>)map.get(\"staleLocks\");\n    assertNotNull(locks);\n    assertTrue(\"missing stale lock data: \" + locks + \"\\nevents: \" + events, locks.containsKey(staleLockName));\n\n    ClusterState state = cloudManager.getClusterStateProvider().getClusterState();\n\n    CloudTestUtils.clusterShape(2, 1).matches(state.getLiveNodes(), state.getCollection(collection1));\n  }\n\n","sourceOld":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 17-Mar-2018\n  public void testInactiveShardCleanup() throws Exception {\n    String collection1 = getClass().getSimpleName() + \"_collection1\";\n    CollectionAdminRequest.Create create1 = CollectionAdminRequest.createCollection(collection1,\n        \"conf\", 1, 1);\n\n    create1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collection1, collection1,\n        CloudTestUtils.clusterShape(1, 1));\n\n    // also create a very stale lock\n    Map<String, Object> lockData = new HashMap<>();\n    lockData.put(ZkStateReader.STATE_TIMESTAMP_PROP, String.valueOf(cloudManager.getTimeSource().getEpochTimeNs() -\n        TimeUnit.NANOSECONDS.convert(48, TimeUnit.HOURS)));\n    String staleLockName = collection1 + \"/staleShard-splitting\";\n    cloudManager.getDistribStateManager().makePath(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" +\n        staleLockName, Utils.toJSON(lockData), CreateMode.EPHEMERAL, true);\n\n    // expect two events - one for a very stale lock, one for the cleanup\n    triggerFired = new CountDownLatch(2);\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'foo',\" +\n        \"'trigger' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'stage' : ['STARTED','ABORTED','SUCCEEDED','FAILED'],\" +\n        \"'beforeAction' : 'inactive_shard_plan',\" +\n        \"'afterAction' : 'inactive_shard_plan',\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : 'NOW+10SECONDS',\" +\n        \"'every' : '+2SECONDS',\" +\n        \"'enabled' : true,\" +\n        \"'actions' : [{'name' : 'inactive_shard_plan', 'class' : 'solr.InactiveShardPlanAction', 'ttl' : '20'},\" +\n        \"{'name' : 'execute_plan', 'class' : '\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'test', 'class' : '\" + TestTriggerAction.class.getName() + \"'}]\" +\n        \"}}\";\n    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n\n    boolean await = listenerCreated.await(10, TimeUnit.SECONDS);\n    assertTrue(\"listener not created in time\", await);\n\n    CollectionAdminRequest.SplitShard split1 = CollectionAdminRequest.splitShard(collection1)\n        .setShardName(\"shard1\");\n    split1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to split \" + collection1, collection1,\n        CloudTestUtils.clusterShape(3, 1, true, true));\n\n\n    await = triggerFired.await(90, TimeUnit.SECONDS);\n    assertTrue(\"cleanup action didn't run\", await);\n\n    // cleanup should have occurred\n    assertFalse(\"no events captured!\", listenerEvents.isEmpty());\n    List<CapturedEvent> events = new ArrayList<>(listenerEvents.get(\"foo\"));\n    listenerEvents.clear();\n\n    assertFalse(events.isEmpty());\n    CapturedEvent ce = null;\n    CapturedEvent staleLock = null;\n    for (CapturedEvent e : events) {\n      if (e.stage != TriggerEventProcessorStage.AFTER_ACTION) {\n        continue;\n      }\n      Map<String, Object> plan = (Map<String, Object>)e.context.get(\"properties.inactive_shard_plan\");\n      if (plan == null) {\n        continue;\n      }\n      if (plan.containsKey(\"cleanup\")) {\n        ce = e;\n      }\n      // capture only the first\n      if (plan.containsKey(\"staleLocks\") && staleLock == null) {\n        staleLock = e;\n      }\n    }\n    assertNotNull(\"missing cleanup event: \" + events, ce);\n    assertNotNull(\"missing staleLocks event: \" + events, staleLock);\n\n    Map<String, Object> map = (Map<String, Object>)ce.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n\n    Map<String, List<String>> inactive = (Map<String, List<String>>)map.get(\"inactive\");\n    assertEquals(1, inactive.size());\n    assertNotNull(inactive.get(collection1));\n    Map<String, List<String>> cleanup = (Map<String, List<String>>)map.get(\"cleanup\");\n    assertEquals(1, cleanup.size());\n    assertNotNull(cleanup.get(collection1));\n\n    map = (Map<String, Object>)staleLock.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n    Map<String, Map<String, Object>> locks = (Map<String, Map<String, Object>>)map.get(\"staleLocks\");\n    assertNotNull(locks);\n    assertTrue(\"missing stale lock data: \" + locks + \"\\nevents: \" + events, locks.containsKey(staleLockName));\n\n    ClusterState state = cloudManager.getClusterStateProvider().getClusterState();\n\n    CloudTestUtils.clusterShape(2, 1).matches(state.getLiveNodes(), state.getCollection(collection1));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7fb1186f5b61e0b74289e6786df8cbecfa471bc","date":1545308188,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledMaintenanceTriggerTest#testInactiveShardCleanup().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledMaintenanceTriggerTest#testInactiveShardCleanup().mjava","sourceNew":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 17-Mar-2018\n  public void testInactiveShardCleanup() throws Exception {\n    String collection1 = getClass().getSimpleName() + \"_collection1\";\n    CollectionAdminRequest.Create create1 = CollectionAdminRequest.createCollection(collection1,\n        \"conf\", 1, 1);\n\n    create1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collection1, collection1,\n        CloudTestUtils.clusterShape(1, 1));\n\n    // also create a very stale lock\n    Map<String, Object> lockData = new HashMap<>();\n    lockData.put(ZkStateReader.STATE_TIMESTAMP_PROP, String.valueOf(cloudManager.getTimeSource().getEpochTimeNs() -\n        TimeUnit.NANOSECONDS.convert(48, TimeUnit.HOURS)));\n    String staleLockName = collection1 + \"/staleShard-splitting\";\n    cloudManager.getDistribStateManager().makePath(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" +\n        staleLockName, Utils.toJSON(lockData), CreateMode.EPHEMERAL, true);\n\n    // expect two events - one for a very stale lock, one for the cleanup\n    triggerFired = new CountDownLatch(2);\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'foo',\" +\n        \"'trigger' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'stage' : ['STARTED','ABORTED','SUCCEEDED','FAILED'],\" +\n        \"'beforeAction' : 'inactive_shard_plan',\" +\n        \"'afterAction' : 'inactive_shard_plan',\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setListenerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : 'NOW+10SECONDS',\" +\n        \"'every' : '+2SECONDS',\" + // must be longer than the cooldown period\n        \"'enabled' : true,\" +\n        \"'actions' : [{'name' : 'inactive_shard_plan', 'class' : 'solr.InactiveShardPlanAction', 'ttl' : '20'},\" +\n        \"{'name' : 'execute_plan', 'class' : '\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'test', 'class' : '\" + TestTriggerAction.class.getName() + \"'}]\" +\n        \"}}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n\n    boolean await = listenerCreated.await(10, TimeUnit.SECONDS);\n    assertTrue(\"listener not created in time\", await);\n\n    CollectionAdminRequest.SplitShard split1 = CollectionAdminRequest.splitShard(collection1)\n        .setShardName(\"shard1\");\n    split1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to split \" + collection1, collection1,\n        CloudTestUtils.clusterShape(3, 1, true, true));\n\n\n    await = triggerFired.await(90, TimeUnit.SECONDS);\n    assertTrue(\"cleanup action didn't run\", await);\n\n    // cleanup should have occurred\n    assertFalse(\"no events captured!\", listenerEvents.isEmpty());\n    List<CapturedEvent> events = new ArrayList<>(listenerEvents.get(\"foo\"));\n    listenerEvents.clear();\n\n    assertFalse(events.isEmpty());\n    CapturedEvent ce = null;\n    CapturedEvent staleLock = null;\n    for (CapturedEvent e : events) {\n      if (e.stage != TriggerEventProcessorStage.AFTER_ACTION) {\n        continue;\n      }\n      Map<String, Object> plan = (Map<String, Object>)e.context.get(\"properties.inactive_shard_plan\");\n      if (plan == null) {\n        continue;\n      }\n      if (plan.containsKey(\"cleanup\")) {\n        ce = e;\n      }\n      // capture only the first\n      if (plan.containsKey(\"staleLocks\") && staleLock == null) {\n        staleLock = e;\n      }\n    }\n    assertNotNull(\"missing cleanup event: \" + events, ce);\n    assertNotNull(\"missing staleLocks event: \" + events, staleLock);\n\n    Map<String, Object> map = (Map<String, Object>)ce.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n\n    Map<String, List<String>> inactive = (Map<String, List<String>>)map.get(\"inactive\");\n    assertEquals(1, inactive.size());\n    assertNotNull(inactive.get(collection1));\n    Map<String, List<String>> cleanup = (Map<String, List<String>>)map.get(\"cleanup\");\n    assertEquals(1, cleanup.size());\n    assertNotNull(cleanup.get(collection1));\n\n    map = (Map<String, Object>)staleLock.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n    Map<String, Map<String, Object>> locks = (Map<String, Map<String, Object>>)map.get(\"staleLocks\");\n    assertNotNull(locks);\n    assertTrue(\"missing stale lock data: \" + locks + \"\\nevents: \" + events, locks.containsKey(staleLockName));\n\n    ClusterState state = cloudManager.getClusterStateProvider().getClusterState();\n\n    CloudTestUtils.clusterShape(2, 1).matches(state.getLiveNodes(), state.getCollection(collection1));\n  }\n\n","sourceOld":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 17-Mar-2018\n  public void testInactiveShardCleanup() throws Exception {\n    String collection1 = getClass().getSimpleName() + \"_collection1\";\n    CollectionAdminRequest.Create create1 = CollectionAdminRequest.createCollection(collection1,\n        \"conf\", 1, 1);\n\n    create1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collection1, collection1,\n        CloudTestUtils.clusterShape(1, 1));\n\n    // also create a very stale lock\n    Map<String, Object> lockData = new HashMap<>();\n    lockData.put(ZkStateReader.STATE_TIMESTAMP_PROP, String.valueOf(cloudManager.getTimeSource().getEpochTimeNs() -\n        TimeUnit.NANOSECONDS.convert(48, TimeUnit.HOURS)));\n    String staleLockName = collection1 + \"/staleShard-splitting\";\n    cloudManager.getDistribStateManager().makePath(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" +\n        staleLockName, Utils.toJSON(lockData), CreateMode.EPHEMERAL, true);\n\n    // expect two events - one for a very stale lock, one for the cleanup\n    triggerFired = new CountDownLatch(2);\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'foo',\" +\n        \"'trigger' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'stage' : ['STARTED','ABORTED','SUCCEEDED','FAILED'],\" +\n        \"'beforeAction' : 'inactive_shard_plan',\" +\n        \"'afterAction' : 'inactive_shard_plan',\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setListenerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : 'NOW+10SECONDS',\" +\n        \"'every' : '+2SECONDS',\" +\n        \"'enabled' : true,\" +\n        \"'actions' : [{'name' : 'inactive_shard_plan', 'class' : 'solr.InactiveShardPlanAction', 'ttl' : '20'},\" +\n        \"{'name' : 'execute_plan', 'class' : '\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'test', 'class' : '\" + TestTriggerAction.class.getName() + \"'}]\" +\n        \"}}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n\n    boolean await = listenerCreated.await(10, TimeUnit.SECONDS);\n    assertTrue(\"listener not created in time\", await);\n\n    CollectionAdminRequest.SplitShard split1 = CollectionAdminRequest.splitShard(collection1)\n        .setShardName(\"shard1\");\n    split1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to split \" + collection1, collection1,\n        CloudTestUtils.clusterShape(3, 1, true, true));\n\n\n    await = triggerFired.await(90, TimeUnit.SECONDS);\n    assertTrue(\"cleanup action didn't run\", await);\n\n    // cleanup should have occurred\n    assertFalse(\"no events captured!\", listenerEvents.isEmpty());\n    List<CapturedEvent> events = new ArrayList<>(listenerEvents.get(\"foo\"));\n    listenerEvents.clear();\n\n    assertFalse(events.isEmpty());\n    CapturedEvent ce = null;\n    CapturedEvent staleLock = null;\n    for (CapturedEvent e : events) {\n      if (e.stage != TriggerEventProcessorStage.AFTER_ACTION) {\n        continue;\n      }\n      Map<String, Object> plan = (Map<String, Object>)e.context.get(\"properties.inactive_shard_plan\");\n      if (plan == null) {\n        continue;\n      }\n      if (plan.containsKey(\"cleanup\")) {\n        ce = e;\n      }\n      // capture only the first\n      if (plan.containsKey(\"staleLocks\") && staleLock == null) {\n        staleLock = e;\n      }\n    }\n    assertNotNull(\"missing cleanup event: \" + events, ce);\n    assertNotNull(\"missing staleLocks event: \" + events, staleLock);\n\n    Map<String, Object> map = (Map<String, Object>)ce.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n\n    Map<String, List<String>> inactive = (Map<String, List<String>>)map.get(\"inactive\");\n    assertEquals(1, inactive.size());\n    assertNotNull(inactive.get(collection1));\n    Map<String, List<String>> cleanup = (Map<String, List<String>>)map.get(\"cleanup\");\n    assertEquals(1, cleanup.size());\n    assertNotNull(cleanup.get(collection1));\n\n    map = (Map<String, Object>)staleLock.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n    Map<String, Map<String, Object>> locks = (Map<String, Map<String, Object>>)map.get(\"staleLocks\");\n    assertNotNull(locks);\n    assertTrue(\"missing stale lock data: \" + locks + \"\\nevents: \" + events, locks.containsKey(staleLockName));\n\n    ClusterState state = cloudManager.getClusterStateProvider().getClusterState();\n\n    CloudTestUtils.clusterShape(2, 1).matches(state.getLiveNodes(), state.getCollection(collection1));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5","date":1556572478,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledMaintenanceTriggerTest#testInactiveShardCleanup().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledMaintenanceTriggerTest#testInactiveShardCleanup().mjava","sourceNew":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 17-Mar-2018\n  public void testInactiveShardCleanup() throws Exception {\n    String collection1 = getClass().getSimpleName() + \"_collection1\";\n    CollectionAdminRequest.Create create1 = CollectionAdminRequest.createCollection(collection1,\n        \"conf\", 1, 1);\n\n    create1.process(solrClient);\n    CloudUtil.waitForState(cloudManager, \"failed to create \" + collection1, collection1,\n        CloudUtil.clusterShape(1, 1));\n\n    // also create a very stale lock\n    Map<String, Object> lockData = new HashMap<>();\n    lockData.put(ZkStateReader.STATE_TIMESTAMP_PROP, String.valueOf(cloudManager.getTimeSource().getEpochTimeNs() -\n        TimeUnit.NANOSECONDS.convert(48, TimeUnit.HOURS)));\n    String staleLockName = collection1 + \"/staleShard-splitting\";\n    cloudManager.getDistribStateManager().makePath(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" +\n        staleLockName, Utils.toJSON(lockData), CreateMode.EPHEMERAL, true);\n\n    // expect two events - one for a very stale lock, one for the cleanup\n    triggerFired = new CountDownLatch(2);\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'foo',\" +\n        \"'trigger' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'stage' : ['STARTED','ABORTED','SUCCEEDED','FAILED'],\" +\n        \"'beforeAction' : 'inactive_shard_plan',\" +\n        \"'afterAction' : 'inactive_shard_plan',\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setListenerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : 'NOW+10SECONDS',\" +\n        \"'every' : '+2SECONDS',\" + // must be longer than the cooldown period\n        \"'enabled' : true,\" +\n        \"'actions' : [{'name' : 'inactive_shard_plan', 'class' : 'solr.InactiveShardPlanAction', 'ttl' : '20'},\" +\n        \"{'name' : 'execute_plan', 'class' : '\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'test', 'class' : '\" + TestTriggerAction.class.getName() + \"'}]\" +\n        \"}}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n\n    boolean await = listenerCreated.await(10, TimeUnit.SECONDS);\n    assertTrue(\"listener not created in time\", await);\n\n    CollectionAdminRequest.SplitShard split1 = CollectionAdminRequest.splitShard(collection1)\n        .setShardName(\"shard1\");\n    split1.process(solrClient);\n    CloudUtil.waitForState(cloudManager, \"failed to split \" + collection1, collection1,\n        CloudUtil.clusterShape(3, 1, true, true));\n\n\n    await = triggerFired.await(90, TimeUnit.SECONDS);\n    assertTrue(\"cleanup action didn't run\", await);\n\n    // cleanup should have occurred\n    assertFalse(\"no events captured!\", listenerEvents.isEmpty());\n    List<CapturedEvent> events = new ArrayList<>(listenerEvents.get(\"foo\"));\n    listenerEvents.clear();\n\n    assertFalse(events.isEmpty());\n    CapturedEvent ce = null;\n    CapturedEvent staleLock = null;\n    for (CapturedEvent e : events) {\n      if (e.stage != TriggerEventProcessorStage.AFTER_ACTION) {\n        continue;\n      }\n      Map<String, Object> plan = (Map<String, Object>)e.context.get(\"properties.inactive_shard_plan\");\n      if (plan == null) {\n        continue;\n      }\n      if (plan.containsKey(\"cleanup\")) {\n        ce = e;\n      }\n      // capture only the first\n      if (plan.containsKey(\"staleLocks\") && staleLock == null) {\n        staleLock = e;\n      }\n    }\n    assertNotNull(\"missing cleanup event: \" + events, ce);\n    assertNotNull(\"missing staleLocks event: \" + events, staleLock);\n\n    Map<String, Object> map = (Map<String, Object>)ce.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n\n    Map<String, List<String>> inactive = (Map<String, List<String>>)map.get(\"inactive\");\n    assertEquals(1, inactive.size());\n    assertNotNull(inactive.get(collection1));\n    Map<String, List<String>> cleanup = (Map<String, List<String>>)map.get(\"cleanup\");\n    assertEquals(1, cleanup.size());\n    assertNotNull(cleanup.get(collection1));\n\n    map = (Map<String, Object>)staleLock.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n    Map<String, Map<String, Object>> locks = (Map<String, Map<String, Object>>)map.get(\"staleLocks\");\n    assertNotNull(locks);\n    assertTrue(\"missing stale lock data: \" + locks + \"\\nevents: \" + events, locks.containsKey(staleLockName));\n\n    ClusterState state = cloudManager.getClusterStateProvider().getClusterState();\n\n    CloudUtil.clusterShape(2, 1).matches(state.getLiveNodes(), state.getCollection(collection1));\n  }\n\n","sourceOld":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 17-Mar-2018\n  public void testInactiveShardCleanup() throws Exception {\n    String collection1 = getClass().getSimpleName() + \"_collection1\";\n    CollectionAdminRequest.Create create1 = CollectionAdminRequest.createCollection(collection1,\n        \"conf\", 1, 1);\n\n    create1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to create \" + collection1, collection1,\n        CloudTestUtils.clusterShape(1, 1));\n\n    // also create a very stale lock\n    Map<String, Object> lockData = new HashMap<>();\n    lockData.put(ZkStateReader.STATE_TIMESTAMP_PROP, String.valueOf(cloudManager.getTimeSource().getEpochTimeNs() -\n        TimeUnit.NANOSECONDS.convert(48, TimeUnit.HOURS)));\n    String staleLockName = collection1 + \"/staleShard-splitting\";\n    cloudManager.getDistribStateManager().makePath(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" +\n        staleLockName, Utils.toJSON(lockData), CreateMode.EPHEMERAL, true);\n\n    // expect two events - one for a very stale lock, one for the cleanup\n    triggerFired = new CountDownLatch(2);\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'foo',\" +\n        \"'trigger' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'stage' : ['STARTED','ABORTED','SUCCEEDED','FAILED'],\" +\n        \"'beforeAction' : 'inactive_shard_plan',\" +\n        \"'afterAction' : 'inactive_shard_plan',\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setListenerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : 'NOW+10SECONDS',\" +\n        \"'every' : '+2SECONDS',\" + // must be longer than the cooldown period\n        \"'enabled' : true,\" +\n        \"'actions' : [{'name' : 'inactive_shard_plan', 'class' : 'solr.InactiveShardPlanAction', 'ttl' : '20'},\" +\n        \"{'name' : 'execute_plan', 'class' : '\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'test', 'class' : '\" + TestTriggerAction.class.getName() + \"'}]\" +\n        \"}}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n\n    boolean await = listenerCreated.await(10, TimeUnit.SECONDS);\n    assertTrue(\"listener not created in time\", await);\n\n    CollectionAdminRequest.SplitShard split1 = CollectionAdminRequest.splitShard(collection1)\n        .setShardName(\"shard1\");\n    split1.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, \"failed to split \" + collection1, collection1,\n        CloudTestUtils.clusterShape(3, 1, true, true));\n\n\n    await = triggerFired.await(90, TimeUnit.SECONDS);\n    assertTrue(\"cleanup action didn't run\", await);\n\n    // cleanup should have occurred\n    assertFalse(\"no events captured!\", listenerEvents.isEmpty());\n    List<CapturedEvent> events = new ArrayList<>(listenerEvents.get(\"foo\"));\n    listenerEvents.clear();\n\n    assertFalse(events.isEmpty());\n    CapturedEvent ce = null;\n    CapturedEvent staleLock = null;\n    for (CapturedEvent e : events) {\n      if (e.stage != TriggerEventProcessorStage.AFTER_ACTION) {\n        continue;\n      }\n      Map<String, Object> plan = (Map<String, Object>)e.context.get(\"properties.inactive_shard_plan\");\n      if (plan == null) {\n        continue;\n      }\n      if (plan.containsKey(\"cleanup\")) {\n        ce = e;\n      }\n      // capture only the first\n      if (plan.containsKey(\"staleLocks\") && staleLock == null) {\n        staleLock = e;\n      }\n    }\n    assertNotNull(\"missing cleanup event: \" + events, ce);\n    assertNotNull(\"missing staleLocks event: \" + events, staleLock);\n\n    Map<String, Object> map = (Map<String, Object>)ce.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n\n    Map<String, List<String>> inactive = (Map<String, List<String>>)map.get(\"inactive\");\n    assertEquals(1, inactive.size());\n    assertNotNull(inactive.get(collection1));\n    Map<String, List<String>> cleanup = (Map<String, List<String>>)map.get(\"cleanup\");\n    assertEquals(1, cleanup.size());\n    assertNotNull(cleanup.get(collection1));\n\n    map = (Map<String, Object>)staleLock.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n    Map<String, Map<String, Object>> locks = (Map<String, Map<String, Object>>)map.get(\"staleLocks\");\n    assertNotNull(locks);\n    assertTrue(\"missing stale lock data: \" + locks + \"\\nevents: \" + events, locks.containsKey(staleLockName));\n\n    ClusterState state = cloudManager.getClusterStateProvider().getClusterState();\n\n    CloudTestUtils.clusterShape(2, 1).matches(state.getLiveNodes(), state.getCollection(collection1));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa2585c33d5d66a1c837c312221eb55ddb3c4300","date":1592493170,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledMaintenanceTriggerTest#testInactiveShardCleanup().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledMaintenanceTriggerTest#testInactiveShardCleanup().mjava","sourceNew":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 17-Mar-2018\n  @SuppressWarnings({\"unchecked\"})\n  public void testInactiveShardCleanup() throws Exception {\n    String collection1 = getClass().getSimpleName() + \"_collection1\";\n    CollectionAdminRequest.Create create1 = CollectionAdminRequest.createCollection(collection1,\n        \"conf\", 1, 1);\n\n    create1.process(solrClient);\n    CloudUtil.waitForState(cloudManager, \"failed to create \" + collection1, collection1,\n        CloudUtil.clusterShape(1, 1));\n\n    // also create a very stale lock\n    Map<String, Object> lockData = new HashMap<>();\n    lockData.put(ZkStateReader.STATE_TIMESTAMP_PROP, String.valueOf(cloudManager.getTimeSource().getEpochTimeNs() -\n        TimeUnit.NANOSECONDS.convert(48, TimeUnit.HOURS)));\n    String staleLockName = collection1 + \"/staleShard-splitting\";\n    cloudManager.getDistribStateManager().makePath(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" +\n        staleLockName, Utils.toJSON(lockData), CreateMode.EPHEMERAL, true);\n\n    // expect two events - one for a very stale lock, one for the cleanup\n    triggerFired = new CountDownLatch(2);\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'foo',\" +\n        \"'trigger' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'stage' : ['STARTED','ABORTED','SUCCEEDED','FAILED'],\" +\n        \"'beforeAction' : 'inactive_shard_plan',\" +\n        \"'afterAction' : 'inactive_shard_plan',\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    @SuppressWarnings({\"rawtypes\"})\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setListenerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : 'NOW+10SECONDS',\" +\n        \"'every' : '+2SECONDS',\" + // must be longer than the cooldown period\n        \"'enabled' : true,\" +\n        \"'actions' : [{'name' : 'inactive_shard_plan', 'class' : 'solr.InactiveShardPlanAction', 'ttl' : '20'},\" +\n        \"{'name' : 'execute_plan', 'class' : '\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'test', 'class' : '\" + TestTriggerAction.class.getName() + \"'}]\" +\n        \"}}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n\n    boolean await = listenerCreated.await(10, TimeUnit.SECONDS);\n    assertTrue(\"listener not created in time\", await);\n\n    CollectionAdminRequest.SplitShard split1 = CollectionAdminRequest.splitShard(collection1)\n        .setShardName(\"shard1\");\n    split1.process(solrClient);\n    CloudUtil.waitForState(cloudManager, \"failed to split \" + collection1, collection1,\n        CloudUtil.clusterShape(3, 1, true, true));\n\n\n    await = triggerFired.await(90, TimeUnit.SECONDS);\n    assertTrue(\"cleanup action didn't run\", await);\n\n    // cleanup should have occurred\n    assertFalse(\"no events captured!\", listenerEvents.isEmpty());\n    List<CapturedEvent> events = new ArrayList<>(listenerEvents.get(\"foo\"));\n    listenerEvents.clear();\n\n    assertFalse(events.isEmpty());\n    CapturedEvent ce = null;\n    CapturedEvent staleLock = null;\n    for (CapturedEvent e : events) {\n      if (e.stage != TriggerEventProcessorStage.AFTER_ACTION) {\n        continue;\n      }\n      Map<String, Object> plan = (Map<String, Object>)e.context.get(\"properties.inactive_shard_plan\");\n      if (plan == null) {\n        continue;\n      }\n      if (plan.containsKey(\"cleanup\")) {\n        ce = e;\n      }\n      // capture only the first\n      if (plan.containsKey(\"staleLocks\") && staleLock == null) {\n        staleLock = e;\n      }\n    }\n    assertNotNull(\"missing cleanup event: \" + events, ce);\n    assertNotNull(\"missing staleLocks event: \" + events, staleLock);\n\n    Map<String, Object> map = (Map<String, Object>)ce.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n\n    Map<String, List<String>> inactive = (Map<String, List<String>>)map.get(\"inactive\");\n    assertEquals(1, inactive.size());\n    assertNotNull(inactive.get(collection1));\n    Map<String, List<String>> cleanup = (Map<String, List<String>>)map.get(\"cleanup\");\n    assertEquals(1, cleanup.size());\n    assertNotNull(cleanup.get(collection1));\n\n    map = (Map<String, Object>)staleLock.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n    Map<String, Map<String, Object>> locks = (Map<String, Map<String, Object>>)map.get(\"staleLocks\");\n    assertNotNull(locks);\n    assertTrue(\"missing stale lock data: \" + locks + \"\\nevents: \" + events, locks.containsKey(staleLockName));\n\n    ClusterState state = cloudManager.getClusterStateProvider().getClusterState();\n\n    CloudUtil.clusterShape(2, 1).matches(state.getLiveNodes(), state.getCollection(collection1));\n  }\n\n","sourceOld":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 17-Mar-2018\n  public void testInactiveShardCleanup() throws Exception {\n    String collection1 = getClass().getSimpleName() + \"_collection1\";\n    CollectionAdminRequest.Create create1 = CollectionAdminRequest.createCollection(collection1,\n        \"conf\", 1, 1);\n\n    create1.process(solrClient);\n    CloudUtil.waitForState(cloudManager, \"failed to create \" + collection1, collection1,\n        CloudUtil.clusterShape(1, 1));\n\n    // also create a very stale lock\n    Map<String, Object> lockData = new HashMap<>();\n    lockData.put(ZkStateReader.STATE_TIMESTAMP_PROP, String.valueOf(cloudManager.getTimeSource().getEpochTimeNs() -\n        TimeUnit.NANOSECONDS.convert(48, TimeUnit.HOURS)));\n    String staleLockName = collection1 + \"/staleShard-splitting\";\n    cloudManager.getDistribStateManager().makePath(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" +\n        staleLockName, Utils.toJSON(lockData), CreateMode.EPHEMERAL, true);\n\n    // expect two events - one for a very stale lock, one for the cleanup\n    triggerFired = new CountDownLatch(2);\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'foo',\" +\n        \"'trigger' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'stage' : ['STARTED','ABORTED','SUCCEEDED','FAILED'],\" +\n        \"'beforeAction' : 'inactive_shard_plan',\" +\n        \"'afterAction' : 'inactive_shard_plan',\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setListenerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : 'NOW+10SECONDS',\" +\n        \"'every' : '+2SECONDS',\" + // must be longer than the cooldown period\n        \"'enabled' : true,\" +\n        \"'actions' : [{'name' : 'inactive_shard_plan', 'class' : 'solr.InactiveShardPlanAction', 'ttl' : '20'},\" +\n        \"{'name' : 'execute_plan', 'class' : '\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'test', 'class' : '\" + TestTriggerAction.class.getName() + \"'}]\" +\n        \"}}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n\n    boolean await = listenerCreated.await(10, TimeUnit.SECONDS);\n    assertTrue(\"listener not created in time\", await);\n\n    CollectionAdminRequest.SplitShard split1 = CollectionAdminRequest.splitShard(collection1)\n        .setShardName(\"shard1\");\n    split1.process(solrClient);\n    CloudUtil.waitForState(cloudManager, \"failed to split \" + collection1, collection1,\n        CloudUtil.clusterShape(3, 1, true, true));\n\n\n    await = triggerFired.await(90, TimeUnit.SECONDS);\n    assertTrue(\"cleanup action didn't run\", await);\n\n    // cleanup should have occurred\n    assertFalse(\"no events captured!\", listenerEvents.isEmpty());\n    List<CapturedEvent> events = new ArrayList<>(listenerEvents.get(\"foo\"));\n    listenerEvents.clear();\n\n    assertFalse(events.isEmpty());\n    CapturedEvent ce = null;\n    CapturedEvent staleLock = null;\n    for (CapturedEvent e : events) {\n      if (e.stage != TriggerEventProcessorStage.AFTER_ACTION) {\n        continue;\n      }\n      Map<String, Object> plan = (Map<String, Object>)e.context.get(\"properties.inactive_shard_plan\");\n      if (plan == null) {\n        continue;\n      }\n      if (plan.containsKey(\"cleanup\")) {\n        ce = e;\n      }\n      // capture only the first\n      if (plan.containsKey(\"staleLocks\") && staleLock == null) {\n        staleLock = e;\n      }\n    }\n    assertNotNull(\"missing cleanup event: \" + events, ce);\n    assertNotNull(\"missing staleLocks event: \" + events, staleLock);\n\n    Map<String, Object> map = (Map<String, Object>)ce.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n\n    Map<String, List<String>> inactive = (Map<String, List<String>>)map.get(\"inactive\");\n    assertEquals(1, inactive.size());\n    assertNotNull(inactive.get(collection1));\n    Map<String, List<String>> cleanup = (Map<String, List<String>>)map.get(\"cleanup\");\n    assertEquals(1, cleanup.size());\n    assertNotNull(cleanup.get(collection1));\n\n    map = (Map<String, Object>)staleLock.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n    Map<String, Map<String, Object>> locks = (Map<String, Map<String, Object>>)map.get(\"staleLocks\");\n    assertNotNull(locks);\n    assertTrue(\"missing stale lock data: \" + locks + \"\\nevents: \" + events, locks.containsKey(staleLockName));\n\n    ClusterState state = cloudManager.getClusterStateProvider().getClusterState();\n\n    CloudUtil.clusterShape(2, 1).matches(state.getLiveNodes(), state.getCollection(collection1));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/ScheduledMaintenanceTriggerTest#testInactiveShardCleanup().mjava","sourceNew":null,"sourceOld":"  @Test\n  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 17-Mar-2018\n  @SuppressWarnings({\"unchecked\"})\n  public void testInactiveShardCleanup() throws Exception {\n    String collection1 = getClass().getSimpleName() + \"_collection1\";\n    CollectionAdminRequest.Create create1 = CollectionAdminRequest.createCollection(collection1,\n        \"conf\", 1, 1);\n\n    create1.process(solrClient);\n    CloudUtil.waitForState(cloudManager, \"failed to create \" + collection1, collection1,\n        CloudUtil.clusterShape(1, 1));\n\n    // also create a very stale lock\n    Map<String, Object> lockData = new HashMap<>();\n    lockData.put(ZkStateReader.STATE_TIMESTAMP_PROP, String.valueOf(cloudManager.getTimeSource().getEpochTimeNs() -\n        TimeUnit.NANOSECONDS.convert(48, TimeUnit.HOURS)));\n    String staleLockName = collection1 + \"/staleShard-splitting\";\n    cloudManager.getDistribStateManager().makePath(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" +\n        staleLockName, Utils.toJSON(lockData), CreateMode.EPHEMERAL, true);\n\n    // expect two events - one for a very stale lock, one for the cleanup\n    triggerFired = new CountDownLatch(2);\n\n    String setListenerCommand = \"{\" +\n        \"'set-listener' : \" +\n        \"{\" +\n        \"'name' : 'foo',\" +\n        \"'trigger' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'stage' : ['STARTED','ABORTED','SUCCEEDED','FAILED'],\" +\n        \"'beforeAction' : 'inactive_shard_plan',\" +\n        \"'afterAction' : 'inactive_shard_plan',\" +\n        \"'class' : '\" + CapturingTriggerListener.class.getName() + \"'\" +\n        \"}\" +\n        \"}\";\n    @SuppressWarnings({\"rawtypes\"})\n    SolrRequest req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setListenerCommand);\n    NamedList<Object> response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n    String setTriggerCommand = \"{\" +\n        \"'set-trigger' : {\" +\n        \"'name' : '\" + AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME + \"',\" +\n        \"'event' : 'scheduled',\" +\n        \"'startTime' : 'NOW+10SECONDS',\" +\n        \"'every' : '+2SECONDS',\" + // must be longer than the cooldown period\n        \"'enabled' : true,\" +\n        \"'actions' : [{'name' : 'inactive_shard_plan', 'class' : 'solr.InactiveShardPlanAction', 'ttl' : '20'},\" +\n        \"{'name' : 'execute_plan', 'class' : '\" + ExecutePlanAction.class.getName() + \"'},\" +\n        \"{'name' : 'test', 'class' : '\" + TestTriggerAction.class.getName() + \"'}]\" +\n        \"}}\";\n    req = AutoScalingRequest.create(SolrRequest.METHOD.POST, setTriggerCommand);\n    response = solrClient.request(req);\n    assertEquals(response.get(\"result\").toString(), \"success\");\n\n\n    boolean await = listenerCreated.await(10, TimeUnit.SECONDS);\n    assertTrue(\"listener not created in time\", await);\n\n    CollectionAdminRequest.SplitShard split1 = CollectionAdminRequest.splitShard(collection1)\n        .setShardName(\"shard1\");\n    split1.process(solrClient);\n    CloudUtil.waitForState(cloudManager, \"failed to split \" + collection1, collection1,\n        CloudUtil.clusterShape(3, 1, true, true));\n\n\n    await = triggerFired.await(90, TimeUnit.SECONDS);\n    assertTrue(\"cleanup action didn't run\", await);\n\n    // cleanup should have occurred\n    assertFalse(\"no events captured!\", listenerEvents.isEmpty());\n    List<CapturedEvent> events = new ArrayList<>(listenerEvents.get(\"foo\"));\n    listenerEvents.clear();\n\n    assertFalse(events.isEmpty());\n    CapturedEvent ce = null;\n    CapturedEvent staleLock = null;\n    for (CapturedEvent e : events) {\n      if (e.stage != TriggerEventProcessorStage.AFTER_ACTION) {\n        continue;\n      }\n      Map<String, Object> plan = (Map<String, Object>)e.context.get(\"properties.inactive_shard_plan\");\n      if (plan == null) {\n        continue;\n      }\n      if (plan.containsKey(\"cleanup\")) {\n        ce = e;\n      }\n      // capture only the first\n      if (plan.containsKey(\"staleLocks\") && staleLock == null) {\n        staleLock = e;\n      }\n    }\n    assertNotNull(\"missing cleanup event: \" + events, ce);\n    assertNotNull(\"missing staleLocks event: \" + events, staleLock);\n\n    Map<String, Object> map = (Map<String, Object>)ce.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n\n    Map<String, List<String>> inactive = (Map<String, List<String>>)map.get(\"inactive\");\n    assertEquals(1, inactive.size());\n    assertNotNull(inactive.get(collection1));\n    Map<String, List<String>> cleanup = (Map<String, List<String>>)map.get(\"cleanup\");\n    assertEquals(1, cleanup.size());\n    assertNotNull(cleanup.get(collection1));\n\n    map = (Map<String, Object>)staleLock.context.get(\"properties.inactive_shard_plan\");\n    assertNotNull(map);\n    Map<String, Map<String, Object>> locks = (Map<String, Map<String, Object>>)map.get(\"staleLocks\");\n    assertNotNull(locks);\n    assertTrue(\"missing stale lock data: \" + locks + \"\\nevents: \" + events, locks.containsKey(staleLockName));\n\n    ClusterState state = cloudManager.getClusterStateProvider().getClusterState();\n\n    CloudUtil.clusterShape(2, 1).matches(state.getLiveNodes(), state.getCollection(collection1));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3f504512a03d978990cbff30db0522b354e846db":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"fea75bde50d2c0a79b0a0be05e7c3e1fdfa89894":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["ae70f2df00762dfce0455c0e39381848762662e5"],"203e3fcf513c02ee2c07015f2ce277e26dc60907":["9c6c0dad4932399aec99b4818086cb1772773916","0bfcbdfe07d46da058707c12412aef939a5f2198"],"43345f1452f9510f8aaadae6156fe0c834e7d957":["203e3fcf513c02ee2c07015f2ce277e26dc60907","ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1"],"ae70f2df00762dfce0455c0e39381848762662e5":["fea75bde50d2c0a79b0a0be05e7c3e1fdfa89894"],"f7fb1186f5b61e0b74289e6786df8cbecfa471bc":["89948af0461fead48f44ba8fb7866f107ce83f22"],"042b92cf48996255bedb0c3c4bf772d7e06e4dea":["43345f1452f9510f8aaadae6156fe0c834e7d957"],"9c6c0dad4932399aec99b4818086cb1772773916":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1":["203e3fcf513c02ee2c07015f2ce277e26dc60907"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0bfcbdfe07d46da058707c12412aef939a5f2198":["9c6c0dad4932399aec99b4818086cb1772773916"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["f7fb1186f5b61e0b74289e6786df8cbecfa471bc"],"89948af0461fead48f44ba8fb7866f107ce83f22":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"]},"commit2Childs":{"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fea75bde50d2c0a79b0a0be05e7c3e1fdfa89894":["ae70f2df00762dfce0455c0e39381848762662e5"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["89948af0461fead48f44ba8fb7866f107ce83f22"],"203e3fcf513c02ee2c07015f2ce277e26dc60907":["43345f1452f9510f8aaadae6156fe0c834e7d957","ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1"],"43345f1452f9510f8aaadae6156fe0c834e7d957":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"ae70f2df00762dfce0455c0e39381848762662e5":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"042b92cf48996255bedb0c3c4bf772d7e06e4dea":["fea75bde50d2c0a79b0a0be05e7c3e1fdfa89894"],"f7fb1186f5b61e0b74289e6786df8cbecfa471bc":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"9c6c0dad4932399aec99b4818086cb1772773916":["203e3fcf513c02ee2c07015f2ce277e26dc60907","0bfcbdfe07d46da058707c12412aef939a5f2198"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["3f504512a03d978990cbff30db0522b354e846db"],"ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1":["43345f1452f9510f8aaadae6156fe0c834e7d957"],"0bfcbdfe07d46da058707c12412aef939a5f2198":["203e3fcf513c02ee2c07015f2ce277e26dc60907"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9c6c0dad4932399aec99b4818086cb1772773916"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"89948af0461fead48f44ba8fb7866f107ce83f22":["f7fb1186f5b61e0b74289e6786df8cbecfa471bc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}