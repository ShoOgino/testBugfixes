{"path":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * @param cmd\n   * @return whether or not to drop this cmd\n   * @throws IOException\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalAdd(cmd);\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["3d7c0c8a97beb56d2e168604f9928de17981eabe","3d7c0c8a97beb56d2e168604f9928de17981eabe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * @param cmd\n   * @return whether or not to drop this cmd\n   * @throws IOException\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalAdd(cmd);\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * @param cmd\n   * @return whether or not to drop this cmd\n   * @throws IOException\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalAdd(cmd);\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1bea3922196318026c4274f2013416acb60c691e","date":1336496433,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @param cmd\n   * @return whether or not to drop this cmd\n   * @throws IOException\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd);\n            if (updated && versionOnUpdate == -1) {\n              versionOnUpdate = 1;  // implied \"doc must exist\" for now...\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalAdd(cmd);\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @param cmd\n   * @return whether or not to drop this cmd\n   * @throws IOException\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalAdd(cmd);\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fb999ed3fc6e419b9104de9ebfe62ace27f31d5f","date":1341327930,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @param cmd\n   * @return whether or not to drop this cmd\n   * @throws IOException\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd);\n            if (updated && versionOnUpdate == -1) {\n              versionOnUpdate = 1;  // implied \"doc must exist\" for now...\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @param cmd\n   * @return whether or not to drop this cmd\n   * @throws IOException\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd);\n            if (updated && versionOnUpdate == -1) {\n              versionOnUpdate = 1;  // implied \"doc must exist\" for now...\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalAdd(cmd);\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5e5dbf4268db532969cc84ef336b9988afce9843","date":1342199436,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @param cmd\n   * @return whether or not to drop this cmd\n   * @throws IOException\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @param cmd\n   * @return whether or not to drop this cmd\n   * @throws IOException\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd);\n            if (updated && versionOnUpdate == -1) {\n              versionOnUpdate = 1;  // implied \"doc must exist\" for now...\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c5fa11bf621ab6d2af49b9e9e05dff485fec0de2","date":1342630362,"type":5,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @param cmd\n   * @param cloneDoc needs the version if it's assigned\n   * @return whether or not to drop this cmd\n   * @throws IOException\n   */\n  private boolean versionAdd(AddUpdateCommand cmd, SolrInputDocument cloneDoc) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            cloneDoc.setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @param cmd\n   * @return whether or not to drop this cmd\n   * @throws IOException\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":4,"author":"Michael McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":null,"sourceOld":"  /**\n   * @param cmd\n   * @return whether or not to drop this cmd\n   * @throws IOException\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd);\n            if (updated && versionOnUpdate == -1) {\n              versionOnUpdate = 1;  // implied \"doc must exist\" for now...\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalAdd(cmd);\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":4,"author":"Uwe Schindler","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":null,"sourceOld":"  /**\n   * @param cmd\n   * @return whether or not to drop this cmd\n   * @throws IOException\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd);\n            if (updated && versionOnUpdate == -1) {\n              versionOnUpdate = 1;  // implied \"doc must exist\" for now...\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e19067e820b148e8dc0b240da4f2771cf7b68252","date":1347730768,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand,SolrInputDocument).mjava","sourceNew":"  /**\n   * @param cmd\n   * @return whether or not to drop this cmd\n   * @throws IOException\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n        \n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @param cmd\n   * @param cloneDoc needs the version if it's assigned\n   * @return whether or not to drop this cmd\n   * @throws IOException\n   */\n  private boolean versionAdd(AddUpdateCommand cmd, SolrInputDocument cloneDoc) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            cloneDoc.setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069","date":1348430063,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n        \n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @param cmd\n   * @return whether or not to drop this cmd\n   * @throws IOException\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n        \n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e212b98d0f919993a50d5d662d73517f1f180ec2","date":1355246702,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n        \n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n        \n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3d7c0c8a97beb56d2e168604f9928de17981eabe","date":1357257676,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.REPLAY)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n        \n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n        \n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.REPLAY)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n        \n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n        \n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8a2f1187198fd8201881b815eea2fa3ba7b8ec5f","date":1369845628,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n        \n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.REPLAY)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n        \n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8f1ea787bab5bdb5e72685e55424898da05509b6","date":1370289750,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n        \n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"da888af1ab894358122a22229051215f58cf4d54","date":1384408702,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(\"distrib.from.collection\") != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3333dd7044501b4f20231ea55ab64e688285d153","date":1384785078,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(\"distrib.from.collection\") != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(\"distrib.from.collection\") != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2d3b450958a83a29a16e492fbff9d094a9a571b6","date":1421525067,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c94d2661bc1c14426980ec7882e951fdcff08d0","date":1427167177,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86290366cefc1b9d4eced13b430858c4a4c0421d","date":1432321109,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c835cc1a7b07477a469cdb1bf6c67bc05b85c07","date":1471849333,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a","date":1472163016,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5937684381598deda2e4ef4f6f0a55678e5090ee","date":1472586582,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bc8f206328a706450934717bec7ccc22ad166fc0","date":1473142172,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"415bbbe7da8065dd3c477bdc3c703c6425622998","date":1485393793,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1; // Last found version for a dependent update; applicable only for in-place updates; useful for logging later\n    // if this is an inplace update, check and wait if we should be waiting for a dependent update, before \n    // entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means in leader, the document has been deleted by now. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); //just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version \n                // from the deleted list (which might be older than the prev update!) \n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place update.\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), (fetchedFromLeader == null? null: ((AddUpdateCommand)fetchedFromLeader).solrDoc));\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the leader\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update.  we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered.  We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n\n                // also need to re-apply newer deleteByQuery commands\n                checkDeleteByQueries = true;\n              }\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"598b5d23aa7c9732bf473c21a9cd309c44599394","date":1485530378,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1; // Last found version for a dependent update; applicable only for in-place updates; useful for logging later\n    // if this is an inplace update, check and wait if we should be waiting for a dependent update, before \n    // entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means in leader, the document has been deleted by now. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); //just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version \n                // from the deleted list (which might be older than the prev update!) \n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place update.\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), (fetchedFromLeader == null? null: ((AddUpdateCommand)fetchedFromLeader).solrDoc));\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the leader\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update.  we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered.  We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n\n                // also need to re-apply newer deleteByQuery commands\n                checkDeleteByQueries = true;\n              }\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c2795aeb0b4c10d1588f672d3d5ac7a394fc8461","date":1487476295,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); //just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version \n                // from the deleted list (which might be older than the prev update!) \n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place update.\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the leader\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update.  we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered.  We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n\n                // also need to re-apply newer deleteByQuery commands\n                checkDeleteByQueries = true;\n              }\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1; // Last found version for a dependent update; applicable only for in-place updates; useful for logging later\n    // if this is an inplace update, check and wait if we should be waiting for a dependent update, before \n    // entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means in leader, the document has been deleted by now. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); //just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version \n                // from the deleted list (which might be older than the prev update!) \n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place update.\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), (fetchedFromLeader == null? null: ((AddUpdateCommand)fetchedFromLeader).solrDoc));\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the leader\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update.  we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered.  We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n\n                // also need to re-apply newer deleteByQuery commands\n                checkDeleteByQueries = true;\n              }\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"be320990bdc77e643388fa801e75017f19289c42","date":1489477067,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); //just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version \n                // from the deleted list (which might be older than the prev update!) \n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place update.\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the leader\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update.  we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered.  We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n\n                // also need to re-apply newer deleteByQuery commands\n                checkDeleteByQueries = true;\n              }\n            }\n            if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); //just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version \n                // from the deleted list (which might be older than the prev update!) \n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place update.\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the leader\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update.  we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered.  We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n\n                // also need to re-apply newer deleteByQuery commands\n                checkDeleteByQueries = true;\n              }\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f996f8177b9204bdc92f7164460c6cefad9ac99a","date":1489482690,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); //just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version \n                // from the deleted list (which might be older than the prev update!) \n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place update.\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the leader\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update.  we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered.  We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n\n                // also need to re-apply newer deleteByQuery commands\n                checkDeleteByQueries = true;\n              }\n            }\n            if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); //just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version \n                // from the deleted list (which might be older than the prev update!) \n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place update.\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the leader\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update.  we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered.  We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n\n                // also need to re-apply newer deleteByQuery commands\n                checkDeleteByQueries = true;\n              }\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab68488225b6a6c357dda72ed11dedca9914a192","date":1490013111,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); //just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version \n                // from the deleted list (which might be older than the prev update!) \n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place update.\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the leader\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update.  we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered.  We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n\n                // also need to re-apply newer deleteByQuery commands\n                checkDeleteByQueries = true;\n              }\n            }\n            if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); //just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version \n                // from the deleted list (which might be older than the prev update!) \n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place update.\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the leader\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update.  we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered.  We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n\n                // also need to re-apply newer deleteByQuery commands\n                checkDeleteByQueries = true;\n              }\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6d2dadc1f5ca8703d8659f4964961f9967935d75","date":1490231750,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); //just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version \n                // from the deleted list (which might be older than the prev update!) \n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place update.\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the leader\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update.  we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered.  We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n\n                // also need to re-apply newer deleteByQuery commands\n                checkDeleteByQueries = true;\n              }\n            }\n            if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); //just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version \n                // from the deleted list (which might be older than the prev update!) \n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place update.\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the leader\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update.  we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered.  We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n\n                // also need to re-apply newer deleteByQuery commands\n                checkDeleteByQueries = true;\n              }\n            }\n            if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e5fa6615014cd2288fe930f8c8bb726f9504961d","date":1490280013,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); //just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version \n                // from the deleted list (which might be older than the prev update!) \n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place update.\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the leader\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update.  we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered.  We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n\n                // also need to re-apply newer deleteByQuery commands\n                checkDeleteByQueries = true;\n              }\n            }\n            if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); //just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version \n                // from the deleted list (which might be older than the prev update!) \n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place update.\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the leader\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update.  we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered.  We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n\n                // also need to re-apply newer deleteByQuery commands\n                checkDeleteByQueries = true;\n              }\n            }\n            if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61c45e99cf6676da48f19d7511c73712ad39402b","date":1495508331,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); //just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version \n                // from the deleted list (which might be older than the prev update!) \n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place update.\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the leader\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update.  we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered.  We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n\n                // also need to re-apply newer deleteByQuery commands\n                checkDeleteByQueries = true;\n              }\n            }\n            if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); //just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version \n                // from the deleted list (which might be older than the prev update!) \n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place update.\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the leader\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update.  we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered.  We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n\n                // also need to re-apply newer deleteByQuery commands\n                checkDeleteByQueries = true;\n              }\n            }\n            if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); //just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version \n                // from the deleted list (which might be older than the prev update!) \n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place update.\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the leader\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update.  we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered.  We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n\n                // also need to re-apply newer deleteByQuery commands\n                checkDeleteByQueries = true;\n              }\n            }\n            if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); //just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version \n                // from the deleted list (which might be older than the prev update!) \n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place update.\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the leader\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update.  we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered.  We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n\n                // also need to re-apply newer deleteByQuery commands\n                checkDeleteByQueries = true;\n              }\n            }\n            if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"615bf5b56d95ed8c9bf06a402db6c817d6bff21a","date":1509492118,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); //just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version \n                // from the deleted list (which might be older than the prev update!) \n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place update.\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the leader\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update.  we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered.  We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); //just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version \n                // from the deleted list (which might be older than the prev update!) \n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place update.\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the leader\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update.  we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered.  We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n\n                // also need to re-apply newer deleteByQuery commands\n                checkDeleteByQueries = true;\n              }\n            }\n            if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"defa11d88d50ec356d5e7428f1ebc89623e840ac","date":1527653148,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = bucketHash(idBytes);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); //just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version \n                // from the deleted list (which might be older than the prev update!) \n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place update.\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the leader\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update.  we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered.  We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); //just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version \n                // from the deleted list (which might be older than the prev update!) \n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place update.\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the leader\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update.  we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered.  We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93883be70036b07c92da36fab94ec4f7a20c94ca","date":1532313208,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = bucketHash(idBytes);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); //just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version \n                // from the deleted list (which might be older than the prev update!) \n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place update.\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the leader\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            } else {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update.  we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered.  We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = bucketHash(idBytes);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); //just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version \n                // from the deleted list (which might be older than the prev update!) \n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place update.\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the leader\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            }\n\n            if (!cmd.isInPlaceUpdate()) {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update.  we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered.  We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2ffc8d70d9f57a62a24c3dd15b66e353de935054","date":1533178472,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = bucketHash(idBytes);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); //just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version \n                // from the deleted list (which might be older than the prev update!) \n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place update.\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the leader\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            } else {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update.  we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered.  We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = bucketHash(idBytes);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); //just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version \n                // from the deleted list (which might be older than the prev update!) \n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place update.\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the leader\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            } else {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update.  we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered.  We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d65446e37ead9e278d9fd19ba6ac154a512916ea","date":1544107016,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash\n    // here)\n    int bucketHash = bucketHash(idBytes);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        bucket.signalAll();\n        // just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                  || (versionOnUpdate == 1 && foundVersion > 0)) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                    + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version\n                // from the deleted list (which might be older than the prev update!)\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place\n                  // update.\n                  log.info(\n                      \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the\n                  // leader\n                  cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            } else {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update. we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered. We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n\n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n\n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n      } finally {\n\n        bucket.unlock();\n\n        vinfo.unlockForUpdate();\n      }\n      return false;\n\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = bucketHash(idBytes);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        bucket.notifyAll(); //just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version \n                // from the deleted list (which might be older than the prev update!) \n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand)fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place update.\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the leader\n                  cmd.solrDoc = ((AddUpdateCommand)fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long)cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            } else {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update.  we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered.  We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b25c66490468a167b569a0466630020b7ffbb76","date":1549481515,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash\n    // here)\n    int bucketHash = bucketHash(idBytes);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        bucket.signalAll();\n        // just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                  || (versionOnUpdate == 1 && foundVersion > 0)) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                    + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version\n                // from the deleted list (which might be older than the prev update!)\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place\n                  // update.\n                  log.info(\n                      \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the\n                  // leader\n                  cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            } else {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update. we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered. We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n\n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n\n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n      } finally {\n\n        bucket.unlock();\n\n        vinfo.unlockForUpdate();\n      }\n      return false;\n\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash\n    // here)\n    int bucketHash = bucketHash(idBytes);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        bucket.signalAll();\n        // just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                  || (versionOnUpdate == 1 && foundVersion > 0)) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                    + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version\n                // from the deleted list (which might be older than the prev update!)\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place\n                  // update.\n                  log.info(\n                      \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the\n                  // leader\n                  cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            } else {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update. we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered. We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n\n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n\n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n      } finally {\n\n        bucket.unlock();\n\n        vinfo.unlockForUpdate();\n      }\n      return false;\n\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9d70e774cb25c8a8d2c3e5e84200f235f9168d87","date":1553016391,"type":3,"author":"Bar Rotstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash\n    // here)\n    int bucketHash = bucketHash(idBytes);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        bucket.signalAll();\n        // just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                  || (versionOnUpdate == 1 && foundVersion > 0)) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                    + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version\n                // from the deleted list (which might be older than the prev update!)\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place\n                  // update.\n                  log.info(\n                      \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the\n                  // leader\n                  cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            } else {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update. we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered. We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        SolrInputDocument clonedDoc = shouldCloneCmdDoc() ? cmd.solrDoc.deepCopy(): null;\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n\n        if (clonedDoc != null) {\n          cmd.solrDoc = clonedDoc;\n        }\n      } finally {\n\n        bucket.unlock();\n\n        vinfo.unlockForUpdate();\n      }\n      return false;\n\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash\n    // here)\n    int bucketHash = bucketHash(idBytes);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        bucket.signalAll();\n        // just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                  || (versionOnUpdate == 1 && foundVersion > 0)) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                    + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version\n                // from the deleted list (which might be older than the prev update!)\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place\n                  // update.\n                  log.info(\n                      \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the\n                  // leader\n                  cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            } else {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update. we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered. We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n\n        SolrInputDocument clonedDoc = null;\n        if (willDistrib && cloneRequiredOnLeader) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n\n        if (willDistrib && cloneRequiredOnLeader) {\n          cmd.solrDoc = clonedDoc;\n        }\n      } finally {\n\n        bucket.unlock();\n\n        vinfo.unlockForUpdate();\n      }\n      return false;\n\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"07749612bed4eb54dd05255c1434c301133310c1","date":1554879779,"type":3,"author":"Moshe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash\n    // here)\n    int bucketHash = bucketHash(idBytes);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        bucket.signalAll();\n        // just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                  || (versionOnUpdate == 1 && foundVersion > 0)) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                    + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version\n                // from the deleted list (which might be older than the prev update!)\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place\n                  // update.\n                  log.info(\n                      \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the\n                  // leader\n                  cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            } else {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update. we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered. We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        SolrInputDocument clonedDoc = shouldCloneCmdDoc() ? cmd.solrDoc.deepCopy(): null;\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n\n        // if the update updates a doc that is part of a nested structure,\n        // force open a realTimeSearcher to trigger a ulog cache refresh.\n        // This refresh makes RTG handler aware of this update.q\n        if(req.getSchema().isUsableForChildDocs() && shouldRefreshUlogCaches(cmd)) {\n          ulog.openRealtimeSearcher();\n        }\n\n        if (clonedDoc != null) {\n          cmd.solrDoc = clonedDoc;\n        }\n      } finally {\n        bucket.unlock();\n        vinfo.unlockForUpdate();\n      }\n      return false;\n\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash\n    // here)\n    int bucketHash = bucketHash(idBytes);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        bucket.signalAll();\n        // just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                  || (versionOnUpdate == 1 && foundVersion > 0)) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                    + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version\n                // from the deleted list (which might be older than the prev update!)\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place\n                  // update.\n                  log.info(\n                      \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the\n                  // leader\n                  cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            } else {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update. we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered. We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        SolrInputDocument clonedDoc = shouldCloneCmdDoc() ? cmd.solrDoc.deepCopy(): null;\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n\n        if (clonedDoc != null) {\n          cmd.solrDoc = clonedDoc;\n        }\n      } finally {\n\n        bucket.unlock();\n\n        vinfo.unlockForUpdate();\n      }\n      return false;\n\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9b3824fcbd3256db359391630ae05b3917ab369a","date":1556656304,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash\n    // here)\n    int bucketHash = bucketHash(idBytes);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    try {\n      long finalVersionOnUpdate = versionOnUpdate;\n      return bucket.runWithLock(vinfo.getVersionBucketLockTimeoutMs(), () -> doVersionAdd(cmd, finalVersionOnUpdate, isReplayOrPeersync, leaderLogic, forwardedFromCollection, bucket));\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","sourceOld":"  /**\n   * @return whether or not to drop this cmd\n   * @throws IOException If there is a low-level I/O error.\n   */\n  protected boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    if (vinfo == null) {\n      if (AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Atomic document updates are not supported unless <updateLog/> is configured\");\n      } else {\n        super.processAdd(cmd);\n        return false;\n      }\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash\n    // here)\n    int bucketHash = bucketHash(idBytes);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(CommonParams.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    long dependentVersionFound = -1;\n    // if this is an in-place update, check and wait if we should be waiting for a previous update (on which\n    // this update depends), before entering the synchronized block\n    if (!leaderLogic && cmd.isInPlaceUpdate()) {\n      dependentVersionFound = waitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket);\n      if (dependentVersionFound == -1) {\n        // it means the document has been deleted by now at the leader. drop this update\n        return true;\n      }\n    }\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        bucket.signalAll();\n        // just in case anyone is waiting let them know that we have a new update\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getPrintableId());\n              cmd.solrDoc.remove(CommonParams.VERSION_FIELD);\n              versionOnUpdate = 0;\n            }\n\n            getUpdatedDocument(cmd, versionOnUpdate);\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getPrintableId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if (versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0)\n                  || (versionOnUpdate == 1 && foundVersion > 0)) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId()\n                    + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(CommonParams.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (shouldBufferUpdate(cmd, isReplayOrPeersync, ulog.getState())) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            if (cmd.isInPlaceUpdate()) {\n              long prev = cmd.prevVersion;\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion == null || Math.abs(lastVersion) < prev) {\n                // this was checked for (in waitForDependentUpdates()) before entering the synchronized block.\n                // So we shouldn't be here, unless what must've happened is:\n                // by the time synchronization block was entered, the prev update was deleted by DBQ. Since\n                // now that update is not in index, the vinfo.lookupVersion() is possibly giving us a version\n                // from the deleted list (which might be older than the prev update!)\n                UpdateCommand fetchedFromLeader = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n\n                if (fetchedFromLeader instanceof DeleteUpdateCommand) {\n                  log.info(\"In-place update of {} failed to find valid lastVersion to apply to, and the document\"\n                      + \" was deleted at the leader subsequently.\", idBytes.utf8ToString());\n                  versionDelete((DeleteUpdateCommand) fetchedFromLeader);\n                  return true;\n                } else {\n                  assert fetchedFromLeader instanceof AddUpdateCommand;\n                  // Newer document was fetched from the leader. Apply that document instead of this current in-place\n                  // update.\n                  log.info(\n                      \"In-place update of {} failed to find valid lastVersion to apply to, forced to fetch full doc from leader: {}\",\n                      idBytes.utf8ToString(), fetchedFromLeader);\n\n                  // Make this update to become a non-inplace update containing the full document obtained from the\n                  // leader\n                  cmd.solrDoc = ((AddUpdateCommand) fetchedFromLeader).solrDoc;\n                  cmd.prevVersion = -1;\n                  cmd.setVersion((long) cmd.solrDoc.getFieldValue(CommonParams.VERSION_FIELD));\n                  assert cmd.isInPlaceUpdate() == false;\n                }\n              } else {\n                if (lastVersion != null && Math.abs(lastVersion) > prev) {\n                  // this means we got a newer full doc update and in that case it makes no sense to apply the older\n                  // inplace update. Drop this update\n                  log.info(\"Update was applied on version: \" + prev + \", but last version I have is: \" + lastVersion\n                      + \". Dropping current update.\");\n                  return true;\n                } else {\n                  // We're good, we should apply this update. First, update the bucket's highest.\n                  if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                    bucket.updateHighest(versionOnUpdate);\n                  }\n                }\n              }\n            } else {\n              // if we aren't the leader, then we need to check that updates were not re-ordered\n              if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n                // we're OK... this update has a version higher than anything we've seen\n                // in this bucket so far, so we know that no reordering has yet occurred.\n                bucket.updateHighest(versionOnUpdate);\n              } else {\n                // there have been updates higher than the current update. we need to check\n                // the specific version for this id.\n                Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n                if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                  // This update is a repeat, or was reordered. We need to drop this update.\n                  log.debug(\"Dropping add update due to version {}\", idBytes.utf8ToString());\n                  return true;\n                }\n              }\n            }\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        SolrInputDocument clonedDoc = shouldCloneCmdDoc() ? cmd.solrDoc.deepCopy(): null;\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n\n        // if the update updates a doc that is part of a nested structure,\n        // force open a realTimeSearcher to trigger a ulog cache refresh.\n        // This refresh makes RTG handler aware of this update.q\n        if(req.getSchema().isUsableForChildDocs() && shouldRefreshUlogCaches(cmd)) {\n          ulog.openRealtimeSearcher();\n        }\n\n        if (clonedDoc != null) {\n          cmd.solrDoc = clonedDoc;\n        }\n      } finally {\n        bucket.unlock();\n        vinfo.unlockForUpdate();\n      }\n      return false;\n\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9b3824fcbd3256db359391630ae05b3917ab369a":["07749612bed4eb54dd05255c1434c301133310c1"],"6c94d2661bc1c14426980ec7882e951fdcff08d0":["2d3b450958a83a29a16e492fbff9d094a9a571b6"],"07749612bed4eb54dd05255c1434c301133310c1":["9d70e774cb25c8a8d2c3e5e84200f235f9168d87"],"c5fa11bf621ab6d2af49b9e9e05dff485fec0de2":["5e5dbf4268db532969cc84ef336b9988afce9843"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["e5fa6615014cd2288fe930f8c8bb726f9504961d","61c45e99cf6676da48f19d7511c73712ad39402b"],"aba371508186796cc6151d8223a5b4e16d02e26e":["fb999ed3fc6e419b9104de9ebfe62ace27f31d5f","c5fa11bf621ab6d2af49b9e9e05dff485fec0de2"],"5e5dbf4268db532969cc84ef336b9988afce9843":["fb999ed3fc6e419b9104de9ebfe62ace27f31d5f"],"c2795aeb0b4c10d1588f672d3d5ac7a394fc8461":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"be320990bdc77e643388fa801e75017f19289c42":["c2795aeb0b4c10d1588f672d3d5ac7a394fc8461"],"ab68488225b6a6c357dda72ed11dedca9914a192":["c2795aeb0b4c10d1588f672d3d5ac7a394fc8461","f996f8177b9204bdc92f7164460c6cefad9ac99a"],"415bbbe7da8065dd3c477bdc3c703c6425622998":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"d65446e37ead9e278d9fd19ba6ac154a512916ea":["2ffc8d70d9f57a62a24c3dd15b66e353de935054"],"da888af1ab894358122a22229051215f58cf4d54":["8f1ea787bab5bdb5e72685e55424898da05509b6"],"8a2f1187198fd8201881b815eea2fa3ba7b8ec5f":["3d7c0c8a97beb56d2e168604f9928de17981eabe"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["c2795aeb0b4c10d1588f672d3d5ac7a394fc8461"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["1bea3922196318026c4274f2013416acb60c691e","c5fa11bf621ab6d2af49b9e9e05dff485fec0de2"],"6b25c66490468a167b569a0466630020b7ffbb76":["d65446e37ead9e278d9fd19ba6ac154a512916ea"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["da888af1ab894358122a22229051215f58cf4d54","3333dd7044501b4f20231ea55ab64e688285d153"],"2d3b450958a83a29a16e492fbff9d094a9a571b6":["3333dd7044501b4f20231ea55ab64e688285d153"],"9d70e774cb25c8a8d2c3e5e84200f235f9168d87":["6b25c66490468a167b569a0466630020b7ffbb76"],"3333dd7044501b4f20231ea55ab64e688285d153":["da888af1ab894358122a22229051215f58cf4d54"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069","3d7c0c8a97beb56d2e168604f9928de17981eabe"],"fb999ed3fc6e419b9104de9ebfe62ace27f31d5f":["1bea3922196318026c4274f2013416acb60c691e"],"598b5d23aa7c9732bf473c21a9cd309c44599394":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","415bbbe7da8065dd3c477bdc3c703c6425622998"],"e212b98d0f919993a50d5d662d73517f1f180ec2":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069"],"8f1ea787bab5bdb5e72685e55424898da05509b6":["8a2f1187198fd8201881b815eea2fa3ba7b8ec5f"],"3d7c0c8a97beb56d2e168604f9928de17981eabe":["e212b98d0f919993a50d5d662d73517f1f180ec2"],"5937684381598deda2e4ef4f6f0a55678e5090ee":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"bc8f206328a706450934717bec7ccc22ad166fc0":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a","5937684381598deda2e4ef4f6f0a55678e5090ee"],"1bea3922196318026c4274f2013416acb60c691e":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["2d3b450958a83a29a16e492fbff9d094a9a571b6","6c94d2661bc1c14426980ec7882e951fdcff08d0"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"4c835cc1a7b07477a469cdb1bf6c67bc05b85c07":["86290366cefc1b9d4eced13b430858c4a4c0421d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a","5937684381598deda2e4ef4f6f0a55678e5090ee"],"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a":["86290366cefc1b9d4eced13b430858c4a4c0421d","4c835cc1a7b07477a469cdb1bf6c67bc05b85c07"],"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["e19067e820b148e8dc0b240da4f2771cf7b68252"],"defa11d88d50ec356d5e7428f1ebc89623e840ac":["615bf5b56d95ed8c9bf06a402db6c817d6bff21a"],"61c45e99cf6676da48f19d7511c73712ad39402b":["6d2dadc1f5ca8703d8659f4964961f9967935d75"],"93883be70036b07c92da36fab94ec4f7a20c94ca":["defa11d88d50ec356d5e7428f1ebc89623e840ac"],"6d2dadc1f5ca8703d8659f4964961f9967935d75":["be320990bdc77e643388fa801e75017f19289c42"],"e19067e820b148e8dc0b240da4f2771cf7b68252":["c5fa11bf621ab6d2af49b9e9e05dff485fec0de2"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["86290366cefc1b9d4eced13b430858c4a4c0421d","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"e5fa6615014cd2288fe930f8c8bb726f9504961d":["ab68488225b6a6c357dda72ed11dedca9914a192"],"86290366cefc1b9d4eced13b430858c4a4c0421d":["6c94d2661bc1c14426980ec7882e951fdcff08d0"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"615bf5b56d95ed8c9bf06a402db6c817d6bff21a":["61c45e99cf6676da48f19d7511c73712ad39402b"],"2ffc8d70d9f57a62a24c3dd15b66e353de935054":["93883be70036b07c92da36fab94ec4f7a20c94ca"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9b3824fcbd3256db359391630ae05b3917ab369a"]},"commit2Childs":{"9b3824fcbd3256db359391630ae05b3917ab369a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6c94d2661bc1c14426980ec7882e951fdcff08d0":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","86290366cefc1b9d4eced13b430858c4a4c0421d"],"07749612bed4eb54dd05255c1434c301133310c1":["9b3824fcbd3256db359391630ae05b3917ab369a"],"c5fa11bf621ab6d2af49b9e9e05dff485fec0de2":["aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424","e19067e820b148e8dc0b240da4f2771cf7b68252"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"5e5dbf4268db532969cc84ef336b9988afce9843":["c5fa11bf621ab6d2af49b9e9e05dff485fec0de2"],"c2795aeb0b4c10d1588f672d3d5ac7a394fc8461":["be320990bdc77e643388fa801e75017f19289c42","ab68488225b6a6c357dda72ed11dedca9914a192","f996f8177b9204bdc92f7164460c6cefad9ac99a"],"be320990bdc77e643388fa801e75017f19289c42":["6d2dadc1f5ca8703d8659f4964961f9967935d75"],"ab68488225b6a6c357dda72ed11dedca9914a192":["e5fa6615014cd2288fe930f8c8bb726f9504961d"],"415bbbe7da8065dd3c477bdc3c703c6425622998":["c2795aeb0b4c10d1588f672d3d5ac7a394fc8461","598b5d23aa7c9732bf473c21a9cd309c44599394"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"d65446e37ead9e278d9fd19ba6ac154a512916ea":["6b25c66490468a167b569a0466630020b7ffbb76"],"da888af1ab894358122a22229051215f58cf4d54":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","3333dd7044501b4f20231ea55ab64e688285d153"],"8a2f1187198fd8201881b815eea2fa3ba7b8ec5f":["8f1ea787bab5bdb5e72685e55424898da05509b6"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["ab68488225b6a6c357dda72ed11dedca9914a192"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"6b25c66490468a167b569a0466630020b7ffbb76":["9d70e774cb25c8a8d2c3e5e84200f235f9168d87"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"2d3b450958a83a29a16e492fbff9d094a9a571b6":["6c94d2661bc1c14426980ec7882e951fdcff08d0","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"9d70e774cb25c8a8d2c3e5e84200f235f9168d87":["07749612bed4eb54dd05255c1434c301133310c1"],"3333dd7044501b4f20231ea55ab64e688285d153":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","2d3b450958a83a29a16e492fbff9d094a9a571b6"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"fb999ed3fc6e419b9104de9ebfe62ace27f31d5f":["aba371508186796cc6151d8223a5b4e16d02e26e","5e5dbf4268db532969cc84ef336b9988afce9843"],"598b5d23aa7c9732bf473c21a9cd309c44599394":[],"e212b98d0f919993a50d5d662d73517f1f180ec2":["3d7c0c8a97beb56d2e168604f9928de17981eabe"],"8f1ea787bab5bdb5e72685e55424898da05509b6":["da888af1ab894358122a22229051215f58cf4d54"],"3d7c0c8a97beb56d2e168604f9928de17981eabe":["8a2f1187198fd8201881b815eea2fa3ba7b8ec5f","d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"5937684381598deda2e4ef4f6f0a55678e5090ee":["bc8f206328a706450934717bec7ccc22ad166fc0","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"bc8f206328a706450934717bec7ccc22ad166fc0":[],"1bea3922196318026c4274f2013416acb60c691e":["fe33227f6805edab2036cbb80645cc4e2d1fa424","fb999ed3fc6e419b9104de9ebfe62ace27f31d5f"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"4c835cc1a7b07477a469cdb1bf6c67bc05b85c07":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["415bbbe7da8065dd3c477bdc3c703c6425622998","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a":["5937684381598deda2e4ef4f6f0a55678e5090ee","bc8f206328a706450934717bec7ccc22ad166fc0","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","e212b98d0f919993a50d5d662d73517f1f180ec2"],"61c45e99cf6676da48f19d7511c73712ad39402b":["e9017cf144952056066919f1ebc7897ff9bd71b1","615bf5b56d95ed8c9bf06a402db6c817d6bff21a"],"defa11d88d50ec356d5e7428f1ebc89623e840ac":["93883be70036b07c92da36fab94ec4f7a20c94ca"],"6d2dadc1f5ca8703d8659f4964961f9967935d75":["61c45e99cf6676da48f19d7511c73712ad39402b"],"93883be70036b07c92da36fab94ec4f7a20c94ca":["2ffc8d70d9f57a62a24c3dd15b66e353de935054"],"e19067e820b148e8dc0b240da4f2771cf7b68252":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["598b5d23aa7c9732bf473c21a9cd309c44599394"],"e5fa6615014cd2288fe930f8c8bb726f9504961d":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"86290366cefc1b9d4eced13b430858c4a4c0421d":["4c835cc1a7b07477a469cdb1bf6c67bc05b85c07","e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","1bea3922196318026c4274f2013416acb60c691e","0d22ac6a4146774c1bc8400160fc0b6150294e92"],"615bf5b56d95ed8c9bf06a402db6c817d6bff21a":["defa11d88d50ec356d5e7428f1ebc89623e840ac"],"2ffc8d70d9f57a62a24c3dd15b66e353de935054":["d65446e37ead9e278d9fd19ba6ac154a512916ea"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","aba371508186796cc6151d8223a5b4e16d02e26e","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","fe33227f6805edab2036cbb80645cc4e2d1fa424","74f45af4339b0daf7a95c820ab88c1aea74fbce0","d3fcb70cf561547c7bb1506e0cf32ca7b1287064","598b5d23aa7c9732bf473c21a9cd309c44599394","bc8f206328a706450934717bec7ccc22ad166fc0","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","0d22ac6a4146774c1bc8400160fc0b6150294e92","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}