{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/TemporalEvaluator#evaluate(Tuple).mjava","commits":[{"id":"64ff6b743fd4051da7ebb3d397d1ef80833a741a","date":1492023891,"type":0,"author":"Gethin James","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/TemporalEvaluator#evaluate(Tuple).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Object evaluate(Tuple tuple) throws IOException {\n\n    Instant instant = null;\n    TemporalAccessor date = null;\n\n    //First evaluate the parameter\n    StreamEvaluator streamEvaluator = subEvaluators.get(0);\n    Object tupleValue = streamEvaluator.evaluate(tuple);\n\n    if (tupleValue == null) return null;\n\n    if (tupleValue instanceof String) {\n      instant = getInstant((String) tupleValue);\n    } else if (tupleValue instanceof Long) {\n      instant = Instant.ofEpochMilli((Long)tupleValue);\n    } else if (tupleValue instanceof Instant) {\n      instant = (Instant) tupleValue;\n    } else if (tupleValue instanceof Date) {\n      instant = ((Date) tupleValue).toInstant();\n    } else if (tupleValue instanceof TemporalAccessor) {\n      date = ((TemporalAccessor) tupleValue);\n    }\n\n    if (instant != null) {\n      if (TemporalEvaluatorEpoch.FUNCTION_NAME.equals(getFunction())) return instant.toEpochMilli();\n      date = LocalDateTime.ofInstant(instant, ZoneOffset.UTC);\n    }\n\n    if (date != null) {\n      try {\n        return evaluateDate(date);\n      } catch (UnsupportedTemporalTypeException utte) {\n        throw new IOException(String.format(Locale.ROOT, \"It is not possible to call '%s' function on %s\", getFunction(), date.getClass().getName()));\n      }\n    }\n\n    throw new IOException(String.format(Locale.ROOT, \"Invalid parameter %s - The parameter must be a string formatted ISO_INSTANT or of type Instant,Date or LocalDateTime.\", String.valueOf(tupleValue)));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e4177dd81a9f4ea02615ad384a4c17f13edf868b","date":1492023891,"type":3,"author":"Gethin James","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/TemporalEvaluator#evaluate(Tuple).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/TemporalEvaluator#evaluate(Tuple).mjava","sourceNew":"  @Override\n  public Object evaluate(Tuple tuple) throws IOException {\n\n    Instant instant = null;\n    TemporalAccessor date = null;\n\n    //First evaluate the parameter\n    StreamEvaluator streamEvaluator = subEvaluators.get(0);\n    Object tupleValue = streamEvaluator.evaluate(tuple);\n\n    if (tupleValue == null) return null;\n\n    if (tupleValue instanceof String) {\n      instant = getInstant((String) tupleValue);\n    } else if (tupleValue instanceof Long) {\n      instant = Instant.ofEpochMilli((Long)tupleValue);\n    } else if (tupleValue instanceof Instant) {\n      instant = (Instant) tupleValue;\n    } else if (tupleValue instanceof Date) {\n      instant = ((Date) tupleValue).toInstant();\n    } else if (tupleValue instanceof TemporalAccessor) {\n      date = ((TemporalAccessor) tupleValue);\n    }\n\n    if (instant != null) {\n      if (TemporalEvaluatorEpoch.FUNCTION_NAME.equals(getFunction())) return instant.toEpochMilli();\n      date = LocalDateTime.ofInstant(instant, ZoneOffset.UTC);\n    }\n\n    if (date != null) {\n      try {\n        return evaluateDate(date);\n      } catch (UnsupportedTemporalTypeException utte) {\n        throw new IOException(String.format(Locale.ROOT, \"It is not possible to call '%s' function on %s\", getFunction(), date.getClass().getName()));\n      }\n    }\n\n    throw new IOException(String.format(Locale.ROOT, \"Invalid parameter %s - The parameter must be a string formatted ISO_INSTANT or of type Long,Instant,Date,LocalDateTime or TemporalAccessor.\", String.valueOf(tupleValue)));\n  }\n\n","sourceOld":"  @Override\n  public Object evaluate(Tuple tuple) throws IOException {\n\n    Instant instant = null;\n    TemporalAccessor date = null;\n\n    //First evaluate the parameter\n    StreamEvaluator streamEvaluator = subEvaluators.get(0);\n    Object tupleValue = streamEvaluator.evaluate(tuple);\n\n    if (tupleValue == null) return null;\n\n    if (tupleValue instanceof String) {\n      instant = getInstant((String) tupleValue);\n    } else if (tupleValue instanceof Long) {\n      instant = Instant.ofEpochMilli((Long)tupleValue);\n    } else if (tupleValue instanceof Instant) {\n      instant = (Instant) tupleValue;\n    } else if (tupleValue instanceof Date) {\n      instant = ((Date) tupleValue).toInstant();\n    } else if (tupleValue instanceof TemporalAccessor) {\n      date = ((TemporalAccessor) tupleValue);\n    }\n\n    if (instant != null) {\n      if (TemporalEvaluatorEpoch.FUNCTION_NAME.equals(getFunction())) return instant.toEpochMilli();\n      date = LocalDateTime.ofInstant(instant, ZoneOffset.UTC);\n    }\n\n    if (date != null) {\n      try {\n        return evaluateDate(date);\n      } catch (UnsupportedTemporalTypeException utte) {\n        throw new IOException(String.format(Locale.ROOT, \"It is not possible to call '%s' function on %s\", getFunction(), date.getClass().getName()));\n      }\n    }\n\n    throw new IOException(String.format(Locale.ROOT, \"Invalid parameter %s - The parameter must be a string formatted ISO_INSTANT or of type Instant,Date or LocalDateTime.\", String.valueOf(tupleValue)));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56ebde9c21d35a39c07989c178372e901ad377da","date":1492023892,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/TemporalEvaluator#evaluate(Tuple).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/TemporalEvaluator#evaluate(Tuple).mjava","sourceNew":"  @Override\n  public Object evaluate(Tuple tuple) throws IOException {\n\n    Instant instant = null;\n    TemporalAccessor date = null;\n\n    //First evaluate the parameter\n    StreamEvaluator streamEvaluator = subEvaluators.get(0);\n    Object tupleValue = streamEvaluator.evaluate(tuple);\n\n    if (tupleValue == null) return null;\n\n    if(field == null) {\n      field = streamEvaluator.toExpression(constructingFactory).toString();\n    }\n\n    Map tupleContext = streamContext.getTupleContext();\n    date = (LocalDateTime)tupleContext.get(field); // Check to see if the date has already been created for this field\n\n    if(date == null) {\n      if (tupleValue instanceof String) {\n        instant = getInstant((String) tupleValue);\n      } else if (tupleValue instanceof Long) {\n        instant = Instant.ofEpochMilli((Long) tupleValue);\n      } else if (tupleValue instanceof Instant) {\n        instant = (Instant) tupleValue;\n      } else if (tupleValue instanceof Date) {\n        instant = ((Date) tupleValue).toInstant();\n      } else if (tupleValue instanceof TemporalAccessor) {\n        date = ((TemporalAccessor) tupleValue);\n        tupleContext.put(field, date); // Cache the date in the TupleContext\n      }\n    }\n\n    if (instant != null) {\n      if (TemporalEvaluatorEpoch.FUNCTION_NAME.equals(getFunction())) return instant.toEpochMilli();\n      date = LocalDateTime.ofInstant(instant, ZoneOffset.UTC);\n      tupleContext.put(field, date); // Cache the date in the TupleContext\n    }\n\n    if (date != null) {\n      try {\n        return evaluateDate(date);\n      } catch (UnsupportedTemporalTypeException utte) {\n        throw new IOException(String.format(Locale.ROOT, \"It is not possible to call '%s' function on %s\", getFunction(), date.getClass().getName()));\n      }\n    }\n\n    throw new IOException(String.format(Locale.ROOT, \"Invalid parameter %s - The parameter must be a string formatted ISO_INSTANT or of type Long,Instant,Date,LocalDateTime or TemporalAccessor.\", String.valueOf(tupleValue)));\n  }\n\n","sourceOld":"  @Override\n  public Object evaluate(Tuple tuple) throws IOException {\n\n    Instant instant = null;\n    TemporalAccessor date = null;\n\n    //First evaluate the parameter\n    StreamEvaluator streamEvaluator = subEvaluators.get(0);\n    Object tupleValue = streamEvaluator.evaluate(tuple);\n\n    if (tupleValue == null) return null;\n\n    if (tupleValue instanceof String) {\n      instant = getInstant((String) tupleValue);\n    } else if (tupleValue instanceof Long) {\n      instant = Instant.ofEpochMilli((Long)tupleValue);\n    } else if (tupleValue instanceof Instant) {\n      instant = (Instant) tupleValue;\n    } else if (tupleValue instanceof Date) {\n      instant = ((Date) tupleValue).toInstant();\n    } else if (tupleValue instanceof TemporalAccessor) {\n      date = ((TemporalAccessor) tupleValue);\n    }\n\n    if (instant != null) {\n      if (TemporalEvaluatorEpoch.FUNCTION_NAME.equals(getFunction())) return instant.toEpochMilli();\n      date = LocalDateTime.ofInstant(instant, ZoneOffset.UTC);\n    }\n\n    if (date != null) {\n      try {\n        return evaluateDate(date);\n      } catch (UnsupportedTemporalTypeException utte) {\n        throw new IOException(String.format(Locale.ROOT, \"It is not possible to call '%s' function on %s\", getFunction(), date.getClass().getName()));\n      }\n    }\n\n    throw new IOException(String.format(Locale.ROOT, \"Invalid parameter %s - The parameter must be a string formatted ISO_INSTANT or of type Long,Instant,Date,LocalDateTime or TemporalAccessor.\", String.valueOf(tupleValue)));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/TemporalEvaluator#evaluate(Tuple).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Object evaluate(Tuple tuple) throws IOException {\n\n    Instant instant = null;\n    TemporalAccessor date = null;\n\n    //First evaluate the parameter\n    StreamEvaluator streamEvaluator = subEvaluators.get(0);\n    Object tupleValue = streamEvaluator.evaluate(tuple);\n\n    if (tupleValue == null) return null;\n\n    if(field == null) {\n      field = streamEvaluator.toExpression(constructingFactory).toString();\n    }\n\n    Map tupleContext = streamContext.getTupleContext();\n    date = (LocalDateTime)tupleContext.get(field); // Check to see if the date has already been created for this field\n\n    if(date == null) {\n      if (tupleValue instanceof String) {\n        instant = getInstant((String) tupleValue);\n      } else if (tupleValue instanceof Long) {\n        instant = Instant.ofEpochMilli((Long) tupleValue);\n      } else if (tupleValue instanceof Instant) {\n        instant = (Instant) tupleValue;\n      } else if (tupleValue instanceof Date) {\n        instant = ((Date) tupleValue).toInstant();\n      } else if (tupleValue instanceof TemporalAccessor) {\n        date = ((TemporalAccessor) tupleValue);\n        tupleContext.put(field, date); // Cache the date in the TupleContext\n      }\n    }\n\n    if (instant != null) {\n      if (TemporalEvaluatorEpoch.FUNCTION_NAME.equals(getFunction())) return instant.toEpochMilli();\n      date = LocalDateTime.ofInstant(instant, ZoneOffset.UTC);\n      tupleContext.put(field, date); // Cache the date in the TupleContext\n    }\n\n    if (date != null) {\n      try {\n        return evaluateDate(date);\n      } catch (UnsupportedTemporalTypeException utte) {\n        throw new IOException(String.format(Locale.ROOT, \"It is not possible to call '%s' function on %s\", getFunction(), date.getClass().getName()));\n      }\n    }\n\n    throw new IOException(String.format(Locale.ROOT, \"Invalid parameter %s - The parameter must be a string formatted ISO_INSTANT or of type Long,Instant,Date,LocalDateTime or TemporalAccessor.\", String.valueOf(tupleValue)));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba1e7de64990e3928b90142a52fb92eeff556475","date":1503713257,"type":4,"author":"Dennis Gove","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/TemporalEvaluator#evaluate(Tuple).mjava","sourceNew":null,"sourceOld":"  @Override\n  public Object evaluate(Tuple tuple) throws IOException {\n\n    Instant instant = null;\n    TemporalAccessor date = null;\n\n    //First evaluate the parameter\n    StreamEvaluator streamEvaluator = subEvaluators.get(0);\n    Object tupleValue = streamEvaluator.evaluate(tuple);\n\n    if (tupleValue == null) return null;\n\n    if(field == null) {\n      field = streamEvaluator.toExpression(constructingFactory).toString();\n    }\n\n    Map tupleContext = streamContext.getTupleContext();\n    date = (LocalDateTime)tupleContext.get(field); // Check to see if the date has already been created for this field\n\n    if(date == null) {\n      if (tupleValue instanceof String) {\n        instant = getInstant((String) tupleValue);\n      } else if (tupleValue instanceof Long) {\n        instant = Instant.ofEpochMilli((Long) tupleValue);\n      } else if (tupleValue instanceof Instant) {\n        instant = (Instant) tupleValue;\n      } else if (tupleValue instanceof Date) {\n        instant = ((Date) tupleValue).toInstant();\n      } else if (tupleValue instanceof TemporalAccessor) {\n        date = ((TemporalAccessor) tupleValue);\n        tupleContext.put(field, date); // Cache the date in the TupleContext\n      }\n    }\n\n    if (instant != null) {\n      if (TemporalEvaluatorEpoch.FUNCTION_NAME.equals(getFunction())) return instant.toEpochMilli();\n      date = LocalDateTime.ofInstant(instant, ZoneOffset.UTC);\n      tupleContext.put(field, date); // Cache the date in the TupleContext\n    }\n\n    if (date != null) {\n      try {\n        return evaluateDate(date);\n      } catch (UnsupportedTemporalTypeException utte) {\n        throw new IOException(String.format(Locale.ROOT, \"It is not possible to call '%s' function on %s\", getFunction(), date.getClass().getName()));\n      }\n    }\n\n    throw new IOException(String.format(Locale.ROOT, \"Invalid parameter %s - The parameter must be a string formatted ISO_INSTANT or of type Long,Instant,Date,LocalDateTime or TemporalAccessor.\", String.valueOf(tupleValue)));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"45c28dbb559366e1f4ef8077346552bfb3f7ecf6","date":1503738439,"type":4,"author":"Karl Wright","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/TemporalEvaluator#evaluate(Tuple).mjava","sourceNew":null,"sourceOld":"  @Override\n  public Object evaluate(Tuple tuple) throws IOException {\n\n    Instant instant = null;\n    TemporalAccessor date = null;\n\n    //First evaluate the parameter\n    StreamEvaluator streamEvaluator = subEvaluators.get(0);\n    Object tupleValue = streamEvaluator.evaluate(tuple);\n\n    if (tupleValue == null) return null;\n\n    if(field == null) {\n      field = streamEvaluator.toExpression(constructingFactory).toString();\n    }\n\n    Map tupleContext = streamContext.getTupleContext();\n    date = (LocalDateTime)tupleContext.get(field); // Check to see if the date has already been created for this field\n\n    if(date == null) {\n      if (tupleValue instanceof String) {\n        instant = getInstant((String) tupleValue);\n      } else if (tupleValue instanceof Long) {\n        instant = Instant.ofEpochMilli((Long) tupleValue);\n      } else if (tupleValue instanceof Instant) {\n        instant = (Instant) tupleValue;\n      } else if (tupleValue instanceof Date) {\n        instant = ((Date) tupleValue).toInstant();\n      } else if (tupleValue instanceof TemporalAccessor) {\n        date = ((TemporalAccessor) tupleValue);\n        tupleContext.put(field, date); // Cache the date in the TupleContext\n      }\n    }\n\n    if (instant != null) {\n      if (TemporalEvaluatorEpoch.FUNCTION_NAME.equals(getFunction())) return instant.toEpochMilli();\n      date = LocalDateTime.ofInstant(instant, ZoneOffset.UTC);\n      tupleContext.put(field, date); // Cache the date in the TupleContext\n    }\n\n    if (date != null) {\n      try {\n        return evaluateDate(date);\n      } catch (UnsupportedTemporalTypeException utte) {\n        throw new IOException(String.format(Locale.ROOT, \"It is not possible to call '%s' function on %s\", getFunction(), date.getClass().getName()));\n      }\n    }\n\n    throw new IOException(String.format(Locale.ROOT, \"Invalid parameter %s - The parameter must be a string formatted ISO_INSTANT or of type Long,Instant,Date,LocalDateTime or TemporalAccessor.\", String.valueOf(tupleValue)));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a7809d1d753b67f48b1a706e17034bf8b624ea3","date":1504366927,"type":4,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/TemporalEvaluator#evaluate(Tuple).mjava","sourceNew":null,"sourceOld":"  @Override\n  public Object evaluate(Tuple tuple) throws IOException {\n\n    Instant instant = null;\n    TemporalAccessor date = null;\n\n    //First evaluate the parameter\n    StreamEvaluator streamEvaluator = subEvaluators.get(0);\n    Object tupleValue = streamEvaluator.evaluate(tuple);\n\n    if (tupleValue == null) return null;\n\n    if(field == null) {\n      field = streamEvaluator.toExpression(constructingFactory).toString();\n    }\n\n    Map tupleContext = streamContext.getTupleContext();\n    date = (LocalDateTime)tupleContext.get(field); // Check to see if the date has already been created for this field\n\n    if(date == null) {\n      if (tupleValue instanceof String) {\n        instant = getInstant((String) tupleValue);\n      } else if (tupleValue instanceof Long) {\n        instant = Instant.ofEpochMilli((Long) tupleValue);\n      } else if (tupleValue instanceof Instant) {\n        instant = (Instant) tupleValue;\n      } else if (tupleValue instanceof Date) {\n        instant = ((Date) tupleValue).toInstant();\n      } else if (tupleValue instanceof TemporalAccessor) {\n        date = ((TemporalAccessor) tupleValue);\n        tupleContext.put(field, date); // Cache the date in the TupleContext\n      }\n    }\n\n    if (instant != null) {\n      if (TemporalEvaluatorEpoch.FUNCTION_NAME.equals(getFunction())) return instant.toEpochMilli();\n      date = LocalDateTime.ofInstant(instant, ZoneOffset.UTC);\n      tupleContext.put(field, date); // Cache the date in the TupleContext\n    }\n\n    if (date != null) {\n      try {\n        return evaluateDate(date);\n      } catch (UnsupportedTemporalTypeException utte) {\n        throw new IOException(String.format(Locale.ROOT, \"It is not possible to call '%s' function on %s\", getFunction(), date.getClass().getName()));\n      }\n    }\n\n    throw new IOException(String.format(Locale.ROOT, \"Invalid parameter %s - The parameter must be a string formatted ISO_INSTANT or of type Long,Instant,Date,LocalDateTime or TemporalAccessor.\", String.valueOf(tupleValue)));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"56ebde9c21d35a39c07989c178372e901ad377da":["e4177dd81a9f4ea02615ad384a4c17f13edf868b"],"64ff6b743fd4051da7ebb3d397d1ef80833a741a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","45c28dbb559366e1f4ef8077346552bfb3f7ecf6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e4177dd81a9f4ea02615ad384a4c17f13edf868b":["64ff6b743fd4051da7ebb3d397d1ef80833a741a"],"45c28dbb559366e1f4ef8077346552bfb3f7ecf6":["56ebde9c21d35a39c07989c178372e901ad377da","ba1e7de64990e3928b90142a52fb92eeff556475"],"ba1e7de64990e3928b90142a52fb92eeff556475":["56ebde9c21d35a39c07989c178372e901ad377da"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["45c28dbb559366e1f4ef8077346552bfb3f7ecf6"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["3a7809d1d753b67f48b1a706e17034bf8b624ea3"],"56ebde9c21d35a39c07989c178372e901ad377da":["45c28dbb559366e1f4ef8077346552bfb3f7ecf6","ba1e7de64990e3928b90142a52fb92eeff556475"],"64ff6b743fd4051da7ebb3d397d1ef80833a741a":["e4177dd81a9f4ea02615ad384a4c17f13edf868b"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","64ff6b743fd4051da7ebb3d397d1ef80833a741a"],"e4177dd81a9f4ea02615ad384a4c17f13edf868b":["56ebde9c21d35a39c07989c178372e901ad377da"],"45c28dbb559366e1f4ef8077346552bfb3f7ecf6":["3a7809d1d753b67f48b1a706e17034bf8b624ea3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ba1e7de64990e3928b90142a52fb92eeff556475":["45c28dbb559366e1f4ef8077346552bfb3f7ecf6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3a7809d1d753b67f48b1a706e17034bf8b624ea3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}