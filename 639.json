{"path":"src/java/org/apache/lucene/index/IndexWriter#sync(boolean,long).mjava","commits":[{"id":"e82780afe6097066eb5befb86e9432f077667e3d","date":1202756169,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#sync(boolean,long).mjava","pathOld":"/dev/null","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos, minus flushes, and ask the Directory to\n   *  sync each file, if it wasn't already.  If that\n   *  succeeds, then we write a new segments_N file & sync\n   *  that. */\n  private void sync(boolean includeFlushes, long sizeInBytes) throws IOException {\n\n    message(\"start sync() includeFlushes=\" + includeFlushes);\n\n    if (!includeFlushes)\n      syncPause(sizeInBytes);\n\n    // First, we clone & incref the segmentInfos we intend\n    // to sync, then, without locking, we sync() each file\n    // referenced by toSync, in the background.  Multiple\n    // threads can be doing this at once, if say a large\n    // merge and a small merge finish at the same time:\n\n    SegmentInfos toSync = null;\n    final int mySyncCount;\n    synchronized(this) {\n\n      if (!commitPending) {\n        message(\"  skip sync(): no commit pending\");\n        return;\n      }\n\n      // Create the segmentInfos we want to sync, by copying\n      // the current one and possibly removing flushed\n      // segments:\n      toSync = (SegmentInfos) segmentInfos.clone();\n      final int numSegmentsToSync = toSync.size();\n\n      boolean newCommitPending = false;\n\n      if (!includeFlushes) {\n        // Do not sync flushes:\n        assert lastMergeInfo != null;\n        assert toSync.contains(lastMergeInfo);\n        int downTo = numSegmentsToSync-1;\n        while(!toSync.info(downTo).equals(lastMergeInfo)) {\n          message(\"  skip segment \" + toSync.info(downTo).name);\n          toSync.remove(downTo);\n          downTo--;\n          newCommitPending = true;\n        }\n\n      } else if (numSegmentsToSync > 0)\n        // Force all subsequent syncs to include up through\n        // the final info in the current segments.  This\n        // ensure that a call to commit() will force another\n        // sync (due to merge finishing) to sync all flushed\n        // segments as well:\n        lastMergeInfo = toSync.info(numSegmentsToSync-1);\n\n      mySyncCount = syncCount++;\n      deleter.incRef(toSync, false);\n\n      commitPending = newCommitPending;\n    }\n\n    boolean success0 = false;\n\n    try {\n\n      // Loop until all files toSync references are sync'd:\n      while(true) {\n\n        final Collection pending = new ArrayList();\n\n        for(int i=0;i<toSync.size();i++) {\n          final SegmentInfo info = toSync.info(i);\n          final List files = info.files();\n          for(int j=0;j<files.size();j++) {\n            final String fileName = (String) files.get(j);\n            if (startSync(fileName, pending)) {\n              boolean success = false;\n              try {\n                // Because we incRef'd this commit point, above,\n                // the file had better exist:\n                assert directory.fileExists(fileName);\n                message(\"now sync \" + fileName);\n                directory.sync(fileName);\n                success = true;\n              } finally {\n                finishSync(fileName, success);\n              }\n            }\n          }\n        }\n\n        // All files that I require are either synced or being\n        // synced by other threads.  If they are being synced,\n        // we must at this point block until they are done.\n        // If this returns false, that means an error in\n        // another thread resulted in failing to actually\n        // sync one of our files, so we repeat:\n        if (waitForAllSynced(pending))\n          break;\n      }\n\n      synchronized(this) {\n        // If someone saved a newer version of segments file\n        // since I first started syncing my version, I can\n        // safely skip saving myself since I've been\n        // superseded:\n        if (mySyncCount > syncCountSaved) {\n          \n          if (segmentInfos.getGeneration() > toSync.getGeneration())\n            toSync.updateGeneration(segmentInfos);\n\n          boolean success = false;\n          try {\n            toSync.commit(directory);\n            success = true;\n          } finally {\n            // Have our master segmentInfos record the\n            // generations we just sync'd\n            segmentInfos.updateGeneration(toSync);\n            if (!success) {\n              commitPending = true;\n              message(\"hit exception committing segments file\");\n            }\n          }\n          message(\"commit complete\");\n\n          syncCountSaved = mySyncCount;\n\n          deleter.checkpoint(toSync, true);\n          setRollbackSegmentInfos();\n        } else\n          message(\"sync superseded by newer infos\");\n      }\n\n      message(\"done all syncs\");\n\n      success0 = true;\n\n    } finally {\n      synchronized(this) {\n        deleter.decRef(toSync);\n        if (!success0)\n          commitPending = true;\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["df2e19759ba573689671d3ed4451ede4d92e479a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"01deb9e9fb9dbd5fddce32a5fcd952bbb611fe63","date":1204234542,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#sync(boolean,long).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#sync(boolean,long).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos, minus flushes, and ask the Directory to\n   *  sync each file, if it wasn't already.  If that\n   *  succeeds, then we write a new segments_N file & sync\n   *  that. */\n  private void sync(boolean includeFlushes, long sizeInBytes) throws IOException {\n\n    if (hitOOM)\n      return;\n\n    try {\n\n      message(\"start sync() includeFlushes=\" + includeFlushes);\n\n      if (!includeFlushes)\n        syncPause(sizeInBytes);\n\n      // First, we clone & incref the segmentInfos we intend\n      // to sync, then, without locking, we sync() each file\n      // referenced by toSync, in the background.  Multiple\n      // threads can be doing this at once, if say a large\n      // merge and a small merge finish at the same time:\n\n      SegmentInfos toSync = null;\n      final int mySyncCount;\n      synchronized(this) {\n\n        if (!commitPending) {\n          message(\"  skip sync(): no commit pending\");\n          return;\n        }\n\n        // Create the segmentInfos we want to sync, by copying\n        // the current one and possibly removing flushed\n        // segments:\n        toSync = (SegmentInfos) segmentInfos.clone();\n        final int numSegmentsToSync = toSync.size();\n\n        boolean newCommitPending = false;\n\n        if (!includeFlushes) {\n          // Do not sync flushes:\n          assert lastMergeInfo != null;\n          assert toSync.contains(lastMergeInfo);\n          int downTo = numSegmentsToSync-1;\n          while(!toSync.info(downTo).equals(lastMergeInfo)) {\n            message(\"  skip segment \" + toSync.info(downTo).name);\n            toSync.remove(downTo);\n            downTo--;\n            newCommitPending = true;\n          }\n\n        } else if (numSegmentsToSync > 0)\n          // Force all subsequent syncs to include up through\n          // the final info in the current segments.  This\n          // ensure that a call to commit() will force another\n          // sync (due to merge finishing) to sync all flushed\n          // segments as well:\n          lastMergeInfo = toSync.info(numSegmentsToSync-1);\n\n        mySyncCount = syncCount++;\n        deleter.incRef(toSync, false);\n\n        commitPending = newCommitPending;\n      }\n\n      boolean success0 = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection pending = new ArrayList();\n\n          for(int i=0;i<toSync.size();i++) {\n            final SegmentInfo info = toSync.info(i);\n            final List files = info.files();\n            for(int j=0;j<files.size();j++) {\n              final String fileName = (String) files.get(j);\n              if (startSync(fileName, pending)) {\n                boolean success = false;\n                try {\n                  // Because we incRef'd this commit point, above,\n                  // the file had better exist:\n                  assert directory.fileExists(fileName);\n                  message(\"now sync \" + fileName);\n                  directory.sync(fileName);\n                  success = true;\n                } finally {\n                  finishSync(fileName, success);\n                }\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n          if (mySyncCount > syncCountSaved) {\n          \n            if (segmentInfos.getGeneration() > toSync.getGeneration())\n              toSync.updateGeneration(segmentInfos);\n\n            boolean success = false;\n            try {\n              toSync.commit(directory);\n              success = true;\n            } finally {\n              // Have our master segmentInfos record the\n              // generations we just sync'd\n              segmentInfos.updateGeneration(toSync);\n              if (!success) {\n                commitPending = true;\n                message(\"hit exception committing segments file\");\n              }\n            }\n            message(\"commit complete\");\n\n            syncCountSaved = mySyncCount;\n\n            deleter.checkpoint(toSync, true);\n            setRollbackSegmentInfos();\n          } else\n            message(\"sync superseded by newer infos\");\n        }\n\n        message(\"done all syncs\");\n\n        success0 = true;\n\n      } finally {\n        synchronized(this) {\n          deleter.decRef(toSync);\n          if (!success0)\n            commitPending = true;\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      hitOOM = true;\n      throw oom;\n    }\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos, minus flushes, and ask the Directory to\n   *  sync each file, if it wasn't already.  If that\n   *  succeeds, then we write a new segments_N file & sync\n   *  that. */\n  private void sync(boolean includeFlushes, long sizeInBytes) throws IOException {\n\n    message(\"start sync() includeFlushes=\" + includeFlushes);\n\n    if (!includeFlushes)\n      syncPause(sizeInBytes);\n\n    // First, we clone & incref the segmentInfos we intend\n    // to sync, then, without locking, we sync() each file\n    // referenced by toSync, in the background.  Multiple\n    // threads can be doing this at once, if say a large\n    // merge and a small merge finish at the same time:\n\n    SegmentInfos toSync = null;\n    final int mySyncCount;\n    synchronized(this) {\n\n      if (!commitPending) {\n        message(\"  skip sync(): no commit pending\");\n        return;\n      }\n\n      // Create the segmentInfos we want to sync, by copying\n      // the current one and possibly removing flushed\n      // segments:\n      toSync = (SegmentInfos) segmentInfos.clone();\n      final int numSegmentsToSync = toSync.size();\n\n      boolean newCommitPending = false;\n\n      if (!includeFlushes) {\n        // Do not sync flushes:\n        assert lastMergeInfo != null;\n        assert toSync.contains(lastMergeInfo);\n        int downTo = numSegmentsToSync-1;\n        while(!toSync.info(downTo).equals(lastMergeInfo)) {\n          message(\"  skip segment \" + toSync.info(downTo).name);\n          toSync.remove(downTo);\n          downTo--;\n          newCommitPending = true;\n        }\n\n      } else if (numSegmentsToSync > 0)\n        // Force all subsequent syncs to include up through\n        // the final info in the current segments.  This\n        // ensure that a call to commit() will force another\n        // sync (due to merge finishing) to sync all flushed\n        // segments as well:\n        lastMergeInfo = toSync.info(numSegmentsToSync-1);\n\n      mySyncCount = syncCount++;\n      deleter.incRef(toSync, false);\n\n      commitPending = newCommitPending;\n    }\n\n    boolean success0 = false;\n\n    try {\n\n      // Loop until all files toSync references are sync'd:\n      while(true) {\n\n        final Collection pending = new ArrayList();\n\n        for(int i=0;i<toSync.size();i++) {\n          final SegmentInfo info = toSync.info(i);\n          final List files = info.files();\n          for(int j=0;j<files.size();j++) {\n            final String fileName = (String) files.get(j);\n            if (startSync(fileName, pending)) {\n              boolean success = false;\n              try {\n                // Because we incRef'd this commit point, above,\n                // the file had better exist:\n                assert directory.fileExists(fileName);\n                message(\"now sync \" + fileName);\n                directory.sync(fileName);\n                success = true;\n              } finally {\n                finishSync(fileName, success);\n              }\n            }\n          }\n        }\n\n        // All files that I require are either synced or being\n        // synced by other threads.  If they are being synced,\n        // we must at this point block until they are done.\n        // If this returns false, that means an error in\n        // another thread resulted in failing to actually\n        // sync one of our files, so we repeat:\n        if (waitForAllSynced(pending))\n          break;\n      }\n\n      synchronized(this) {\n        // If someone saved a newer version of segments file\n        // since I first started syncing my version, I can\n        // safely skip saving myself since I've been\n        // superseded:\n        if (mySyncCount > syncCountSaved) {\n          \n          if (segmentInfos.getGeneration() > toSync.getGeneration())\n            toSync.updateGeneration(segmentInfos);\n\n          boolean success = false;\n          try {\n            toSync.commit(directory);\n            success = true;\n          } finally {\n            // Have our master segmentInfos record the\n            // generations we just sync'd\n            segmentInfos.updateGeneration(toSync);\n            if (!success) {\n              commitPending = true;\n              message(\"hit exception committing segments file\");\n            }\n          }\n          message(\"commit complete\");\n\n          syncCountSaved = mySyncCount;\n\n          deleter.checkpoint(toSync, true);\n          setRollbackSegmentInfos();\n        } else\n          message(\"sync superseded by newer infos\");\n      }\n\n      message(\"done all syncs\");\n\n      success0 = true;\n\n    } finally {\n      synchronized(this) {\n        deleter.decRef(toSync);\n        if (!success0)\n          commitPending = true;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["cd488f50316362b01a7f67b11a96796b9652e3e5","0f44610301174bfb430443d89a88dc1c502feea1","df2e19759ba573689671d3ed4451ede4d92e479a","c48871ed951104729f5e17a8ee1091b43fa18980"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be","date":1204801324,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#commit(boolean,long).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#sync(boolean,long).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos, minus flushes, and ask the Directory to\n   *  sync each file, if it wasn't already.  If that\n   *  succeeds, then we write a new segments_N file & sync\n   *  that. */\n  private void commit(boolean skipWait, long sizeInBytes) throws IOException {\n\n    assert testPoint(\"startCommit\");\n\n    if (hitOOM)\n      return;\n\n    try {\n\n      if (infoStream != null)\n        message(\"start commit() skipWait=\" + skipWait + \" sizeInBytes=\" + sizeInBytes);\n\n      if (!skipWait)\n        syncPause(sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        assert lastCommitChangeCount <= changeCount;\n\n        if (changeCount == lastCommitChangeCount) {\n          if (infoStream != null)\n            message(\"  skip commit(): no changes pending\");\n          return;\n        }\n\n        // First, we clone & incref the segmentInfos we intend\n        // to sync, then, without locking, we sync() each file\n        // referenced by toSync, in the background.  Multiple\n        // threads can be doing this at once, if say a large\n        // merge and a small merge finish at the same time:\n\n        toSync = (SegmentInfos) segmentInfos.clone();\n        deleter.incRef(toSync, false);\n        myChangeCount = changeCount;\n      }\n\n      if (infoStream != null)\n        message(\"commit index=\" + segString(toSync));\n\n      assert testPoint(\"midCommit\");\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection pending = new ArrayList();\n\n          for(int i=0;i<toSync.size();i++) {\n            final SegmentInfo info = toSync.info(i);\n            final List files = info.files();\n            for(int j=0;j<files.size();j++) {\n              final String fileName = (String) files.get(j);\n              if (startSync(fileName, pending)) {\n                boolean success = false;\n                try {\n                  // Because we incRef'd this commit point, above,\n                  // the file had better exist:\n                  assert directory.fileExists(fileName);\n                  message(\"now sync \" + fileName);\n                  directory.sync(fileName);\n                  success = true;\n                } finally {\n                  finishSync(fileName, success);\n                }\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midCommit2\");\n      \n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n          if (myChangeCount > lastCommitChangeCount) {\n          \n            if (segmentInfos.getGeneration() > toSync.getGeneration())\n              toSync.updateGeneration(segmentInfos);\n\n            boolean success = false;\n            try {\n              toSync.commit(directory);\n              success = true;\n            } finally {\n              // Have our master segmentInfos record the\n              // generations we just sync'd\n              segmentInfos.updateGeneration(toSync);\n              if (!success)\n                message(\"hit exception committing segments file\");\n            }\n\n            message(\"commit complete\");\n\n            lastCommitChangeCount = myChangeCount;\n\n            deleter.checkpoint(toSync, true);\n            setRollbackSegmentInfos();\n          } else\n            message(\"sync superseded by newer infos\");\n        }\n\n        message(\"done all syncs\");\n\n        assert testPoint(\"midCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      hitOOM = true;\n      throw oom;\n    }\n    assert testPoint(\"finishCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos, minus flushes, and ask the Directory to\n   *  sync each file, if it wasn't already.  If that\n   *  succeeds, then we write a new segments_N file & sync\n   *  that. */\n  private void sync(boolean includeFlushes, long sizeInBytes) throws IOException {\n\n    if (hitOOM)\n      return;\n\n    try {\n\n      message(\"start sync() includeFlushes=\" + includeFlushes);\n\n      if (!includeFlushes)\n        syncPause(sizeInBytes);\n\n      // First, we clone & incref the segmentInfos we intend\n      // to sync, then, without locking, we sync() each file\n      // referenced by toSync, in the background.  Multiple\n      // threads can be doing this at once, if say a large\n      // merge and a small merge finish at the same time:\n\n      SegmentInfos toSync = null;\n      final int mySyncCount;\n      synchronized(this) {\n\n        if (!commitPending) {\n          message(\"  skip sync(): no commit pending\");\n          return;\n        }\n\n        // Create the segmentInfos we want to sync, by copying\n        // the current one and possibly removing flushed\n        // segments:\n        toSync = (SegmentInfos) segmentInfos.clone();\n        final int numSegmentsToSync = toSync.size();\n\n        boolean newCommitPending = false;\n\n        if (!includeFlushes) {\n          // Do not sync flushes:\n          assert lastMergeInfo != null;\n          assert toSync.contains(lastMergeInfo);\n          int downTo = numSegmentsToSync-1;\n          while(!toSync.info(downTo).equals(lastMergeInfo)) {\n            message(\"  skip segment \" + toSync.info(downTo).name);\n            toSync.remove(downTo);\n            downTo--;\n            newCommitPending = true;\n          }\n\n        } else if (numSegmentsToSync > 0)\n          // Force all subsequent syncs to include up through\n          // the final info in the current segments.  This\n          // ensure that a call to commit() will force another\n          // sync (due to merge finishing) to sync all flushed\n          // segments as well:\n          lastMergeInfo = toSync.info(numSegmentsToSync-1);\n\n        mySyncCount = syncCount++;\n        deleter.incRef(toSync, false);\n\n        commitPending = newCommitPending;\n      }\n\n      boolean success0 = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection pending = new ArrayList();\n\n          for(int i=0;i<toSync.size();i++) {\n            final SegmentInfo info = toSync.info(i);\n            final List files = info.files();\n            for(int j=0;j<files.size();j++) {\n              final String fileName = (String) files.get(j);\n              if (startSync(fileName, pending)) {\n                boolean success = false;\n                try {\n                  // Because we incRef'd this commit point, above,\n                  // the file had better exist:\n                  assert directory.fileExists(fileName);\n                  message(\"now sync \" + fileName);\n                  directory.sync(fileName);\n                  success = true;\n                } finally {\n                  finishSync(fileName, success);\n                }\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n          if (mySyncCount > syncCountSaved) {\n          \n            if (segmentInfos.getGeneration() > toSync.getGeneration())\n              toSync.updateGeneration(segmentInfos);\n\n            boolean success = false;\n            try {\n              toSync.commit(directory);\n              success = true;\n            } finally {\n              // Have our master segmentInfos record the\n              // generations we just sync'd\n              segmentInfos.updateGeneration(toSync);\n              if (!success) {\n                commitPending = true;\n                message(\"hit exception committing segments file\");\n              }\n            }\n            message(\"commit complete\");\n\n            syncCountSaved = mySyncCount;\n\n            deleter.checkpoint(toSync, true);\n            setRollbackSegmentInfos();\n          } else\n            message(\"sync superseded by newer infos\");\n        }\n\n        message(\"done all syncs\");\n\n        success0 = true;\n\n      } finally {\n        synchronized(this) {\n          deleter.decRef(toSync);\n          if (!success0)\n            commitPending = true;\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      hitOOM = true;\n      throw oom;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"01deb9e9fb9dbd5fddce32a5fcd952bbb611fe63":["e82780afe6097066eb5befb86e9432f077667e3d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be":["01deb9e9fb9dbd5fddce32a5fcd952bbb611fe63"],"e82780afe6097066eb5befb86e9432f077667e3d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be"]},"commit2Childs":{"01deb9e9fb9dbd5fddce32a5fcd952bbb611fe63":["a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e82780afe6097066eb5befb86e9432f077667e3d"],"e82780afe6097066eb5befb86e9432f077667e3d":["01deb9e9fb9dbd5fddce32a5fcd952bbb611fe63"],"a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}