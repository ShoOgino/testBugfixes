{"path":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","commits":[{"id":"fa64435b5902ce266c23755a4a00691a3285dab8","date":1347243290,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","pathOld":"/dev/null","sourceNew":"  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<String,Object>(props));\n    this.name = name;\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, replicas);\n\n    String rangeStr = (String)propMap.get(RANGE);\n    HashPartitioner.Range tmpRange = null;\n    if (rangeStr != null) {\n      HashPartitioner hp = new HashPartitioner();\n      tmpRange = hp.fromString(rangeStr);\n    }\n\n    range = tmpRange;\n    // replicationFactor = null;  // future\n    leader = findLeader();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e7d59baa18f0aed2bb5f93a76ffce5343aee13d","date":1347918051,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","sourceNew":"  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<String,Object>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    HashPartitioner.Range tmpRange = null;\n    if (rangeObj instanceof HashPartitioner.Range) {\n      tmpRange = (HashPartitioner.Range)rangeObj;\n    } else if (rangeObj != null) {\n      HashPartitioner hp = new HashPartitioner();\n      tmpRange = hp.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    leader = findLeader();\n  }\n\n","sourceOld":"  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<String,Object>(props));\n    this.name = name;\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, replicas);\n\n    String rangeStr = (String)propMap.get(RANGE);\n    HashPartitioner.Range tmpRange = null;\n    if (rangeStr != null) {\n      HashPartitioner hp = new HashPartitioner();\n      tmpRange = hp.fromString(rangeStr);\n    }\n\n    range = tmpRange;\n    // replicationFactor = null;  // future\n    leader = findLeader();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5280dd0bd8aa6103cae92307392505c83841c9d5","date":1348001289,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","sourceNew":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<String,Object>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    HashPartitioner.Range tmpRange = null;\n    if (rangeObj instanceof HashPartitioner.Range) {\n      tmpRange = (HashPartitioner.Range)rangeObj;\n    } else if (rangeObj != null) {\n      HashPartitioner hp = new HashPartitioner();\n      tmpRange = hp.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    leader = findLeader();\n  }\n\n","sourceOld":"  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<String,Object>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    HashPartitioner.Range tmpRange = null;\n    if (rangeObj instanceof HashPartitioner.Range) {\n      tmpRange = (HashPartitioner.Range)rangeObj;\n    } else if (rangeObj != null) {\n      HashPartitioner hp = new HashPartitioner();\n      tmpRange = hp.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    leader = findLeader();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5a558d54519c651068ddb202f03befefb1514a7","date":1354382006,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","sourceNew":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<String,Object>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      DocRouter hp = new DocRouter();\n      tmpRange = hp.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    leader = findLeader();\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<String,Object>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    HashPartitioner.Range tmpRange = null;\n    if (rangeObj instanceof HashPartitioner.Range) {\n      tmpRange = (HashPartitioner.Range)rangeObj;\n    } else if (rangeObj != null) {\n      HashPartitioner hp = new HashPartitioner();\n      tmpRange = hp.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    leader = findLeader();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89f828d954597b98a28942874636f35c719b8a5d","date":1354471211,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","sourceNew":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<String,Object>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      // Doesn't support custom implementations of Range, but currently not needed.\n      tmpRange = DocRouter.DEFAULT.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    /** debugging.  this isn't an error condition for custom sharding.\n    if (range == null) {\n      System.out.println(\"###### NO RANGE for \" + name + \" props=\" + props);\n    }\n    **/\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    leader = findLeader();\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<String,Object>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      DocRouter hp = new DocRouter();\n      tmpRange = hp.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    leader = findLeader();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","sourceNew":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<String,Object>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      // Doesn't support custom implementations of Range, but currently not needed.\n      tmpRange = DocRouter.DEFAULT.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    /** debugging.  this isn't an error condition for custom sharding.\n    if (range == null) {\n      System.out.println(\"###### NO RANGE for \" + name + \" props=\" + props);\n    }\n    **/\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    leader = findLeader();\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<String,Object>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    HashPartitioner.Range tmpRange = null;\n    if (rangeObj instanceof HashPartitioner.Range) {\n      tmpRange = (HashPartitioner.Range)rangeObj;\n    } else if (rangeObj != null) {\n      HashPartitioner hp = new HashPartitioner();\n      tmpRange = hp.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    leader = findLeader();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"630b72110afca0a13a755e07ef8a4d764afb52aa","date":1361202100,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","sourceNew":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<String,Object>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    if (propMap.containsKey(STATE))\n      state = (String) propMap.get(STATE);\n    else {\n      state = ACTIVE;                         //Default to ACTIVE\n      propMap.put(STATE, this.state);\n    }\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      // Doesn't support custom implementations of Range, but currently not needed.\n      tmpRange = DocRouter.DEFAULT.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    /** debugging.  this isn't an error condition for custom sharding.\n    if (range == null) {\n      System.out.println(\"###### NO RANGE for \" + name + \" props=\" + props);\n    }\n    **/\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    leader = findLeader();\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<String,Object>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      // Doesn't support custom implementations of Range, but currently not needed.\n      tmpRange = DocRouter.DEFAULT.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    /** debugging.  this isn't an error condition for custom sharding.\n    if (range == null) {\n      System.out.println(\"###### NO RANGE for \" + name + \" props=\" + props);\n    }\n    **/\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    leader = findLeader();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0beaed456aa3358e5e4a99ea2aea994ef6c81de3","date":1365434191,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","sourceNew":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<String,Object>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    if (propMap.containsKey(STATE) && propMap.get(STATE) != null)\n      this.state = (String) propMap.get(STATE);\n    else {\n      this.state = ACTIVE;                         //Default to ACTIVE\n      propMap.put(STATE, this.state);\n    }\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      // Doesn't support custom implementations of Range, but currently not needed.\n      tmpRange = DocRouter.DEFAULT.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    /** debugging.  this isn't an error condition for custom sharding.\n    if (range == null) {\n      System.out.println(\"###### NO RANGE for \" + name + \" props=\" + props);\n    }\n    **/\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    leader = findLeader();\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<String,Object>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    if (propMap.containsKey(STATE))\n      state = (String) propMap.get(STATE);\n    else {\n      state = ACTIVE;                         //Default to ACTIVE\n      propMap.put(STATE, this.state);\n    }\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      // Doesn't support custom implementations of Range, but currently not needed.\n      tmpRange = DocRouter.DEFAULT.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    /** debugging.  this isn't an error condition for custom sharding.\n    if (range == null) {\n      System.out.println(\"###### NO RANGE for \" + name + \" props=\" + props);\n    }\n    **/\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    leader = findLeader();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bc841231667f1f315bae6799c068f9aad6543967","date":1381415189,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","sourceNew":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<String,Object>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    if (propMap.containsKey(STATE) && propMap.get(STATE) != null)\n      this.state = (String) propMap.get(STATE);\n    else {\n      this.state = ACTIVE;                         //Default to ACTIVE\n      propMap.put(STATE, this.state);\n    }\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      // Doesn't support custom implementations of Range, but currently not needed.\n      tmpRange = DocRouter.DEFAULT.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    /** debugging.  this isn't an error condition for custom sharding.\n    if (range == null) {\n      System.out.println(\"###### NO RANGE for \" + name + \" props=\" + props);\n    }\n    **/\n\n    if (propMap.containsKey(PARENT) && propMap.get(PARENT) != null)\n      this.parent = (String) propMap.get(PARENT);\n    else\n      this.parent = null;\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    leader = findLeader();\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<String,Object>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    if (propMap.containsKey(STATE) && propMap.get(STATE) != null)\n      this.state = (String) propMap.get(STATE);\n    else {\n      this.state = ACTIVE;                         //Default to ACTIVE\n      propMap.put(STATE, this.state);\n    }\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      // Doesn't support custom implementations of Range, but currently not needed.\n      tmpRange = DocRouter.DEFAULT.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    /** debugging.  this isn't an error condition for custom sharding.\n    if (range == null) {\n      System.out.println(\"###### NO RANGE for \" + name + \" props=\" + props);\n    }\n    **/\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    leader = findLeader();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"da888af1ab894358122a22229051215f58cf4d54","date":1384408702,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","sourceNew":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<String,Object>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    if (propMap.containsKey(STATE) && propMap.get(STATE) != null)\n      this.state = (String) propMap.get(STATE);\n    else {\n      this.state = ACTIVE;                         //Default to ACTIVE\n      propMap.put(STATE, this.state);\n    }\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      // Doesn't support custom implementations of Range, but currently not needed.\n      tmpRange = DocRouter.DEFAULT.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    /** debugging.  this isn't an error condition for custom sharding.\n    if (range == null) {\n      System.out.println(\"###### NO RANGE for \" + name + \" props=\" + props);\n    }\n    **/\n\n    if (propMap.containsKey(PARENT) && propMap.get(PARENT) != null)\n      this.parent = (String) propMap.get(PARENT);\n    else\n      this.parent = null;\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    Map<String, Object> rules = (Map<String, Object>) propMap.get(\"routingRules\");\n    if (rules != null) {\n      this.routingRules = new HashMap<String, RoutingRule>();\n      for (Map.Entry<String, Object> entry : rules.entrySet()) {\n        Object o = entry.getValue();\n        if (o instanceof Map) {\n          Map map = (Map) o;\n          RoutingRule rule = new RoutingRule(entry.getKey(), map);\n          routingRules.put(entry.getKey(), rule);\n        } else {\n          routingRules.put(entry.getKey(), (RoutingRule) o);\n        }\n      }\n    } else {\n      this.routingRules = null;\n    }\n\n    leader = findLeader();\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<String,Object>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    if (propMap.containsKey(STATE) && propMap.get(STATE) != null)\n      this.state = (String) propMap.get(STATE);\n    else {\n      this.state = ACTIVE;                         //Default to ACTIVE\n      propMap.put(STATE, this.state);\n    }\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      // Doesn't support custom implementations of Range, but currently not needed.\n      tmpRange = DocRouter.DEFAULT.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    /** debugging.  this isn't an error condition for custom sharding.\n    if (range == null) {\n      System.out.println(\"###### NO RANGE for \" + name + \" props=\" + props);\n    }\n    **/\n\n    if (propMap.containsKey(PARENT) && propMap.get(PARENT) != null)\n      this.parent = (String) propMap.get(PARENT);\n    else\n      this.parent = null;\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    leader = findLeader();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","sourceNew":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    if (propMap.containsKey(STATE) && propMap.get(STATE) != null)\n      this.state = (String) propMap.get(STATE);\n    else {\n      this.state = ACTIVE;                         //Default to ACTIVE\n      propMap.put(STATE, this.state);\n    }\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      // Doesn't support custom implementations of Range, but currently not needed.\n      tmpRange = DocRouter.DEFAULT.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    /** debugging.  this isn't an error condition for custom sharding.\n    if (range == null) {\n      System.out.println(\"###### NO RANGE for \" + name + \" props=\" + props);\n    }\n    **/\n\n    if (propMap.containsKey(PARENT) && propMap.get(PARENT) != null)\n      this.parent = (String) propMap.get(PARENT);\n    else\n      this.parent = null;\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    Map<String, Object> rules = (Map<String, Object>) propMap.get(\"routingRules\");\n    if (rules != null) {\n      this.routingRules = new HashMap<>();\n      for (Map.Entry<String, Object> entry : rules.entrySet()) {\n        Object o = entry.getValue();\n        if (o instanceof Map) {\n          Map map = (Map) o;\n          RoutingRule rule = new RoutingRule(entry.getKey(), map);\n          routingRules.put(entry.getKey(), rule);\n        } else {\n          routingRules.put(entry.getKey(), (RoutingRule) o);\n        }\n      }\n    } else {\n      this.routingRules = null;\n    }\n\n    leader = findLeader();\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<String,Object>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    if (propMap.containsKey(STATE) && propMap.get(STATE) != null)\n      this.state = (String) propMap.get(STATE);\n    else {\n      this.state = ACTIVE;                         //Default to ACTIVE\n      propMap.put(STATE, this.state);\n    }\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      // Doesn't support custom implementations of Range, but currently not needed.\n      tmpRange = DocRouter.DEFAULT.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    /** debugging.  this isn't an error condition for custom sharding.\n    if (range == null) {\n      System.out.println(\"###### NO RANGE for \" + name + \" props=\" + props);\n    }\n    **/\n\n    if (propMap.containsKey(PARENT) && propMap.get(PARENT) != null)\n      this.parent = (String) propMap.get(PARENT);\n    else\n      this.parent = null;\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    Map<String, Object> rules = (Map<String, Object>) propMap.get(\"routingRules\");\n    if (rules != null) {\n      this.routingRules = new HashMap<String, RoutingRule>();\n      for (Map.Entry<String, Object> entry : rules.entrySet()) {\n        Object o = entry.getValue();\n        if (o instanceof Map) {\n          Map map = (Map) o;\n          RoutingRule rule = new RoutingRule(entry.getKey(), map);\n          routingRules.put(entry.getKey(), rule);\n        } else {\n          routingRules.put(entry.getKey(), (RoutingRule) o);\n        }\n      }\n    } else {\n      this.routingRules = null;\n    }\n\n    leader = findLeader();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296","date":1427866967,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","sourceNew":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    if (propMap.get(ZkStateReader.STATE_PROP) != null) {\n      this.state = State.getState((String) propMap.get(ZkStateReader.STATE_PROP));\n    } else {\n      this.state = State.ACTIVE;                         //Default to ACTIVE\n      propMap.put(ZkStateReader.STATE_PROP, state.toString());\n    }\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      // Doesn't support custom implementations of Range, but currently not needed.\n      tmpRange = DocRouter.DEFAULT.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    /** debugging.  this isn't an error condition for custom sharding.\n    if (range == null) {\n      System.out.println(\"###### NO RANGE for \" + name + \" props=\" + props);\n    }\n    **/\n\n    if (propMap.containsKey(PARENT) && propMap.get(PARENT) != null)\n      this.parent = (String) propMap.get(PARENT);\n    else\n      this.parent = null;\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    Map<String, Object> rules = (Map<String, Object>) propMap.get(\"routingRules\");\n    if (rules != null) {\n      this.routingRules = new HashMap<>();\n      for (Map.Entry<String, Object> entry : rules.entrySet()) {\n        Object o = entry.getValue();\n        if (o instanceof Map) {\n          Map map = (Map) o;\n          RoutingRule rule = new RoutingRule(entry.getKey(), map);\n          routingRules.put(entry.getKey(), rule);\n        } else {\n          routingRules.put(entry.getKey(), (RoutingRule) o);\n        }\n      }\n    } else {\n      this.routingRules = null;\n    }\n\n    leader = findLeader();\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    if (propMap.containsKey(STATE) && propMap.get(STATE) != null)\n      this.state = (String) propMap.get(STATE);\n    else {\n      this.state = ACTIVE;                         //Default to ACTIVE\n      propMap.put(STATE, this.state);\n    }\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      // Doesn't support custom implementations of Range, but currently not needed.\n      tmpRange = DocRouter.DEFAULT.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    /** debugging.  this isn't an error condition for custom sharding.\n    if (range == null) {\n      System.out.println(\"###### NO RANGE for \" + name + \" props=\" + props);\n    }\n    **/\n\n    if (propMap.containsKey(PARENT) && propMap.get(PARENT) != null)\n      this.parent = (String) propMap.get(PARENT);\n    else\n      this.parent = null;\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    Map<String, Object> rules = (Map<String, Object>) propMap.get(\"routingRules\");\n    if (rules != null) {\n      this.routingRules = new HashMap<>();\n      for (Map.Entry<String, Object> entry : rules.entrySet()) {\n        Object o = entry.getValue();\n        if (o instanceof Map) {\n          Map map = (Map) o;\n          RoutingRule rule = new RoutingRule(entry.getKey(), map);\n          routingRules.put(entry.getKey(), rule);\n        } else {\n          routingRules.put(entry.getKey(), (RoutingRule) o);\n        }\n      }\n    } else {\n      this.routingRules = null;\n    }\n\n    leader = findLeader();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0c924d4069ef5a5bc479a493befe0121aada6896","date":1427901860,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","sourceNew":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    if (propMap.get(ZkStateReader.STATE_PROP) != null) {\n      this.state = State.getState((String) propMap.get(ZkStateReader.STATE_PROP));\n    } else {\n      this.state = State.ACTIVE;                         //Default to ACTIVE\n      propMap.put(ZkStateReader.STATE_PROP, state.toString());\n    }\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      // Doesn't support custom implementations of Range, but currently not needed.\n      tmpRange = DocRouter.DEFAULT.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    /** debugging.  this isn't an error condition for custom sharding.\n    if (range == null) {\n      System.out.println(\"###### NO RANGE for \" + name + \" props=\" + props);\n    }\n    **/\n\n    if (propMap.containsKey(PARENT) && propMap.get(PARENT) != null)\n      this.parent = (String) propMap.get(PARENT);\n    else\n      this.parent = null;\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    Map<String, Object> rules = (Map<String, Object>) propMap.get(\"routingRules\");\n    if (rules != null) {\n      this.routingRules = new HashMap<>();\n      for (Map.Entry<String, Object> entry : rules.entrySet()) {\n        Object o = entry.getValue();\n        if (o instanceof Map) {\n          Map map = (Map) o;\n          RoutingRule rule = new RoutingRule(entry.getKey(), map);\n          routingRules.put(entry.getKey(), rule);\n        } else {\n          routingRules.put(entry.getKey(), (RoutingRule) o);\n        }\n      }\n    } else {\n      this.routingRules = null;\n    }\n\n    leader = findLeader();\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    if (propMap.containsKey(STATE) && propMap.get(STATE) != null)\n      this.state = (String) propMap.get(STATE);\n    else {\n      this.state = ACTIVE;                         //Default to ACTIVE\n      propMap.put(STATE, this.state);\n    }\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      // Doesn't support custom implementations of Range, but currently not needed.\n      tmpRange = DocRouter.DEFAULT.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    /** debugging.  this isn't an error condition for custom sharding.\n    if (range == null) {\n      System.out.println(\"###### NO RANGE for \" + name + \" props=\" + props);\n    }\n    **/\n\n    if (propMap.containsKey(PARENT) && propMap.get(PARENT) != null)\n      this.parent = (String) propMap.get(PARENT);\n    else\n      this.parent = null;\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    Map<String, Object> rules = (Map<String, Object>) propMap.get(\"routingRules\");\n    if (rules != null) {\n      this.routingRules = new HashMap<>();\n      for (Map.Entry<String, Object> entry : rules.entrySet()) {\n        Object o = entry.getValue();\n        if (o instanceof Map) {\n          Map map = (Map) o;\n          RoutingRule rule = new RoutingRule(entry.getKey(), map);\n          routingRules.put(entry.getKey(), rule);\n        } else {\n          routingRules.put(entry.getKey(), (RoutingRule) o);\n        }\n      }\n    } else {\n      this.routingRules = null;\n    }\n\n    leader = findLeader();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61c45e99cf6676da48f19d7511c73712ad39402b","date":1495508331,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","sourceNew":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    if (propMap.get(ZkStateReader.STATE_PROP) != null) {\n      this.state = State.getState((String) propMap.get(ZkStateReader.STATE_PROP));\n    } else {\n      this.state = State.ACTIVE;                         //Default to ACTIVE\n      propMap.put(ZkStateReader.STATE_PROP, state.toString());\n    }\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      // Doesn't support custom implementations of Range, but currently not needed.\n      tmpRange = DocRouter.DEFAULT.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    /** debugging.  this isn't an error condition for custom sharding.\n    if (range == null) {\n      System.out.println(\"###### NO RANGE for \" + name + \" props=\" + props);\n    }\n    **/\n\n    if (propMap.containsKey(PARENT) && propMap.get(PARENT) != null)\n      this.parent = (String) propMap.get(PARENT);\n    else\n      this.parent = null;\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n    \n    Map<String, Object> rules = (Map<String, Object>) propMap.get(\"routingRules\");\n    if (rules != null) {\n      this.routingRules = new HashMap<>();\n      for (Map.Entry<String, Object> entry : rules.entrySet()) {\n        Object o = entry.getValue();\n        if (o instanceof Map) {\n          Map map = (Map) o;\n          RoutingRule rule = new RoutingRule(entry.getKey(), map);\n          routingRules.put(entry.getKey(), rule);\n        } else {\n          routingRules.put(entry.getKey(), (RoutingRule) o);\n        }\n      }\n    } else {\n      this.routingRules = null;\n    }\n\n    leader = findLeader();\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    if (propMap.get(ZkStateReader.STATE_PROP) != null) {\n      this.state = State.getState((String) propMap.get(ZkStateReader.STATE_PROP));\n    } else {\n      this.state = State.ACTIVE;                         //Default to ACTIVE\n      propMap.put(ZkStateReader.STATE_PROP, state.toString());\n    }\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      // Doesn't support custom implementations of Range, but currently not needed.\n      tmpRange = DocRouter.DEFAULT.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    /** debugging.  this isn't an error condition for custom sharding.\n    if (range == null) {\n      System.out.println(\"###### NO RANGE for \" + name + \" props=\" + props);\n    }\n    **/\n\n    if (propMap.containsKey(PARENT) && propMap.get(PARENT) != null)\n      this.parent = (String) propMap.get(PARENT);\n    else\n      this.parent = null;\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    Map<String, Object> rules = (Map<String, Object>) propMap.get(\"routingRules\");\n    if (rules != null) {\n      this.routingRules = new HashMap<>();\n      for (Map.Entry<String, Object> entry : rules.entrySet()) {\n        Object o = entry.getValue();\n        if (o instanceof Map) {\n          Map map = (Map) o;\n          RoutingRule rule = new RoutingRule(entry.getKey(), map);\n          routingRules.put(entry.getKey(), rule);\n        } else {\n          routingRules.put(entry.getKey(), (RoutingRule) o);\n        }\n      }\n    } else {\n      this.routingRules = null;\n    }\n\n    leader = findLeader();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","sourceNew":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    if (propMap.get(ZkStateReader.STATE_PROP) != null) {\n      this.state = State.getState((String) propMap.get(ZkStateReader.STATE_PROP));\n    } else {\n      this.state = State.ACTIVE;                         //Default to ACTIVE\n      propMap.put(ZkStateReader.STATE_PROP, state.toString());\n    }\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      // Doesn't support custom implementations of Range, but currently not needed.\n      tmpRange = DocRouter.DEFAULT.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    /** debugging.  this isn't an error condition for custom sharding.\n    if (range == null) {\n      System.out.println(\"###### NO RANGE for \" + name + \" props=\" + props);\n    }\n    **/\n\n    if (propMap.containsKey(PARENT) && propMap.get(PARENT) != null)\n      this.parent = (String) propMap.get(PARENT);\n    else\n      this.parent = null;\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n    \n    Map<String, Object> rules = (Map<String, Object>) propMap.get(\"routingRules\");\n    if (rules != null) {\n      this.routingRules = new HashMap<>();\n      for (Map.Entry<String, Object> entry : rules.entrySet()) {\n        Object o = entry.getValue();\n        if (o instanceof Map) {\n          Map map = (Map) o;\n          RoutingRule rule = new RoutingRule(entry.getKey(), map);\n          routingRules.put(entry.getKey(), rule);\n        } else {\n          routingRules.put(entry.getKey(), (RoutingRule) o);\n        }\n      }\n    } else {\n      this.routingRules = null;\n    }\n\n    leader = findLeader();\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    if (propMap.get(ZkStateReader.STATE_PROP) != null) {\n      this.state = State.getState((String) propMap.get(ZkStateReader.STATE_PROP));\n    } else {\n      this.state = State.ACTIVE;                         //Default to ACTIVE\n      propMap.put(ZkStateReader.STATE_PROP, state.toString());\n    }\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      // Doesn't support custom implementations of Range, but currently not needed.\n      tmpRange = DocRouter.DEFAULT.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    /** debugging.  this isn't an error condition for custom sharding.\n    if (range == null) {\n      System.out.println(\"###### NO RANGE for \" + name + \" props=\" + props);\n    }\n    **/\n\n    if (propMap.containsKey(PARENT) && propMap.get(PARENT) != null)\n      this.parent = (String) propMap.get(PARENT);\n    else\n      this.parent = null;\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    Map<String, Object> rules = (Map<String, Object>) propMap.get(\"routingRules\");\n    if (rules != null) {\n      this.routingRules = new HashMap<>();\n      for (Map.Entry<String, Object> entry : rules.entrySet()) {\n        Object o = entry.getValue();\n        if (o instanceof Map) {\n          Map map = (Map) o;\n          RoutingRule rule = new RoutingRule(entry.getKey(), map);\n          routingRules.put(entry.getKey(), rule);\n        } else {\n          routingRules.put(entry.getKey(), (RoutingRule) o);\n        }\n      }\n    } else {\n      this.routingRules = null;\n    }\n\n    leader = findLeader();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"32f5fad3313a0922cfbb864cbab11af491e86ed7","date":1508943542,"type":3,"author":"Cassandra Targett","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","sourceNew":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    if (propMap.get(ZkStateReader.STATE_PROP) != null) {\n      this.state = State.getState((String) propMap.get(ZkStateReader.STATE_PROP));\n    } else {\n      this.state = State.ACTIVE;                         //Default to ACTIVE\n      propMap.put(ZkStateReader.STATE_PROP, state.toString());\n    }\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      // Doesn't support custom implementations of Range, but currently not needed.\n      tmpRange = DocRouter.DEFAULT.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    /** debugging.  this isn't an error condition for custom sharding.\n    if (range == null) {\n      System.out.println(\"###### NO RANGE for \" + name + \" props=\" + props);\n    }\n    **/\n\n    if (propMap.containsKey(PARENT) && propMap.get(PARENT) != null)\n      this.parent = (String) propMap.get(PARENT);\n    else\n      this.parent = null;\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    Map<String, Object> rules = (Map<String, Object>) propMap.get(\"routingRules\");\n    if (rules != null) {\n      this.routingRules = new HashMap<>();\n      for (Map.Entry<String, Object> entry : rules.entrySet()) {\n        Object o = entry.getValue();\n        if (o instanceof Map) {\n          Map map = (Map) o;\n          RoutingRule rule = new RoutingRule(entry.getKey(), map);\n          routingRules.put(entry.getKey(), rule);\n        } else {\n          routingRules.put(entry.getKey(), (RoutingRule) o);\n        }\n      }\n    } else {\n      this.routingRules = null;\n    }\n\n    leader = findLeader();\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    if (propMap.get(ZkStateReader.STATE_PROP) != null) {\n      this.state = State.getState((String) propMap.get(ZkStateReader.STATE_PROP));\n    } else {\n      this.state = State.ACTIVE;                         //Default to ACTIVE\n      propMap.put(ZkStateReader.STATE_PROP, state.toString());\n    }\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      // Doesn't support custom implementations of Range, but currently not needed.\n      tmpRange = DocRouter.DEFAULT.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    /** debugging.  this isn't an error condition for custom sharding.\n    if (range == null) {\n      System.out.println(\"###### NO RANGE for \" + name + \" props=\" + props);\n    }\n    **/\n\n    if (propMap.containsKey(PARENT) && propMap.get(PARENT) != null)\n      this.parent = (String) propMap.get(PARENT);\n    else\n      this.parent = null;\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n    \n    Map<String, Object> rules = (Map<String, Object>) propMap.get(\"routingRules\");\n    if (rules != null) {\n      this.routingRules = new HashMap<>();\n      for (Map.Entry<String, Object> entry : rules.entrySet()) {\n        Object o = entry.getValue();\n        if (o instanceof Map) {\n          Map map = (Map) o;\n          RoutingRule rule = new RoutingRule(entry.getKey(), map);\n          routingRules.put(entry.getKey(), rule);\n        } else {\n          routingRules.put(entry.getKey(), (RoutingRule) o);\n        }\n      }\n    } else {\n      this.routingRules = null;\n    }\n\n    leader = findLeader();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6681d02f2302c363be938426e68f8dfd090cc1bf","date":1575339019,"type":5,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object],String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","sourceNew":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props, String collection) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<>(props));\n    this.name = name;\n    this.collection = collection;\n\n    Object rangeObj = propMap.get(RANGE);\n    if (propMap.get(ZkStateReader.STATE_PROP) != null) {\n      this.state = State.getState((String) propMap.get(ZkStateReader.STATE_PROP));\n    } else {\n      this.state = State.ACTIVE;                         //Default to ACTIVE\n      propMap.put(ZkStateReader.STATE_PROP, state.toString());\n    }\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      // Doesn't support custom implementations of Range, but currently not needed.\n      tmpRange = DocRouter.DEFAULT.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    /** debugging.  this isn't an error condition for custom sharding.\n    if (range == null) {\n      System.out.println(\"###### NO RANGE for \" + name + \" props=\" + props);\n    }\n    **/\n\n    if (propMap.containsKey(PARENT) && propMap.get(PARENT) != null)\n      this.parent = (String) propMap.get(PARENT);\n    else\n      this.parent = null;\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas(collection,name, (Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    Map<String, Object> rules = (Map<String, Object>) propMap.get(\"routingRules\");\n    if (rules != null) {\n      this.routingRules = new HashMap<>();\n      for (Map.Entry<String, Object> entry : rules.entrySet()) {\n        Object o = entry.getValue();\n        if (o instanceof Map) {\n          Map map = (Map) o;\n          RoutingRule rule = new RoutingRule(entry.getKey(), map);\n          routingRules.put(entry.getKey(), rule);\n        } else {\n          routingRules.put(entry.getKey(), (RoutingRule) o);\n        }\n      }\n    } else {\n      this.routingRules = null;\n    }\n\n    leader = findLeader();\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    if (propMap.get(ZkStateReader.STATE_PROP) != null) {\n      this.state = State.getState((String) propMap.get(ZkStateReader.STATE_PROP));\n    } else {\n      this.state = State.ACTIVE;                         //Default to ACTIVE\n      propMap.put(ZkStateReader.STATE_PROP, state.toString());\n    }\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      // Doesn't support custom implementations of Range, but currently not needed.\n      tmpRange = DocRouter.DEFAULT.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    /** debugging.  this isn't an error condition for custom sharding.\n    if (range == null) {\n      System.out.println(\"###### NO RANGE for \" + name + \" props=\" + props);\n    }\n    **/\n\n    if (propMap.containsKey(PARENT) && propMap.get(PARENT) != null)\n      this.parent = (String) propMap.get(PARENT);\n    else\n      this.parent = null;\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    Map<String, Object> rules = (Map<String, Object>) propMap.get(\"routingRules\");\n    if (rules != null) {\n      this.routingRules = new HashMap<>();\n      for (Map.Entry<String, Object> entry : rules.entrySet()) {\n        Object o = entry.getValue();\n        if (o instanceof Map) {\n          Map map = (Map) o;\n          RoutingRule rule = new RoutingRule(entry.getKey(), map);\n          routingRules.put(entry.getKey(), rule);\n        } else {\n          routingRules.put(entry.getKey(), (RoutingRule) o);\n        }\n      }\n    } else {\n      this.routingRules = null;\n    }\n\n    leader = findLeader();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3aa683bba99315838c968fefedf3d74f44aa993","date":1575395112,"type":5,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object],String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","sourceNew":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props, String collection) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<>(props));\n    this.name = name;\n    this.collection = collection;\n\n    Object rangeObj = propMap.get(RANGE);\n    if (propMap.get(ZkStateReader.STATE_PROP) != null) {\n      this.state = State.getState((String) propMap.get(ZkStateReader.STATE_PROP));\n    } else {\n      this.state = State.ACTIVE;                         //Default to ACTIVE\n      propMap.put(ZkStateReader.STATE_PROP, state.toString());\n    }\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      // Doesn't support custom implementations of Range, but currently not needed.\n      tmpRange = DocRouter.DEFAULT.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    /** debugging.  this isn't an error condition for custom sharding.\n    if (range == null) {\n      System.out.println(\"###### NO RANGE for \" + name + \" props=\" + props);\n    }\n    **/\n\n    if (propMap.containsKey(PARENT) && propMap.get(PARENT) != null)\n      this.parent = (String) propMap.get(PARENT);\n    else\n      this.parent = null;\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas(collection,name, (Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    Map<String, Object> rules = (Map<String, Object>) propMap.get(\"routingRules\");\n    if (rules != null) {\n      this.routingRules = new HashMap<>();\n      for (Map.Entry<String, Object> entry : rules.entrySet()) {\n        Object o = entry.getValue();\n        if (o instanceof Map) {\n          Map map = (Map) o;\n          RoutingRule rule = new RoutingRule(entry.getKey(), map);\n          routingRules.put(entry.getKey(), rule);\n        } else {\n          routingRules.put(entry.getKey(), (RoutingRule) o);\n        }\n      }\n    } else {\n      this.routingRules = null;\n    }\n\n    leader = findLeader();\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    if (propMap.get(ZkStateReader.STATE_PROP) != null) {\n      this.state = State.getState((String) propMap.get(ZkStateReader.STATE_PROP));\n    } else {\n      this.state = State.ACTIVE;                         //Default to ACTIVE\n      propMap.put(ZkStateReader.STATE_PROP, state.toString());\n    }\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      // Doesn't support custom implementations of Range, but currently not needed.\n      tmpRange = DocRouter.DEFAULT.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    /** debugging.  this isn't an error condition for custom sharding.\n    if (range == null) {\n      System.out.println(\"###### NO RANGE for \" + name + \" props=\" + props);\n    }\n    **/\n\n    if (propMap.containsKey(PARENT) && propMap.get(PARENT) != null)\n      this.parent = (String) propMap.get(PARENT);\n    else\n      this.parent = null;\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    Map<String, Object> rules = (Map<String, Object>) propMap.get(\"routingRules\");\n    if (rules != null) {\n      this.routingRules = new HashMap<>();\n      for (Map.Entry<String, Object> entry : rules.entrySet()) {\n        Object o = entry.getValue();\n        if (o instanceof Map) {\n          Map map = (Map) o;\n          RoutingRule rule = new RoutingRule(entry.getKey(), map);\n          routingRules.put(entry.getKey(), rule);\n        } else {\n          routingRules.put(entry.getKey(), (RoutingRule) o);\n        }\n      }\n    } else {\n      this.routingRules = null;\n    }\n\n    leader = findLeader();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3aa683bba99315838c968fefedf3d74f44aa993":["32f5fad3313a0922cfbb864cbab11af491e86ed7","6681d02f2302c363be938426e68f8dfd090cc1bf"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["da888af1ab894358122a22229051215f58cf4d54"],"89f828d954597b98a28942874636f35c719b8a5d":["c5a558d54519c651068ddb202f03befefb1514a7"],"61c45e99cf6676da48f19d7511c73712ad39402b":["d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296"],"5280dd0bd8aa6103cae92307392505c83841c9d5":["7e7d59baa18f0aed2bb5f93a76ffce5343aee13d"],"d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"7e7d59baa18f0aed2bb5f93a76ffce5343aee13d":["fa64435b5902ce266c23755a4a00691a3285dab8"],"fa64435b5902ce266c23755a4a00691a3285dab8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"407687e67faf6e1f02a211ca078d8e3eed631027":["5280dd0bd8aa6103cae92307392505c83841c9d5","89f828d954597b98a28942874636f35c719b8a5d"],"0beaed456aa3358e5e4a99ea2aea994ef6c81de3":["630b72110afca0a13a755e07ef8a4d764afb52aa"],"6681d02f2302c363be938426e68f8dfd090cc1bf":["32f5fad3313a0922cfbb864cbab11af491e86ed7"],"630b72110afca0a13a755e07ef8a4d764afb52aa":["89f828d954597b98a28942874636f35c719b8a5d"],"0c924d4069ef5a5bc479a493befe0121aada6896":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296"],"32f5fad3313a0922cfbb864cbab11af491e86ed7":["61c45e99cf6676da48f19d7511c73712ad39402b"],"da888af1ab894358122a22229051215f58cf4d54":["bc841231667f1f315bae6799c068f9aad6543967"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296","61c45e99cf6676da48f19d7511c73712ad39402b"],"bc841231667f1f315bae6799c068f9aad6543967":["0beaed456aa3358e5e4a99ea2aea994ef6c81de3"],"c5a558d54519c651068ddb202f03befefb1514a7":["5280dd0bd8aa6103cae92307392505c83841c9d5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6681d02f2302c363be938426e68f8dfd090cc1bf"]},"commit2Childs":{"d3aa683bba99315838c968fefedf3d74f44aa993":[],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296","0c924d4069ef5a5bc479a493befe0121aada6896"],"89f828d954597b98a28942874636f35c719b8a5d":["407687e67faf6e1f02a211ca078d8e3eed631027","630b72110afca0a13a755e07ef8a4d764afb52aa"],"61c45e99cf6676da48f19d7511c73712ad39402b":["32f5fad3313a0922cfbb864cbab11af491e86ed7","e9017cf144952056066919f1ebc7897ff9bd71b1"],"5280dd0bd8aa6103cae92307392505c83841c9d5":["407687e67faf6e1f02a211ca078d8e3eed631027","c5a558d54519c651068ddb202f03befefb1514a7"],"d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296":["61c45e99cf6676da48f19d7511c73712ad39402b","0c924d4069ef5a5bc479a493befe0121aada6896","e9017cf144952056066919f1ebc7897ff9bd71b1"],"7e7d59baa18f0aed2bb5f93a76ffce5343aee13d":["5280dd0bd8aa6103cae92307392505c83841c9d5"],"fa64435b5902ce266c23755a4a00691a3285dab8":["7e7d59baa18f0aed2bb5f93a76ffce5343aee13d"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"0beaed456aa3358e5e4a99ea2aea994ef6c81de3":["bc841231667f1f315bae6799c068f9aad6543967"],"6681d02f2302c363be938426e68f8dfd090cc1bf":["d3aa683bba99315838c968fefedf3d74f44aa993","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"630b72110afca0a13a755e07ef8a4d764afb52aa":["0beaed456aa3358e5e4a99ea2aea994ef6c81de3"],"0c924d4069ef5a5bc479a493befe0121aada6896":[],"32f5fad3313a0922cfbb864cbab11af491e86ed7":["d3aa683bba99315838c968fefedf3d74f44aa993","6681d02f2302c363be938426e68f8dfd090cc1bf"],"da888af1ab894358122a22229051215f58cf4d54":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"bc841231667f1f315bae6799c068f9aad6543967":["da888af1ab894358122a22229051215f58cf4d54"],"c5a558d54519c651068ddb202f03befefb1514a7":["89f828d954597b98a28942874636f35c719b8a5d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fa64435b5902ce266c23755a4a00691a3285dab8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3aa683bba99315838c968fefedf3d74f44aa993","407687e67faf6e1f02a211ca078d8e3eed631027","0c924d4069ef5a5bc479a493befe0121aada6896","e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}