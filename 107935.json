{"path":"solr/core/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequestForFieldFacets(ResponseBuilder,ShardRequest,FacetInfo).mjava","commits":[{"id":"92751ba9273251eab6a2e379ec42a1697a32ff96","date":1407954233,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequestForFieldFacets(ResponseBuilder,ShardRequest,FacetInfo).mjava","pathOld":"/dev/null","sourceNew":"  private void modifyRequestForFieldFacets(ResponseBuilder rb, ShardRequest sreq, FacetInfo fi) {\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      \n      String paramStart = \"f.\" + dff.field + '.';\n      sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n      sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n      \n      dff.initialLimit = dff.limit <= 0 ? dff.limit : dff.offset + dff.limit;\n      \n      if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n        if (dff.limit > 0) {\n          // set the initial limit higher to increase accuracy\n          dff.initialLimit = doOverRequestMath(dff.initialLimit, dff.overrequestRatio, \n                                               dff.overrequestCount);\n          dff.initialMincount = 0; // TODO: we could change this to 1, but would\n                                   // then need more refinement for small facet\n                                   // result sets?\n        } else {\n          // if limit==-1, then no need to artificially lower mincount to 0 if\n          // it's 1\n          dff.initialMincount = Math.min(dff.minCount, 1);\n        }\n      } else {\n        // we're sorting by index order.\n        // if minCount==0, we should always be able to get accurate results w/o\n        // over-requesting or refining\n        // if minCount==1, we should be able to get accurate results w/o\n        // over-requesting, but we'll need to refine\n        // if minCount==n (>1), we can set the initialMincount to\n        // minCount/nShards, rounded up.\n        // For example, we know that if minCount=10 and we have 3 shards, then\n        // at least one shard must have a count of 4 for the term\n        // For the minCount>1 case, we can generate too short of a list (miss\n        // terms at the end of the list) unless limit==-1\n        // For example: each shard could produce a list of top 10, but some of\n        // those could fail to make it into the combined list (i.e.\n        // we needed to go beyond the top 10 to generate the top 10 combined).\n        // Overrequesting can help a little here, but not as\n        // much as when sorting by count.\n        if (dff.minCount <= 1) {\n          dff.initialMincount = dff.minCount;\n        } else {\n          dff.initialMincount = (int) Math.ceil((double) dff.minCount / rb.slices.length);\n        }\n      }\n      \n      // Currently this is for testing only and allows overriding of the\n      // facet.limit set to the shards\n      dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n      \n      sreq.params.set(paramStart + FacetParams.FACET_LIMIT, dff.initialLimit);\n      sreq.params.set(paramStart + FacetParams.FACET_MINCOUNT, dff.initialMincount);\n\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8ff4734b6c86245e852fe8b6a286716d5e59d415","date":1410194063,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequestForFieldFacets(ResponseBuilder,ShardRequest,FacetInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequestForFieldFacets(ResponseBuilder,ShardRequest,FacetInfo).mjava","sourceNew":"  private void modifyRequestForFieldFacets(ResponseBuilder rb, ShardRequest sreq, FacetInfo fi) {\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      \n      String paramStart = \"f.\" + dff.field + '.';\n      sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n      sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n      \n      dff.initialLimit = dff.limit <= 0 ? dff.limit : dff.offset + dff.limit;\n      \n      if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n        if (dff.limit > 0) {\n          // set the initial limit higher to increase accuracy\n          dff.initialLimit = doOverRequestMath(dff.initialLimit, dff.overrequestRatio, \n                                               dff.overrequestCount);\n          dff.initialMincount = 0; // TODO: we could change this to 1, but would\n                                   // then need more refinement for small facet\n                                   // result sets?\n        } else {\n          // if limit==-1, then no need to artificially lower mincount to 0 if\n          // it's 1\n          dff.initialMincount = Math.min(dff.minCount, 1);\n        }\n      } else {\n        // we're sorting by index order.\n        // if minCount==0, we should always be able to get accurate results w/o\n        // over-requesting or refining\n        // if minCount==1, we should be able to get accurate results w/o\n        // over-requesting, but we'll need to refine\n        // if minCount==n (>1), we can set the initialMincount to\n        // minCount/nShards, rounded up.\n        // For example, we know that if minCount=10 and we have 3 shards, then\n        // at least one shard must have a count of 4 for the term\n        // For the minCount>1 case, we can generate too short of a list (miss\n        // terms at the end of the list) unless limit==-1\n        // For example: each shard could produce a list of top 10, but some of\n        // those could fail to make it into the combined list (i.e.\n        // we needed to go beyond the top 10 to generate the top 10 combined).\n        // Overrequesting can help a little here, but not as\n        // much as when sorting by count.\n        if (dff.minCount <= 1) {\n          dff.initialMincount = dff.minCount;\n        } else {\n          dff.initialMincount = (int) Math.ceil((double) dff.minCount / rb.slices.length);\n        }\n      }\n\n      // Currently this is for testing only and allows overriding of the\n      // facet.limit set to the shards\n      dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n      \n      sreq.params.set(paramStart + FacetParams.FACET_LIMIT, dff.initialLimit);\n      sreq.params.set(paramStart + FacetParams.FACET_MINCOUNT, dff.initialMincount);\n\n    }\n  }\n\n","sourceOld":"  private void modifyRequestForFieldFacets(ResponseBuilder rb, ShardRequest sreq, FacetInfo fi) {\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      \n      String paramStart = \"f.\" + dff.field + '.';\n      sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n      sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n      \n      dff.initialLimit = dff.limit <= 0 ? dff.limit : dff.offset + dff.limit;\n      \n      if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n        if (dff.limit > 0) {\n          // set the initial limit higher to increase accuracy\n          dff.initialLimit = doOverRequestMath(dff.initialLimit, dff.overrequestRatio, \n                                               dff.overrequestCount);\n          dff.initialMincount = 0; // TODO: we could change this to 1, but would\n                                   // then need more refinement for small facet\n                                   // result sets?\n        } else {\n          // if limit==-1, then no need to artificially lower mincount to 0 if\n          // it's 1\n          dff.initialMincount = Math.min(dff.minCount, 1);\n        }\n      } else {\n        // we're sorting by index order.\n        // if minCount==0, we should always be able to get accurate results w/o\n        // over-requesting or refining\n        // if minCount==1, we should be able to get accurate results w/o\n        // over-requesting, but we'll need to refine\n        // if minCount==n (>1), we can set the initialMincount to\n        // minCount/nShards, rounded up.\n        // For example, we know that if minCount=10 and we have 3 shards, then\n        // at least one shard must have a count of 4 for the term\n        // For the minCount>1 case, we can generate too short of a list (miss\n        // terms at the end of the list) unless limit==-1\n        // For example: each shard could produce a list of top 10, but some of\n        // those could fail to make it into the combined list (i.e.\n        // we needed to go beyond the top 10 to generate the top 10 combined).\n        // Overrequesting can help a little here, but not as\n        // much as when sorting by count.\n        if (dff.minCount <= 1) {\n          dff.initialMincount = dff.minCount;\n        } else {\n          dff.initialMincount = (int) Math.ceil((double) dff.minCount / rb.slices.length);\n        }\n      }\n      \n      // Currently this is for testing only and allows overriding of the\n      // facet.limit set to the shards\n      dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n      \n      sreq.params.set(paramStart + FacetParams.FACET_LIMIT, dff.initialLimit);\n      sreq.params.set(paramStart + FacetParams.FACET_MINCOUNT, dff.initialMincount);\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"25107e8bc3cbaed9427c9c7092c430cf4ce48b1b","date":1464030817,"type":3,"author":"Dennis Gove","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequestForFieldFacets(ResponseBuilder,ShardRequest,FacetInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequestForFieldFacets(ResponseBuilder,ShardRequest,FacetInfo).mjava","sourceNew":"  private void modifyRequestForFieldFacets(ResponseBuilder rb, ShardRequest sreq, FacetInfo fi) {\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      \n      String paramStart = \"f.\" + dff.field + '.';\n      sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n      sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n      \n      dff.initialLimit = dff.limit <= 0 ? dff.limit : dff.offset + dff.limit;\n      \n      if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n        if (dff.limit > 0) {\n          // set the initial limit higher to increase accuracy\n          dff.initialLimit = doOverRequestMath(dff.initialLimit, dff.overrequestRatio, \n                                               dff.overrequestCount);\n          \n          // If option FACET_DISTRIB_MCO is turned on then we will use 1 as the initial \n          // minCount (unless the user explicitly set it to something less than 1). If \n          // option FACET_DISTRIB_MCO is turned off then we will use 0 as the initial \n          // minCount regardless of what the user might have provided (prior to the\n          // addition of the FACET_DISTRIB_MCO option the default logic was to use 0).\n          // As described in issues SOLR-8559 and SOLR-8988 the use of 1 provides a \n          // significant performance boost.\n          dff.initialMincount = dff.mco ? Math.min(dff.minCount, 1) : 0;\n                                   \n        } else {\n          // if limit==-1, then no need to artificially lower mincount to 0 if\n          // it's 1\n          dff.initialMincount = Math.min(dff.minCount, 1);\n        }\n      } else {\n        // we're sorting by index order.\n        // if minCount==0, we should always be able to get accurate results w/o\n        // over-requesting or refining\n        // if minCount==1, we should be able to get accurate results w/o\n        // over-requesting, but we'll need to refine\n        // if minCount==n (>1), we can set the initialMincount to\n        // minCount/nShards, rounded up.\n        // For example, we know that if minCount=10 and we have 3 shards, then\n        // at least one shard must have a count of 4 for the term\n        // For the minCount>1 case, we can generate too short of a list (miss\n        // terms at the end of the list) unless limit==-1\n        // For example: each shard could produce a list of top 10, but some of\n        // those could fail to make it into the combined list (i.e.\n        // we needed to go beyond the top 10 to generate the top 10 combined).\n        // Overrequesting can help a little here, but not as\n        // much as when sorting by count.\n        if (dff.minCount <= 1) {\n          dff.initialMincount = dff.minCount;\n        } else {\n          dff.initialMincount = (int) Math.ceil((double) dff.minCount / rb.slices.length);\n        }\n      }\n\n      // Currently this is for testing only and allows overriding of the\n      // facet.limit set to the shards\n      dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n      \n      sreq.params.set(paramStart + FacetParams.FACET_LIMIT, dff.initialLimit);\n      sreq.params.set(paramStart + FacetParams.FACET_MINCOUNT, dff.initialMincount);\n\n    }\n  }\n\n","sourceOld":"  private void modifyRequestForFieldFacets(ResponseBuilder rb, ShardRequest sreq, FacetInfo fi) {\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      \n      String paramStart = \"f.\" + dff.field + '.';\n      sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n      sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n      \n      dff.initialLimit = dff.limit <= 0 ? dff.limit : dff.offset + dff.limit;\n      \n      if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n        if (dff.limit > 0) {\n          // set the initial limit higher to increase accuracy\n          dff.initialLimit = doOverRequestMath(dff.initialLimit, dff.overrequestRatio, \n                                               dff.overrequestCount);\n          dff.initialMincount = 0; // TODO: we could change this to 1, but would\n                                   // then need more refinement for small facet\n                                   // result sets?\n        } else {\n          // if limit==-1, then no need to artificially lower mincount to 0 if\n          // it's 1\n          dff.initialMincount = Math.min(dff.minCount, 1);\n        }\n      } else {\n        // we're sorting by index order.\n        // if minCount==0, we should always be able to get accurate results w/o\n        // over-requesting or refining\n        // if minCount==1, we should be able to get accurate results w/o\n        // over-requesting, but we'll need to refine\n        // if minCount==n (>1), we can set the initialMincount to\n        // minCount/nShards, rounded up.\n        // For example, we know that if minCount=10 and we have 3 shards, then\n        // at least one shard must have a count of 4 for the term\n        // For the minCount>1 case, we can generate too short of a list (miss\n        // terms at the end of the list) unless limit==-1\n        // For example: each shard could produce a list of top 10, but some of\n        // those could fail to make it into the combined list (i.e.\n        // we needed to go beyond the top 10 to generate the top 10 combined).\n        // Overrequesting can help a little here, but not as\n        // much as when sorting by count.\n        if (dff.minCount <= 1) {\n          dff.initialMincount = dff.minCount;\n        } else {\n          dff.initialMincount = (int) Math.ceil((double) dff.minCount / rb.slices.length);\n        }\n      }\n\n      // Currently this is for testing only and allows overriding of the\n      // facet.limit set to the shards\n      dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n      \n      sreq.params.set(paramStart + FacetParams.FACET_LIMIT, dff.initialLimit);\n      sreq.params.set(paramStart + FacetParams.FACET_MINCOUNT, dff.initialMincount);\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e616cfbf284ecbd0f40b4b9e4196daa27e92abd5","date":1464066565,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequestForFieldFacets(ResponseBuilder,ShardRequest,FacetInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequestForFieldFacets(ResponseBuilder,ShardRequest,FacetInfo).mjava","sourceNew":"  private void modifyRequestForFieldFacets(ResponseBuilder rb, ShardRequest sreq, FacetInfo fi) {\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      \n      String paramStart = \"f.\" + dff.field + '.';\n      sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n      sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n      \n      dff.initialLimit = dff.limit <= 0 ? dff.limit : dff.offset + dff.limit;\n      \n      if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n        if (dff.limit > 0) {\n          // set the initial limit higher to increase accuracy\n          dff.initialLimit = doOverRequestMath(dff.initialLimit, dff.overrequestRatio, \n                                               dff.overrequestCount);\n          \n          // If option FACET_DISTRIB_MCO is turned on then we will use 1 as the initial \n          // minCount (unless the user explicitly set it to something less than 1). If \n          // option FACET_DISTRIB_MCO is turned off then we will use 0 as the initial \n          // minCount regardless of what the user might have provided (prior to the\n          // addition of the FACET_DISTRIB_MCO option the default logic was to use 0).\n          // As described in issues SOLR-8559 and SOLR-8988 the use of 1 provides a \n          // significant performance boost.\n          dff.initialMincount = dff.mco ? Math.min(dff.minCount, 1) : 0;\n                                   \n        } else {\n          // if limit==-1, then no need to artificially lower mincount to 0 if\n          // it's 1\n          dff.initialMincount = Math.min(dff.minCount, 1);\n        }\n      } else {\n        // we're sorting by index order.\n        // if minCount==0, we should always be able to get accurate results w/o\n        // over-requesting or refining\n        // if minCount==1, we should be able to get accurate results w/o\n        // over-requesting, but we'll need to refine\n        // if minCount==n (>1), we can set the initialMincount to\n        // minCount/nShards, rounded up.\n        // For example, we know that if minCount=10 and we have 3 shards, then\n        // at least one shard must have a count of 4 for the term\n        // For the minCount>1 case, we can generate too short of a list (miss\n        // terms at the end of the list) unless limit==-1\n        // For example: each shard could produce a list of top 10, but some of\n        // those could fail to make it into the combined list (i.e.\n        // we needed to go beyond the top 10 to generate the top 10 combined).\n        // Overrequesting can help a little here, but not as\n        // much as when sorting by count.\n        if (dff.minCount <= 1) {\n          dff.initialMincount = dff.minCount;\n        } else {\n          dff.initialMincount = (int) Math.ceil((double) dff.minCount / rb.slices.length);\n        }\n      }\n\n      // Currently this is for testing only and allows overriding of the\n      // facet.limit set to the shards\n      dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n      \n      sreq.params.set(paramStart + FacetParams.FACET_LIMIT, dff.initialLimit);\n      sreq.params.set(paramStart + FacetParams.FACET_MINCOUNT, dff.initialMincount);\n\n    }\n  }\n\n","sourceOld":"  private void modifyRequestForFieldFacets(ResponseBuilder rb, ShardRequest sreq, FacetInfo fi) {\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      \n      String paramStart = \"f.\" + dff.field + '.';\n      sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n      sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n      \n      dff.initialLimit = dff.limit <= 0 ? dff.limit : dff.offset + dff.limit;\n      \n      if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n        if (dff.limit > 0) {\n          // set the initial limit higher to increase accuracy\n          dff.initialLimit = doOverRequestMath(dff.initialLimit, dff.overrequestRatio, \n                                               dff.overrequestCount);\n          dff.initialMincount = 0; // TODO: we could change this to 1, but would\n                                   // then need more refinement for small facet\n                                   // result sets?\n        } else {\n          // if limit==-1, then no need to artificially lower mincount to 0 if\n          // it's 1\n          dff.initialMincount = Math.min(dff.minCount, 1);\n        }\n      } else {\n        // we're sorting by index order.\n        // if minCount==0, we should always be able to get accurate results w/o\n        // over-requesting or refining\n        // if minCount==1, we should be able to get accurate results w/o\n        // over-requesting, but we'll need to refine\n        // if minCount==n (>1), we can set the initialMincount to\n        // minCount/nShards, rounded up.\n        // For example, we know that if minCount=10 and we have 3 shards, then\n        // at least one shard must have a count of 4 for the term\n        // For the minCount>1 case, we can generate too short of a list (miss\n        // terms at the end of the list) unless limit==-1\n        // For example: each shard could produce a list of top 10, but some of\n        // those could fail to make it into the combined list (i.e.\n        // we needed to go beyond the top 10 to generate the top 10 combined).\n        // Overrequesting can help a little here, but not as\n        // much as when sorting by count.\n        if (dff.minCount <= 1) {\n          dff.initialMincount = dff.minCount;\n        } else {\n          dff.initialMincount = (int) Math.ceil((double) dff.minCount / rb.slices.length);\n        }\n      }\n\n      // Currently this is for testing only and allows overriding of the\n      // facet.limit set to the shards\n      dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n      \n      sreq.params.set(paramStart + FacetParams.FACET_LIMIT, dff.initialLimit);\n      sreq.params.set(paramStart + FacetParams.FACET_MINCOUNT, dff.initialMincount);\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequestForFieldFacets(ResponseBuilder,ShardRequest,FacetInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequestForFieldFacets(ResponseBuilder,ShardRequest,FacetInfo).mjava","sourceNew":"  private void modifyRequestForFieldFacets(ResponseBuilder rb, ShardRequest sreq, FacetInfo fi) {\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      \n      String paramStart = \"f.\" + dff.field + '.';\n      sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n      sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n      \n      dff.initialLimit = dff.limit <= 0 ? dff.limit : dff.offset + dff.limit;\n      \n      if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n        if (dff.limit > 0) {\n          // set the initial limit higher to increase accuracy\n          dff.initialLimit = doOverRequestMath(dff.initialLimit, dff.overrequestRatio, \n                                               dff.overrequestCount);\n          \n          // If option FACET_DISTRIB_MCO is turned on then we will use 1 as the initial \n          // minCount (unless the user explicitly set it to something less than 1). If \n          // option FACET_DISTRIB_MCO is turned off then we will use 0 as the initial \n          // minCount regardless of what the user might have provided (prior to the\n          // addition of the FACET_DISTRIB_MCO option the default logic was to use 0).\n          // As described in issues SOLR-8559 and SOLR-8988 the use of 1 provides a \n          // significant performance boost.\n          dff.initialMincount = dff.mco ? Math.min(dff.minCount, 1) : 0;\n                                   \n        } else {\n          // if limit==-1, then no need to artificially lower mincount to 0 if\n          // it's 1\n          dff.initialMincount = Math.min(dff.minCount, 1);\n        }\n      } else {\n        // we're sorting by index order.\n        // if minCount==0, we should always be able to get accurate results w/o\n        // over-requesting or refining\n        // if minCount==1, we should be able to get accurate results w/o\n        // over-requesting, but we'll need to refine\n        // if minCount==n (>1), we can set the initialMincount to\n        // minCount/nShards, rounded up.\n        // For example, we know that if minCount=10 and we have 3 shards, then\n        // at least one shard must have a count of 4 for the term\n        // For the minCount>1 case, we can generate too short of a list (miss\n        // terms at the end of the list) unless limit==-1\n        // For example: each shard could produce a list of top 10, but some of\n        // those could fail to make it into the combined list (i.e.\n        // we needed to go beyond the top 10 to generate the top 10 combined).\n        // Overrequesting can help a little here, but not as\n        // much as when sorting by count.\n        if (dff.minCount <= 1) {\n          dff.initialMincount = dff.minCount;\n        } else {\n          dff.initialMincount = (int) Math.ceil((double) dff.minCount / rb.slices.length);\n        }\n      }\n\n      // Currently this is for testing only and allows overriding of the\n      // facet.limit set to the shards\n      dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n      \n      sreq.params.set(paramStart + FacetParams.FACET_LIMIT, dff.initialLimit);\n      sreq.params.set(paramStart + FacetParams.FACET_MINCOUNT, dff.initialMincount);\n\n    }\n  }\n\n","sourceOld":"  private void modifyRequestForFieldFacets(ResponseBuilder rb, ShardRequest sreq, FacetInfo fi) {\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      \n      String paramStart = \"f.\" + dff.field + '.';\n      sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n      sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n      \n      dff.initialLimit = dff.limit <= 0 ? dff.limit : dff.offset + dff.limit;\n      \n      if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n        if (dff.limit > 0) {\n          // set the initial limit higher to increase accuracy\n          dff.initialLimit = doOverRequestMath(dff.initialLimit, dff.overrequestRatio, \n                                               dff.overrequestCount);\n          dff.initialMincount = 0; // TODO: we could change this to 1, but would\n                                   // then need more refinement for small facet\n                                   // result sets?\n        } else {\n          // if limit==-1, then no need to artificially lower mincount to 0 if\n          // it's 1\n          dff.initialMincount = Math.min(dff.minCount, 1);\n        }\n      } else {\n        // we're sorting by index order.\n        // if minCount==0, we should always be able to get accurate results w/o\n        // over-requesting or refining\n        // if minCount==1, we should be able to get accurate results w/o\n        // over-requesting, but we'll need to refine\n        // if minCount==n (>1), we can set the initialMincount to\n        // minCount/nShards, rounded up.\n        // For example, we know that if minCount=10 and we have 3 shards, then\n        // at least one shard must have a count of 4 for the term\n        // For the minCount>1 case, we can generate too short of a list (miss\n        // terms at the end of the list) unless limit==-1\n        // For example: each shard could produce a list of top 10, but some of\n        // those could fail to make it into the combined list (i.e.\n        // we needed to go beyond the top 10 to generate the top 10 combined).\n        // Overrequesting can help a little here, but not as\n        // much as when sorting by count.\n        if (dff.minCount <= 1) {\n          dff.initialMincount = dff.minCount;\n        } else {\n          dff.initialMincount = (int) Math.ceil((double) dff.minCount / rb.slices.length);\n        }\n      }\n\n      // Currently this is for testing only and allows overriding of the\n      // facet.limit set to the shards\n      dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n      \n      sreq.params.set(paramStart + FacetParams.FACET_LIMIT, dff.initialLimit);\n      sreq.params.set(paramStart + FacetParams.FACET_MINCOUNT, dff.initialMincount);\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ef57266eb048f5d440958e9b0612adf7535e5e8b","date":1513013215,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequestForFieldFacets(ResponseBuilder,ShardRequest,FacetInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequestForFieldFacets(ResponseBuilder,ShardRequest,FacetInfo).mjava","sourceNew":"  private void modifyRequestForFieldFacets(ResponseBuilder rb, ShardRequest sreq, FacetInfo fi) {\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      \n      String paramStart = \"f.\" + dff.field + '.';\n      sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n      sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n      \n      dff.initialLimit = dff.limit <= 0 ? dff.limit : dff.offset + dff.limit;\n      \n      if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n        if (dff.limit > 0) {\n          // set the initial limit higher to increase accuracy\n          dff.initialLimit = doOverRequestMath(dff.initialLimit, dff.overrequestRatio, \n                                               dff.overrequestCount);\n        }\n        dff.initialMincount = Math.min(dff.minCount, 1);\n      } else {\n        // we're sorting by index order.\n        // if minCount==0, we should always be able to get accurate results w/o\n        // over-requesting or refining\n        // if minCount==1, we should be able to get accurate results w/o\n        // over-requesting, but we'll need to refine\n        // if minCount==n (>1), we can set the initialMincount to\n        // minCount/nShards, rounded up.\n        // For example, we know that if minCount=10 and we have 3 shards, then\n        // at least one shard must have a count of 4 for the term\n        // For the minCount>1 case, we can generate too short of a list (miss\n        // terms at the end of the list) unless limit==-1\n        // For example: each shard could produce a list of top 10, but some of\n        // those could fail to make it into the combined list (i.e.\n        // we needed to go beyond the top 10 to generate the top 10 combined).\n        // Overrequesting can help a little here, but not as\n        // much as when sorting by count.\n        if (dff.minCount <= 1) {\n          dff.initialMincount = dff.minCount;\n        } else {\n          dff.initialMincount = (int) Math.ceil((double) dff.minCount / rb.slices.length);\n        }\n      }\n\n      // Currently this is for testing only and allows overriding of the\n      // facet.limit set to the shards\n      dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n      \n      sreq.params.set(paramStart + FacetParams.FACET_LIMIT, dff.initialLimit);\n      sreq.params.set(paramStart + FacetParams.FACET_MINCOUNT, dff.initialMincount);\n\n    }\n  }\n\n","sourceOld":"  private void modifyRequestForFieldFacets(ResponseBuilder rb, ShardRequest sreq, FacetInfo fi) {\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      \n      String paramStart = \"f.\" + dff.field + '.';\n      sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n      sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n      \n      dff.initialLimit = dff.limit <= 0 ? dff.limit : dff.offset + dff.limit;\n      \n      if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n        if (dff.limit > 0) {\n          // set the initial limit higher to increase accuracy\n          dff.initialLimit = doOverRequestMath(dff.initialLimit, dff.overrequestRatio, \n                                               dff.overrequestCount);\n          \n          // If option FACET_DISTRIB_MCO is turned on then we will use 1 as the initial \n          // minCount (unless the user explicitly set it to something less than 1). If \n          // option FACET_DISTRIB_MCO is turned off then we will use 0 as the initial \n          // minCount regardless of what the user might have provided (prior to the\n          // addition of the FACET_DISTRIB_MCO option the default logic was to use 0).\n          // As described in issues SOLR-8559 and SOLR-8988 the use of 1 provides a \n          // significant performance boost.\n          dff.initialMincount = dff.mco ? Math.min(dff.minCount, 1) : 0;\n                                   \n        } else {\n          // if limit==-1, then no need to artificially lower mincount to 0 if\n          // it's 1\n          dff.initialMincount = Math.min(dff.minCount, 1);\n        }\n      } else {\n        // we're sorting by index order.\n        // if minCount==0, we should always be able to get accurate results w/o\n        // over-requesting or refining\n        // if minCount==1, we should be able to get accurate results w/o\n        // over-requesting, but we'll need to refine\n        // if minCount==n (>1), we can set the initialMincount to\n        // minCount/nShards, rounded up.\n        // For example, we know that if minCount=10 and we have 3 shards, then\n        // at least one shard must have a count of 4 for the term\n        // For the minCount>1 case, we can generate too short of a list (miss\n        // terms at the end of the list) unless limit==-1\n        // For example: each shard could produce a list of top 10, but some of\n        // those could fail to make it into the combined list (i.e.\n        // we needed to go beyond the top 10 to generate the top 10 combined).\n        // Overrequesting can help a little here, but not as\n        // much as when sorting by count.\n        if (dff.minCount <= 1) {\n          dff.initialMincount = dff.minCount;\n        } else {\n          dff.initialMincount = (int) Math.ceil((double) dff.minCount / rb.slices.length);\n        }\n      }\n\n      // Currently this is for testing only and allows overriding of the\n      // facet.limit set to the shards\n      dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n      \n      sreq.params.set(paramStart + FacetParams.FACET_LIMIT, dff.initialLimit);\n      sreq.params.set(paramStart + FacetParams.FACET_MINCOUNT, dff.initialMincount);\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"927e6deec13723e5fd6fb8f1e0457e8597dae15e","date":1513167013,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequestForFieldFacets(ResponseBuilder,ShardRequest,FacetInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequestForFieldFacets(ResponseBuilder,ShardRequest,FacetInfo).mjava","sourceNew":"  private void modifyRequestForFieldFacets(ResponseBuilder rb, ShardRequest sreq, FacetInfo fi) {\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      \n      String paramStart = \"f.\" + dff.field + '.';\n      sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n      sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n      \n      dff.initialLimit = dff.limit <= 0 ? dff.limit : dff.offset + dff.limit;\n      \n      if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n        if (dff.limit > 0) {\n          // set the initial limit higher to increase accuracy\n          dff.initialLimit = doOverRequestMath(dff.initialLimit, dff.overrequestRatio, \n                                               dff.overrequestCount);\n        }\n        dff.initialMincount = Math.min(dff.minCount, 1);\n      } else {\n        // we're sorting by index order.\n        // if minCount==0, we should always be able to get accurate results w/o\n        // over-requesting or refining\n        // if minCount==1, we should be able to get accurate results w/o\n        // over-requesting, but we'll need to refine\n        // if minCount==n (>1), we can set the initialMincount to\n        // minCount/nShards, rounded up.\n        // For example, we know that if minCount=10 and we have 3 shards, then\n        // at least one shard must have a count of 4 for the term\n        // For the minCount>1 case, we can generate too short of a list (miss\n        // terms at the end of the list) unless limit==-1\n        // For example: each shard could produce a list of top 10, but some of\n        // those could fail to make it into the combined list (i.e.\n        // we needed to go beyond the top 10 to generate the top 10 combined).\n        // Overrequesting can help a little here, but not as\n        // much as when sorting by count.\n        if (dff.minCount <= 1) {\n          dff.initialMincount = dff.minCount;\n        } else {\n          dff.initialMincount = (int) Math.ceil((double) dff.minCount / rb.slices.length);\n        }\n      }\n\n      // Currently this is for testing only and allows overriding of the\n      // facet.limit set to the shards\n      dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n      \n      sreq.params.set(paramStart + FacetParams.FACET_LIMIT, dff.initialLimit);\n      sreq.params.set(paramStart + FacetParams.FACET_MINCOUNT, dff.initialMincount);\n\n    }\n  }\n\n","sourceOld":"  private void modifyRequestForFieldFacets(ResponseBuilder rb, ShardRequest sreq, FacetInfo fi) {\n    for (DistribFieldFacet dff : fi.facets.values()) {\n      \n      String paramStart = \"f.\" + dff.field + '.';\n      sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n      sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n      \n      dff.initialLimit = dff.limit <= 0 ? dff.limit : dff.offset + dff.limit;\n      \n      if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n        if (dff.limit > 0) {\n          // set the initial limit higher to increase accuracy\n          dff.initialLimit = doOverRequestMath(dff.initialLimit, dff.overrequestRatio, \n                                               dff.overrequestCount);\n          \n          // If option FACET_DISTRIB_MCO is turned on then we will use 1 as the initial \n          // minCount (unless the user explicitly set it to something less than 1). If \n          // option FACET_DISTRIB_MCO is turned off then we will use 0 as the initial \n          // minCount regardless of what the user might have provided (prior to the\n          // addition of the FACET_DISTRIB_MCO option the default logic was to use 0).\n          // As described in issues SOLR-8559 and SOLR-8988 the use of 1 provides a \n          // significant performance boost.\n          dff.initialMincount = dff.mco ? Math.min(dff.minCount, 1) : 0;\n                                   \n        } else {\n          // if limit==-1, then no need to artificially lower mincount to 0 if\n          // it's 1\n          dff.initialMincount = Math.min(dff.minCount, 1);\n        }\n      } else {\n        // we're sorting by index order.\n        // if minCount==0, we should always be able to get accurate results w/o\n        // over-requesting or refining\n        // if minCount==1, we should be able to get accurate results w/o\n        // over-requesting, but we'll need to refine\n        // if minCount==n (>1), we can set the initialMincount to\n        // minCount/nShards, rounded up.\n        // For example, we know that if minCount=10 and we have 3 shards, then\n        // at least one shard must have a count of 4 for the term\n        // For the minCount>1 case, we can generate too short of a list (miss\n        // terms at the end of the list) unless limit==-1\n        // For example: each shard could produce a list of top 10, but some of\n        // those could fail to make it into the combined list (i.e.\n        // we needed to go beyond the top 10 to generate the top 10 combined).\n        // Overrequesting can help a little here, but not as\n        // much as when sorting by count.\n        if (dff.minCount <= 1) {\n          dff.initialMincount = dff.minCount;\n        } else {\n          dff.initialMincount = (int) Math.ceil((double) dff.minCount / rb.slices.length);\n        }\n      }\n\n      // Currently this is for testing only and allows overriding of the\n      // facet.limit set to the shards\n      dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n      \n      sreq.params.set(paramStart + FacetParams.FACET_LIMIT, dff.initialLimit);\n      sreq.params.set(paramStart + FacetParams.FACET_MINCOUNT, dff.initialMincount);\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"92751ba9273251eab6a2e379ec42a1697a32ff96":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ef57266eb048f5d440958e9b0612adf7535e5e8b":["e616cfbf284ecbd0f40b4b9e4196daa27e92abd5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e616cfbf284ecbd0f40b4b9e4196daa27e92abd5":["8ff4734b6c86245e852fe8b6a286716d5e59d415","25107e8bc3cbaed9427c9c7092c430cf4ce48b1b"],"25107e8bc3cbaed9427c9c7092c430cf4ce48b1b":["8ff4734b6c86245e852fe8b6a286716d5e59d415"],"8ff4734b6c86245e852fe8b6a286716d5e59d415":["92751ba9273251eab6a2e379ec42a1697a32ff96"],"927e6deec13723e5fd6fb8f1e0457e8597dae15e":["e616cfbf284ecbd0f40b4b9e4196daa27e92abd5","ef57266eb048f5d440958e9b0612adf7535e5e8b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["8ff4734b6c86245e852fe8b6a286716d5e59d415","e616cfbf284ecbd0f40b4b9e4196daa27e92abd5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["927e6deec13723e5fd6fb8f1e0457e8597dae15e"]},"commit2Childs":{"92751ba9273251eab6a2e379ec42a1697a32ff96":["8ff4734b6c86245e852fe8b6a286716d5e59d415"],"ef57266eb048f5d440958e9b0612adf7535e5e8b":["927e6deec13723e5fd6fb8f1e0457e8597dae15e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["92751ba9273251eab6a2e379ec42a1697a32ff96"],"e616cfbf284ecbd0f40b4b9e4196daa27e92abd5":["ef57266eb048f5d440958e9b0612adf7535e5e8b","927e6deec13723e5fd6fb8f1e0457e8597dae15e","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"25107e8bc3cbaed9427c9c7092c430cf4ce48b1b":["e616cfbf284ecbd0f40b4b9e4196daa27e92abd5"],"8ff4734b6c86245e852fe8b6a286716d5e59d415":["e616cfbf284ecbd0f40b4b9e4196daa27e92abd5","25107e8bc3cbaed9427c9c7092c430cf4ce48b1b","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"927e6deec13723e5fd6fb8f1e0457e8597dae15e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}